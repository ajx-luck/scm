---- H:\MyDownloads\说明书&测试报告\开发包\SC8P171XE开发包\SC8P171XE_C_demo\SC8P171XE_SLEEP\SC8P171XE_SLEEP.c ----------------------------------------------------------------------
1:                /*-------------------------------------------
2:                
3:                程序名称：休眠模式及唤醒程序
4:                日期版本：2021/01/10 <V1.0>
5:                
6:                备注：WDT已被禁止，休眠模式下利用PORTA,PORTB电平变化唤醒 
7:                
8:                *本程序由 &应用支持部& 编写整理
9:                -------------------------------------------*/
10:               
11:               
12:               #include <sc.h>
13:               
14:               
15:               void Init_System();
16:               void Sleep_Mode();
17:               
18:               void main()
19:               {
20:               	Init_System();
  0060    2036    CALL	0x36
21:               	while(1)
22:               	{
23:               		Sleep_Mode();
  0061    200D    CALL	0xD
  0062    2861    JP	0x61
24:               	}
25:               }
26:               
27:               
28:               /***********************************************
29:               函数名称：Sleep_Mode
30:               函数功能：进入休眠模式
31:               入口参数：无
32:               出口参数：无
33:               备注：
34:               ************************************************/
35:               void Sleep_Mode()
36:               {
37:               	INTCON = 0;		
  000D    018B    CLR	0xB
38:               	
39:               	OPTION_REG = 0;
  000E    1683    SETB	0x3,5
  000F    0181    CLR	0x1
40:               	ADCON0 = 0;					//关闭所有模块
  0010    1283    CLRB	0x3,5
  0011    019F    CLR	0x1F
41:               	PWMCON = 0;
  0012    019B    CLR	0x1B
42:               	PWMCON1 = 0;
  0013    1683    SETB	0x3,5
  0014    018E    CLR	0xE
43:               	
44:               	OSCCON = 0X70;				//配置振荡为8M,
  0015    3070    LDIA	0x70
  0016    008F    LD	0xF,A
45:               
46:               	TRISA = 0B00000001; 		//悬空的管脚设为输出脚
  0017    3001    LDIA	0x1
  0018    0085    LD	0x5,A
47:               //	PORTA = 0B00000001;			//设置RA0口为输入
48:               	WPUA  = 0B00000001;			//设置RA0口开上拉电阻
  0019    1283    CLRB	0x3,5
  001A    0087    LD	0x7,A
49:               	TRISB = 0B0001000;	
  001B    3008    LDIA	0x8
  001C    1683    SETB	0x3,5
  001D    0086    LD	0x6,A
50:               	PORTB = 0B00000000;
  001E    1283    CLRB	0x3,5
  001F    0186    CLR	0x6
51:               	WPUB  = 0B00001000;		
  0020    1683    SETB	0x3,5
  0021    0095    LD	0x15,A
52:                  			
53:               	IOCA = 0B00000001;			//允许RA0的IO口电平变化中断
  0022    3001    LDIA	0x1
  0023    1283    CLRB	0x3,5
  0024    0089    LD	0x9,A
54:               	RAIE = 1;					//允许PORTA电平变化中断
  0025    1683    SETB	0x3,5
  0026    158C    SETB	0xC,3
55:               	PEIE = 1;					//PORTA电平变化中断是外设中断，所以必须打开PEIE
  0027    170B    SETB	0xB,6
56:                  
57:                  	IOCB = 0B00001000;			//允许RB3的IO口电平变化中断
  0028    3008    LDIA	0x8
  0029    0096    LD	0x16,A
58:               	RBIE = 1;					//允许PORTB电平变化中断
  002A    158B    SETB	0xB,3
59:               	GIE = 1;					//GIE = 0时，唤醒后执行SLEEP后程序;GIE = 1时，唤醒后跳至中断服务
  002B    178B    SETB	0xB,7
60:               	
61:               	
62:               	SWDTEN = 0;					//关闭WDT,此处在仿真器配置里面必须设置WDT为DISABLE，否则软件无法关闭WDT
  002C    1008    CLRB	0x8,0
63:               	
64:               	RAIF = 0;					//清中断标志
  002D    1283    CLRB	0x3,5
  002E    118C    CLRB	0xC,3
65:               	PORTA;						//读PORTA值并锁存,必须在打开电平中断允许后读取
  002F    0805    LD	A,0x5
66:               	RBIF = 0;					//清中断标志
  0030    100B    CLRB	0xB,0
67:               	PORTB;						//读PORTB值并锁存,必须在打开电平中断允许后读取			
  0031    0806    LD	A,0x6
  0032    0064    CLRWDT
  0033    0063    STOP
  0034    0000    NOP
68:               	asm("clrwdt");
69:               
70:               	asm("sleep");				//进入休眠模式
71:               	
72:               	asm("nop");
73:               	Init_System();
  0035    2836    JP	0x36
74:               }
75:               
76:               /***********************************************
77:               函数名称：Init_System
78:               函数功能：系统初始化
79:               入口参数：无
80:               出口参数：无
81:               备注：
82:               ************************************************/
83:               void Init_System()
84:               {
85:               	asm("nop");
86:               	asm("clrwdt");
87:               	INTCON = 0;					//系统初始化
  0038    018B    CLR	0xB
88:               	OSCCON = 0X70;				//配置振荡为8M
  0039    3070    LDIA	0x70
  003A    1683    SETB	0x3,5
  003B    008F    LD	0xF,A
89:               	SWDTEN = 1;					//开 WDT
  003C    1408    SETB	0x8,0
90:               	OPTION_REG = 0;
  003D    0181    CLR	0x1
91:               	
92:                   WPUA  = 0B00000001;			//初始化上拉
  003E    3001    LDIA	0x1
  003F    1283    CLRB	0x3,5
  0040    0087    LD	0x7,A
93:                   WPUB  = 0B00001000;			
  0041    3008    LDIA	0x8
  0042    1683    SETB	0x3,5
  0043    0095    LD	0x15,A
94:                 
95:                
96:               	TRISA = 0B00000001;			//初始化IO状态，PORTA.0设为上拉输入
  0044    3001    LDIA	0x1
  0045    0085    LD	0x5,A
97:               	TRISB = 0B00001000;			//PORTB.3设为上拉输入
  0046    3008    LDIA	0x8
  0047    0086    LD	0x6,A
98:               
99:               	PORTA = 0B00000000;
  0048    1283    CLRB	0x3,5
  0049    0185    CLR	0x5
100:              	PORTB = 0B00000000;			//初始化输出
  004A    0186    CLR	0x6
  004B    0008    RET
101:              
102:              }
103:              
104:              /***********************************************
105:              函数名称：PB_Isr
106:              函数功能：PB电平变化中断服务
107:              入口参数：无
108:              出口参数：无
109:              备注：
110:              ************************************************/
111:              void interrupt PB_Isr()
112:              {
113:              	if(RAIF)
  004C    1283    CLRB	0x3,5
  004D    1D8C    SNZB	0xC,3
  004E    2853    JP	0x53
114:              	{
115:              		RAIF = 0;			//清中断标志
  004F    118C    CLRB	0xC,3
116:              		PORTA;				//读PORTB值并锁存
  0050    0805    LD	A,0x5
117:              		PORTA ^= 0X04;
  0051    3004    LDIA	0x4
  0052    0685    XORR	0x5
118:              		//Init_System();
119:              	}
120:              	if(RBIF)
  0053    1C0B    SNZB	0xB,0
  0054    2859    JP	0x59
121:              	{
122:              		RBIF = 0;			//清中断标志
  0055    100B    CLRB	0xB,0
123:              		PORTB;				//读PORTB值并锁存
  0056    0806    LD	A,0x6
124:              		PORTA ^= 0X02;
  0057    3002    LDIA	0x2
  0058    0685    XORR	0x5
  0059    0871    LD	A,0x71
  005A    008A    LD	0xA,A
  005B    0E70    SWAPA	0x70
  005C    0083    LD	0x3,A
  005D    0EFE    SWAPR	0x7E
  005E    0E7E    SWAPA	0x7E
  005F    0009    RETI
125:              		//Init_System();
126:              	}
127:              }
---- stringtab ------------------------------------------------------------------
---- reset_enter ------------------------------------------------------------------
  0000    280A    JP	0xA
  000A    280B    JP	0xB
---- start_initialization ------------------------------------------------------------------
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F0    LD	0x70,A
  0007    080A    LD	A,0xA
  0008    00F1    LD	0x71,A
  0009    284C    JP	0x4C
---- common_function ------------------------------------------------------------------
  000B    0183    CLR	0x3
  000C    2860    JP	0x60
  0036    0000    NOP
  0037    0064    CLRWDT
