---- C:\SCMCU WorkSpace\n9_fan_no_led\main.c ----------------------------------------------------------------------
1:                #include "scankey.h"
2:                #include "init.h"
3:                #include "adc.h"
4:                
5:                #define MAX_FAN_LEVEL 4
6:                #define MIN_FAN_LEVEL 1
7:                
8:                #define FAN_STATUS_OFF  0
9:                #define FAN_STATUS_ON  1
10:               #define FAN_STATUS_NONE 2
11:               
12:               #define PBPORTB PORTA
13:               #define PBTRISB TRISA
14:               
15:               
16:               //1毫秒中断标志
17:               static unsigned char time0Flag = 0;
18:               static unsigned int countTime = 0;
19:               static unsigned int count10Ms = 0;
20:               unsigned char currentLevel = 1;
21:               //风扇状态
22:               unsigned char FAN_STATUS = FAN_STATUS_NONE;
23:               //检测风扇次数
24:               unsigned int fan_check_time = 0;
25:               //按键结构体
26:               struct Keys key1;
27:               //关闭风扇
28:               void closeFan();
29:               //初始化配置
30:               void Init_Config();
31:               //睡眠模式
32:               void Sleep_Mode();
33:               
34:               void checkUsbStatus() {
35:               	//工作时不亮灯
36:                   if(FAN_STATUS == FAN_STATUS_ON && currentLevel != 1)
  01AD    0B77    SZDECA	0x77
  01AE    29B5    JP	0x1B5
  01AF    0378    DECA	0x78
  01B0    1903    SZB	0x3,2
  01B1    29B5    JP	0x1B5
37:               	{
38:               		setbit(PORTA, 0);
  01B2    1405    SETB	0x5,0
39:               		setbit(PORTC, 1);
  01B3    1487    SETB	0x7,1
40:               		return;
  01B4    0008    RET
41:               	}
42:               	if (getbit(PORTB, 2) == 1) {
  01B5    0806    LD	A,0x6
  01B6    00F4    LD	0x74,A
  01B7    1003    CLRB	0x3,0
  01B8    0CF4    RRCR	0x74
  01B9    1003    CLRB	0x3,0
  01BA    0CF4    RRCR	0x74
  01BB    1C74    SNZB	0x74,0
  01BC    29B2    JP	0x1B2
43:                       if (getbit(PORTB, 1) == 1) {
  01BD    0806    LD	A,0x6
  01BE    00F4    LD	0x74,A
  01BF    1003    CLRB	0x3,0
  01C0    0CF4    RRCR	0x74
  01C1    1C74    SNZB	0x74,0
  01C2    29C6    JP	0x1C6
44:                           //充满了，PC1常亮,A0关闭
45:                           resetbit(PORTC, 1);
  01C3    1087    CLRB	0x7,1
46:               			setbit(PORTA, 0);
  01C4    1405    SETB	0x5,0
47:                       } else if (countTime == 100) {
  01C5    0008    RET
  01C6    3064    LDIA	0x64
  01C7    062C    XORA	0x2C
  01C8    042D    ORA	0x2D
  01C9    1D03    SNZB	0x3,2
  01CA    0008    RET
48:                           //充电中，一直闪，C1关闭		
49:                           reversebit(PORTA, 0);
  01CB    3001    LDIA	0x1
  01CC    0685    XORR	0x5
50:               			setbit(PORTC, 1);
  01CD    1487    SETB	0x7,1
  01CE    0008    RET
51:                       }
52:                   } else {
53:                       //usb断开充电灯熄灭,PA0 = 1
54:                       setbit(PORTA, 0);
55:               		setbit(PORTC, 1);
56:                   }
57:               }
58:               
59:               void Init_PWM() {
60:                   CCP1CON = 0x0F;//设置PC2为PWM模式，4,5位为占空比的低2位
  029E    300F    LDIA	0xF
  029F    0097    LD	0x17,A
  02AB    300F    LDIA	0xF
  02AC    0097    LD	0x17,A
61:                   T2CON = 0; //时钟分频 1:1 PWM周期为（PR2+1）*4/8,000,000
  02A0    0192    CLR	0x12
  02AD    0192    CLR	0x12
62:                   PR2 = 7;
  02A1    3007    LDIA	0x7
  02A2    1683    SETB	0x3,5
  02A3    0092    LD	0x12,A
  02AE    3007    LDIA	0x7
  02AF    1683    SETB	0x3,5
  02B0    0092    LD	0x12,A
63:               
64:                   CCPR1L = 0;//占空比高8位，低2位设置为0，结果就是 占空比 = CCPR1L*4/4*(PR2+1)
  02A4    1283    CLRB	0x3,5
  02A5    0195    CLR	0x15
  02B1    1283    CLRB	0x3,5
  02B2    0195    CLR	0x15
65:                   TMR2IF = 0;
  02A6    108C    CLRB	0xC,1
  02B3    108C    CLRB	0xC,1
66:                   T2CON = 0;
  02A7    0192    CLR	0x12
  02B4    0192    CLR	0x12
67:                   //PC2设置为输出脚
68:                   resetbit(TRISC, 2);
  02A8    1683    SETB	0x3,5
  02A9    1107    CLRB	0x7,2
  02AA    0008    RET
  02B5    1683    SETB	0x3,5
  02B6    1107    CLRB	0x7,2
  02B7    0008    RET
69:                   //T2CON = 0X04 //启动定时器2，溢出后启动PWM
70:               }
71:               
72:               //设置风扇转速
73:               void setFanLevel(char level) {
  014A    00F4    LD	0x74,A
74:               	if(level == 0)
  014B    0874    LD	A,0x74
  014C    1D03    SNZB	0x3,2
  014D    2950    JP	0x150
75:               	{
76:               		currentLevel = 3;
  014E    3003    LDIA	0x3
  014F    00F8    LD	0x78,A
77:               	}
78:                   unsigned int levelWidth = (PR2 + 1) / MAX_FAN_LEVEL;
  0150    1683    SETB	0x3,5
  0151    0812    LD	A,0x12
  0152    1283    CLRB	0x3,5
  0153    00BA    LD	0x3A,A
  0154    01BB    CLR	0x3B
  0155    0ABA    INCR	0x3A
  0156    1903    SZB	0x3,2
  0157    0ABB    INCR	0x3B
  0158    3004    LDIA	0x4
  0159    00B8    LD	0x38,A
  015A    01B9    CLR	0x39
  015B    20C3    CALL	0xC3
79:                   char tempLevel = currentLevel + level;
  015C    0874    LD	A,0x74
  015D    0778    ADDA	0x78
  015E    00F5    LD	0x75,A
80:                   if (tempLevel > MAX_FAN_LEVEL) {
  015F    3005    LDIA	0x5
  0160    0275    SUBA	0x75
  0161    1C03    SNZB	0x3,0
  0162    2965    JP	0x165
81:                       tempLevel = MIN_FAN_LEVEL;
  0163    01F5    CLR	0x75
  0164    0AF5    INCR	0x75
82:                   }
83:               
84:                   
85:                   if (FAN_STATUS == FAN_STATUS_ON) {
  0165    0B77    SZDECA	0x77
  0166    0008    RET
86:               		currentLevel = tempLevel;
  0167    0875    LD	A,0x75
  0168    00F8    LD	0x78,A
87:               		switch(currentLevel)
  0169    2974    JP	0x174
88:               		{
89:               			case 1:
90:               			closeFan();
  016A    2AB8    JP	0x2B8
91:               			break;
92:               			case 2:
93:               			CCPR1L = 2;
  016B    3002    LDIA	0x2
  016C    0095    LD	0x15,A
94:               			break;
  016D    0008    RET
95:               			case 3:
96:               			CCPR1L = 3;
  016E    3003    LDIA	0x3
  016F    0095    LD	0x15,A
97:               			break;
  0170    0008    RET
98:               			case 4:
99:               			CCPR1L = 5;
  0171    3005    LDIA	0x5
  0172    0095    LD	0x15,A
100:              			break;
  0173    0008    RET
  0174    0878    LD	A,0x78
  0175    3A01    XORIA	0x1
  0176    1903    SZB	0x3,2
  0177    296A    JP	0x16A
  0178    3A03    XORIA	0x3
  0179    1903    SZB	0x3,2
  017A    296B    JP	0x16B
  017B    3A01    XORIA	0x1
  017C    1903    SZB	0x3,2
  017D    296E    JP	0x16E
  017E    3A07    XORIA	0x7
  017F    1903    SZB	0x3,2
  0180    2971    JP	0x171
  0181    2982    JP	0x182
  0182    0008    RET
101:              		}
102:                  //设置占宽比
103:              		//CCPR1L = levelWidth * currentLevel;
104:                    
105:                  }
106:              
107:              }
108:              
109:              //关闭风扇
110:              void closeFan() {
111:                  Init_PWM();
  02B8    229E    CALL	0x29E
112:                  currentLevel = 2;
  02B9    3002    LDIA	0x2
  02BA    00F8    LD	0x78,A
113:                  setbit(PORTA, 0);
  02BB    1283    CLRB	0x3,5
  02BC    1405    SETB	0x5,0
114:                  //PWM输出脚设置为输入，关闭PWM
115:                  setbit(TRISC, 2);
  02BD    1683    SETB	0x3,5
  02BE    1507    SETB	0x7,2
116:                  fan_check_time = 0;
  02BF    1283    CLRB	0x3,5
  02C0    01A8    CLR	0x28
  02C1    01A9    CLR	0x29
117:                  FAN_STATUS = FAN_STATUS_OFF;
  02C2    01F7    CLR	0x77
  02C3    0008    RET
118:                  //Sleep_Mode();
119:              }
120:              
121:              
122:              //检测风扇是否连接
123:              void checkFan() {
124:              	resetbit(TRISA, 1);
  0183    1683    SETB	0x3,5
  0184    1085    CLRB	0x5,1
125:                  setbit(PORTA, 1);
  0185    1283    CLRB	0x3,5
  0186    1485    SETB	0x5,1
126:                  //PC2设置为输出脚
127:                  resetbit(TRISC, 2);
  0187    1683    SETB	0x3,5
  0188    1107    CLRB	0x7,2
128:              	setbit(PORTA, 2);
  0189    1283    CLRB	0x3,5
  018A    1505    SETB	0x5,2
129:                  T2CON = 0X04; //启动定时器2，溢出后启动PWM
  018B    3004    LDIA	0x4
  018C    0092    LD	0x12,A
130:              
131:                  //EN IN输出高电位，D1点亮，检测FAN DET，FAN DET为低电位则风扇正常工作，高电位则未连接
132:                  if (getbit(PORTB, 6) == 0) {
  018D    0806    LD	A,0x6
  018E    00F6    LD	0x76,A
  018F    3006    LDIA	0x6
  0190    1003    CLRB	0x3,0
  0191    0CF6    RRCR	0x76
  0192    3EFF    ADDIA	0xFF
  0193    1D03    SNZB	0x3,2
  0194    2990    JP	0x190
  0195    1876    SZB	0x76,0
  0196    299A    JP	0x19A
133:                      FAN_STATUS = FAN_STATUS_ON;
  0197    01F7    CLR	0x77
  0198    0AF7    INCR	0x77
134:                  } else {
  0199    299C    JP	0x19C
135:                      FAN_STATUS = FAN_STATUS_NONE;
  019A    3002    LDIA	0x2
  019B    00F7    LD	0x77,A
136:                  }
137:              	
138:              	setFanLevel(0);
  019C    3000    LDIA	0x0
  019D    214A    CALL	0x14A
139:              
140:                  //没有检测到风扇
141:                  if (FAN_STATUS == FAN_STATUS_NONE) {
  019E    3002    LDIA	0x2
  019F    0677    XORA	0x77
  01A0    1D03    SNZB	0x3,2
  01A1    0008    RET
142:                      fan_check_time++;
  01A2    0AA8    INCR	0x28
  01A3    1903    SZB	0x3,2
  01A4    0AA9    INCR	0x29
143:                      if (fan_check_time == 3000) {
  01A5    30B8    LDIA	0xB8
  01A6    0628    XORA	0x28
  01A7    300B    LDIA	0xB
  01A8    1903    SZB	0x3,2
  01A9    0629    XORA	0x29
  01AA    1D03    SNZB	0x3,2
  01AB    0008    RET
144:                          closeFan();
  01AC    2AB8    JP	0x2B8
145:                          return;
146:                      }
147:                  }
148:              
149:              
150:              }
151:              
152:              
153:              
154:              
155:              //扫描按键
156:              void scanKeys() {
157:                  key1.key_addr_result = PORTB;
  02CF    1283    CLRB	0x3,5
  02D0    1303    CLRB	0x3,6
  02D1    0806    LD	A,0x6
  02D2    00B6    LD	0x36,A
158:                  sacnKeyInput(&key1);
  02D3    3031    LDIA	0x31
  02D4    21EE    CALL	0x1EE
159:                  countTime++;
  02D5    0AAC    INCR	0x2C
  02D6    1903    SZB	0x3,2
  02D7    0AAD    INCR	0x2D
  02D8    0008    RET
160:                 
161:              }
162:              
163:              //检测按键状态并处理
164:              void checkKeys() {
165:                  if (key_driver(&key1) == key_click) {
  026D    3031    LDIA	0x31
  026E    2108    CALL	0x108
  026F    3A01    XORIA	0x1
  0270    1D03    SNZB	0x3,2
  0271    2A79    JP	0x279
166:                      //检测到按键了，检测风扇是否存在
167:              
168:                      if (FAN_STATUS == FAN_STATUS_ON) {
  0272    0B77    SZDECA	0x77
  0273    2A76    JP	0x276
169:              			//按一下，风扇加档
170:                          setFanLevel(1);
  0274    3001    LDIA	0x1
  0275    294A    JP	0x14A
171:                          
172:                      } else {
173:                          FAN_STATUS = FAN_STATUS_NONE;
  0276    3002    LDIA	0x2
  0277    00F7    LD	0x77,A
174:                          checkFan();
  0278    2983    JP	0x183
  0279    3002    LDIA	0x2
  027A    0677    XORA	0x77
  027B    1D03    SNZB	0x3,2
  027C    0008    RET
  027D    2A78    JP	0x278
175:                      }
176:                      return;
177:                  } else if (FAN_STATUS == FAN_STATUS_NONE) {
178:                      checkFan();
179:                  }
180:              
181:              
182:              }
183:              
184:              
185:              void main(void) {
186:                  Init_Config();
  01CF    2221    CALL	0x221
187:                  while (1) {
188:                      //0.1毫秒检测一次
189:                      if (time0Flag) {
  01D0    0879    LD	A,0x79
  01D1    1903    SZB	0x3,2
  01D2    29D9    JP	0x1D9
  01D3    0064    CLRWDT
190:                          asm("clrwdt");
191:                          time0Flag = 0;
  01D4    01F9    CLR	0x79
192:              			scanKeys();
  01D5    22CF    CALL	0x2CF
193:                          count10Ms++;
  01D6    0AAA    INCR	0x2A
  01D7    1903    SZB	0x3,2
  01D8    0AAB    INCR	0x2B
194:                      }
195:              
196:                      //10毫秒检测一次
197:                      if (count10Ms == 100) {		
  01D9    3064    LDIA	0x64
  01DA    1283    CLRB	0x3,5
  01DB    062A    XORA	0x2A
  01DC    042B    ORA	0x2B
  01DD    1D03    SNZB	0x3,2
  01DE    29E4    JP	0x1E4
198:                          checkKeys();
  01DF    226D    CALL	0x26D
199:                          count10Ms = 0;
  01E0    01AA    CLR	0x2A
  01E1    01AB    CLR	0x2B
200:                          //检测USB状态
201:                          checkUsbStatus();
  01E2    21AD    CALL	0x1AD
202:              			//检测内部电压
203:              			readVrefADC();
  01E3    22FF    CALL	0x2FF
204:                      }
205:              
206:                      if (countTime == 1000) {
  01E4    30E8    LDIA	0xE8
  01E5    062C    XORA	0x2C
  01E6    3003    LDIA	0x3
  01E7    1903    SZB	0x3,2
  01E8    062D    XORA	0x2D
  01E9    1D03    SNZB	0x3,2
  01EA    29D0    JP	0x1D0
207:                          countTime = 0;
  01EB    01AC    CLR	0x2C
  01EC    01AD    CLR	0x2D
  01ED    29D0    JP	0x1D0
208:                      }
209:              		
210:                  }
211:              
212:              }
213:              
214:              void Init_Config() {
215:              
216:                  Init_System();
  0221    22D9    CALL	0x2D9
  0235    22E2    CALL	0x2E2
217:                  Init_GPIO();
  0222    2249    CALL	0x249
  0236    225B    CALL	0x25B
218:                  Init_Interupt();
  0223    22F3    CALL	0x2F3
  0237    22F9    CALL	0x2F9
219:                  Init_PWM();
  0224    229E    CALL	0x29E
  0238    22AB    CALL	0x2AB
220:                  //设置唤醒
221:                  IOCB = 0x04;
  0225    3004    LDIA	0x4
  0226    0096    LD	0x16,A
  0239    3004    LDIA	0x4
  023A    0096    LD	0x16,A
222:                  TMR0 = 155;
  0227    309B    LDIA	0x9B
  0228    1283    CLRB	0x3,5
  0229    0081    LD	0x1,A
  023B    309B    LDIA	0x9B
  023C    1283    CLRB	0x3,5
  023D    0081    LD	0x1,A
223:                  TO = 0;
  022A    1203    CLRB	0x3,4
  023E    1203    CLRB	0x3,4
224:              
225:                  //K1开关
226:                  key1.key_index = 5;
  022B    3005    LDIA	0x5
  022C    00B7    LD	0x37,A
  023F    3005    LDIA	0x5
  0240    00B7    LD	0x37,A
227:                  
228:                  resetKey(&key1);
  022D    3031    LDIA	0x31
  022E    227E    CALL	0x27E
  0241    3031    LDIA	0x31
  0242    228E    CALL	0x28E
229:              
230:                  //设置IO方向
231:                  TRISA = 0;
  022F    1683    SETB	0x3,5
  0230    0185    CLR	0x5
  0243    1683    SETB	0x3,5
  0244    0185    CLR	0x5
232:                  TRISB = 0x7E;//1-6脚输入
  0231    307E    LDIA	0x7E
  0232    0086    LD	0x6,A
  0245    307E    LDIA	0x7E
  0246    0086    LD	0x6,A
233:                  TRISC = 0;
  0233    0187    CLR	0x7
  0234    0008    RET
  0247    0187    CLR	0x7
  0248    0008    RET
234:              }
235:              
236:              
237:              void Sleep_Mode() {
238:                  INTCON = 0;
239:              
240:                  OPTION_REG = 0;
241:              
242:                  TRISA = 0B00000000;        //关闭所有输出
243:                  PORTA = 0B00000000;
244:                  WPUA = 0B00000000;
245:              
246:                  TRISB = 0B00100000;
247:                  PORTB = 0B00000000;
248:              
249:                  PORTB = 0;
250:                  WPUB = 0B00100000;         //RB3 上拉
251:              
252:                  IOCB = 0B00100000;            //允许RB3的IO口电平变化中断
253:                  RBIE = 1;                    //允许PORTB电平变化中断
254:                  GIE = 1;                    //GIE = 0时，唤醒后执行SLEEP后程序;GIE = 1时，唤醒后跳至中断服务
255:              
256:                  ADCON0 = 0;                    //关闭所有模块
257:              
258:                  OSCCON = 0X70;                //配置振荡为16M,关闭WDT
259:              
260:                  PORTB;                        //读PORTB值并锁存			
261:                  asm("clrwdt");
262:              
263:                  asm("sleep");                //进入休眠模式
264:              
265:                  asm("nop");
266:              
267:              
268:              }
269:              
270:              
271:              /***********************************************
272:              函数名称：Timer0_Isr
273:              函数功能：中断服务
274:              入口参数：无
275:              出口参数：无
276:              备注：
277:              ***********************************************/
278:              void interrupt Timer0_Isr() {
279:                  if (T0IF) {
  020B    1D0B    SNZB	0xB,2
  020C    2A14    JP	0x214
280:                      //---------------------------------------
281:                      TMR0 += 155;        //重新赋初值，在赋值前Timer0已有计数，故在该基础上加初值
  020D    309B    LDIA	0x9B
  020E    1283    CLRB	0x3,5
  020F    1303    CLRB	0x3,6
  0210    0781    ADDR	0x1
282:                      //---------------------------------------
283:              
284:                      T0IF = 0;            //清中断标志位	
  0211    110B    CLRB	0xB,2
285:                      time0Flag = 1;
  0212    01F9    CLR	0x79
  0213    0AF9    INCR	0x79
286:              
287:                  }
288:              
289:                  if (RBIF) {
  0214    1C0B    SNZB	0xB,0
  0215    2A18    JP	0x218
290:                      RBIF = 0;            //清中断标志
  0216    100B    CLRB	0xB,0
291:                      Init_Config();
  0217    2235    CALL	0x235
  0218    0873    LD	A,0x73
  0219    008A    LD	0xA,A
  021A    0872    LD	A,0x72
  021B    0084    LD	0x4,A
  021C    0E71    SWAPA	0x71
  021D    0083    LD	0x3,A
  021E    0EFE    SWAPR	0x7E
  021F    0E7E    SWAPA	0x7E
  0220    0009    RETI
292:                  }
293:              }
---- C:\SCMCU WorkSpace\n9_fan_no_led\scankey.c ----------------------------------------------------------------------
1:                #include "scankey.h"
2:                
3:                void sacnKeyInput(struct Keys *key) {
  01EE    00F6    LD	0x76,A
4:                    key->key_input = getbit(key->key_addr_result, key->key_index);
  01EF    3E05    ADDIA	0x5
  01F0    0084    LD	0x4,A
  01F1    1383    CLRB	0x3,7
  01F2    0800    LD	A,0x0
  01F3    00F4    LD	0x74,A
  01F4    0876    LD	A,0x76
  01F5    3E06    ADDIA	0x6
  01F6    0084    LD	0x4,A
  01F7    0A00    INCA	0x0
  01F8    29FB    JP	0x1FB
  01F9    1003    CLRB	0x3,0
  01FA    0CF4    RRCR	0x74
  01FB    3EFF    ADDIA	0xFF
  01FC    1D03    SNZB	0x3,2
  01FD    29F9    JP	0x1F9
  01FE    0874    LD	A,0x74
  01FF    00F5    LD	0x75,A
  0200    0876    LD	A,0x76
  0201    3E04    ADDIA	0x4
  0202    0084    LD	0x4,A
  0203    0875    LD	A,0x75
  0204    0080    LD	0x0,A
  0205    0876    LD	A,0x76
  0206    3E04    ADDIA	0x4
  0207    0084    LD	0x4,A
  0208    3001    LDIA	0x1
  0209    0580    ANDR	0x0
  020A    0008    RET
5:                
6:                }
7:                
8:                
9:                unsigned char key_driver(struct Keys *key) {
  0108    00F6    LD	0x76,A
10:               
11:               
12:                   unsigned char key_return = key_no;
  0109    01F4    CLR	0x74
13:                   unsigned char key_read = key->key_input;  //read the I/O states
  010A    3E04    ADDIA	0x4
  010B    0084    LD	0x4,A
  010C    1383    CLRB	0x3,7
  010D    0800    LD	A,0x0
  010E    00F5    LD	0x75,A
14:               
15:                   switch (key->key_state_buffer1) {
  010F    293B    JP	0x13B
16:                       case key_state_0:
17:                           if (key_read == 0) {
  0110    0875    LD	A,0x75
  0111    1D03    SNZB	0x3,2
  0112    2948    JP	0x148
18:                               key->key_state_buffer1 = key_state_1;
  0113    0A76    INCA	0x76
  0114    0084    LD	0x4,A
  0115    0180    CLR	0x0
  0116    0A80    INCR	0x0
  0117    2948    JP	0x148
19:                           }
20:               
21:                           //按键被按下，状态转换到按键消抖和确认状态//
22:                           break;
23:               
24:                       case key_state_1:
25:                           if (key_read == 0) {
  0118    0875    LD	A,0x75
  0119    1D03    SNZB	0x3,2
  011A    2937    JP	0x137
26:                               key->key_timer_cnt1 = 0;
  011B    0876    LD	A,0x76
  011C    0084    LD	0x4,A
  011D    0180    CLR	0x0
27:                               key->key_state_buffer1 = key_state_2;
  011E    0A76    INCA	0x76
  011F    0084    LD	0x4,A
  0120    3002    LDIA	0x2
  0121    2933    JP	0x133
28:                               //按键仍然处于按下状态
29:                               //消抖完成，key_timer开始准备计时
30:                               //状态切换到按下时间计时状态
31:                           } else {
32:                               key->key_state_buffer1 = key_state_0;
33:                           }
34:               
35:                           //按键已经抬起，回到按键初始状态
36:                           break;  //完成软件消抖
37:               
38:                       case key_state_2:
39:                           if (key_read == 1) {
  0122    0B75    SZDECA	0x75
  0123    2927    JP	0x127
40:                               key_return = key_click;  //按键抬起，产生一次click操作
  0124    01F4    CLR	0x74
  0125    0AF4    INCR	0x74
  0126    2937    JP	0x137
41:                               key->key_state_buffer1 = key_state_0;  //转换到按键初始状态
  0127    0876    LD	A,0x76
  0128    0084    LD	0x4,A
  0129    3064    LDIA	0x64
  012A    0A80    INCR	0x0
  012B    0200    SUBA	0x0
  012C    1C03    SNZB	0x3,0
  012D    2948    JP	0x148
42:                           } else if (++(key->key_timer_cnt1) >= 100)  //按键继续按下，计时超过1000ms
43:                           {
44:                               key_return = key_long;  //送回长按事件
  012E    3003    LDIA	0x3
  012F    00F4    LD	0x74,A
45:                               key->key_state_buffer1 = key_state_3;  //转换到等待按键释放状态
  0130    0A76    INCA	0x76
  0131    0084    LD	0x4,A
  0132    3003    LDIA	0x3
  0133    0080    LD	0x0,A
  0134    2948    JP	0x148
46:               
47:                           }
48:                           break;
49:               
50:                       case key_state_3:  //等待按键释放
51:                           if (key_read == 1)  //按键释放
  0135    0B75    SZDECA	0x75
  0136    2948    JP	0x148
52:                           {
53:                               key->key_state_buffer1 = key_state_0;  //切回按键初始状态
  0137    0A76    INCA	0x76
  0138    0084    LD	0x4,A
  0139    0180    CLR	0x0
  013A    2948    JP	0x148
  013B    0A76    INCA	0x76
  013C    0084    LD	0x4,A
  013D    0800    LD	A,0x0
  013E    0084    LD	0x4,A
  013F    3004    LDIA	0x4
  0140    0204    SUBA	0x4
  0141    1803    SZB	0x3,0
  0142    2948    JP	0x148
  0143    3003    LDIA	0x3
  0144    008A    LD	0xA,A
  0145    3003    LDIA	0x3
  0146    0704    ADDA	0x4
  0147    0082    LD	0x2,A
54:                           }
55:               
56:                           break;
57:                   }
58:                   return key_return;
  0148    0874    LD	A,0x74
  0149    0008    RET
59:               }
60:               
61:               /***************************************************************************
62:               函数功能：中层按键处理函数，调用底层函数一次，处理双击事件的判断，
63:                                                       返回上层正确的无键、单击、双击、长按四种状态
64:               本函数由上层循环调用，间隔10ms
65:               ***************************************************************************/
66:               unsigned char key_read(struct Keys *key) {
67:               
68:                   unsigned char key_return = key_no;
69:                   unsigned char key_read = key_driver(key);
70:               //    printf("IO:%d  key status: %d\n",getSimpleKeyInput(key_input),key);
71:                   switch (key->key_state_buffer2) {
72:                       case key_state_0:
73:                           if (key_read == key_click) {
74:                               key->key_timer_cnt2 = 0;  //第一次单击，不返回，到下个状态判断是否会出现双击
75:                               key->key_state_buffer2 = key_state_1;
76:                           } else
77:                               key_return = key_read;  //对于无键、长按，返回原事件
78:                           break;
79:               
80:                       case key_state_1:
81:                           if (key_read == key_click)  //又一次单击，时间间隔小于500ms
82:                           {
83:                               key_return = key_double;  //返回双击事件，回到初始状态
84:                               key->key_state_buffer2 = key_state_0;
85:                           } else if (++(key->key_timer_cnt2) >= 50) {
86:                               //这里500ms内肯定读到的都是无键事件，因为长按大于1000ms
87:                               //在1s前底层返回的都是无键
88:               
89:                               key_return = key_click;  //500ms内没有再次出现单击事件，返回单击事件
90:                               key->key_state_buffer2 = key_state_0;  //返回初始状态
91:               
92:                           }
93:                           break;
94:                   }
95:               
96:                   return key_return;
97:               }
98:               
99:               
100:              void resetKey(struct Keys *key) {
  027E    00F4    LD	0x74,A
  028E    00F0    LD	0x70,A
101:                  key->key_timer_cnt1 = key->key_timer_cnt2 = key->key_state_buffer1 = key->key_state_buffer2 = 0;
  027F    3E03    ADDIA	0x3
  0280    0084    LD	0x4,A
  0281    1383    CLRB	0x3,7
  0282    0180    CLR	0x0
  0283    0A74    INCA	0x74
  0284    0084    LD	0x4,A
  0285    0180    CLR	0x0
  0286    0874    LD	A,0x74
  0287    3E02    ADDIA	0x2
  0288    0084    LD	0x4,A
  0289    0180    CLR	0x0
  028A    0874    LD	A,0x74
  028B    0084    LD	0x4,A
  028C    0180    CLR	0x0
  028D    0008    RET
  028F    3E03    ADDIA	0x3
  0290    0084    LD	0x4,A
  0291    1383    CLRB	0x3,7
  0292    0180    CLR	0x0
  0293    0A70    INCA	0x70
  0294    0084    LD	0x4,A
  0295    0180    CLR	0x0
  0296    0870    LD	A,0x70
  0297    3E02    ADDIA	0x2
  0298    0084    LD	0x4,A
  0299    0180    CLR	0x0
  029A    0870    LD	A,0x70
  029B    0084    LD	0x4,A
  029C    0180    CLR	0x0
  029D    0008    RET
102:              }
---- C:\SCMCU WorkSpace\n9_fan_no_led\adc.c ----------------------------------------------------------------------
1:                #include "adc.h"
2:                
3:                /**********************************************************
4:                函数名称：AD_Sample
5:                函数功能：AD检测
6:                入口参数：adch - 检测通道
7:                出口参数：无 
8:                备    注：采样通道需自行设置为模拟口
9:                	      采样10次,取中间八次的平均值为采样结果存于adresult中
10:               **********************************************************/
11:               void ADC_Sample(unsigned char adch)
  0019    00BC    LD	0x3C,A
12:               {
13:               	static unsigned long adsum = 0;
14:               	static unsigned int admin = 0,admax = 0;
15:               	static unsigned char adtimes = 0;
16:               	volatile unsigned int ad_temp;
17:               	ADCON1 = 0;						//左对齐
  001A    1683    SETB	0x3,5
  001B    019F    CLR	0x1F
18:               	ADCON0 = 0X41 | (adch << 2);	//16分频
  001C    1283    CLRB	0x3,5
  001D    083C    LD	A,0x3C
  001E    00B8    LD	0x38,A
  001F    3001    LDIA	0x1
  0020    1003    CLRB	0x3,0
  0021    0DB8    RLCR	0x38
  0022    3EFF    ADDIA	0xFF
  0023    1003    CLRB	0x3,0
  0024    1D03    SNZB	0x3,2
  0025    2821    JP	0x21
  0026    0D38    RLCA	0x38
  0027    3841    ORIA	0x41
  0028    009F    LD	0x1F,A
  0029    0000    NOP
  002A    0000    NOP
19:               	asm("nop");
20:               	asm("nop");
21:               	GODONE = 1;						//开始转换
  002B    1283    CLRB	0x3,5
  002C    1303    CLRB	0x3,6
  002D    149F    SETB	0x1F,1
22:               
23:               	unsigned char i = 0;
  002E    01BD    CLR	0x3D
24:               	while(GODONE)
  002F    1C9F    SNZB	0x1F,1
  0030    2834    JP	0x34
25:               	{
26:               		if(0 == (--i))
  0031    0BBD    SZDECR	0x3D
  0032    282F    JP	0x2F
  0033    0008    RET
27:               			return;
28:               	}
29:               	
30:               	ad_temp=(ADRESH<<4)+(ADRESL>>4);	//计算12位AD值
  0034    081E    LD	A,0x1E
  0035    00BE    LD	0x3E,A
  0036    01BF    CLR	0x3F
  0037    0EBE    SWAPR	0x3E
  0038    0EBF    SWAPR	0x3F
  0039    30F0    LDIA	0xF0
  003A    05BF    ANDR	0x3F
  003B    083E    LD	A,0x3E
  003C    390F    ANDIA	0xF
  003D    04BF    ORR	0x3F
  003E    30F0    LDIA	0xF0
  003F    05BE    ANDR	0x3E
  0040    1683    SETB	0x3,5
  0041    0E1E    SWAPA	0x1E
  0042    390F    ANDIA	0xF
  0043    1283    CLRB	0x3,5
  0044    07BE    ADDR	0x3E
  0045    1803    SZB	0x3,0
  0046    0ABF    INCR	0x3F
31:               	
32:               	if(0 == admax)
  0047    0824    LD	A,0x24
  0048    0425    ORA	0x25
  0049    1D03    SNZB	0x3,2
  004A    284D    JP	0x4D
33:               	{
34:               		admax = ad_temp;
  004B    20BE    CALL	0xBE
  004C    285F    JP	0x5F
35:               		admin = ad_temp;
36:               	}
37:               	else if(ad_temp > admax)
  004D    083F    LD	A,0x3F
  004E    0225    SUBA	0x25
  004F    1D03    SNZB	0x3,2
  0050    2853    JP	0x53
  0051    083E    LD	A,0x3E
  0052    0224    SUBA	0x24
  0053    1803    SZB	0x3,0
  0054    2857    JP	0x57
38:               		admax = ad_temp;				//AD采样最大值
  0055    20BE    CALL	0xBE
  0056    2863    JP	0x63
39:               	else if(ad_temp < admin)
  0057    0827    LD	A,0x27
  0058    023F    SUBA	0x3F
  0059    1D03    SNZB	0x3,2
  005A    285D    JP	0x5D
  005B    0826    LD	A,0x26
  005C    023E    SUBA	0x3E
  005D    1803    SZB	0x3,0
  005E    2863    JP	0x63
40:               		admin = ad_temp;				//AD采样最小值
  005F    083F    LD	A,0x3F
  0060    00A7    LD	0x27,A
  0061    083E    LD	A,0x3E
  0062    00A6    LD	0x26,A
41:               	
42:               	adsum += ad_temp;
  0063    083E    LD	A,0x3E
  0064    00B8    LD	0x38,A
  0065    083F    LD	A,0x3F
  0066    00B9    LD	0x39,A
  0067    01BA    CLR	0x3A
  0068    01BB    CLR	0x3B
  0069    0838    LD	A,0x38
  006A    07A0    ADDR	0x20
  006B    0839    LD	A,0x39
  006C    1103    CLRB	0x3,2
  006D    1803    SZB	0x3,0
  006E    3E01    ADDIA	0x1
  006F    1D03    SNZB	0x3,2
  0070    07A1    ADDR	0x21
  0071    083A    LD	A,0x3A
  0072    1103    CLRB	0x3,2
  0073    1803    SZB	0x3,0
  0074    3E01    ADDIA	0x1
  0075    1D03    SNZB	0x3,2
  0076    07A2    ADDR	0x22
  0077    083B    LD	A,0x3B
  0078    1103    CLRB	0x3,2
  0079    1803    SZB	0x3,0
  007A    3E01    ADDIA	0x1
  007B    1D03    SNZB	0x3,2
  007C    07A3    ADDR	0x23
43:               	if(++adtimes >= 10)
  007D    300A    LDIA	0xA
  007E    0AB0    INCR	0x30
  007F    0230    SUBA	0x30
  0080    1C03    SNZB	0x3,0
  0081    0008    RET
44:               	{
45:               		adsum -= admax;
  0082    0824    LD	A,0x24
  0083    00B8    LD	0x38,A
  0084    0825    LD	A,0x25
  0085    20AF    CALL	0xAF
  0086    1C03    SNZB	0x3,0
  0087    0F3B    SZINCA	0x3B
  0088    02A3    SUBR	0x23
46:               		adsum -= admin;
  0089    0826    LD	A,0x26
  008A    00B8    LD	0x38,A
  008B    0827    LD	A,0x27
  008C    20AF    CALL	0xAF
  008D    1C03    SNZB	0x3,0
  008E    0F3B    SZINCA	0x3B
  008F    02A3    SUBR	0x23
47:               		
48:               		adresult = adsum >> 3;		//8次平均值作为最终结果
  0090    0820    LD	A,0x20
  0091    00B8    LD	0x38,A
  0092    0821    LD	A,0x21
  0093    00B9    LD	0x39,A
  0094    0822    LD	A,0x22
  0095    00BA    LD	0x3A,A
  0096    0823    LD	A,0x23
  0097    00BB    LD	0x3B,A
  0098    3003    LDIA	0x3
  0099    1003    CLRB	0x3,0
  009A    0CBB    RRCR	0x3B
  009B    0CBA    RRCR	0x3A
  009C    0CB9    RRCR	0x39
  009D    0CB8    RRCR	0x38
  009E    3EFF    ADDIA	0xFF
  009F    1D03    SNZB	0x3,2
  00A0    2899    JP	0x99
  00A1    0839    LD	A,0x39
  00A2    00AF    LD	0x2F,A
  00A3    0838    LD	A,0x38
  00A4    00AE    LD	0x2E,A
49:               		
50:               		adsum = 0;
  00A5    01A0    CLR	0x20
  00A6    01A1    CLR	0x21
  00A7    01A2    CLR	0x22
  00A8    01A3    CLR	0x23
51:               		admin = 0;
  00A9    01A6    CLR	0x26
  00AA    01A7    CLR	0x27
52:               		admax = 0;
  00AB    01A4    CLR	0x24
  00AC    01A5    CLR	0x25
53:               		adtimes = 0;
  00AD    01B0    CLR	0x30
  00AE    0008    RET
54:               	}
55:               }
56:               
57:               
58:               //ADC单次采样
59:               unsigned char ADC_Result(unsigned char adch)
60:               {
61:               	ADCON1 = 0;						//左对齐
62:               	ADCON0 = 0X41 | (adch << 2);	//16分频
63:               	asm("nop");
64:               	asm("nop");
65:               	GODONE = 1;						//开始转换
66:               
67:               	unsigned char i = 0;
68:               	while(GODONE)
69:               	{
70:               		if(0 == (--i))
71:               			return 0;				//转换超时
72:               	}
73:               	return ADRESH;
74:               }
75:               /***********************************************************
76:               函数名称：DelayXms
77:               函数功能：毫秒级非精准延时
78:               入口参数：x - 延时时间
79:               出口参数：
80:               备    注：
81:               ***********************************************************/
82:               void DelayXms(unsigned char x)
  02C4    00F4    LD	0x74,A
83:               {
84:               	unsigned char i,j;
85:               	for(i=x;i>0;i--)
  02C5    00F5    LD	0x75,A
  02C6    0875    LD	A,0x75
  02C7    1903    SZB	0x3,2
  02C8    0008    RET
86:               		for(j=153;j>0;j--);
  02C9    3099    LDIA	0x99
  02CA    00F6    LD	0x76,A
  02CB    0BF6    SZDECR	0x76
  02CC    2ACB    JP	0x2CB
  02CD    03F5    DECR	0x75
  02CE    2AC6    JP	0x2C6
87:               }
88:               
89:               //读取内部电压
90:               unsigned int readVrefADC()
91:               {
92:               	DelayXms(1);
  02FF    3001    LDIA	0x1
  0300    22C4    CALL	0x2C4
93:               	ADC_Sample(15);
  0301    300F    LDIA	0xF
  0302    2819    JP	0x19
94:               	//unsigned char result;
95:               		
96:               	//result = ADC_Result(15);
97:               	return adresult;
98:               }
---- C:\工具\单片机学习资料\SC8P\SCMCU_IDE_V2.00.07\data\sources\common\awdiv.c ----------------------------------------------------------------------
1:                // integer signed division
2:                
3:                signed int
4:                #ifdef __PICC__
5:                #warning TODO: update cgpic and this file to use the other prototype
6:                __awdiv(signed int divisor, signed int dividend)
  00C3    01BD    CLR	0x3D
  00C4    1FB9    SNZB	0x39,7
  00C5    28CD    JP	0xCD
  00C6    09B8    COMR	0x38
  00C7    09B9    COMR	0x39
  00C8    0AB8    INCR	0x38
  00C9    1903    SZB	0x3,2
  00CA    0AB9    INCR	0x39
  00CB    01BD    CLR	0x3D
  00CC    0ABD    INCR	0x3D
  00CD    1FBB    SNZB	0x3B,7
  00CE    28D6    JP	0xD6
  00CF    09BA    COMR	0x3A
  00D0    09BB    COMR	0x3B
  00D1    0ABA    INCR	0x3A
  00D2    1903    SZB	0x3,2
  00D3    0ABB    INCR	0x3B
  00D4    3001    LDIA	0x1
  00D5    06BD    XORR	0x3D
  00D6    01BE    CLR	0x3E
  00D7    01BF    CLR	0x3F
  00D8    0838    LD	A,0x38
  00D9    0439    ORA	0x39
  00DA    1903    SZB	0x3,2
  00DB    28FB    JP	0xFB
  00DC    01BC    CLR	0x3C
  00DD    0ABC    INCR	0x3C
  00DE    1BB9    SZB	0x39,7
  00DF    28E4    JP	0xE4
  00E0    1003    CLRB	0x3,0
  00E1    0DB8    RLCR	0x38
  00E2    0DB9    RLCR	0x39
  00E3    28DD    JP	0xDD
  00E4    1003    CLRB	0x3,0
  00E5    0DBE    RLCR	0x3E
  00E6    0DBF    RLCR	0x3F
  00E7    0839    LD	A,0x39
  00E8    023B    SUBA	0x3B
  00E9    1D03    SNZB	0x3,2
  00EA    28ED    JP	0xED
  00EB    0838    LD	A,0x38
  00EC    023A    SUBA	0x3A
  00ED    1C03    SNZB	0x3,0
  00EE    28F7    JP	0xF7
  00EF    0838    LD	A,0x38
  00F0    02BA    SUBR	0x3A
  00F1    0839    LD	A,0x39
  00F2    1C03    SNZB	0x3,0
  00F3    03BB    DECR	0x3B
  00F4    02BB    SUBR	0x3B
  00F5    143E    SETB	0x3E,0
  00F6    1003    CLRB	0x3,0
  00F7    0CB9    RRCR	0x39
  00F8    0CB8    RRCR	0x38
  00F9    0BBC    SZDECR	0x3C
  00FA    28E4    JP	0xE4
  00FB    083D    LD	A,0x3D
  00FC    1903    SZB	0x3,2
  00FD    2903    JP	0x103
  00FE    09BE    COMR	0x3E
  00FF    09BF    COMR	0x3F
  0100    0ABE    INCR	0x3E
  0101    1903    SZB	0x3,2
  0102    0ABF    INCR	0x3F
  0103    083F    LD	A,0x3F
  0104    00B9    LD	0x39,A
  0105    083E    LD	A,0x3E
  0106    00B8    LD	0x38,A
  0107    0008    RET
7:                #else
8:                __awdiv(signed int dividend, signed int divisor)
9:                #endif
10:               {
11:               	signed int	quotient;
12:               	unsigned char	counter, sign;
13:               
14:               	sign = 0;
15:               	if(divisor < 0) {
16:               		divisor = -divisor;
17:               		sign = 1;
18:               	}
19:               	if(dividend < 0) {
20:               		dividend = -dividend;
21:               		sign ^= 1;
22:               	}
23:               	quotient = 0;
24:               	if(divisor != 0) {
25:               		counter = 1;
26:               		while((divisor & 0x8000U) == 0) {
27:               			divisor <<= 1;
28:               			counter++;
29:               		}
30:               		do {
31:               			quotient <<= 1;
32:               			if((unsigned int)divisor <= (unsigned int)dividend) {
33:               				dividend -= divisor;
34:               				quotient |= 1;
35:               			}
36:               			*(unsigned int *)&divisor >>= 1;
37:               		} while(--counter != 0);
38:               	}
39:               	if(sign)
40:               		quotient = -quotient;
41:               	return quotient;
42:               }
---- C:\SCMCU WorkSpace\n9_fan_no_led\init.c ----------------------------------------------------------------------
1:                #include "init.h"
2:                
3:                void Init_System() {
  02D9    0000    NOP
  02DA    0064    CLRWDT
  02E2    0000    NOP
  02E3    0064    CLRWDT
4:                    asm("nop");
5:                    asm("clrwdt");
6:                    INTCON = 0;                    //系统初始化
  02DB    018B    CLR	0xB
  02E4    018B    CLR	0xB
7:                    OSCCON = 0X71;                //配置振荡为8M,开 WDT
  02DC    3071    LDIA	0x71
  02DD    1683    SETB	0x3,5
  02DE    1303    CLRB	0x3,6
  02DF    008F    LD	0xF,A
  02E5    3071    LDIA	0x71
  02E6    1683    SETB	0x3,5
  02E7    1303    CLRB	0x3,6
  02E8    008F    LD	0xF,A
8:                    OPTION_REG = 0x00;        //Timer0使用内部时钟Focs/4，预分频比为1:2
  02E0    0181    CLR	0x1
  02E1    0008    RET
  02E9    0181    CLR	0x1
  02EA    0008    RET
9:                
10:               }
11:               
12:               
13:               void Init_GPIO() {
14:                   TRISA = 0;
  0249    0185    CLR	0x5
  025B    0185    CLR	0x5
15:                   TRISB = 0;
  024A    0186    CLR	0x6
  025C    0186    CLR	0x6
16:                   TRISC = 0;
  024B    0187    CLR	0x7
  025D    0187    CLR	0x7
17:                   WPUA = 0xFF;
  024C    30FF    LDIA	0xFF
  024D    1703    SETB	0x3,6
  024E    008E    LD	0xE,A
  025E    30FF    LDIA	0xFF
  025F    1703    SETB	0x3,6
  0260    008E    LD	0xE,A
18:                   WPUB = 0xFF;
  024F    1303    CLRB	0x3,6
  0250    0095    LD	0x15,A
  0261    1303    CLRB	0x3,6
  0262    0095    LD	0x15,A
19:                   WPUC = 0xFF;
  0251    1703    SETB	0x3,6
  0252    008F    LD	0xF,A
  0263    1703    SETB	0x3,6
  0264    008F    LD	0xF,A
20:                   PORTA = 0xFF;
  0253    1283    CLRB	0x3,5
  0254    1303    CLRB	0x3,6
  0255    0085    LD	0x5,A
  0265    1283    CLRB	0x3,5
  0266    1303    CLRB	0x3,6
  0267    0085    LD	0x5,A
21:                   PORTB = 0xFF;
  0256    0086    LD	0x6,A
  0268    0086    LD	0x6,A
22:                   PORTC = 0xFF;
  0257    0087    LD	0x7,A
  0269    0087    LD	0x7,A
23:                   IOCB = 0x00;
  0258    1683    SETB	0x3,5
  0259    0196    CLR	0x16
  025A    0008    RET
  026A    1683    SETB	0x3,5
  026B    0196    CLR	0x16
  026C    0008    RET
24:               
25:               }
26:               
27:               void Init_Interupt() {
28:                   OPTION_REG = 0x00;        //Timer0使用内部时钟Focs/4，预分频比为1:2
  02F3    0181    CLR	0x1
  02F9    0181    CLR	0x1
29:                   TMR0 = 0;                //赋予初始值
  02F4    1283    CLRB	0x3,5
  02F5    0181    CLR	0x1
  02FA    1283    CLRB	0x3,5
  02FB    0181    CLR	0x1
30:                   INTCON = 0xE0;            //允许所有未被屏蔽的中断、禁止外设中断，使能Timer0
  02F6    30E0    LDIA	0xE0
  02F7    008B    LD	0xB,A
  02F8    0008    RET
  02FC    30E0    LDIA	0xE0
  02FD    008B    LD	0xB,A
  02FE    0008    RET
31:               
32:               }
---- stringtab ------------------------------------------------------------------
---- reset_enter ------------------------------------------------------------------
  0000    280C    JP	0xC
  000C    280D    JP	0xD
---- start_initialization ------------------------------------------------------------------
  000D    3002    LDIA	0x2
  000E    00F7    LD	0x77,A
  000F    3001    LDIA	0x1
  0010    00F8    LD	0x78,A
  0011    3020    LDIA	0x20
  0012    1383    CLRB	0x3,7
  0013    0084    LD	0x4,A
  0014    3038    LDIA	0x38
  0015    22EB    CALL	0x2EB
  0016    01F9    CLR	0x79
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F1    LD	0x71,A
  0007    0804    LD	A,0x4
  0008    00F2    LD	0x72,A
  0009    080A    LD	A,0xA
  000A    00F3    LD	0x73,A
  000B    2A0B    JP	0x20B
---- common_function ------------------------------------------------------------------
  0017    0183    CLR	0x3
  0018    29CF    JP	0x1CF
  00AF    00B9    LD	0x39,A
  00B0    01BA    CLR	0x3A
  00B1    01BB    CLR	0x3B
  00B2    0838    LD	A,0x38
  00B3    02A0    SUBR	0x20
  00B4    0839    LD	A,0x39
  00B5    1C03    SNZB	0x3,0
  00B6    0F39    SZINCA	0x39
  00B7    02A1    SUBR	0x21
  00B8    083A    LD	A,0x3A
  00B9    1C03    SNZB	0x3,0
  00BA    0F3A    SZINCA	0x3A
  00BB    02A2    SUBR	0x22
  00BC    083B    LD	A,0x3B
  00BD    0008    RET
  00BE    083F    LD	A,0x3F
  00BF    00A5    LD	0x25,A
  00C0    083E    LD	A,0x3E
  00C1    00A4    LD	0x24,A
  00C2    0008    RET
  02EB    0064    CLRWDT
  02EC    0180    CLR	0x0
  02ED    0A84    INCR	0x4
  02EE    0604    XORA	0x4
  02EF    1903    SZB	0x3,2
  02F0    3400    RET	0x0
  02F1    0604    XORA	0x4
  02F2    2AEC    JP	0x2EC
  0303    2910    JP	0x110
  0304    2918    JP	0x118
  0305    2922    JP	0x122
  0306    2935    JP	0x135
