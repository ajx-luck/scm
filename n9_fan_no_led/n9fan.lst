---- E:\project\project0508\scm\n9_fan_no_led\main.c ----------------------------------------------------------------------
1:                #include "scankey.h"
2:                #include "init.h"
3:                #include "adc.h"
4:                
5:                #define MAX_FAN_LEVEL 4
6:                #define MIN_FAN_LEVEL 1
7:                
8:                #define FAN_STATUS_OFF  0
9:                #define FAN_STATUS_ON  1
10:               #define FAN_STATUS_NONE 2
11:               
12:               #define PBPORTB PORTA
13:               #define PBTRISB TRISA
14:               
15:               
16:               //1毫秒中断标志
17:               static unsigned char time0Flag = 0;
18:               static unsigned int countTime = 0;
19:               static unsigned int count10Ms = 0;
20:               unsigned char currentLevel = 1;
21:               //低电压检测次数
22:               unsigned char lowVTime = 0;
23:               //风扇状态
24:               unsigned char FAN_STATUS = FAN_STATUS_ON;
25:               //检测风扇次数
26:               unsigned int fan_check_time = 0;
27:               //按键结构体
28:               struct Keys key1;
29:               //关闭风扇
30:               void closeFan();
31:               //初始化配置
32:               void Init_Config();
33:               //睡眠模式
34:               void Sleep_Mode();
35:               
36:               void checkUsbStatus() {
37:               	//工作时不亮灯
38:                   if(FAN_STATUS == FAN_STATUS_ON)
  0108    0B78    SZDECA	0x78
  0109    290D    JP	0x10D
39:               	{
40:               		setbit(PORTA, 0);
  010A    1405    SETB	0x5,0
41:               		setbit(PORTC, 1);
  010B    1487    SETB	0x7,1
42:               		return;
  010C    0008    RET
43:               	}
44:               	//USB连接了
45:               	if (getbit(PORTB, 2) == 1) {
  010D    0806    LD	A,0x6
  010E    00F4    LD	0x74,A
  010F    1003    CLRB	0x3,0
  0110    0CF4    RRCR	0x74
  0111    1003    CLRB	0x3,0
  0112    0CF4    RRCR	0x74
  0113    1C74    SNZB	0x74,0
  0114    2928    JP	0x128
46:               		lowVTime = 0;
  0115    01F6    CLR	0x76
47:                       if (getbit(PORTB, 1) == 1) {
  0116    0806    LD	A,0x6
  0117    00F4    LD	0x74,A
  0118    1003    CLRB	0x3,0
  0119    0CF4    RRCR	0x74
  011A    1C74    SNZB	0x74,0
  011B    291F    JP	0x11F
48:                           //充满了，PC1常亮,A0关闭
49:                           resetbit(PORTC, 1);
  011C    1087    CLRB	0x7,1
50:               			setbit(PORTA, 0);
  011D    1405    SETB	0x5,0
51:                       } else if (countTime == 100) {
  011E    0008    RET
  011F    3064    LDIA	0x64
  0120    062A    XORA	0x2A
  0121    042B    ORA	0x2B
  0122    1D03    SNZB	0x3,2
  0123    0008    RET
52:                           //充电中，一直闪，C1关闭		
53:                           reversebit(PORTA, 0);
  0124    3001    LDIA	0x1
  0125    0685    XORR	0x5
54:               			setbit(PORTC, 1);
  0126    1487    SETB	0x7,1
  0127    0008    RET
55:                       }
56:                   } else {
57:                       //usb断开充电灯熄灭,PA0 = 1
58:                       setbit(PORTA, 0);
  0128    1405    SETB	0x5,0
59:               		setbit(PORTC, 1);
  0129    1487    SETB	0x7,1
60:               		
61:               		//检测内部电压值,电压低于3.1V
62:               		if((adresult/8) > 0x63 && countTime == 100)
  012A    082D    LD	A,0x2D
  012B    00F5    LD	0x75,A
  012C    082C    LD	A,0x2C
  012D    00F4    LD	0x74,A
  012E    3000    LDIA	0x0
  012F    1003    CLRB	0x3,0
  0130    0CF5    RRCR	0x75
  0131    0CF4    RRCR	0x74
  0132    1003    CLRB	0x3,0
  0133    0CF5    RRCR	0x75
  0134    0CF4    RRCR	0x74
  0135    1003    CLRB	0x3,0
  0136    0CF5    RRCR	0x75
  0137    0CF4    RRCR	0x74
  0138    0275    SUBA	0x75
  0139    3064    LDIA	0x64
  013A    1903    SZB	0x3,2
  013B    0274    SUBA	0x74
  013C    1C03    SNZB	0x3,0
  013D    0008    RET
  013E    3064    LDIA	0x64
  013F    062A    XORA	0x2A
  0140    042B    ORA	0x2B
  0141    1D03    SNZB	0x3,2
  0142    0008    RET
63:               		{
64:               			if(lowVTime < 10)
  0143    300A    LDIA	0xA
  0144    0276    SUBA	0x76
  0145    1803    SZB	0x3,0
  0146    0008    RET
  0147    3001    LDIA	0x1
65:               			{
66:               				lowVTime++;
  0148    0AF6    INCR	0x76
67:               				//闪红灯，
68:               				reversebit(PORTA, 0);
  0149    0685    XORR	0x5
  014A    0008    RET
69:               			}
70:               		}
71:                   }
72:               }
73:               
74:               void Init_PWM() {
75:                   CCP1CON = 0x0F;//设置PC2为PWM模式，4,5位为占空比的低2位
76:                   T2CON = 0; //时钟分频 1:1 PWM周期为（PR2+1）*4/8,000,000
77:                   PR2 = 7;
78:               
79:                   CCPR1L = 0;//占空比高8位，低2位设置为0，结果就是 占空比 = CCPR1L*4/4*(PR2+1)
80:                   TMR2IF = 0;
81:                   T2CON = 0;
82:                   //PC2设置为输出脚
83:                   resetbit(TRISC, 2);
  0293    2A94    JP	0x294
  02F6    2A94    JP	0x294
84:                   //T2CON = 0X04 //启动定时器2，溢出后启动PWM
85:               }
86:               
87:               //设置风扇转速
88:               void setFanLevel(char level) {
  018D    00F4    LD	0x74,A
89:               	if(level == 0)
  018E    0874    LD	A,0x74
  018F    1D03    SNZB	0x3,2
  0190    2993    JP	0x193
90:               	{
91:               		currentLevel = 2;
  0191    3002    LDIA	0x2
  0192    00F9    LD	0x79,A
92:               	}
93:                   unsigned int levelWidth = (PR2 + 1) / MAX_FAN_LEVEL;
  0193    1683    SETB	0x3,5
  0194    0812    LD	A,0x12
  0195    1283    CLRB	0x3,5
  0196    00B8    LD	0x38,A
  0197    01B9    CLR	0x39
  0198    0AB8    INCR	0x38
  0199    1903    SZB	0x3,2
  019A    0AB9    INCR	0x39
  019B    3004    LDIA	0x4
  019C    00B6    LD	0x36,A
  019D    01B7    CLR	0x37
  019E    20C3    CALL	0xC3
94:                   char tempLevel = currentLevel + level;
  019F    0874    LD	A,0x74
  01A0    0779    ADDA	0x79
  01A1    00F5    LD	0x75,A
95:                   if (tempLevel > MAX_FAN_LEVEL) {
  01A2    3005    LDIA	0x5
  01A3    0275    SUBA	0x75
  01A4    1C03    SNZB	0x3,0
  01A5    29A8    JP	0x1A8
96:                       tempLevel = MIN_FAN_LEVEL;
  01A6    01F5    CLR	0x75
  01A7    0AF5    INCR	0x75
97:                   }
98:               
99:                   
100:                  if (FAN_STATUS == FAN_STATUS_ON) {
  01A8    0B78    SZDECA	0x78
  01A9    0008    RET
101:              		currentLevel = tempLevel;
  01AA    0875    LD	A,0x75
  01AB    00F9    LD	0x79,A
102:              		switch(currentLevel)
  01AC    29B7    JP	0x1B7
103:              		{
104:              			case 1:
105:              			closeFan();
  01AD    2ACC    JP	0x2CC
106:              			break;
107:              			case 2:
108:              			CCPR1L = 2;
  01AE    3002    LDIA	0x2
  01AF    0095    LD	0x15,A
109:              			break;
  01B0    0008    RET
110:              			case 3:
111:              			CCPR1L = 3;
  01B1    3003    LDIA	0x3
  01B2    0095    LD	0x15,A
112:              			break;
  01B3    0008    RET
113:              			case 4:
114:              			CCPR1L = 5;
  01B4    3005    LDIA	0x5
  01B5    0095    LD	0x15,A
115:              			break;
  01B6    0008    RET
  01B7    0879    LD	A,0x79
  01B8    3A01    XORIA	0x1
  01B9    1903    SZB	0x3,2
  01BA    29AD    JP	0x1AD
  01BB    3A03    XORIA	0x3
  01BC    1903    SZB	0x3,2
  01BD    29AE    JP	0x1AE
  01BE    3A01    XORIA	0x1
  01BF    1903    SZB	0x3,2
  01C0    29B1    JP	0x1B1
  01C1    3A07    XORIA	0x7
  01C2    1903    SZB	0x3,2
  01C3    29B4    JP	0x1B4
  01C4    29C5    JP	0x1C5
  01C5    0008    RET
116:              		}
117:                  //设置占宽比
118:              		//CCPR1L = levelWidth * currentLevel;
119:                    
120:                  }
121:              
122:              }
123:              
124:              //关闭风扇
125:              void closeFan() {
126:                  Init_PWM();
  02CC    2293    CALL	0x293
127:                  currentLevel = 1;
  02CD    01F9    CLR	0x79
  02CE    0AF9    INCR	0x79
128:                  setbit(PORTA, 0);
  02CF    1283    CLRB	0x3,5
  02D0    1405    SETB	0x5,0
129:                  //PWM输出脚设置为输入，关闭PWM
130:                  setbit(TRISC, 2);
131:                  fan_check_time = 0;
  02D1    1683    SETB	0x3,5
  02D2    1507    SETB	0x7,2
132:                  FAN_STATUS = FAN_STATUS_OFF;
  02D3    01F8    CLR	0x78
133:                  Sleep_Mode();
  02D4    29E5    JP	0x1E5
134:              }
135:              
136:              
137:              //检测风扇是否连接
138:              void checkFan() {
139:              	resetbit(TRISA, 1);
  02A1    1683    SETB	0x3,5
  02A2    1303    CLRB	0x3,6
  02A3    1085    CLRB	0x5,1
140:                  resetbit(PORTA, 1);
  02A4    1283    CLRB	0x3,5
  02A5    1085    CLRB	0x5,1
141:                  //PC2设置为输出脚
142:                  resetbit(TRISC, 2);
  02A6    1683    SETB	0x3,5
  02A7    1107    CLRB	0x7,2
143:              	setbit(PORTA, 2);
  02A8    1283    CLRB	0x3,5
  02A9    1505    SETB	0x5,2
144:                  T2CON = 0X04; //启动定时器2，溢出后启动PWM
  02AA    3004    LDIA	0x4
  02AB    0092    LD	0x12,A
  02AC    0008    RET
145:              
146:                  //EN IN输出高电位，D1点亮，检测FAN DET，FAN DET为低电位则风扇正常工作，高电位则未连接
147:                //  if (getbit(PORTB, 6) == 0) {
148:                 //     FAN_STATUS = FAN_STATUS_ON;
149:                 // } else {
150:                  //    FAN_STATUS = FAN_STATUS_NONE;
151:                 // }
152:              	
153:              	
154:                  //没有检测到风扇
155:                  //if (FAN_STATUS == FAN_STATUS_NONE) {
156:                  //    fan_check_time++;
157:                  //    if (fan_check_time == 3000) {
158:                   //       closeFan();
159:                    //      return;
160:                   //   }
161:                  //}
162:              
163:              
164:              }
165:              
166:              
167:              
168:              
169:              //扫描按键
170:              void scanKeys() {
171:                  key1.key_addr_result = PORTB;
  02B8    1283    CLRB	0x3,5
  02B9    1303    CLRB	0x3,6
  02BA    0806    LD	A,0x6
  02BB    00B4    LD	0x34,A
172:                  sacnKeyInput(&key1);
  02BC    302F    LDIA	0x2F
  02BD    2204    CALL	0x204
173:                  countTime++;
  02BE    0AAA    INCR	0x2A
  02BF    1903    SZB	0x3,2
  02C0    0AAB    INCR	0x2B
  02C1    0008    RET
174:                 
175:              }
176:              
177:              //检测按键状态并处理
178:              void checkKeys() {
179:                  if (key_driver(&key1) == key_click) {
  024D    302F    LDIA	0x2F
  024E    214B    CALL	0x14B
  024F    3A01    XORIA	0x1
  0250    1D03    SNZB	0x3,2
  0251    2A5B    JP	0x25B
180:                      //检测到按键了，检测风扇是否存在
181:              
182:                      if (FAN_STATUS == FAN_STATUS_ON) {
  0252    0B78    SZDECA	0x78
  0253    2A56    JP	0x256
183:              			//按一下，风扇加档
184:                          setFanLevel(1);
  0254    3001    LDIA	0x1
  0255    298D    JP	0x18D
185:                          
186:                      } else {
  0256    3000    LDIA	0x0
187:                          FAN_STATUS = FAN_STATUS_ON;
  0257    01F8    CLR	0x78
  0258    0AF8    INCR	0x78
188:              			setFanLevel(0);
  0259    218D    CALL	0x18D
189:                          checkFan();
  025A    2AA1    JP	0x2A1
  025B    3002    LDIA	0x2
  025C    0678    XORA	0x78
  025D    1D03    SNZB	0x3,2
  025E    0008    RET
  025F    2A5A    JP	0x25A
190:                      }
191:                      return;
192:                  } else if (FAN_STATUS == FAN_STATUS_NONE) {
193:                      checkFan();
194:                  }
195:              
196:              
197:              }
198:              
199:              
200:              void main(void) {
201:              	//Sleep_Mode();
202:                  Init_Config();
  01C6    2221    CALL	0x221
203:                  while (1) {
204:                      //0.1毫秒检测一次
205:                      if (time0Flag) {
  01C7    0877    LD	A,0x77
  01C8    1903    SZB	0x3,2
  01C9    29D0    JP	0x1D0
  01CA    0064    CLRWDT
206:                          asm("clrwdt");
207:                          time0Flag = 0;
  01CB    01F7    CLR	0x77
208:              			scanKeys();
  01CC    22B8    CALL	0x2B8
209:                          count10Ms++;
  01CD    0AA8    INCR	0x28
  01CE    1903    SZB	0x3,2
  01CF    0AA9    INCR	0x29
210:                      }
211:              
212:                      //10毫秒检测一次
213:                      if (count10Ms == 100) {		
  01D0    3064    LDIA	0x64
  01D1    1283    CLRB	0x3,5
  01D2    0628    XORA	0x28
  01D3    0429    ORA	0x29
  01D4    1D03    SNZB	0x3,2
  01D5    29DD    JP	0x1DD
214:                          checkKeys();
  01D6    224D    CALL	0x24D
215:                          count10Ms = 0;
  01D7    1283    CLRB	0x3,5
  01D8    1303    CLRB	0x3,6
  01D9    01A8    CLR	0x28
  01DA    01A9    CLR	0x29
216:                          //检测USB状态
217:                          checkUsbStatus();
  01DB    2108    CALL	0x108
218:              			//检测内部电压
219:              			readVrefADC();
  01DC    22EB    CALL	0x2EB
220:                      }
221:              
222:                      if (countTime == 101) {
  01DD    3065    LDIA	0x65
  01DE    062A    XORA	0x2A
  01DF    042B    ORA	0x2B
  01E0    1D03    SNZB	0x3,2
  01E1    29C7    JP	0x1C7
223:                          countTime = 0;
  01E2    01AA    CLR	0x2A
  01E3    01AB    CLR	0x2B
  01E4    29C7    JP	0x1C7
224:                      }
225:              		
226:                  }
227:              
228:              }
229:              
230:              void Init_Config() {
231:              
232:                  Init_System();
  0221    22F3    CALL	0x2F3
  02E4    22C2    CALL	0x2C2
233:                  Init_GPIO();
  0222    2260    CALL	0x260
  02E5    22F8    CALL	0x2F8
234:                  Init_Interupt();
  0223    22DD    CALL	0x2DD
  02E6    22F7    CALL	0x2F7
235:                  Init_PWM();
  0224    2293    CALL	0x293
  02E7    22F6    CALL	0x2F6
236:                  //设置唤醒
237:                  IOCB = 0x04;
238:                  TMR0 = 155;
239:                  TO = 0;
240:              
241:                  //K1开关
242:                  key1.key_index = 5;
243:                  
244:                  resetKey(&key1);
  0225    2228    CALL	0x228
  0226    2273    CALL	0x273
  02E8    2228    CALL	0x228
  02E9    2283    CALL	0x283
245:              
246:                  //设置IO方向
247:                  TRISA = 0;
248:                  TRISB = 0x7E;//1-6脚输入
249:                  TRISC = 0;
  0227    2A31    JP	0x231
  02EA    2A31    JP	0x231
250:              }
251:              
252:              
253:              void Sleep_Mode() {
254:                  INTCON = 0;
  01E5    018B    CLR	0xB
255:              
256:                  OPTION_REG = 0;
  01E6    0181    CLR	0x1
257:              
258:                  TRISA = 0B00000000;        //关闭所有输出
  01E7    0185    CLR	0x5
259:                  PORTA = 0B00000000;
  01E8    1283    CLRB	0x3,5
  01E9    0185    CLR	0x5
260:                  WPUA = 0B00000000;
  01EA    1683    SETB	0x3,5
  01EB    1703    SETB	0x3,6
  01EC    018E    CLR	0xE
261:              
262:                  TRISB = 0B00100000;
  01ED    3020    LDIA	0x20
  01EE    1303    CLRB	0x3,6
  01EF    0086    LD	0x6,A
263:                  PORTB = 0B00000000;
  01F0    1283    CLRB	0x3,5
  01F1    0186    CLR	0x6
264:              
265:                  PORTB = 0;
  01F2    0186    CLR	0x6
266:                  WPUB = 0B00100000;         //RB5 上拉
  01F3    1683    SETB	0x3,5
  01F4    0095    LD	0x15,A
267:              
268:                  IOCB = 0B00100100;            //允许RB5 RB2的IO口电平变化中断
  01F5    3024    LDIA	0x24
  01F6    0096    LD	0x16,A
269:                  RBIE = 1;                    //允许PORTB电平变化中断
  01F7    158B    SETB	0xB,3
270:                  GIE = 1;                    //GIE = 0时，唤醒后执行SLEEP后程序;GIE = 1时，唤醒后跳至中断服务
  01F8    178B    SETB	0xB,7
271:              
272:                  ADCON0 = 0;                    //关闭所有模块
  01F9    1283    CLRB	0x3,5
  01FA    019F    CLR	0x1F
273:              
274:                  OSCCON = 0X70;                //配置振荡为16M,关闭WDT
  01FB    3070    LDIA	0x70
  01FC    1683    SETB	0x3,5
  01FD    008F    LD	0xF,A
275:              	
276:                  PORTB;                        //读PORTB值并锁存	
  01FE    1283    CLRB	0x3,5
  01FF    0806    LD	A,0x6
  0200    0064    CLRWDT
  0201    0063    STOP
  0202    0000    NOP
  0203    0008    RET
277:              			
278:                  asm("clrwdt");
279:              
280:                  asm("sleep");                //进入休眠模式
281:              
282:                  asm("nop");
283:              	
284:              	
285:              
286:              
287:              }
288:              
289:              
290:              /***********************************************
291:              函数名称：Timer0_Isr
292:              函数功能：中断服务
293:              入口参数：无
294:              出口参数：无
295:              备注：
296:              ***********************************************/
297:              void interrupt Timer0_Isr() {
298:                  if (T0IF) {
  0237    1D0B    SNZB	0xB,2
  0238    2A40    JP	0x240
299:                      //---------------------------------------
300:                      TMR0 += 155;        //重新赋初值，在赋值前Timer0已有计数，故在该基础上加初值
  0239    309B    LDIA	0x9B
  023A    1283    CLRB	0x3,5
  023B    1303    CLRB	0x3,6
  023C    0781    ADDR	0x1
301:                      //---------------------------------------
302:              
303:                      T0IF = 0;            //清中断标志位	
  023D    110B    CLRB	0xB,2
304:                      time0Flag = 1;
  023E    01F7    CLR	0x77
  023F    0AF7    INCR	0x77
305:              
306:                  }
307:              
308:                  if (RBIF) {
  0240    1C0B    SNZB	0xB,0
  0241    2A44    JP	0x244
309:                      RBIF = 0;            //清中断标志
  0242    100B    CLRB	0xB,0
310:                      Init_Config();
  0243    22E4    CALL	0x2E4
  0244    0873    LD	A,0x73
  0245    008A    LD	0xA,A
  0246    0872    LD	A,0x72
  0247    0084    LD	0x4,A
  0248    0E71    SWAPA	0x71
  0249    0083    LD	0x3,A
  024A    0EFE    SWAPR	0x7E
  024B    0E7E    SWAPA	0x7E
  024C    0009    RETI
311:                  }
312:              }
---- E:\project\project0508\scm\n9_fan_no_led\scankey.c ----------------------------------------------------------------------
1:                #include "scankey.h"
2:                
3:                void sacnKeyInput(struct Keys *key) {
  0204    00B6    LD	0x36,A
4:                    key->key_input = getbit(key->key_addr_result, key->key_index);
  0205    3E05    ADDIA	0x5
  0206    0084    LD	0x4,A
  0207    1383    CLRB	0x3,7
  0208    0800    LD	A,0x0
  0209    00F4    LD	0x74,A
  020A    0836    LD	A,0x36
  020B    3E06    ADDIA	0x6
  020C    0084    LD	0x4,A
  020D    0A00    INCA	0x0
  020E    2A11    JP	0x211
  020F    1003    CLRB	0x3,0
  0210    0CF4    RRCR	0x74
  0211    3EFF    ADDIA	0xFF
  0212    1D03    SNZB	0x3,2
  0213    2A0F    JP	0x20F
  0214    0874    LD	A,0x74
  0215    00F5    LD	0x75,A
  0216    0836    LD	A,0x36
  0217    3E04    ADDIA	0x4
  0218    0084    LD	0x4,A
  0219    0875    LD	A,0x75
  021A    0080    LD	0x0,A
  021B    0836    LD	A,0x36
  021C    3E04    ADDIA	0x4
  021D    0084    LD	0x4,A
  021E    3001    LDIA	0x1
  021F    0580    ANDR	0x0
  0220    0008    RET
5:                
6:                }
7:                
8:                
9:                unsigned char key_driver(struct Keys *key) {
  014B    00B8    LD	0x38,A
10:               
11:               
12:                   unsigned char key_return = key_no;
  014C    01B6    CLR	0x36
13:                   unsigned char key_read = key->key_input;  //read the I/O states
  014D    3E04    ADDIA	0x4
  014E    0084    LD	0x4,A
  014F    1383    CLRB	0x3,7
  0150    0800    LD	A,0x0
  0151    00B7    LD	0x37,A
14:               
15:                   switch (key->key_state_buffer1) {
  0152    297E    JP	0x17E
16:                       case key_state_0:
17:                           if (key_read == 0) {
  0153    0837    LD	A,0x37
  0154    1D03    SNZB	0x3,2
  0155    298B    JP	0x18B
18:                               key->key_state_buffer1 = key_state_1;
  0156    0A38    INCA	0x38
  0157    0084    LD	0x4,A
  0158    0180    CLR	0x0
  0159    0A80    INCR	0x0
  015A    298B    JP	0x18B
19:                           }
20:               
21:                           //按键被按下，状态转换到按键消抖和确认状态//
22:                           break;
23:               
24:                       case key_state_1:
25:                           if (key_read == 0) {
  015B    0837    LD	A,0x37
  015C    1D03    SNZB	0x3,2
  015D    297A    JP	0x17A
26:                               key->key_timer_cnt1 = 0;
  015E    0838    LD	A,0x38
  015F    0084    LD	0x4,A
  0160    0180    CLR	0x0
27:                               key->key_state_buffer1 = key_state_2;
  0161    0A38    INCA	0x38
  0162    0084    LD	0x4,A
  0163    3002    LDIA	0x2
  0164    2976    JP	0x176
28:                               //按键仍然处于按下状态
29:                               //消抖完成，key_timer开始准备计时
30:                               //状态切换到按下时间计时状态
31:                           } else {
32:                               key->key_state_buffer1 = key_state_0;
33:                           }
34:               
35:                           //按键已经抬起，回到按键初始状态
36:                           break;  //完成软件消抖
37:               
38:                       case key_state_2:
39:                           if (key_read == 1) {
  0165    0B37    SZDECA	0x37
  0166    296A    JP	0x16A
40:                               key_return = key_click;  //按键抬起，产生一次click操作
  0167    01B6    CLR	0x36
  0168    0AB6    INCR	0x36
  0169    297A    JP	0x17A
41:                               key->key_state_buffer1 = key_state_0;  //转换到按键初始状态
  016A    0838    LD	A,0x38
  016B    0084    LD	0x4,A
  016C    3064    LDIA	0x64
  016D    0A80    INCR	0x0
  016E    0200    SUBA	0x0
  016F    1C03    SNZB	0x3,0
  0170    298B    JP	0x18B
42:                           } else if (++(key->key_timer_cnt1) >= 100)  //按键继续按下，计时超过1000ms
43:                           {
44:                               key_return = key_long;  //送回长按事件
  0171    3003    LDIA	0x3
  0172    00B6    LD	0x36,A
45:                               key->key_state_buffer1 = key_state_3;  //转换到等待按键释放状态
  0173    0A38    INCA	0x38
  0174    0084    LD	0x4,A
  0175    3003    LDIA	0x3
  0176    0080    LD	0x0,A
  0177    298B    JP	0x18B
46:               
47:                           }
48:                           break;
49:               
50:                       case key_state_3:  //等待按键释放
51:                           if (key_read == 1)  //按键释放
  0178    0B37    SZDECA	0x37
  0179    298B    JP	0x18B
52:                           {
53:                               key->key_state_buffer1 = key_state_0;  //切回按键初始状态
  017A    0A38    INCA	0x38
  017B    0084    LD	0x4,A
  017C    0180    CLR	0x0
  017D    298B    JP	0x18B
  017E    0A38    INCA	0x38
  017F    0084    LD	0x4,A
  0180    0800    LD	A,0x0
  0181    0084    LD	0x4,A
  0182    3004    LDIA	0x4
  0183    0204    SUBA	0x4
  0184    1803    SZB	0x3,0
  0185    298B    JP	0x18B
  0186    3002    LDIA	0x2
  0187    008A    LD	0xA,A
  0188    30EF    LDIA	0xEF
  0189    0704    ADDA	0x4
  018A    0082    LD	0x2,A
54:                           }
55:               
56:                           break;
57:                   }
58:                   return key_return;
  018B    0836    LD	A,0x36
  018C    0008    RET
59:               }
60:               
61:               /***************************************************************************
62:               函数功能：中层按键处理函数，调用底层函数一次，处理双击事件的判断，
63:                                                       返回上层正确的无键、单击、双击、长按四种状态
64:               本函数由上层循环调用，间隔10ms
65:               ***************************************************************************/
66:               unsigned char key_read(struct Keys *key) {
67:               
68:                   unsigned char key_return = key_no;
69:                   unsigned char key_read = key_driver(key);
70:               //    printf("IO:%d  key status: %d\n",getSimpleKeyInput(key_input),key);
71:                   switch (key->key_state_buffer2) {
72:                       case key_state_0:
73:                           if (key_read == key_click) {
74:                               key->key_timer_cnt2 = 0;  //第一次单击，不返回，到下个状态判断是否会出现双击
75:                               key->key_state_buffer2 = key_state_1;
76:                           } else
77:                               key_return = key_read;  //对于无键、长按，返回原事件
78:                           break;
79:               
80:                       case key_state_1:
81:                           if (key_read == key_click)  //又一次单击，时间间隔小于500ms
82:                           {
83:                               key_return = key_double;  //返回双击事件，回到初始状态
84:                               key->key_state_buffer2 = key_state_0;
85:                           } else if (++(key->key_timer_cnt2) >= 50) {
86:                               //这里500ms内肯定读到的都是无键事件，因为长按大于1000ms
87:                               //在1s前底层返回的都是无键
88:               
89:                               key_return = key_click;  //500ms内没有再次出现单击事件，返回单击事件
90:                               key->key_state_buffer2 = key_state_0;  //返回初始状态
91:               
92:                           }
93:                           break;
94:                   }
95:               
96:                   return key_return;
97:               }
98:               
99:               
100:              void resetKey(struct Keys *key) {
  0273    00F4    LD	0x74,A
  0283    00F0    LD	0x70,A
101:                  key->key_timer_cnt1 = key->key_timer_cnt2 = key->key_state_buffer1 = key->key_state_buffer2 = 0;
  0274    3E03    ADDIA	0x3
  0275    0084    LD	0x4,A
  0276    1383    CLRB	0x3,7
  0277    0180    CLR	0x0
  0278    0A74    INCA	0x74
  0279    0084    LD	0x4,A
  027A    0180    CLR	0x0
  027B    0874    LD	A,0x74
  027C    3E02    ADDIA	0x2
  027D    0084    LD	0x4,A
  027E    0180    CLR	0x0
  027F    0874    LD	A,0x74
  0280    0084    LD	0x4,A
  0281    0180    CLR	0x0
  0282    0008    RET
  0284    3E03    ADDIA	0x3
  0285    0084    LD	0x4,A
  0286    1383    CLRB	0x3,7
  0287    0180    CLR	0x0
  0288    0A70    INCA	0x70
  0289    0084    LD	0x4,A
  028A    0180    CLR	0x0
  028B    0870    LD	A,0x70
  028C    3E02    ADDIA	0x2
  028D    0084    LD	0x4,A
  028E    0180    CLR	0x0
  028F    0870    LD	A,0x70
  0290    0084    LD	0x4,A
  0291    0180    CLR	0x0
  0292    0008    RET
102:              }
---- E:\project\project0508\scm\n9_fan_no_led\adc.c ----------------------------------------------------------------------
1:                #include "adc.h"
2:                
3:                /**********************************************************
4:                函数名称：AD_Sample
5:                函数功能：AD检测
6:                入口参数：adch - 检测通道
7:                出口参数：无 
8:                备    注：采样通道需自行设置为模拟口
9:                	      采样10次,取中间八次的平均值为采样结果存于adresult中
10:               **********************************************************/
11:               void ADC_Sample(unsigned char adch)
  0019    00BA    LD	0x3A,A
12:               {
13:               	static unsigned long adsum = 0;
14:               	static unsigned int admin = 0,admax = 0;
15:               	static unsigned char adtimes = 0;
16:               	volatile unsigned int ad_temp;
17:               	ADCON1 = 0;						//左对齐
  001A    1683    SETB	0x3,5
  001B    019F    CLR	0x1F
18:               	ADCON0 = 0X41 | (adch << 2);	//16分频
  001C    1283    CLRB	0x3,5
  001D    083A    LD	A,0x3A
  001E    00B6    LD	0x36,A
  001F    3001    LDIA	0x1
  0020    1003    CLRB	0x3,0
  0021    0DB6    RLCR	0x36
  0022    3EFF    ADDIA	0xFF
  0023    1003    CLRB	0x3,0
  0024    1D03    SNZB	0x3,2
  0025    2821    JP	0x21
  0026    0D36    RLCA	0x36
  0027    3841    ORIA	0x41
  0028    009F    LD	0x1F,A
  0029    0000    NOP
  002A    0000    NOP
19:               	asm("nop");
20:               	asm("nop");
21:               	GODONE = 1;						//开始转换
  002B    1283    CLRB	0x3,5
  002C    1303    CLRB	0x3,6
  002D    149F    SETB	0x1F,1
22:               
23:               	unsigned char i = 0;
  002E    01BB    CLR	0x3B
24:               	while(GODONE)
  002F    1C9F    SNZB	0x1F,1
  0030    2834    JP	0x34
25:               	{
26:               		if(0 == (--i))
  0031    0BBB    SZDECR	0x3B
  0032    282F    JP	0x2F
  0033    0008    RET
27:               			return;
28:               	}
29:               	
30:               	ad_temp=(ADRESH<<4)+(ADRESL>>4);	//计算12位AD值
  0034    081E    LD	A,0x1E
  0035    00BC    LD	0x3C,A
  0036    01BD    CLR	0x3D
  0037    0EBC    SWAPR	0x3C
  0038    0EBD    SWAPR	0x3D
  0039    30F0    LDIA	0xF0
  003A    05BD    ANDR	0x3D
  003B    083C    LD	A,0x3C
  003C    390F    ANDIA	0xF
  003D    04BD    ORR	0x3D
  003E    30F0    LDIA	0xF0
  003F    05BC    ANDR	0x3C
  0040    1683    SETB	0x3,5
  0041    0E1E    SWAPA	0x1E
  0042    390F    ANDIA	0xF
  0043    1283    CLRB	0x3,5
  0044    07BC    ADDR	0x3C
  0045    1803    SZB	0x3,0
  0046    0ABD    INCR	0x3D
31:               	
32:               	if(0 == admax)
  0047    0824    LD	A,0x24
  0048    0425    ORA	0x25
  0049    1D03    SNZB	0x3,2
  004A    284D    JP	0x4D
33:               	{
34:               		admax = ad_temp;
  004B    20BE    CALL	0xBE
  004C    285F    JP	0x5F
35:               		admin = ad_temp;
36:               	}
37:               	else if(ad_temp > admax)
  004D    083D    LD	A,0x3D
  004E    0225    SUBA	0x25
  004F    1D03    SNZB	0x3,2
  0050    2853    JP	0x53
  0051    083C    LD	A,0x3C
  0052    0224    SUBA	0x24
  0053    1803    SZB	0x3,0
  0054    2857    JP	0x57
38:               		admax = ad_temp;				//AD采样最大值
  0055    20BE    CALL	0xBE
  0056    2863    JP	0x63
39:               	else if(ad_temp < admin)
  0057    0827    LD	A,0x27
  0058    023D    SUBA	0x3D
  0059    1D03    SNZB	0x3,2
  005A    285D    JP	0x5D
  005B    0826    LD	A,0x26
  005C    023C    SUBA	0x3C
  005D    1803    SZB	0x3,0
  005E    2863    JP	0x63
40:               		admin = ad_temp;				//AD采样最小值
  005F    083D    LD	A,0x3D
  0060    00A7    LD	0x27,A
  0061    083C    LD	A,0x3C
  0062    00A6    LD	0x26,A
41:               	
42:               	adsum += ad_temp;
  0063    083C    LD	A,0x3C
  0064    00B6    LD	0x36,A
  0065    083D    LD	A,0x3D
  0066    00B7    LD	0x37,A
  0067    01B8    CLR	0x38
  0068    01B9    CLR	0x39
  0069    0836    LD	A,0x36
  006A    07A0    ADDR	0x20
  006B    0837    LD	A,0x37
  006C    1103    CLRB	0x3,2
  006D    1803    SZB	0x3,0
  006E    3E01    ADDIA	0x1
  006F    1D03    SNZB	0x3,2
  0070    07A1    ADDR	0x21
  0071    0838    LD	A,0x38
  0072    1103    CLRB	0x3,2
  0073    1803    SZB	0x3,0
  0074    3E01    ADDIA	0x1
  0075    1D03    SNZB	0x3,2
  0076    07A2    ADDR	0x22
  0077    0839    LD	A,0x39
  0078    1103    CLRB	0x3,2
  0079    1803    SZB	0x3,0
  007A    3E01    ADDIA	0x1
  007B    1D03    SNZB	0x3,2
  007C    07A3    ADDR	0x23
43:               	if(++adtimes >= 10)
  007D    300A    LDIA	0xA
  007E    0AAE    INCR	0x2E
  007F    022E    SUBA	0x2E
  0080    1C03    SNZB	0x3,0
  0081    0008    RET
44:               	{
45:               		adsum -= admax;
  0082    0824    LD	A,0x24
  0083    00B6    LD	0x36,A
  0084    0825    LD	A,0x25
  0085    20AF    CALL	0xAF
  0086    1C03    SNZB	0x3,0
  0087    0F39    SZINCA	0x39
  0088    02A3    SUBR	0x23
46:               		adsum -= admin;
  0089    0826    LD	A,0x26
  008A    00B6    LD	0x36,A
  008B    0827    LD	A,0x27
  008C    20AF    CALL	0xAF
  008D    1C03    SNZB	0x3,0
  008E    0F39    SZINCA	0x39
  008F    02A3    SUBR	0x23
47:               		
48:               		adresult = adsum >> 3;		//8次平均值作为最终结果
  0090    0820    LD	A,0x20
  0091    00B6    LD	0x36,A
  0092    0821    LD	A,0x21
  0093    00B7    LD	0x37,A
  0094    0822    LD	A,0x22
  0095    00B8    LD	0x38,A
  0096    0823    LD	A,0x23
  0097    00B9    LD	0x39,A
  0098    3003    LDIA	0x3
  0099    1003    CLRB	0x3,0
  009A    0CB9    RRCR	0x39
  009B    0CB8    RRCR	0x38
  009C    0CB7    RRCR	0x37
  009D    0CB6    RRCR	0x36
  009E    3EFF    ADDIA	0xFF
  009F    1D03    SNZB	0x3,2
  00A0    2899    JP	0x99
  00A1    0837    LD	A,0x37
  00A2    00AD    LD	0x2D,A
  00A3    0836    LD	A,0x36
  00A4    00AC    LD	0x2C,A
49:               		
50:               		adsum = 0;
  00A5    01A0    CLR	0x20
  00A6    01A1    CLR	0x21
  00A7    01A2    CLR	0x22
  00A8    01A3    CLR	0x23
51:               		admin = 0;
  00A9    01A6    CLR	0x26
  00AA    01A7    CLR	0x27
52:               		admax = 0;
  00AB    01A4    CLR	0x24
  00AC    01A5    CLR	0x25
53:               		adtimes = 0;
  00AD    01AE    CLR	0x2E
  00AE    0008    RET
54:               	}
55:               }
56:               
57:               
58:               //ADC单次采样
59:               unsigned char ADC_Result(unsigned char adch)
60:               {
61:               	ADCON1 = 0;						//左对齐
62:               	ADCON0 = 0X41 | (adch << 2);	//16分频
63:               	asm("nop");
64:               	asm("nop");
65:               	GODONE = 1;						//开始转换
66:               
67:               	unsigned char i = 0;
68:               	while(GODONE)
69:               	{
70:               		if(0 == (--i))
71:               			return 0;				//转换超时
72:               	}
73:               	return ADRESH;
74:               }
75:               /***********************************************************
76:               函数名称：DelayXms
77:               函数功能：毫秒级非精准延时
78:               入口参数：x - 延时时间
79:               出口参数：
80:               备    注：
81:               ***********************************************************/
82:               void DelayXms(unsigned char x)
  02AD    00B6    LD	0x36,A
83:               {
84:               	unsigned char i,j;
85:               	for(i=x;i>0;i--)
  02AE    00B7    LD	0x37,A
  02AF    0837    LD	A,0x37
  02B0    1903    SZB	0x3,2
  02B1    0008    RET
86:               		for(j=153;j>0;j--);
  02B2    3099    LDIA	0x99
  02B3    00B8    LD	0x38,A
  02B4    0BB8    SZDECR	0x38
  02B5    2AB4    JP	0x2B4
  02B6    03B7    DECR	0x37
  02B7    2AAF    JP	0x2AF
87:               }
88:               
89:               //读取内部电压
90:               unsigned int readVrefADC()
91:               {
92:               	DelayXms(1);
  02EB    3001    LDIA	0x1
  02EC    22AD    CALL	0x2AD
93:               	ADC_Sample(15);
  02ED    300F    LDIA	0xF
  02EE    2819    JP	0x19
94:               	//unsigned char result;
95:               		
96:               	//result = ADC_Result(15);
97:               	return adresult;
98:               }
---- E:\cms\SCMCU_IDE_V2.00.07\data\sources\common\awdiv.c ----------------------------------------------------------------------
1:                // integer signed division
2:                
3:                signed int
4:                #ifdef __PICC__
5:                #warning TODO: update cgpic and this file to use the other prototype
6:                __awdiv(signed int divisor, signed int dividend)
  00C3    01BB    CLR	0x3B
  00C4    1FB7    SNZB	0x37,7
  00C5    28CD    JP	0xCD
  00C6    09B6    COMR	0x36
  00C7    09B7    COMR	0x37
  00C8    0AB6    INCR	0x36
  00C9    1903    SZB	0x3,2
  00CA    0AB7    INCR	0x37
  00CB    01BB    CLR	0x3B
  00CC    0ABB    INCR	0x3B
  00CD    1FB9    SNZB	0x39,7
  00CE    28D6    JP	0xD6
  00CF    09B8    COMR	0x38
  00D0    09B9    COMR	0x39
  00D1    0AB8    INCR	0x38
  00D2    1903    SZB	0x3,2
  00D3    0AB9    INCR	0x39
  00D4    3001    LDIA	0x1
  00D5    06BB    XORR	0x3B
  00D6    01BC    CLR	0x3C
  00D7    01BD    CLR	0x3D
  00D8    0836    LD	A,0x36
  00D9    0437    ORA	0x37
  00DA    1903    SZB	0x3,2
  00DB    28FB    JP	0xFB
  00DC    01BA    CLR	0x3A
  00DD    0ABA    INCR	0x3A
  00DE    1BB7    SZB	0x37,7
  00DF    28E4    JP	0xE4
  00E0    1003    CLRB	0x3,0
  00E1    0DB6    RLCR	0x36
  00E2    0DB7    RLCR	0x37
  00E3    28DD    JP	0xDD
  00E4    1003    CLRB	0x3,0
  00E5    0DBC    RLCR	0x3C
  00E6    0DBD    RLCR	0x3D
  00E7    0837    LD	A,0x37
  00E8    0239    SUBA	0x39
  00E9    1D03    SNZB	0x3,2
  00EA    28ED    JP	0xED
  00EB    0836    LD	A,0x36
  00EC    0238    SUBA	0x38
  00ED    1C03    SNZB	0x3,0
  00EE    28F7    JP	0xF7
  00EF    0836    LD	A,0x36
  00F0    02B8    SUBR	0x38
  00F1    0837    LD	A,0x37
  00F2    1C03    SNZB	0x3,0
  00F3    03B9    DECR	0x39
  00F4    02B9    SUBR	0x39
  00F5    143C    SETB	0x3C,0
  00F6    1003    CLRB	0x3,0
  00F7    0CB7    RRCR	0x37
  00F8    0CB6    RRCR	0x36
  00F9    0BBA    SZDECR	0x3A
  00FA    28E4    JP	0xE4
  00FB    083B    LD	A,0x3B
  00FC    1903    SZB	0x3,2
  00FD    2903    JP	0x103
  00FE    09BC    COMR	0x3C
  00FF    09BD    COMR	0x3D
  0100    0ABC    INCR	0x3C
  0101    1903    SZB	0x3,2
  0102    0ABD    INCR	0x3D
  0103    083D    LD	A,0x3D
  0104    00B7    LD	0x37,A
  0105    083C    LD	A,0x3C
  0106    00B6    LD	0x36,A
  0107    0008    RET
7:                #else
8:                __awdiv(signed int dividend, signed int divisor)
9:                #endif
10:               {
11:               	signed int	quotient;
12:               	unsigned char	counter, sign;
13:               
14:               	sign = 0;
15:               	if(divisor < 0) {
16:               		divisor = -divisor;
17:               		sign = 1;
18:               	}
19:               	if(dividend < 0) {
20:               		dividend = -dividend;
21:               		sign ^= 1;
22:               	}
23:               	quotient = 0;
24:               	if(divisor != 0) {
25:               		counter = 1;
26:               		while((divisor & 0x8000U) == 0) {
27:               			divisor <<= 1;
28:               			counter++;
29:               		}
30:               		do {
31:               			quotient <<= 1;
32:               			if((unsigned int)divisor <= (unsigned int)dividend) {
33:               				dividend -= divisor;
34:               				quotient |= 1;
35:               			}
36:               			*(unsigned int *)&divisor >>= 1;
37:               		} while(--counter != 0);
38:               	}
39:               	if(sign)
40:               		quotient = -quotient;
41:               	return quotient;
42:               }
---- E:\project\project0508\scm\n9_fan_no_led\init.c ----------------------------------------------------------------------
1:                #include "init.h"
2:                
3:                void Init_System() {
  02C2    0000    NOP
  02C3    0064    CLRWDT
  02F3    0000    NOP
  02F4    0064    CLRWDT
4:                    asm("nop");
5:                    asm("clrwdt");
6:                    INTCON = 0;                    //系统初始化
7:                    OSCCON = 0X71;                //配置振荡为8M,开 WDT
8:                    OPTION_REG = 0x00;        //Timer0使用内部时钟Focs/4，预分频比为1:2
  02C4    2AC5    JP	0x2C5
  02F5    2AC5    JP	0x2C5
9:                
10:               }
11:               
12:               
13:               void Init_GPIO() {
14:                   TRISA = 0;
15:                   TRISB = 0;
16:                   TRISC = 0;
17:                   WPUA = 0xFF;
18:                   WPUB = 0xFF;
19:                   WPUC = 0xFF;
20:                   PORTA = 0xFF;
21:                   PORTB = 0xFF;
22:                   PORTC = 0xFF;
23:                   IOCB = 0x00;
  0260    2A61    JP	0x261
  02F8    2A61    JP	0x261
24:               
25:               }
26:               
27:               void Init_Interupt() {
28:                   OPTION_REG = 0x00;        //Timer0使用内部时钟Focs/4，预分频比为1:2
29:                   TMR0 = 0;                //赋予初始值
30:                   INTCON = 0xE0;            //允许所有未被屏蔽的中断、禁止外设中断，使能Timer0
  02DD    2ADE    JP	0x2DE
  02F7    2ADE    JP	0x2DE
31:               
32:               }
---- stringtab ------------------------------------------------------------------
---- reset_enter ------------------------------------------------------------------
  0000    280C    JP	0xC
  000C    280D    JP	0xD
---- start_initialization ------------------------------------------------------------------
  000D    3001    LDIA	0x1
  000E    00F8    LD	0x78,A
  000F    00F9    LD	0x79,A
  0010    3020    LDIA	0x20
  0011    1383    CLRB	0x3,7
  0012    0084    LD	0x4,A
  0013    3036    LDIA	0x36
  0014    22D5    CALL	0x2D5
  0015    01F6    CLR	0x76
  0016    01F7    CLR	0x77
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F1    LD	0x71,A
  0007    0804    LD	A,0x4
  0008    00F2    LD	0x72,A
  0009    080A    LD	A,0xA
  000A    00F3    LD	0x73,A
  000B    2A37    JP	0x237
---- common_function ------------------------------------------------------------------
  0017    0183    CLR	0x3
  0018    29C6    JP	0x1C6
  00AF    00B7    LD	0x37,A
  00B0    01B8    CLR	0x38
  00B1    01B9    CLR	0x39
  00B2    0836    LD	A,0x36
  00B3    02A0    SUBR	0x20
  00B4    0837    LD	A,0x37
  00B5    1C03    SNZB	0x3,0
  00B6    0F37    SZINCA	0x37
  00B7    02A1    SUBR	0x21
  00B8    0838    LD	A,0x38
  00B9    1C03    SNZB	0x3,0
  00BA    0F38    SZINCA	0x38
  00BB    02A2    SUBR	0x22
  00BC    0839    LD	A,0x39
  00BD    0008    RET
  00BE    083D    LD	A,0x3D
  00BF    00A5    LD	0x25,A
  00C0    083C    LD	A,0x3C
  00C1    00A4    LD	0x24,A
  00C2    0008    RET
  0228    3004    LDIA	0x4
  0229    0096    LD	0x16,A
  022A    309B    LDIA	0x9B
  022B    1283    CLRB	0x3,5
  022C    0081    LD	0x1,A
  022D    1203    CLRB	0x3,4
  022E    3005    LDIA	0x5
  022F    00B5    LD	0x35,A
  0230    342F    RET	0x2F
  0231    1683    SETB	0x3,5
  0232    0185    CLR	0x5
  0233    307E    LDIA	0x7E
  0234    0086    LD	0x6,A
  0235    0187    CLR	0x7
  0236    0008    RET
  0261    0185    CLR	0x5
  0262    0186    CLR	0x6
  0263    0187    CLR	0x7
  0264    30FF    LDIA	0xFF
  0265    1703    SETB	0x3,6
  0266    008E    LD	0xE,A
  0267    1303    CLRB	0x3,6
  0268    0095    LD	0x15,A
  0269    1703    SETB	0x3,6
  026A    008F    LD	0xF,A
  026B    1283    CLRB	0x3,5
  026C    1303    CLRB	0x3,6
  026D    0085    LD	0x5,A
  026E    0086    LD	0x6,A
  026F    0087    LD	0x7,A
  0270    1683    SETB	0x3,5
  0271    0196    CLR	0x16
  0272    0008    RET
  0294    300F    LDIA	0xF
  0295    0097    LD	0x17,A
  0296    0192    CLR	0x12
  0297    3007    LDIA	0x7
  0298    1683    SETB	0x3,5
  0299    0092    LD	0x12,A
  029A    1283    CLRB	0x3,5
  029B    0195    CLR	0x15
  029C    108C    CLRB	0xC,1
  029D    0192    CLR	0x12
  029E    1683    SETB	0x3,5
  029F    1107    CLRB	0x7,2
  02A0    0008    RET
  02C5    018B    CLR	0xB
  02C6    3071    LDIA	0x71
  02C7    1683    SETB	0x3,5
  02C8    1303    CLRB	0x3,6
  02C9    008F    LD	0xF,A
  02CA    0181    CLR	0x1
  02CB    0008    RET
  02D5    0064    CLRWDT
  02D6    0180    CLR	0x0
  02D7    0A84    INCR	0x4
  02D8    0604    XORA	0x4
  02D9    1903    SZB	0x3,2
  02DA    3400    RET	0x0
  02DB    0604    XORA	0x4
  02DC    2AD6    JP	0x2D6
  02DE    0181    CLR	0x1
  02DF    1283    CLRB	0x3,5
  02E0    0181    CLR	0x1
  02E1    30E0    LDIA	0xE0
  02E2    008B    LD	0xB,A
  02E3    0008    RET
  02EF    2953    JP	0x153
  02F0    295B    JP	0x15B
  02F1    2965    JP	0x165
  02F2    2978    JP	0x178
