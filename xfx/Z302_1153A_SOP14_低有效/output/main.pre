
# 1 "C:\mcuproject\scm\xfx\Z302_1153A_SOP14_低有效\main.c"

# 26 "C:\工具\单片机学习资料\SC8P\SCMCU_IDE_V2.00.07\data\include\htc.h"
extern const char __xc8_OPTIM_SPEED;

extern double __fpnormalize(double);


# 13 "C:\工具\单片机学习资料\SC8P\SCMCU_IDE_V2.00.07\data\include\xc8debug.h"
#pragma intrinsic(__builtin_software_breakpoint)
extern void __builtin_software_breakpoint(void);

# 10 "C:\工具\单片机学习资料\SC8P\SCMCU_IDE_V2.00.07\data\include\SC8P1153.h"
volatile unsigned char INDF @0x0000;
volatile unsigned char TMR0 @0x0001;
volatile unsigned char PCL @0x0002;
volatile unsigned char STATUS @0x0003;
volatile unsigned char FSR @0x0004;
volatile unsigned char PORTB @0x0005;
volatile unsigned char TRISB @0x0006;
volatile unsigned char OPTION_REG @0x0007;
volatile unsigned char OSCCON @0x0008;
volatile unsigned char INTCON @0x0009;
volatile unsigned char PCLATH @0x000A;
volatile unsigned char PDCONB @0x000B;
volatile unsigned char ODCONB @0x000C;
volatile unsigned char WPUB @0x000D;
volatile unsigned char IOCB @0x000E;
volatile unsigned char TMR0PRD @0x000F;
volatile unsigned char PWMCTR0 @0x0010;
volatile unsigned char PWMCTR1 @0x0011;
volatile unsigned char PWMCTR2 @0x0012;
volatile unsigned char PWMR @0x0013;
volatile unsigned char PWM_PRD @0x0014;
volatile unsigned char PWMPRD @0x0014;


volatile unsigned char DTCON @0x0015;
volatile unsigned char DTREG @0x0016;
volatile unsigned char PORTA @0x0017;
volatile unsigned char TRISA @0x0018;
volatile unsigned char UPDOWNA @0x0019;




volatile bit TO @ ((unsigned)&STATUS*8)+4;
volatile bit PD @ ((unsigned)&STATUS*8)+3;
volatile bit ZERO @ ((unsigned)&STATUS*8)+2;
volatile bit Z @ ((unsigned)&STATUS*8)+2;
volatile bit DC @ ((unsigned)&STATUS*8)+1;
volatile bit CARRY @ ((unsigned)&STATUS*8)+0;
volatile bit C @ ((unsigned)&STATUS*8)+0;


volatile bit PB7 @ ((unsigned)&PORTB*8)+7;
volatile bit PB6 @ ((unsigned)&PORTB*8)+6;
volatile bit PB5 @ ((unsigned)&PORTB*8)+5;
volatile bit PB4 @ ((unsigned)&PORTB*8)+4;
volatile bit PB3 @ ((unsigned)&PORTB*8)+3;
volatile bit PB2 @ ((unsigned)&PORTB*8)+2;
volatile bit PB1 @ ((unsigned)&PORTB*8)+1;
volatile bit PB0 @ ((unsigned)&PORTB*8)+0;


volatile bit PORTB7 @ ((unsigned)&PORTB*8)+7;
volatile bit PORTB6 @ ((unsigned)&PORTB*8)+6;
volatile bit PORTB5 @ ((unsigned)&PORTB*8)+5;
volatile bit PORTB4 @ ((unsigned)&PORTB*8)+4;
volatile bit PORTB3 @ ((unsigned)&PORTB*8)+3;
volatile bit PORTB2 @ ((unsigned)&PORTB*8)+2;
volatile bit PORTB1 @ ((unsigned)&PORTB*8)+1;
volatile bit PORTB0 @ ((unsigned)&PORTB*8)+0;


volatile bit TRISB7 @ ((unsigned)&TRISB*8)+7;
volatile bit TRISB6 @ ((unsigned)&TRISB*8)+6;
volatile bit TRISB5 @ ((unsigned)&TRISB*8)+5;
volatile bit TRISB4 @ ((unsigned)&TRISB*8)+4;
volatile bit TRISB3 @ ((unsigned)&TRISB*8)+3;
volatile bit TRISB2 @ ((unsigned)&TRISB*8)+2;
volatile bit TRISB1 @ ((unsigned)&TRISB*8)+1;
volatile bit TRISB0 @ ((unsigned)&TRISB*8)+0;


volatile bit XT_EN @ ((unsigned)&OPTION_REG*8)+7;
volatile bit T0SYNC @ ((unsigned)&OPTION_REG*8)+6;
volatile bit T0CS @ ((unsigned)&OPTION_REG*8)+5;
volatile bit T0SE @ ((unsigned)&OPTION_REG*8)+4;
volatile bit PSA @ ((unsigned)&OPTION_REG*8)+3;
volatile bit PS2 @ ((unsigned)&OPTION_REG*8)+2;
volatile bit PS1 @ ((unsigned)&OPTION_REG*8)+1;
volatile bit PS0 @ ((unsigned)&OPTION_REG*8)+0;


volatile bit SWDTEN @ ((unsigned)&OSCCON*8)+7;
volatile bit IRCF2 @ ((unsigned)&OSCCON*8)+6;
volatile bit IRCF1 @ ((unsigned)&OSCCON*8)+5;
volatile bit IRCF0 @ ((unsigned)&OSCCON*8)+4;
volatile bit TMR2EN @ ((unsigned)&OSCCON*8)+0;
volatile bit TMR0EN @ ((unsigned)&OSCCON*8)+0;


volatile bit GIE @ ((unsigned)&INTCON*8)+7;
volatile bit INTEG @ ((unsigned)&INTCON*8)+6;
volatile bit T0IE @ ((unsigned)&INTCON*8)+5;
volatile bit INTE @ ((unsigned)&INTCON*8)+4;
volatile bit RBIE @ ((unsigned)&INTCON*8)+3;
volatile bit PBIE @ ((unsigned)&INTCON*8)+3;

volatile bit T0IF @ ((unsigned)&INTCON*8)+2;
volatile bit INTF @ ((unsigned)&INTCON*8)+1;
volatile bit RBIF @ ((unsigned)&INTCON*8)+0;
volatile bit PBIF @ ((unsigned)&INTCON*8)+0;


volatile bit PDCONB7 @ ((unsigned)&PDCONB*8)+7;
volatile bit PDCONB6 @ ((unsigned)&PDCONB*8)+6;
volatile bit PDCONB5 @ ((unsigned)&PDCONB*8)+5;
volatile bit PDCONB4 @ ((unsigned)&PDCONB*8)+4;
volatile bit PDCONB2 @ ((unsigned)&PDCONB*8)+2;
volatile bit PDCONB1 @ ((unsigned)&PDCONB*8)+1;
volatile bit PDCONB0 @ ((unsigned)&PDCONB*8)+0;



volatile bit ODCONB7 @ ((unsigned)&ODCONB*8)+7;
volatile bit ODCONB6 @ ((unsigned)&ODCONB*8)+6;
volatile bit ODCONB5 @ ((unsigned)&ODCONB*8)+5;
volatile bit ODCONB4 @ ((unsigned)&ODCONB*8)+4;
volatile bit ODCONB2 @ ((unsigned)&ODCONB*8)+2;
volatile bit ODCONB1 @ ((unsigned)&ODCONB*8)+1;
volatile bit ODCONB0 @ ((unsigned)&ODCONB*8)+0;


volatile bit WPUB7 @ ((unsigned)&WPUB*8)+7;
volatile bit WPUB6 @ ((unsigned)&WPUB*8)+6;
volatile bit WPUB5 @ ((unsigned)&WPUB*8)+5;
volatile bit WPUB4 @ ((unsigned)&WPUB*8)+4;
volatile bit WPUB3 @ ((unsigned)&WPUB*8)+3;
volatile bit WPUB2 @ ((unsigned)&WPUB*8)+2;
volatile bit WPUB1 @ ((unsigned)&WPUB*8)+1;
volatile bit WPUB0 @ ((unsigned)&WPUB*8)+0;


volatile bit IOCB7 @ ((unsigned)&IOCB*8)+7;
volatile bit IOCB6 @ ((unsigned)&IOCB*8)+6;
volatile bit IOCB5 @ ((unsigned)&IOCB*8)+5;
volatile bit IOCB4 @ ((unsigned)&IOCB*8)+4;
volatile bit IOCB3 @ ((unsigned)&IOCB*8)+3;
volatile bit IOCB2 @ ((unsigned)&IOCB*8)+2;
volatile bit IOCB1 @ ((unsigned)&IOCB*8)+1;
volatile bit IOCB0 @ ((unsigned)&IOCB*8)+0;


volatile bit PWMR49 @ ((unsigned)&PWMCTR0*8)+7;
volatile bit PWMR48 @ ((unsigned)&PWMCTR0*8)+6;
volatile bit PWM4EN @ ((unsigned)&PWMCTR0*8)+4;
volatile bit PWM3EN @ ((unsigned)&PWMCTR0*8)+3;
volatile bit PWM2EN @ ((unsigned)&PWMCTR0*8)+2;
volatile bit PWM1EN @ ((unsigned)&PWMCTR0*8)+1;
volatile bit PWM0EN @ ((unsigned)&PWMCTR0*8)+0;

volatile bit PWMEN4 @ ((unsigned)&PWMCTR0*8)+4;
volatile bit PWMEN3 @ ((unsigned)&PWMCTR0*8)+3;
volatile bit PWMEN2 @ ((unsigned)&PWMCTR0*8)+2;
volatile bit PWMEN1 @ ((unsigned)&PWMCTR0*8)+1;
volatile bit PWMEN0 @ ((unsigned)&PWMCTR0*8)+0;


volatile bit PWMR39 @ ((unsigned)&PWMCTR1*8)+7;
volatile bit PWMR38 @ ((unsigned)&PWMCTR1*8)+6;
volatile bit PWMR29 @ ((unsigned)&PWMCTR1*8)+5;
volatile bit PWMR28 @ ((unsigned)&PWMCTR1*8)+4;
volatile bit PWMR19 @ ((unsigned)&PWMCTR1*8)+3;
volatile bit PWMR18 @ ((unsigned)&PWMCTR1*8)+2;
volatile bit PWMR09 @ ((unsigned)&PWMCTR1*8)+1;
volatile bit PWMR08 @ ((unsigned)&PWMCTR1*8)+0;


volatile bit PWMPRD9 @ ((unsigned)&PWMCTR2*8)+7;
volatile bit PWMPRD8 @ ((unsigned)&PWMCTR2*8)+6;
volatile bit T2CKPS1 @ ((unsigned)&PWMCTR2*8)+5;
volatile bit T2CKPS0 @ ((unsigned)&PWMCTR2*8)+4;
volatile bit SEL2 @ ((unsigned)&PWMCTR2*8)+2;
volatile bit SEL1 @ ((unsigned)&PWMCTR2*8)+1;
volatile bit SEL0 @ ((unsigned)&PWMCTR2*8)+0;

volatile bit PWMCK1 @ ((unsigned)&PWMCTR2*8)+5;
volatile bit PWMCK0 @ ((unsigned)&PWMCTR2*8)+4;
volatile bit PWMS2 @ ((unsigned)&PWMCTR2*8)+2;
volatile bit PWMS1 @ ((unsigned)&PWMCTR2*8)+1;
volatile bit PWMS0 @ ((unsigned)&PWMCTR2*8)+0;



volatile bit DTSEL1 @ ((unsigned)&DTCON*8)+7;
volatile bit DTSEL0 @ ((unsigned)&DTCON*8)+6;
volatile bit DTSEL @ ((unsigned)&DTCON*8)+6;
volatile bit ENDT1 @ ((unsigned)&DTCON*8)+3;
volatile bit ENDT0 @ ((unsigned)&DTCON*8)+2;
volatile bit ENCM1 @ ((unsigned)&DTCON*8)+1;
volatile bit ENCM0 @ ((unsigned)&DTCON*8)+0;


volatile bit PA3 @ ((unsigned)&PORTA*8)+3;
volatile bit PA2 @ ((unsigned)&PORTA*8)+2;
volatile bit PA1 @ ((unsigned)&PORTA*8)+1;
volatile bit PA0 @ ((unsigned)&PORTA*8)+0;


volatile bit PORTA3 @ ((unsigned)&PORTA*8)+3;
volatile bit PORTA2 @ ((unsigned)&PORTA*8)+2;
volatile bit PORTA1 @ ((unsigned)&PORTA*8)+1;
volatile bit PORTA0 @ ((unsigned)&PORTA*8)+0;


volatile bit TRISA3 @ ((unsigned)&TRISA*8)+3;
volatile bit TRISA2 @ ((unsigned)&TRISA*8)+2;
volatile bit TRISA1 @ ((unsigned)&TRISA*8)+1;
volatile bit TRISA0 @ ((unsigned)&TRISA*8)+0;


volatile bit WPUA3 @ ((unsigned)&UPDOWNA*8)+7;
volatile bit WPUA2 @ ((unsigned)&UPDOWNA*8)+6;
volatile bit WPUA1 @ ((unsigned)&UPDOWNA*8)+5;
volatile bit WPUA0 @ ((unsigned)&UPDOWNA*8)+4;
volatile bit PDCONA3 @ ((unsigned)&UPDOWNA*8)+3;
volatile bit PDCONA2 @ ((unsigned)&UPDOWNA*8)+2;
volatile bit PDCONA1 @ ((unsigned)&UPDOWNA*8)+1;
volatile bit PDCONA0 @ ((unsigned)&UPDOWNA*8)+0;


# 27 "C:\工具\单片机学习资料\SC8P\SCMCU_IDE_V2.00.07\data\include\sc.h"
#pragma intrinsic(__nop)
extern void __nop(void);

# 76
extern unsigned int flash_read(unsigned short addr);


# 149
#pragma intrinsic(_delay)
extern __nonreentrant void _delay(unsigned long);

# 184
extern unsigned char __resetbits;
extern __bit __powerdown;
extern __bit __timeout;

# 3 "C:\mcuproject\scm\xfx\Z302_1153A_SOP14_低有效\main.c"
typedef unsigned char u8t;
typedef unsigned short u16t;

u8t IntFlag = 0;
u8t intCount = 0;
u8t colorStep = 0;
u8t red = 0;
u8t lastRed = 0;
u8t green = 0;
u8t lastGreen = 0;
u8t blue = 0;
u8t lastBlue = 0;
u8t delayTime = 0;
u8t workStep = 0;
u8t waitTime = 0;
u8t workTime = 0;
u8t count1s = 0;
u8t ledCount = 0;
u8t keyCount = 0;
u8t chrgFlag = 0;
u8t chrgFullCount = 0;
u8t sleepTime = 0;


void InitSys();
void workCtr();
void showRGB();
void keyCtr();
char keyRead(char KeyStatus);
void rainbow();
void chrgCtr();
void gotoSleep();

void main()
{
InitSys();
while(1)
{
asm("clrwdt");
if(workStep == 1)
{
showRGB();
}
if(!IntFlag)
continue;
IntFlag = 0;
chrgCtr();
if(chrgFlag == 0)
keyCtr();
workCtr();
if((0x10 & PORTB) == 0 && keyCount == 0 && workStep == 0)
{
if(++sleepTime > 200)
{
sleepTime = 0;
gotoSleep();
}
}
}
}


void gotoSleep()
{
sleepTime = 0;
RBIE = 1;
GIE = 0;

IOCB = 0x18;
OSCCON = 0X71;
PORTA;
PORTB;

asm("clrwdt");

asm("sleep");

asm("nop");
OSCCON = 0X81;
PORTA;
PORTB;
IOCB = 0x00;
RBIE = 0;
}


void chrgCtr()
{
if(0x10 & PORTB)
{

workStep = 0;
waitTime = 0;
workTime = 0;
chrgFlag = 1;
if(0x20 & PORTB)
{

if(++chrgFullCount > 200)
{
chrgFullCount = 200;

PORTA &= 0xFE;
PORTB &= 0xFB;

PORTB |= 0x82;
}
}
else
{
chrgFullCount = 0;

PORTB &= 0x79;
if(count1s < 50)
{
PORTA |= 0x01;
PORTB |= 0x04;
}
else
{
PORTA &= 0xFE;
PORTB &= 0xFB;
}
}
}
else
{
chrgFlag = 0;
}
}


void workCtr()
{
if(workStep == 1)
{
PORTA |= 0x06;
rainbow();
if(workTime == 0)
{
workStep = 2;
}
}
else if(workStep == 0)
{
if(chrgFlag)
{
PORTA &= 0x01;

PORTB &= 0xFE;
}
else
{
PORTA = 0x00;
PORTB = 0x00;
}
}
else if(workStep == 2)
{
PORTB &= 0xF9;
PORTA = 0x00;



PORTB |= 0x41;
if(waitTime == 0)
{
workStep = 0;
}
}
}


void showRGB()
{

if(blue > ledCount)
{
PORTB |= 0x41;
}
else
{
PORTB &= 0xBE;
}

if(red > ledCount)
{
PORTA |= 0x01;
PORTB |= 0x04;
}
else
{
PORTA &= 0xFE;
PORTB &= 0xFB;
}

if(green > ledCount)
{
PORTB |= 0x82;
}
else
{
PORTB &= 0x7D;
}
if(++ledCount > 254)
ledCount = 0;
}



void InitSys()
{
asm("nop");
asm("clrwdt");
PORTA = 0x01;
PORTB = 0xFF;
INTCON = 0;
OSCCON = 0X71;
OPTION_REG = 0x00;
TMR0 = 155;
INTCON = 0xE0;
TRISA = 0x00;
TRISB = 0x38;
PORTA = 0x01;
PORTB = 0xFF;
PDCONB = 0x00;
WPUB = 0x28;


}

void keyCtr()
{
PORTB;
if(keyRead(0x08 & (~PORTB)))
{
if(workStep == 1)
{
workStep = 2;
waitTime = 30;
}
else
{
workStep = 1;
colorStep = 1;
workTime = 120;
}
}
}

char keyRead(char KeyStatus)
{
if (KeyStatus)
{
if(++keyCount >= 150)
{
keyCount = 150;
}
}
else
{
if(keyCount >= 5)
{
keyCount = 0;
return 1;
}
keyCount = 0;
}
return 0;
}



void rainbow()
{

if(red > lastRed)
red--;
if(green > lastGreen)
green--;
if(blue > lastBlue)
blue--;
if(red < lastRed)
red++;
if(green < lastGreen)
green++;
if(blue < lastBlue)
blue++;
if(delayTime > 0)
{
delayTime--;
return;
}
if(colorStep == 1)
{
lastRed = 255;
lastGreen = 0;
lastBlue = 0;

}
else if(colorStep == 2)
{
lastRed = 255;
lastGreen = 255;
lastBlue = 0;
}
else if(colorStep == 3)
{
lastRed = 0;
lastGreen = 255;
lastBlue = 0;
}
else if(colorStep == 4)
{
lastRed = 0;
lastGreen = 0;
lastBlue = 255;
}
else if(colorStep == 5)
{
lastRed = 255;
lastGreen = 0;
lastBlue = 255;
}
else if(colorStep == 6)
{
lastRed = 255;
lastGreen = 0;
lastBlue = 0;
}
else if(colorStep == 7)
{
lastRed = 255;
lastGreen = 255;
lastBlue = 0;
}
else if(colorStep == 8)
{
lastRed = 0;
lastGreen = 255;
lastBlue = 0;
}


if(red == lastRed && blue == lastBlue && green == lastGreen)
{
if(++colorStep > 8)
{
colorStep = 4;
}
if(delayTime == 0)
delayTime = 90;
}
}

# 365
void interrupt Timer0_Isr() {
if (T0IF) {

TMR0 += 155;


T0IF = 0;
if(++intCount >= 100)
{
IntFlag = 1;
intCount = 0;
if(++count1s >= 100)
{
count1s = 0;
if(workTime > 0)
workTime--;
if(waitTime > 0)
waitTime--;
}
}

}

if (RBIF) {
RBIF = 0;
}
}
