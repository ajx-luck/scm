
# 1 "C:\mcuproject\scm\xfx\D101_SC1711E_SOP14_\SC8P171XE_Timer2.c"

# 26 "C:\mcuproject\scm\SC8P171XE开发包\SCMCU_IDE_V2.00.09_Beta4\data\include\htc.h"
extern const char __xc8_OPTIM_SPEED;

extern double __fpnormalize(double);


# 13 "C:\mcuproject\scm\SC8P171XE开发包\SCMCU_IDE_V2.00.09_Beta4\data\include\xc8debug.h"
#pragma intrinsic(__builtin_software_breakpoint)
extern void __builtin_software_breakpoint(void);

# 10 "C:\mcuproject\scm\SC8P171XE开发包\SCMCU_IDE_V2.00.09_Beta4\data\include\SC8P171xE.h"
volatile unsigned char INDF @ 0x00;
volatile unsigned char TMR0 @ 0x01;
volatile unsigned char PCL @ 0x02;
volatile unsigned char STATUS @ 0x03;
volatile unsigned char FSR @ 0x04;
volatile unsigned char PORTA @ 0x05;
volatile unsigned char PORTB @ 0x06;
volatile unsigned char WPUA @ 0x07;
volatile unsigned char WPDA @ 0x08;
volatile unsigned char IOCA @ 0x09;
volatile unsigned char PCLATH @ 0x0A;
volatile unsigned char INTCON @ 0x0B;
volatile unsigned char PIR1 @ 0x0C;
volatile unsigned char PIR2 @ 0x0D;
volatile unsigned char PWMD2L @ 0x0E;
volatile unsigned char PWMD3L @ 0x0F;
volatile unsigned char PWMD4L @ 0x10;
volatile unsigned char TMR2 @ 0x11;
volatile unsigned char T2CON @ 0x12;
volatile unsigned char LCDCON0 @ 0x13;
volatile unsigned char LCDCON1 @ 0x14;
volatile unsigned char LCDCON @ 0x15;
volatile unsigned char PWMD0L @ 0x16;
volatile unsigned char PWMD1L @ 0x17;
volatile unsigned char PWMD01H @ 0x18;
volatile unsigned char PWMTL @ 0x19;
volatile unsigned char PWMTH @ 0x1A;
volatile unsigned char PWMCON @ 0x1B;
volatile unsigned char PWMD23H @ 0x1C;
volatile unsigned char PWM4TL @ 0x1D;
volatile unsigned char ADRESH @ 0x1E;
volatile unsigned char ADCON0 @ 0x1F;
volatile unsigned char OPTION_REG @ 0x81;
volatile unsigned char TRISA @ 0x85;
volatile unsigned char TRISB @ 0x86;
volatile unsigned char WPDB @ 0x87;
volatile unsigned char WDTCON @ 0x88;
volatile unsigned char PIE1 @ 0x8C;
volatile unsigned char PIE2 @ 0x8D;
volatile unsigned char PWMCON1 @ 0x8E;
volatile unsigned char OSCCON @ 0x8F;
volatile unsigned char LVDCON @ 0x91;
volatile unsigned char PR2 @ 0x92;
volatile unsigned char ANSEL @ 0x93;
volatile unsigned char ANSELH @ 0x94;
volatile unsigned char WPUB @ 0x95;
volatile unsigned char IOCB @ 0x96;
volatile unsigned char TABLE_SPH @ 0x97;
volatile unsigned char TABLE_SPL @ 0x98;
volatile unsigned char TABLE_DATAH @ 0x99;
volatile unsigned char ADRESL @ 0x9E;
volatile unsigned char ADCON1 @ 0x9F;



volatile bit RP0 @ ((unsigned)&STATUS*8)+5;
volatile bit TO @ ((unsigned)&STATUS*8)+4;
volatile bit PD @ ((unsigned)&STATUS*8)+3;
volatile bit Z @ ((unsigned)&STATUS*8)+2;
volatile bit DC @ ((unsigned)&STATUS*8)+1;
volatile bit C @ ((unsigned)&STATUS*8)+0;


volatile bit RA6 @ ((unsigned)&PORTA*8)+6;
volatile bit RA5 @ ((unsigned)&PORTA*8)+5;
volatile bit RA4 @ ((unsigned)&PORTA*8)+4;
volatile bit RA3 @ ((unsigned)&PORTA*8)+3;
volatile bit RA2 @ ((unsigned)&PORTA*8)+2;
volatile bit RA1 @ ((unsigned)&PORTA*8)+1;
volatile bit RA0 @ ((unsigned)&PORTA*8)+0;


volatile bit RB6 @ ((unsigned)&PORTB*8)+6;
volatile bit RB5 @ ((unsigned)&PORTB*8)+5;
volatile bit RB4 @ ((unsigned)&PORTB*8)+4;
volatile bit RB3 @ ((unsigned)&PORTB*8)+3;
volatile bit RB2 @ ((unsigned)&PORTB*8)+2;
volatile bit RB1 @ ((unsigned)&PORTB*8)+1;
volatile bit RB0 @ ((unsigned)&PORTB*8)+0;


volatile bit WPUA6 @ ((unsigned)&WPUA*8)+6;
volatile bit WPUA5 @ ((unsigned)&WPUA*8)+5;
volatile bit WPUA4 @ ((unsigned)&WPUA*8)+4;
volatile bit WPUA3 @ ((unsigned)&WPUA*8)+3;
volatile bit WPUA2 @ ((unsigned)&WPUA*8)+2;
volatile bit WPUA1 @ ((unsigned)&WPUA*8)+1;
volatile bit WPUA0 @ ((unsigned)&WPUA*8)+0;


volatile bit WPDA6 @ ((unsigned)&WPDA*8)+6;
volatile bit WPDA5 @ ((unsigned)&WPDA*8)+5;
volatile bit WPDA4 @ ((unsigned)&WPDA*8)+4;
volatile bit WPDA3 @ ((unsigned)&WPDA*8)+3;
volatile bit WPDA2 @ ((unsigned)&WPDA*8)+2;
volatile bit WPDA1 @ ((unsigned)&WPDA*8)+1;
volatile bit WPDA0 @ ((unsigned)&WPDA*8)+0;


volatile bit IOCA6 @ ((unsigned)&IOCA*8)+6;
volatile bit IOCA5 @ ((unsigned)&IOCA*8)+5;
volatile bit IOCA4 @ ((unsigned)&IOCA*8)+4;
volatile bit IOCA3 @ ((unsigned)&IOCA*8)+3;
volatile bit IOCA2 @ ((unsigned)&IOCA*8)+2;
volatile bit IOCA1 @ ((unsigned)&IOCA*8)+1;
volatile bit IOCA0 @ ((unsigned)&IOCA*8)+0;


volatile bit GIE @ ((unsigned)&INTCON*8)+7;
volatile bit PEIE @ ((unsigned)&INTCON*8)+6;
volatile bit T0IE @ ((unsigned)&INTCON*8)+5;
volatile bit INTE @ ((unsigned)&INTCON*8)+4;
volatile bit RBIE @ ((unsigned)&INTCON*8)+3;
volatile bit T0IF @ ((unsigned)&INTCON*8)+2;
volatile bit INTF @ ((unsigned)&INTCON*8)+1;
volatile bit RBIF @ ((unsigned)&INTCON*8)+0;


volatile bit RAIF @ ((unsigned)&PIR1*8)+3;
volatile bit PWMIF @ ((unsigned)&PIR1*8)+2;
volatile bit TMR2IF @ ((unsigned)&PIR1*8)+1;
volatile bit ADIF @ ((unsigned)&PIR1*8)+0;


volatile bit LVDIF @ ((unsigned)&PIR2*8)+0;


volatile bit TOUTPS3 @ ((unsigned)&T2CON*8)+6;
volatile bit TOUTPS2 @ ((unsigned)&T2CON*8)+5;
volatile bit TOUTPS1 @ ((unsigned)&T2CON*8)+4;
volatile bit TOUTPS0 @ ((unsigned)&T2CON*8)+3;
volatile bit TMR2ON @ ((unsigned)&T2CON*8)+2;
volatile bit T2CKPS1 @ ((unsigned)&T2CON*8)+1;
volatile bit T2CKPS0 @ ((unsigned)&T2CON*8)+0;


volatile bit COM6EN @ ((unsigned)&LCDCON0*8)+6;
volatile bit COM5EN @ ((unsigned)&LCDCON0*8)+5;
volatile bit COM4EN @ ((unsigned)&LCDCON0*8)+4;
volatile bit COM3EN @ ((unsigned)&LCDCON0*8)+3;
volatile bit COM2EN @ ((unsigned)&LCDCON0*8)+2;
volatile bit COM1EN @ ((unsigned)&LCDCON0*8)+1;
volatile bit COM0EN @ ((unsigned)&LCDCON0*8)+0;


volatile bit COM14EN @ ((unsigned)&LCDCON1*8)+6;
volatile bit COM13EN @ ((unsigned)&LCDCON1*8)+5;
volatile bit COM12EN @ ((unsigned)&LCDCON1*8)+4;
volatile bit COM11EN @ ((unsigned)&LCDCON1*8)+3;
volatile bit COM9EN @ ((unsigned)&LCDCON1*8)+1;
volatile bit COM8EN @ ((unsigned)&LCDCON1*8)+0;


volatile bit LCDEN @ ((unsigned)&LCDCON*8)+7;
volatile bit LCD_ISLE1 @ ((unsigned)&LCDCON*8)+1;
volatile bit LCD_ISLE0 @ ((unsigned)&LCDCON*8)+0;


volatile bit PWMD19 @ ((unsigned)&PWMD01H*8)+3;
volatile bit PWMD18 @ ((unsigned)&PWMD01H*8)+2;
volatile bit PWMD09 @ ((unsigned)&PWMD01H*8)+1;
volatile bit PWMD08 @ ((unsigned)&PWMD01H*8)+0;


volatile bit CLKDIV2 @ ((unsigned)&PWMCON*8)+7;
volatile bit CLKDIV1 @ ((unsigned)&PWMCON*8)+6;
volatile bit CLKDIV0 @ ((unsigned)&PWMCON*8)+5;
volatile bit PWM1DIR @ ((unsigned)&PWMCON*8)+3;
volatile bit PWM0DIR @ ((unsigned)&PWMCON*8)+2;
volatile bit PWM1EN @ ((unsigned)&PWMCON*8)+1;
volatile bit PWM0EN @ ((unsigned)&PWMCON*8)+0;


volatile bit PWMD39 @ ((unsigned)&PWMD23H*8)+3;
volatile bit PWMD38 @ ((unsigned)&PWMD23H*8)+2;
volatile bit PWMD29 @ ((unsigned)&PWMD23H*8)+1;
volatile bit PWMD28 @ ((unsigned)&PWMD23H*8)+0;


volatile bit ADCS1 @ ((unsigned)&ADCON0*8)+7;
volatile bit ADCS0 @ ((unsigned)&ADCON0*8)+6;
volatile bit CHS3 @ ((unsigned)&ADCON0*8)+5;
volatile bit CHS2 @ ((unsigned)&ADCON0*8)+4;
volatile bit CHS1 @ ((unsigned)&ADCON0*8)+3;
volatile bit CHS0 @ ((unsigned)&ADCON0*8)+2;
volatile bit GODONE @ ((unsigned)&ADCON0*8)+1;
volatile bit ADON @ ((unsigned)&ADCON0*8)+0;


volatile bit INTEDG @ ((unsigned)&OPTION_REG*8)+6;
volatile bit T0CS @ ((unsigned)&OPTION_REG*8)+5;
volatile bit T0SE @ ((unsigned)&OPTION_REG*8)+4;
volatile bit PSA @ ((unsigned)&OPTION_REG*8)+3;
volatile bit PS2 @ ((unsigned)&OPTION_REG*8)+2;
volatile bit PS1 @ ((unsigned)&OPTION_REG*8)+1;
volatile bit PS0 @ ((unsigned)&OPTION_REG*8)+0;


volatile bit TRISA6 @ ((unsigned)&TRISA*8)+6;
volatile bit TRISA5 @ ((unsigned)&TRISA*8)+5;
volatile bit TRISA4 @ ((unsigned)&TRISA*8)+4;
volatile bit TRISA3 @ ((unsigned)&TRISA*8)+3;
volatile bit TRISA2 @ ((unsigned)&TRISA*8)+2;
volatile bit TRISA1 @ ((unsigned)&TRISA*8)+1;
volatile bit TRISA0 @ ((unsigned)&TRISA*8)+0;


volatile bit TRISB6 @ ((unsigned)&TRISB*8)+6;
volatile bit TRISB5 @ ((unsigned)&TRISB*8)+5;
volatile bit TRISB4 @ ((unsigned)&TRISB*8)+4;
volatile bit TRISB3 @ ((unsigned)&TRISB*8)+3;
volatile bit TRISB2 @ ((unsigned)&TRISB*8)+2;
volatile bit TRISB1 @ ((unsigned)&TRISB*8)+1;
volatile bit TRISB0 @ ((unsigned)&TRISB*8)+0;


volatile bit WPDB6 @ ((unsigned)&WPDB*8)+6;
volatile bit WPDB5 @ ((unsigned)&WPDB*8)+5;
volatile bit WPDB4 @ ((unsigned)&WPDB*8)+4;
volatile bit WPDB3 @ ((unsigned)&WPDB*8)+3;
volatile bit WPDB1 @ ((unsigned)&WPDB*8)+1;
volatile bit WPDB0 @ ((unsigned)&WPDB*8)+0;


volatile bit SWDTEN @ ((unsigned)&WDTCON*8)+0;


volatile bit RAIE @ ((unsigned)&PIE1*8)+3;
volatile bit PWMIE @ ((unsigned)&PIE1*8)+2;
volatile bit TMR2IE @ ((unsigned)&PIE1*8)+1;
volatile bit ADIE @ ((unsigned)&PIE1*8)+0;


volatile bit LVDIE @ ((unsigned)&PIE2*8)+0;


volatile bit PMW4DIR @ ((unsigned)&PWMCON1*8)+5;
volatile bit PWM3DIR @ ((unsigned)&PWMCON1*8)+4;
volatile bit PWM2DIR @ ((unsigned)&PWMCON1*8)+3;
volatile bit PWM4EN @ ((unsigned)&PWMCON1*8)+2;
volatile bit PWM3EN @ ((unsigned)&PWMCON1*8)+1;
volatile bit PWM2EN @ ((unsigned)&PWMCON1*8)+0;


volatile bit IRCF2 @ ((unsigned)&OSCCON*8)+6;
volatile bit IRCF1 @ ((unsigned)&OSCCON*8)+5;
volatile bit IRCF0 @ ((unsigned)&OSCCON*8)+4;


volatile bit LVD_RES @ ((unsigned)&LVDCON*8)+7;
volatile bit LVD_SEL2 @ ((unsigned)&LVDCON*8)+3;
volatile bit LVD_SEL1 @ ((unsigned)&LVDCON*8)+2;
volatile bit LVD_SEL0 @ ((unsigned)&LVDCON*8)+1;
volatile bit LVDEN @ ((unsigned)&LVDCON*8)+0;


volatile bit ANS6 @ ((unsigned)&ANSEL*8)+6;
volatile bit ANS5 @ ((unsigned)&ANSEL*8)+5;
volatile bit ANS4 @ ((unsigned)&ANSEL*8)+4;
volatile bit ANS3 @ ((unsigned)&ANSEL*8)+3;
volatile bit ANS2 @ ((unsigned)&ANSEL*8)+2;
volatile bit ANS1 @ ((unsigned)&ANSEL*8)+1;
volatile bit ANS0 @ ((unsigned)&ANSEL*8)+0;


volatile bit ANS14 @ ((unsigned)&ANSELH*8)+6;
volatile bit ANS13 @ ((unsigned)&ANSELH*8)+5;
volatile bit ANS12 @ ((unsigned)&ANSELH*8)+4;
volatile bit ANS11 @ ((unsigned)&ANSELH*8)+3;
volatile bit ANS9 @ ((unsigned)&ANSELH*8)+1;
volatile bit ANS8 @ ((unsigned)&ANSELH*8)+0;


volatile bit WPUB6 @ ((unsigned)&WPUB*8)+6;
volatile bit WPUB5 @ ((unsigned)&WPUB*8)+5;
volatile bit WPUB4 @ ((unsigned)&WPUB*8)+4;
volatile bit WPUB3 @ ((unsigned)&WPUB*8)+3;
volatile bit WPUB2 @ ((unsigned)&WPUB*8)+2;
volatile bit WPUB1 @ ((unsigned)&WPUB*8)+1;
volatile bit WPUB0 @ ((unsigned)&WPUB*8)+0;


volatile bit IOCB6 @ ((unsigned)&IOCB*8)+6;
volatile bit IOCB5 @ ((unsigned)&IOCB*8)+5;
volatile bit IOCB4 @ ((unsigned)&IOCB*8)+4;
volatile bit IOCB3 @ ((unsigned)&IOCB*8)+3;
volatile bit IOCB2 @ ((unsigned)&IOCB*8)+2;
volatile bit IOCB1 @ ((unsigned)&IOCB*8)+1;
volatile bit IOCB0 @ ((unsigned)&IOCB*8)+0;


volatile bit ADFM @ ((unsigned)&ADCON1*8)+7;
volatile bit TADSEL @ ((unsigned)&ADCON1*8)+3;
volatile bit LDOEN @ ((unsigned)&ADCON1*8)+2;
volatile bit LDOSEL @ ((unsigned)&ADCON1*8)+0;


# 27 "C:\mcuproject\scm\SC8P171XE开发包\SCMCU_IDE_V2.00.09_Beta4\data\include\sc.h"
#pragma intrinsic(__nop)
extern void __nop(void);

# 76
extern unsigned int flash_read(unsigned short addr);


# 149
#pragma intrinsic(_delay)
extern __nonreentrant void _delay(unsigned long);

# 184
extern unsigned char __resetbits;
extern __bit __powerdown;
extern __bit __timeout;

# 22 "C:\mcuproject\scm\xfx\D101_SC1711E_SOP14_\SC8P171XE_Timer2.c"
typedef unsigned char u8t;
typedef unsigned int u16t;

# 37
static unsigned char table[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x71,0x38};

u8t intCount = 0;
u8t IntFlag = 0;
u8t sleepTime = 0;
u8t workStep = 0;
u8t lowCount = 0;
u8t red = 0;
u8t blue = 0;
u8t green = 0;
u8t ledCount = 0;
u8t ledFlag = 0;
u8t lastRed = 0;
u8t lastGreen = 0;
u8t lastBlue = 0;
u8t colorStep = 0;
u8t count250 = 0;
u8t count10ms = 0;
u8t keyCount = 0;
u8t duty = 0;
u16t count900s = 0;
u8t longPressFlag = 0;
u8t breathTime = 0;
u8t breathFalg = 0;
u8t delayTime = 0;
u16t fullTime = 0;
u16t closeTime = 0;
u8t breathWaitTime = 0;
u8t count1s = 0;
u8t currentDuty = 0;
u8t preDuty = 0;
u16t waitRainbowTime = 0;
u16t D_ADDATA1H = 0;
u16t D_ADDATA1L = 0;
u8t chrgStep = 0;
u8t batValue = 0;
u8t keyCount2 = 0;
u8t keyCount3 = 0;
u8t shiwei = 0;
u8t gewei = 0;
u8t adCheckTime = 0;
u8t firstTime = 0;
u8t maxDuty = 0;
u16t count3S = 0;
u8t pwmFlag = 0;
volatile unsigned int adresult;
volatile unsigned long adsum;
volatile unsigned int admin,admax;
volatile unsigned char adtimes;

void ADC_Sample(unsigned char adch,unsigned char adldo);
void DelayXms(unsigned char x);
void ind_light_disp( u8t udata );

void IO_Init(void);
extern int IntVecIdx;
void pwmStop();
void pwmInit();
void delay(u8t time);
void keyCtr();
void workCtr();
void gotoSleep();
void ledRed();
void ledGreen();
void ledOff();
void chrgCtr();
void checkBatAD();
char keyRead2(char KeyStatus,u8t* keyCount);
char keyRead(char KeyStatus);
void refresh();
void delay_us(u8t time);
void Delay10Us(void);



void main(void)
{
asm("nop");
asm("clrwdt");
OSCCON = 0X70;
WDTCON = 0x01;
TRISA = 0;
TRISB = 0;
IO_Init();

OPTION_REG = 0B00000000;

TMR0 = 155;
T0IF = 0;
T0IE = 1;

GIE = 1;

while(1)
{
asm("clrwdt");
if(chrgStep)
{
if(adCheckTime > 20)
{
if(batValue < 100)
{
shiwei = batValue/10;
gewei = batValue%10;
}
else
{
shiwei = gewei = 10;
}
}
refresh();
}
else if(workStep)
{
shiwei = 0;
gewei = workStep;
refresh();
}
else
{
if(firstTime == 0)
{
PORTA |= 0x11;
shiwei = gewei = 8;
refresh();
}
else
{
PORTA &= 0xEE;
RA5 = 1;
RB3 = 1;
}
}
if(!IntFlag)
continue;
IntFlag = 0;
if(++adCheckTime >= 40)
adCheckTime = 0;
if(adCheckTime < 20)
checkBatAD();
chrgCtr();
keyCtr();
if(workStep)
workCtr();
else
{
if(keyCount == 0)
pwmStop();

if(chrgStep == 0 && keyCount == 0)
{
if(++sleepTime >= 100)
gotoSleep();

}
else if(chrgStep == 0 && firstTime == 0)
{
sleepTime = 0;
}
else
{
sleepTime = 0;
}
}
}
}


void workCtr()
{
pwmInit();

if(workStep < 9)
{
maxDuty = 70 + workStep*3;
if(workStep == 1)
maxDuty = 70;
else if(workStep == 8)
maxDuty = 94;
if(duty < maxDuty)
duty++;
else
duty = maxDuty;
}
else
{

if(++count3S >= 300)
{
count3S = 0;
duty = 70;
}
if(count3S % 9 == 0)
{
if(count3S < 150)
{
if(++duty > 94)
duty = 94;
}
else
{
if(--duty < 70)
duty = 70;
}
}
}




PWMD1L = duty;
if(adresult > 2260)
{
RA0 = 1;
PORTA;
PORTB;
RA4 = 0;
}
else
{
RA0 = 0;
PORTA;
PORTB;
RA4 = 1;
}

if(count900s > 900)
{
gotoSleep();
}

}



void pwmInit()
{
if(pwmFlag == 0)
{
pwmFlag = 1;
TRISB |= 0x10;
PWMCON = 0x60;
PWMTH = 0x00;
PWMTL = 100;
PWMD01H = 0X00;
PWMD1L = duty;
PWMCON |= 0x02;
TRISB &= 0xEF;
}
}


void pwmStop()
{
pwmFlag = 0;
PWMCON &= 0xFD;
TRISB |= 0x10;
}


void checkBatAD()
{
ANS3 = 1;
TRISA3 = 1;
ADC_Sample(3,5);

if(adresult > 2800)
adresult = 2800;
else if(adresult < 2200)
adresult = 2200;
batValue = adresult - 2200;

batValue= batValue/6;

}

# 324
void ADC_Sample(unsigned char adch,unsigned char adldo)
{
volatile unsigned int ad_temp;

if(LDOEN^(adldo!=0))
{
ADCON1 = adldo;
_delay((unsigned long)((100)*(8000000UL/4000000.0)));
}
else
ADCON1 = adldo;

ADCON0 = 0X41 | (adch << 2);
asm("nop");
asm("nop");
asm("nop");
asm("nop");
GODONE = 1;

unsigned char i = 0;
while(GODONE)
{
if(0 == (--i))
return;
}

ad_temp=(ADRESH<<4)+(ADRESL>>4);

if(0 == admax)
{
admax = ad_temp;
admin = ad_temp;
}
else if(ad_temp > admax)
admax = ad_temp;
else if(ad_temp < admin)
admin = ad_temp;

adsum += ad_temp;
if(++adtimes >= 10)
{
adsum -= admax;
if(adsum >= admin) adsum -= admin;
else adsum = 0;

adresult = (unsigned int)(adsum >> 3);

adsum = 0;
admin = 0;
admax = 0;
adtimes = 0;
}
}



unsigned int ADC_Result(unsigned char adch)
{
ADCON1 = 0;
_delay((unsigned long)((20)*(8000000UL/4000000.0)));
ADCON0 = 0X41 | (adch << 2);
asm("nop");
asm("nop");
asm("nop");
asm("nop");
GODONE = 1;

unsigned char i = 0;
while(GODONE)
{
if(0 == (--i))
return 0;
}

unsigned int ad_result ;
ad_result=(ADRESH<<4)+(ADRESL>>4);
return ad_result;
}

# 409
void DelayXms(unsigned char x)
{
unsigned char i,j;
for(i=x;i>0;i--)
for(j=153;j>0;j--);
}

char keyRead(char KeyStatus)
{
if (KeyStatus)
{
if(++keyCount >= 150)
{
keyCount = 150;
if(!longPressFlag)
{
longPressFlag = 1;
return 2;
}

}
}
else
{
if(keyCount >= 150)
{
keyCount = 0;
longPressFlag = 0;
return 0;
}
else if(keyCount >= 5)
{
keyCount = 0;
return 1;
}
keyCount = 0;
}
return 0;
}



char keyRead2(char KeyStatus,u8t* keyCount)
{
if (KeyStatus)
{
(*keyCount)++;
if(*keyCount >= 200)
{
*keyCount = 200;
}
}
else
{
if(*keyCount >= 8)
{
*keyCount = 0;
return 1;
}
*keyCount = 0;
}
return 0;
}



void gotoSleep()
{
count900s = 0;
colorStep = 0;
ledFlag = 0;
sleepTime = 0;
firstTime = 1;

pwmStop();
PORTA = 0x00;
PORTB = 0x00;
workStep = 0;
RA5 = 1;
RB3 = 1;

# 516
}




void chrgCtr()
{
if(RB5)
{

chrgStep = 1;
workStep = 0;
if(batValue > 99)
{


PORTA |= 0x01;
PORTB;
PORTA &= 0xEF;
}
else
{


PORTA |= 0x10;
PORTB;
PORTA &= 0xFE;
}
}
else
{
chrgStep = 0;
}
}

void keyCtr()
{
u8t kclick = keyRead(!RA2);
if(kclick == 1)
{

workStep = 0;
}
else if(kclick == 2)
{
workStep = 1;
count900s = 0;
}
if(workStep)
{
if(keyRead2(!RA1,&keyCount2))
{

if(++workStep >= 9)
workStep = 9;
}

if(keyRead2(!RB2,&keyCount3))
{

if(--workStep <= 1)
workStep = 1;
}
}
}


void refresh()
{
RA5 = 1;
RB3 = 1;
if(shiwei > 0)
{
ind_light_disp(table[shiwei]);
RA5 = 1;
RB3 = 0;
delay_us(100);
RA5 = 1;
RB3 = 1;
}
ind_light_disp(table[gewei]);
RA5 = 0;
RB3 = 1;
delay_us(100);
RA5 = 1;
RB3 = 1;
}

void ind_light_disp( u8t udata )
{
unsigned char Count0;
for(Count0=0;Count0<=7;Count0++)
{
RB1=0;
Delay10Us();
if(udata&0x80)
{
RB0=1;
Delay10Us();
}
else
{
RB0=0;
Delay10Us();
}
RB1=1;
Delay10Us();
udata<<=1;
}
RB1=0;
RB0=0;
}

void IO_Init(void)
{

PORTA = 0x00;
PORTB = 0x00;
TRISB = 0x34;
TRISA = 0x06;
WPUA = 0x06;
WPDA = 0x00;
WPUB = 0x04;
WPDB = 0x00;

}


void Delay10Us(void)
{
__nop();
__nop();
__nop();
__nop();
__nop();
__nop();
}


void delay_us(u8t time)
{
while(time)
{
--time;
__nop();
}
}

void delay(u8t time)
{
u8t i=0;
for(i=0;i<time;i++)
__nop();
}


void interrupt Timer0_Isr(void)
{
if(T0IF)
{
TMR0 += 155;


if(++intCount>=100)
{
intCount = 0;
IntFlag = 1;
if(++count1s >= 100)
{
count1s = 0;
if(workStep)
{
++count900s;
}
else
{
count900s = 0;
}
}
}
T0IF = 0;

}
}

