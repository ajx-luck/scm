---- C:\Users\edwar\Desktop\CMS79F5118_5139程序\Usart_Demo\Async_Usart_Demo.c ----------------------------------------------------------------------
1:                /*-------------------------------------------
2:                
3:                程序名称：Usart异步收发程序
4:                日期版本：2019/12/30 <V1.0>
5:                
6:                备注：发送控制亦可选择使用发送中断（TXIE）来控制
7:                      发送，有待发送数据时将TXIE置1，最后一个字符写入
8:                	  TXREG后，将TXIE中断允许位清零。
9:                
10:               *本程序由 中微半导体有限公司 &应用支持部& 编写整理
11:               *公司网址 www.mcu.com.cn
12:               *技术支持QQ 3001082102  罗工
13:                           3001085706	陈工
14:               -------------------------------------------*/
15:               
16:               
17:               #include <cms.h>
18:               
19:               
20:               //--------------------------------------
21:               //发送/接收数组定义
22:               unsigned char Recebuffer[4];	//接收数据缓存
23:               unsigned char Sendbuffer[4];	//发送数据缓存
24:               
25:               //--------------------------------------
26:               //函数声明部分
27:               void Set_Usart_Async();			//异步USART初始化设置函数
28:               
29:               //--------------------------------------
30:               unsigned char sendcount = 0,rececount = 0;
31:               
32:               //--------------------------------------
33:               //测试示例
34:               
35:               
36:               void main()
  001C    0000    NOP
  001D    0064    CLRWDT
37:               {
38:               	asm("nop");
39:               	asm("clrwdt");
40:               	
41:               	OSCCON = 0x71;				//8M内部时钟
  001E    3071    LDIA	0x71
  001F    1683    SETB	0x3,5
  0020    1303    CLRB	0x3,6
  0021    008F    LD	0xF,A
42:               	INTCON = 0;
  0022    018B    CLR	0xB
43:               	
44:               	PIR1 = 0;
  0023    1283    CLRB	0x3,5
  0024    018C    CLR	0xC
45:               	PIE1 = 0;
  0025    1683    SETB	0x3,5
  0026    018C    CLR	0xC
46:               	PIR2 = 0;
  0027    1283    CLRB	0x3,5
  0028    018D    CLR	0xD
47:               	PIE2 = 0;
  0029    1683    SETB	0x3,5
  002A    018D    CLR	0xD
48:               	
49:               	TRISA = 0B00000000;
  002B    0185    CLR	0x5
50:               	PORTA = 0B00000000;
  002C    1283    CLRB	0x3,5
  002D    0185    CLR	0x5
51:               
52:               	/*初始化USART通信模块*/
53:               	Set_Usart_Async();
  002E    118A    CLRB	0xA,3
  002F    206B    CALL	0x6B
  0030    118A    CLRB	0xA,3
54:               
55:               	
56:               	INTCON = 0XC0;				//全局中断使能
  0031    30C0    LDIA	0xC0
  0032    008B    LD	0xB,A
57:               	
58:               	
59:               	while(1)
  0033    0064    CLRWDT
60:               	{
61:               		asm("clrwdt");	
62:               		
63:               		PORTA = Recebuffer[0];
  0034    0874    LD	A,0x74
  0035    1283    CLRB	0x3,5
  0036    1303    CLRB	0x3,6
  0037    0085    LD	0x5,A
64:               		
65:               		//-------------------------------------------
66:               		//发送控制
67:               		if(TRMT)
  0038    1683    SETB	0x3,5
  0039    1C98    SNZB	0x18,1
  003A    2833    JP	0x33
68:               		{
69:               			TXREG = Sendbuffer[sendcount];	                       
  003B    0879    LD	A,0x79
  003C    3E70    ADDIA	0x70
  003D    0084    LD	0x4,A
  003E    0800    LD	A,0x0
  003F    1283    CLRB	0x3,5
  0040    0099    LD	0x19,A
70:               			
71:               			Sendbuffer[sendcount] ++;
  0041    0879    LD	A,0x79
  0042    3E70    ADDIA	0x70
  0043    0084    LD	0x4,A
  0044    3004    LDIA	0x4
  0045    0A80    INCR	0x0
72:               			
73:               			sendcount++;
  0046    0AF9    INCR	0x79
74:               			if(sendcount >= 4)
  0047    0279    SUBA	0x79
  0048    1C03    SNZB	0x3,0
  0049    2833    JP	0x33
75:               			{
76:               				sendcount = 0;
  004A    01F9    CLR	0x79
  004B    2833    JP	0x33
77:               			}
78:               		}
79:               		
80:               	}
81:               }
82:               
83:               
84:               //--------------------------------------
85:               //中断服务
86:               void interrupt Usart_Isr()
87:               {
88:               	static unsigned char tcount = 0;
89:               
90:               	
91:               	//-------------------------------------------
92:               	//接收控制，如果接收标志位为1，说明有数据接收完毕
93:               	//RCIF在寄存器被读出后自动清零
94:               	if(RCIF)
  004C    1283    CLRB	0x3,5
  004D    1303    CLRB	0x3,6
  004E    1E8C    SNZB	0xC,5
  004F    2862    JP	0x62
95:               	{	
96:               		if(FERR)
  0050    1D18    SNZB	0x18,2
  0051    2854    JP	0x54
97:               		{
98:               			RCREG;							//帧错误
  0052    081A    LD	A,0x1A
  0053    2862    JP	0x62
99:               			return;
100:              		}
101:              		
102:              		Recebuffer[rececount] = RCREG;  	//将接收缓冲区内容读出
  0054    0878    LD	A,0x78
  0055    3E74    ADDIA	0x74
  0056    0084    LD	0x4,A
  0057    081A    LD	A,0x1A
  0058    0080    LD	0x0,A
  0059    3004    LDIA	0x4
103:              		rececount++;
  005A    0AF8    INCR	0x78
104:              			
105:              		if(rececount >= 4)					//接收完一帧数据，处理数据
  005B    0278    SUBA	0x78
  005C    1803    SZB	0x3,0
106:              		{
107:              			rececount = 0;
  005D    01F8    CLR	0x78
108:              		}
109:              			
110:              		if(OERR)							//如果有溢出错误
  005E    1C98    SNZB	0x18,1
  005F    2862    JP	0x62
111:              		{
112:              			CREN = 0;						//清零CREN位可将OERR位清零
  0060    1218    CLRB	0x18,4
113:              			CREN = 1;						//再次将CREN置一，以允许继续接收
  0061    1618    SETB	0x18,4
  0062    087C    LD	A,0x7C
  0063    008A    LD	0xA,A
  0064    087B    LD	A,0x7B
  0065    0084    LD	0x4,A
  0066    0E7A    SWAPA	0x7A
  0067    0083    LD	0x3,A
  0068    0EFE    SWAPR	0x7E
  0069    0E7E    SWAPA	0x7E
  006A    0009    RETI
114:              		}
115:              		
116:              	}
117:              }
118:              
119:              /***********************************************
120:              函数名称：Set_Usart_Async
121:              函数功能：Usart状态设置（异步）
122:              入口参数：无
123:              出口参数：无
124:              备注：
125:              ************************************************/
126:              /*
127:              SYNC = 0,BRG16 = 0,BRGH = 0;目标波特率 = Fosc/(64*([SPBRGH:SPBRG]+1))
128:              
129:              SYNC = 0,BRG16 = 0,BRGH = 1;
130:              SYNC = 0,BRG16 = 1,BRGH = 0;目标波特率 = Fosc/(16*([SPBRGH:SPBRG]+1))
131:              
132:              SYNC = 0,BRG16 = 1,BRGH = 1;目标波特率 = Fosc/(4*([SPBRGH:SPBRG]+1))
133:              */
134:              void Set_Usart_Async()
135:              {
136:              	SPBRG = 47;			//设置波特率为10417 bps，误差0.16%	
  006B    302F    LDIA	0x2F
  006C    1683    SETB	0x3,5
  006D    0099    LD	0x19,A
137:              	
138:              	SYNC = 0;				//0为异步模式，1为同步模式
  006E    1218    CLRB	0x18,4
139:              	SCKP = 0;
  006F    1198    CLRB	0x18,3
140:              	
141:                  SPEN = 1;				//允许串口操作
  0070    1283    CLRB	0x3,5
  0071    1798    SETB	0x18,7
142:              	RCIE = 1;				//接收中断  
  0072    1683    SETB	0x3,5
  0073    168C    SETB	0xC,5
143:              	TXIE = 0;				//发送中断
  0074    120C    CLRB	0xC,4
144:                  RX9EN = 0;				//0为8位接收，1为9位接收
  0075    1283    CLRB	0x3,5
  0076    1318    CLRB	0x18,6
145:              	TX9EN = 0;				//0为8位发送，1为9位发送
  0077    1683    SETB	0x3,5
  0078    1318    CLRB	0x18,6
146:              	CREN = 1;				//0为禁止接收，1为使能接收
  0079    1283    CLRB	0x3,5
  007A    1618    SETB	0x18,4
147:                  TXEN = 1;				//0为禁止发送，1为使能发送
  007B    1683    SETB	0x3,5
  007C    1698    SETB	0x18,5
  007D    0008    RET
148:              }
---- stringtab ------------------------------------------------------------------
---- reset_enter ------------------------------------------------------------------
  0000    118A    CLRB	0xA,3
  0001    280D    JP	0xD
  000D    118A    CLRB	0xA,3
  000E    280F    JP	0xF
---- start_initialization ------------------------------------------------------------------
  000F    01F0    CLR	0x70
  0010    01F1    CLR	0x71
  0011    01F2    CLR	0x72
  0012    01F3    CLR	0x73
  0013    01F4    CLR	0x74
  0014    01F5    CLR	0x75
  0015    01F6    CLR	0x76
  0016    01F7    CLR	0x77
  0017    01F8    CLR	0x78
  0018    01F9    CLR	0x79
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00FA    LD	0x7A,A
  0007    0804    LD	A,0x4
  0008    00FB    LD	0x7B,A
  0009    080A    LD	A,0xA
  000A    00FC    LD	0x7C,A
  000B    118A    CLRB	0xA,3
  000C    284C    JP	0x4C
---- common_function ------------------------------------------------------------------
  0019    0183    CLR	0x3
  001A    118A    CLRB	0xA,3
  001B    281C    JP	0x1C
