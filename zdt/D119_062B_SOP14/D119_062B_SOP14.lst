---- C:\mcuproject\scm\zdt\D119_062B_SOP14\main.c ----------------------------------------------------------------------
1:                /**********************************************************
2:                AD检测范例程序
3:                **********************************************************/
4:                #pragma warning disable 752
5:                #pragma warning disable 373			//屏蔽掉编译的1个警告
6:                #include <sc.h>
7:                
8:                #ifndef _XTAL_FREQ
9:                #define _XTAL_FREQ 16000000			//16MHz,使用内置延时函数必须定义主频，
10:               									//如用FCPU_DIV选择2T，则定时赋值减半
11:               #endif
12:               #define		u8t		unsigned char
13:               #define		u16t	unsigned int
14:               #define     POWER_RATIO  	(4096UL*1.2*1000)
15:               
16:               
17:               #define		A_LED5						 RA1
18:               #define		A_LED4						 RA2
19:               #define		A_LED3						 RA3
20:               #define		A_LED2						 RA4
21:               #define		A_LED1						 RA5
22:               
23:               
24:               #define		A_LED5_OUT					 TRISA	&= 0xFD
25:               #define		A_LED4_OUT					 TRISA	&= 0xFB
26:               #define		A_LED3_OUT					 TRISA	&= 0xF7
27:               #define		A_LED2_OUT					 TRISA	&= 0xEF
28:               #define		A_LED1_OUT					 TRISA	&= 0xDF
29:               
30:               const static unsigned char numArray[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x73,0x76};
31:               
32:               volatile unsigned int adresult;
33:               volatile unsigned int result;
34:               volatile unsigned char test_adc;
35:               volatile unsigned int power_ad;
36:               u8t	intCount;
37:               u8t	count1s;
38:               u8t	IntFlag;
39:               u8t	chrgFlag;
40:               u8t	chrgFullFlag;
41:               u8t	intCount10;
42:               u8t		chrgFullTime;
43:               u8t		workStep = 0;
44:               u8t		ledCnt;
45:               u8t		keyCount;
46:               u8t		longPressFlag;
47:               u8t		firstTime;
48:               u8t		showBatTime;
49:               u8t	ledCntTime;
50:               u16t	lowShanTime;
51:               u16t	count900s;
52:               u8t		lowBatFlag = 0;
53:               u8t		sleepTime;
54:               u8t shiweiNum = 0;	//十位
55:               u8t	geweiNum = 0;	//个位
56:               u8t	baiweiNum = 0;
57:               u8t	motorPwmFlag = 0;
58:               u16t	count30s = 0;
59:               u8t	showBatStep = 0;
60:               u8t		curBatStep = 0;
61:               u8t	lowBatTime = 0;
62:               
63:               unsigned char ADC_Sample(unsigned char adch, unsigned char adldo);
64:               void DelayXms(unsigned char x);
65:               unsigned char ADC_Result(unsigned char adch);
66:               void Init_System();
67:               void AD_Init();
68:               void Sleep_Mode();
69:               void pwmInit();
70:               void pwmStop();
71:               void chrgCtr();
72:               void checkBatAD();
73:               void ledShow();
74:               void keyCtr();
75:               void workCtr();
76:               void ledCtr();
77:               char keyRead(char keyStatus);
78:               void setBatStep();
79:               
80:               
81:               //#define _DEBUG			//调试程序用
82:               
83:               
84:               /***********************************************************
85:               中断服务函数
86:               函数名称：Isr_Timer()
87:               函数功能：中断处理函数
88:               入口参数：
89:               出口参数：
90:               备    注：125US定时2中断
91:               			所有中断都是在这个函数里面处理
92:               ***********************************************************/
93:               void interrupt Isr_Timer() 
94:               {
95:               	if(TMR2IF) 
  0393    1283    CLRB	0x3,5
  0394    1C8D    SNZB	0xD,1
  0395    2BA7    JP	0x3A7
96:               	{			//若只使能了一个中断源,可以略去判断
97:               		TMR2IF = 0;
  0396    108D    CLRB	0xD,1
98:               		if(++intCount >= 160)
  0397    30A0    LDIA	0xA0
  0398    0AB6    INCR	0x36
  0399    0236    SUBA	0x36
  039A    1C03    SNZB	0x3,0
  039B    2BA4    JP	0x3A4
  039C    3064    LDIA	0x64
99:               		{
100:              			intCount = 0;
  039D    01B6    CLR	0x36
101:              			IntFlag = 1;
  039E    01B4    CLR	0x34
  039F    0AB4    INCR	0x34
102:              			if(++count1s >= 100)
  03A0    0AB5    INCR	0x35
  03A1    0235    SUBA	0x35
  03A2    1803    SZB	0x3,0
103:              			{
104:              				count1s = 0;
  03A3    01B5    CLR	0x35
105:              			}
106:              		}
107:              		ledShow();
  03A4    2238    CALL	0x238
108:              		intCount10++;
  03A5    1283    CLRB	0x3,5
  03A6    0AB2    INCR	0x32
  03A7    0872    LD	A,0x72
  03A8    008A    LD	0xA,A
  03A9    0871    LD	A,0x71
  03AA    0084    LD	0x4,A
  03AB    0E70    SWAPA	0x70
  03AC    0083    LD	0x3,A
  03AD    0EFE    SWAPR	0x7E
  03AE    0E7E    SWAPA	0x7E
  03AF    0009    RETI
109:              	}
110:              
111:              }
112:              
113:              
114:              /***********************************************************
115:              main主函数
116:              ***********************************************************/
117:              void main() 
118:              {
119:              	Init_System();
  0308    23E7    CALL	0x3E7
120:              	AD_Init();
  0309    245B    CALL	0x45B
121:              	shiweiNum = geweiNum = numArray[8];
122:              	baiweiNum = 1;
  030A    3009    LDIA	0x9
  030B    0084    LD	0x4,A
  030C    2417    CALL	0x417
  030D    1283    CLRB	0x3,5
  030E    00C9    LD	0x49,A
  030F    00CA    LD	0x4A,A
123:              	firstTime = 250;
  0310    30FA    LDIA	0xFA
  0311    00CB    LD	0x4B,A
124:              	while (1) 
  0312    0064    CLRWDT
125:              	{
126:              		asm("clrwdt");
127:              		if(intCount10 > 10)
  0313    300B    LDIA	0xB
  0314    1283    CLRB	0x3,5
  0315    0232    SUBA	0x32
  0316    1803    SZB	0x3,0
128:              		{
129:              			intCount10 = 0;
  0317    01B2    CLR	0x32
130:              		}
131:              		if(!IntFlag)
  0318    0834    LD	A,0x34
  0319    1903    SZB	0x3,2
  031A    2B12    JP	0x312
132:                  		continue;			//10ms执行一次
133:                  	IntFlag = 0;
  031B    01B4    CLR	0x34
134:              		chrgCtr();
  031C    2369    CALL	0x369
135:              		checkBatAD();
  031D    2401    CALL	0x401
136:              		setBatStep();
  031E    21A3    CALL	0x1A3
137:              		if(lowBatFlag == 0 && firstTime == 0)
  031F    082C    LD	A,0x2C
  0320    1D03    SNZB	0x3,2
  0321    2B26    JP	0x326
  0322    084B    LD	A,0x4B
  0323    1D03    SNZB	0x3,2
  0324    2B26    JP	0x326
138:              		{
139:              			keyCtr();
  0325    2447    CALL	0x447
140:              		}
141:              		workCtr();
  0326    2100    CALL	0x100
142:              		if(chrgFlag == 0 && workStep == 0 && firstTime == 0 && showBatTime == 0)
  0327    087A    LD	A,0x7A
  0328    1D03    SNZB	0x3,2
  0329    2B3D    JP	0x33D
  032A    0830    LD	A,0x30
  032B    1D03    SNZB	0x3,2
  032C    2B3D    JP	0x33D
  032D    084B    LD	A,0x4B
  032E    1D03    SNZB	0x3,2
  032F    2B3D    JP	0x33D
143:              		{
144:              			baiweiNum = 0;
  0330    082E    LD	A,0x2E
  0331    1D03    SNZB	0x3,2
  0332    2B3D    JP	0x33D
  0333    30C8    LDIA	0xC8
145:              			shiweiNum = geweiNum = 0;
  0334    01C9    CLR	0x49
  0335    01CA    CLR	0x4A
146:              			if(++sleepTime >= 200)
  0336    0AAB    INCR	0x2B
  0337    022B    SUBA	0x2B
  0338    1C03    SNZB	0x3,0
  0339    2B12    JP	0x312
147:              			{
148:              				sleepTime = 0;
  033A    01AB    CLR	0x2B
149:              				Sleep_Mode();
  033B    22C6    CALL	0x2C6
  033C    2B12    JP	0x312
150:              			}
151:              		}
152:              		else
153:              		{
154:              			sleepTime = 0;
  033D    01AB    CLR	0x2B
  033E    2B12    JP	0x312
155:              		}
156:              	}
157:              }
158:              
159:              void ledShow()
160:              {
161:              	if(++ledCntTime > 5)
  0238    3006    LDIA	0x6
  0239    0AAD    INCR	0x2D
  023A    022D    SUBA	0x2D
  023B    1C03    SNZB	0x3,0
  023C    0008    RET
  023D    300E    LDIA	0xE
162:              	{
163:              		ledCntTime = 0;
  023E    01AD    CLR	0x2D
164:              		if(++ledCnt > 13)
  023F    0AAF    INCR	0x2F
  0240    022F    SUBA	0x2F
  0241    1803    SZB	0x3,0
165:              		{
166:              			ledCnt = 0;
  0242    01AF    CLR	0x2F
167:              		}
168:              		PORTA &= 0xC1;
  0243    30C1    LDIA	0xC1
  0244    1683    SETB	0x3,5
  0245    0586    ANDR	0x6
169:              		TRISA |= 0x3E;
  0246    303E    LDIA	0x3E
  0247    0485    ORR	0x5
170:              		switch(ledCnt)
  0248    2AB9    JP	0x2B9
171:              		{
172:              			case 1:
173:              			if(shiweiNum & 0x01)
  0249    1C4A    SNZB	0x4A,0
  024A    0008    RET
174:              			{
175:              				A_LED5_OUT;
  024B    1683    SETB	0x3,5
  024C    1085    CLRB	0x5,1
176:              				A_LED1_OUT;
  024D    1285    CLRB	0x5,5
177:              				A_LED5 = 1;
  024E    1486    SETB	0x6,1
178:              				A_LED1 = 0;
  024F    1286    CLRB	0x6,5
  0250    0008    RET
179:              			}
180:              			break;
181:              			case 2:
182:              			if(shiweiNum & 0x02)
  0251    1CCA    SNZB	0x4A,1
  0252    0008    RET
183:              			{
184:              				A_LED3_OUT;
  0253    1683    SETB	0x3,5
  0254    1185    CLRB	0x5,3
185:              				A_LED5_OUT;
  0255    1085    CLRB	0x5,1
186:              				A_LED5 = 1;
  0256    1486    SETB	0x6,1
187:              				A_LED3 = 0;
  0257    1186    CLRB	0x6,3
  0258    0008    RET
188:              			}
189:              			break;
190:              			case 3:
191:              			if(shiweiNum & 0x04)
  0259    1D4A    SNZB	0x4A,2
  025A    0008    RET
192:              			{
193:              				A_LED3_OUT;
  025B    1683    SETB	0x3,5
  025C    1185    CLRB	0x5,3
194:              				A_LED2_OUT;
  025D    1205    CLRB	0x5,4
195:              				A_LED2 = 1;
  025E    1606    SETB	0x6,4
196:              				A_LED3 = 0;
  025F    1186    CLRB	0x6,3
  0260    0008    RET
197:              			}
198:              			break;
199:              			case 4:
200:              			if(shiweiNum & 0x08)
  0261    1DCA    SNZB	0x4A,3
  0262    0008    RET
201:              			{
202:              				A_LED2_OUT;
  0263    1683    SETB	0x3,5
  0264    1205    CLRB	0x5,4
203:              				A_LED1_OUT;
  0265    1285    CLRB	0x5,5
204:              				A_LED1 = 1;
  0266    1686    SETB	0x6,5
205:              				A_LED2 = 0;
  0267    1206    CLRB	0x6,4
  0268    0008    RET
206:              			}
207:              			break;
208:              			case 5:
209:              			if(shiweiNum & 0x10)
  0269    1E4A    SNZB	0x4A,4
  026A    0008    RET
210:              			{
211:              				A_LED1_OUT;
  026B    1683    SETB	0x3,5
  026C    1285    CLRB	0x5,5
212:              				A_LED3_OUT;
  026D    1185    CLRB	0x5,3
213:              				A_LED3 = 1;
  026E    1586    SETB	0x6,3
214:              				A_LED1 = 0;
  026F    1286    CLRB	0x6,5
  0270    0008    RET
215:              			}
216:              			break;
217:              			case 6:
218:              			if(shiweiNum & 0x20)
  0271    1ECA    SNZB	0x4A,5
  0272    0008    RET
219:              			{
220:              				A_LED1_OUT;
  0273    1683    SETB	0x3,5
  0274    1285    CLRB	0x5,5
221:              				A_LED5_OUT;
  0275    1085    CLRB	0x5,1
222:              				A_LED1 = 1;
  0276    1686    SETB	0x6,5
223:              				A_LED5 = 0;
  0277    1086    CLRB	0x6,1
  0278    0008    RET
224:              			}
225:              			break;
226:              			case 7:
227:              			if(shiweiNum & 0x40)
  0279    1F4A    SNZB	0x4A,6
  027A    0008    RET
228:              			{
229:              				A_LED1_OUT;
  027B    1683    SETB	0x3,5
  027C    1285    CLRB	0x5,5
230:              				A_LED3_OUT;
  027D    1185    CLRB	0x5,3
231:              				A_LED1 = 1;
  027E    1686    SETB	0x6,5
232:              				A_LED3 = 0;
  027F    1186    CLRB	0x6,3
  0280    0008    RET
233:              			}
234:              			break;
235:              			case 8:
236:              			if(geweiNum & 0x01)
  0281    1C49    SNZB	0x49,0
  0282    0008    RET
237:              			{
238:              				A_LED4_OUT;
  0283    1683    SETB	0x3,5
  0284    1105    CLRB	0x5,2
239:              				A_LED5_OUT;
  0285    1085    CLRB	0x5,1
240:              				A_LED4 = 1;
  0286    1506    SETB	0x6,2
241:              				A_LED5 = 0;
  0287    1086    CLRB	0x6,1
  0288    0008    RET
242:              			}
243:              			break;
244:              			case 9:
245:              			if(geweiNum & 0x02)
  0289    1CC9    SNZB	0x49,1
  028A    0008    RET
246:              			{
247:              				A_LED5_OUT;
  028B    1683    SETB	0x3,5
  028C    1085    CLRB	0x5,1
248:              				A_LED4_OUT;
  028D    1105    CLRB	0x5,2
249:              				A_LED5 = 1;
  028E    1486    SETB	0x6,1
250:              				A_LED4 = 0;
  028F    1106    CLRB	0x6,2
  0290    0008    RET
251:              			}
252:              			break;
253:              			case 10:
254:              			if(geweiNum & 0x04)
  0291    1D49    SNZB	0x49,2
  0292    0008    RET
255:              			{
256:              				A_LED4_OUT;
  0293    1683    SETB	0x3,5
  0294    1105    CLRB	0x5,2
257:              				A_LED3_OUT;
  0295    1185    CLRB	0x5,3
258:              				A_LED3 = 1;
  0296    1586    SETB	0x6,3
259:              				A_LED4 = 0;
  0297    1106    CLRB	0x6,2
  0298    0008    RET
260:              			}
261:              			break;
262:              			case 11:
263:              			if(geweiNum & 0x08)
  0299    1DC9    SNZB	0x49,3
  029A    0008    RET
264:              			{
265:              				A_LED1_OUT;
  029B    1683    SETB	0x3,5
  029C    1285    CLRB	0x5,5
266:              				A_LED2_OUT;
  029D    1205    CLRB	0x5,4
267:              				A_LED2 = 1;
  029E    1606    SETB	0x6,4
268:              				A_LED1 = 0;
  029F    1286    CLRB	0x6,5
  02A0    0008    RET
269:              			}
270:              			break;
271:              			case 12:
272:              			if(geweiNum & 0x10)
  02A1    1E49    SNZB	0x49,4
  02A2    0008    RET
273:              			{
274:              				A_LED3_OUT;
  02A3    1683    SETB	0x3,5
  02A4    1185    CLRB	0x5,3
275:              				A_LED2_OUT;
  02A5    1205    CLRB	0x5,4
276:              				A_LED3 = 1;
  02A6    1586    SETB	0x6,3
277:              				A_LED2 = 0;
  02A7    1206    CLRB	0x6,4
  02A8    0008    RET
278:              			}
279:              			break;
280:              			case 13:
281:              			if(geweiNum & 0x20)
  02A9    1EC9    SNZB	0x49,5
  02AA    0008    RET
282:              			{
283:              				A_LED3_OUT;
  02AB    1683    SETB	0x3,5
  02AC    1185    CLRB	0x5,3
284:              				A_LED5_OUT;
  02AD    1085    CLRB	0x5,1
285:              				A_LED3 = 1;
  02AE    1586    SETB	0x6,3
286:              				A_LED5 = 0;
  02AF    1086    CLRB	0x6,1
  02B0    0008    RET
287:              			}
288:              			break;
289:              			case 0:
290:              			if(geweiNum & 0x40)
  02B1    1F49    SNZB	0x49,6
  02B2    0008    RET
291:              			{
292:              				A_LED4_OUT;
  02B3    1683    SETB	0x3,5
  02B4    1105    CLRB	0x5,2
293:              				A_LED3_OUT;
  02B5    1185    CLRB	0x5,3
294:              				A_LED4 = 1;
  02B6    1506    SETB	0x6,2
295:              				A_LED3 = 0;
  02B7    1186    CLRB	0x6,3
  02B8    0008    RET
  02B9    1283    CLRB	0x3,5
  02BA    082F    LD	A,0x2F
  02BB    0084    LD	0x4,A
  02BC    300E    LDIA	0xE
  02BD    0204    SUBA	0x4
  02BE    1803    SZB	0x3,0
  02BF    0008    RET
  02C0    3004    LDIA	0x4
  02C1    008A    LD	0xA,A
  02C2    3039    LDIA	0x39
  02C3    0704    ADDA	0x4
  02C4    0082    LD	0x2,A
  02C5    0008    RET
296:              			}
297:              			break;
298:              			default:
299:              			break;
300:              		}
301:              	}
302:              	
303:              	
304:              }
305:              
306:              
307:              
308:              
309:              
310:              
311:              void chrgCtr()
312:              {
313:              	if(PORTB & 0x01)
  0369    1C06    SNZB	0x6,0
  036A    2B7E    JP	0x37E
314:              	{
315:              		chrgFlag = 1;
  036B    01FA    CLR	0x7A
  036C    0AFA    INCR	0x7A
316:              		lowBatFlag = 0;
  036D    01AC    CLR	0x2C
317:              		if(PORTA & 0x01)
  036E    1683    SETB	0x3,5
  036F    1C06    SNZB	0x6,0
  0370    2B74    JP	0x374
318:              		{
319:              			chrgFullTime = 0;
  0371    1283    CLRB	0x3,5
  0372    01B1    CLR	0x31
320:              		}
  0373    0008    RET
321:              		else
322:              		{
323:              			if(++chrgFullTime >= 200)
  0374    30C8    LDIA	0xC8
  0375    1283    CLRB	0x3,5
  0376    0AB1    INCR	0x31
  0377    0231    SUBA	0x31
  0378    1C03    SNZB	0x3,0
  0379    0008    RET
324:              			{
325:              				chrgFullTime = 0;
  037A    01B1    CLR	0x31
326:              				chrgFullFlag = 1;
  037B    01B3    CLR	0x33
  037C    0AB3    INCR	0x33
  037D    0008    RET
  037E    3006    LDIA	0x6
327:              			}
328:              		}
329:              	}
330:              	else
331:              	{
332:              		chrgFlag = 0;
  037F    01FA    CLR	0x7A
333:              		chrgFullFlag = 0;
  0380    01B3    CLR	0x33
334:              		chrgFullTime = 0;
  0381    01B1    CLR	0x31
335:              		if(power_ad < 1563)
  0382    0278    SUBA	0x78
  0383    301B    LDIA	0x1B
  0384    1903    SZB	0x3,2
  0385    0277    SUBA	0x77
  0386    1803    SZB	0x3,0
  0387    2B91    JP	0x391
336:              		{
337:              			if(++lowBatTime > 200)
  0388    30C9    LDIA	0xC9
  0389    0AA8    INCR	0x28
  038A    0228    SUBA	0x28
  038B    1C03    SNZB	0x3,0
  038C    0008    RET
338:              			{
339:              				lowBatTime = 0;
  038D    01A8    CLR	0x28
340:              				lowBatFlag = 1;
  038E    01AC    CLR	0x2C
  038F    0AAC    INCR	0x2C
  0390    0008    RET
341:              			}
342:              		}
343:              		else
344:              		{
345:              			lowBatTime = 0;
  0391    01A8    CLR	0x28
  0392    0008    RET
346:              		}
347:              	}
348:              }
349:              
350:              
351:              
352:              char keyRead(char keyStatus)	
353:              { 
354:              	if(keyStatus)
355:              	{
356:              		keyCount++;
357:              		if(keyCount >= 100)
358:              		{
359:              			keyCount = 100;
360:              			if(!longPressFlag)
361:              			{
362:              				longPressFlag = 1;
363:              				return 2;
364:              			}
365:              		}
366:              	}
367:              	else
368:              	{
369:              		if(keyCount >= 100)
370:              		{
371:              			keyCount = 0;
372:              			longPressFlag = 0;
373:              			return	0;
374:              		}
375:              		else if(keyCount >= 6)
376:              		{
377:              			keyCount = 0;
378:              			return	1;
379:              		}
380:              		keyCount = 0;
381:              	}
382:              	return 0;
383:              }
384:              
385:              
386:              
387:              void keyCtr()
388:              {
389:              	if(PORTB & 0x02)
  0447    1C86    SNZB	0x6,1
  0448    2C51    JP	0x451
390:              	{
391:              		if(PORTB & 0x04)
  0449    1D06    SNZB	0x6,2
  044A    2C4E    JP	0x44E
392:              		{
393:              			workStep = 1;
  044B    01B0    CLR	0x30
  044C    0AB0    INCR	0x30
394:              		}
  044D    0008    RET
395:              		else
396:              		{
397:              			workStep = 2;
  044E    3002    LDIA	0x2
  044F    00B0    LD	0x30,A
  0450    0008    RET
398:              		}
399:              	}
400:              	else
401:              	{
402:              		workStep = 0;
  0451    01B0    CLR	0x30
  0452    0008    RET
403:              	}
404:              	
405:              	
406:              }
407:              
408:              
409:              void workCtr()
410:              {
411:              	/*
412:              	if(workStep > 0 && count1s == 0 && ++count900s >= 900)
413:              	{
414:              		count900s = 0;
415:              		workStep = 0;
416:              	}
417:              	*/
418:              	if(lowShanTime > 0)
  0100    0822    LD	A,0x22
  0101    0423    ORA	0x23
  0102    1903    SZB	0x3,2
  0103    290E    JP	0x10E
419:              	{
420:              		if(--lowShanTime == 0)
  0104    3001    LDIA	0x1
  0105    02A2    SUBR	0x22
  0106    3000    LDIA	0x0
  0107    1C03    SNZB	0x3,0
  0108    03A3    DECR	0x23
  0109    02A3    SUBR	0x23
  010A    0822    LD	A,0x22
  010B    0423    ORA	0x23
  010C    1903    SZB	0x3,2
421:              		{
422:              			workStep = 0;
  010D    01B0    CLR	0x30
423:              		}
424:              	}
425:              	if(showBatTime > 0)
  010E    082E    LD	A,0x2E
  010F    1D03    SNZB	0x3,2
426:              	{
427:              		showBatTime--;
  0110    03AE    DECR	0x2E
428:              	}
429:              	if(firstTime > 0)
  0111    084B    LD	A,0x4B
  0112    1903    SZB	0x3,2
  0113    2924    JP	0x124
430:              	{
431:              		firstTime--;
  0114    03CB    DECR	0x4B
432:              		if(showBatStep < curBatStep)
  0115    0829    LD	A,0x29
  0116    0279    SUBA	0x79
  0117    1803    SZB	0x3,0
  0118    291B    JP	0x11B
433:              		{	
434:              			showBatStep = curBatStep;
  0119    0829    LD	A,0x29
  011A    00F9    LD	0x79,A
435:              		}
436:              		shiweiNum = numArray[8];
  011B    3009    LDIA	0x9
  011C    0084    LD	0x4,A
  011D    2417    CALL	0x417
  011E    00CA    LD	0x4A,A
437:              		geweiNum = numArray[8];
  011F    3009    LDIA	0x9
  0120    0084    LD	0x4,A
  0121    2417    CALL	0x417
  0122    00C9    LD	0x49,A
438:              	}
  0123    295F    JP	0x15F
439:              	else if(workStep == 0 || (lowShanTime > 0 && count1s < 50))
  0124    0830    LD	A,0x30
  0125    1903    SZB	0x3,2
  0126    292F    JP	0x12F
  0127    0822    LD	A,0x22
  0128    0423    ORA	0x23
  0129    1903    SZB	0x3,2
  012A    2933    JP	0x133
  012B    3032    LDIA	0x32
  012C    0235    SUBA	0x35
  012D    1803    SZB	0x3,0
  012E    2933    JP	0x133
440:              	{
441:              		shiweiNum = 0;
  012F    01CA    CLR	0x4A
442:              		geweiNum = 0;
  0130    01C9    CLR	0x49
443:              		pwmStop();
444:              		count900s = 0;
  0131    2463    CALL	0x463
445:              	}
  0132    295F    JP	0x15F
446:              	else if(workStep == 1)
  0133    0B30    SZDECA	0x30
  0134    2948    JP	0x148
447:              	{
448:              		if(chrgFlag == 0)
  0135    087A    LD	A,0x7A
  0136    1D03    SNZB	0x3,2
  0137    2940    JP	0x140
449:              		{
450:              			shiweiNum = numArray[10];
  0138    300B    LDIA	0xB
  0139    0084    LD	0x4,A
  013A    2417    CALL	0x417
  013B    00CA    LD	0x4A,A
451:              			geweiNum = numArray[1];
  013C    3002    LDIA	0x2
  013D    0084    LD	0x4,A
  013E    2417    CALL	0x417
  013F    00C9    LD	0x49,A
452:              		}
453:              		if(motorPwmFlag == 0)
  0140    082A    LD	A,0x2A
  0141    1D03    SNZB	0x3,2
  0142    2944    JP	0x144
454:              		{
455:              			pwmInit();
  0143    2429    CALL	0x429
456:              		}
457:              		PWMD23H = 0X00;
  0144    1683    SETB	0x3,5
  0145    019E    CLR	0x1E
458:              		PWMD2L = 60;
  0146    303C    LDIA	0x3C
  0147    295E    JP	0x15E
459:              	}
460:              	else if(workStep == 2)
  0148    3002    LDIA	0x2
  0149    0630    XORA	0x30
  014A    1D03    SNZB	0x3,2
  014B    295F    JP	0x15F
461:              	{
462:              		if(chrgFlag == 0)
  014C    087A    LD	A,0x7A
  014D    1D03    SNZB	0x3,2
  014E    2957    JP	0x157
463:              		{
464:              			shiweiNum = numArray[10];
  014F    300B    LDIA	0xB
  0150    0084    LD	0x4,A
  0151    2417    CALL	0x417
  0152    00CA    LD	0x4A,A
465:              			geweiNum = numArray[2];
  0153    3003    LDIA	0x3
  0154    0084    LD	0x4,A
  0155    2417    CALL	0x417
  0156    00C9    LD	0x49,A
466:              		}
467:              		if(motorPwmFlag == 0)
  0157    082A    LD	A,0x2A
  0158    1D03    SNZB	0x3,2
  0159    295B    JP	0x15B
468:              		{
469:              			pwmInit();
  015A    2429    CALL	0x429
470:              		}
471:              		PWMD23H = 0X00;
  015B    1683    SETB	0x3,5
  015C    019E    CLR	0x1E
472:              		PWMD2L = 99;
  015D    3063    LDIA	0x63
  015E    009B    LD	0x1B,A
473:              		
474:              	}
475:              	if(chrgFlag || showBatTime > 0)
  015F    087A    LD	A,0x7A
  0160    1D03    SNZB	0x3,2
  0161    2966    JP	0x166
  0162    1283    CLRB	0x3,5
  0163    082E    LD	A,0x2E
  0164    1903    SZB	0x3,2
  0165    0008    RET
476:              	{
477:              		if(showBatStep >=99)
  0166    3063    LDIA	0x63
  0167    0279    SUBA	0x79
  0168    1C03    SNZB	0x3,0
  0169    2974    JP	0x174
478:              		{
479:              			shiweiNum = numArray[9];
  016A    300A    LDIA	0xA
  016B    0084    LD	0x4,A
  016C    2417    CALL	0x417
  016D    1283    CLRB	0x3,5
  016E    00CA    LD	0x4A,A
480:              			geweiNum = numArray[9];
  016F    300A    LDIA	0xA
  0170    0084    LD	0x4,A
  0171    2417    CALL	0x417
  0172    00C9    LD	0x49,A
481:              		}
  0173    0008    RET
482:              		else if(showBatStep > 9)
483:              		{
484:              			baiweiNum = 0;
  0174    300A    LDIA	0xA
  0175    0279    SUBA	0x79
  0176    1C03    SNZB	0x3,0
  0177    2998    JP	0x198
485:              			shiweiNum = numArray[showBatStep/10];
  0178    300A    LDIA	0xA
  0179    00F3    LD	0x73,A
  017A    0879    LD	A,0x79
  017B    23CC    CALL	0x3CC
  017C    3E01    ADDIA	0x1
  017D    0084    LD	0x4,A
  017E    2417    CALL	0x417
  017F    1283    CLRB	0x3,5
  0180    00CA    LD	0x4A,A
486:              			if(chrgFlag && count1s < 50)
  0181    087A    LD	A,0x7A
  0182    1903    SZB	0x3,2
  0183    298F    JP	0x18F
  0184    3032    LDIA	0x32
  0185    0235    SUBA	0x35
  0186    1C03    SNZB	0x3,0
  0187    298D    JP	0x18D
  0188    298F    JP	0x18F
  0189    3032    LDIA	0x32
  018A    0235    SUBA	0x35
  018B    1803    SZB	0x3,0
  018C    299D    JP	0x19D
487:              			{
488:              				geweiNum = 0;
  018D    01C9    CLR	0x49
489:              			}
  018E    0008    RET
490:              			else
491:              			{
492:              				geweiNum = numArray[showBatStep%10];
  018F    300A    LDIA	0xA
  0190    00F3    LD	0x73,A
  0191    0879    LD	A,0x79
  0192    23B0    CALL	0x3B0
  0193    3E01    ADDIA	0x1
  0194    0084    LD	0x4,A
  0195    2417    CALL	0x417
  0196    00C9    LD	0x49,A
  0197    0008    RET
493:              			}
494:              		}
495:              		else
496:              		{
497:              			baiweiNum = 0;
498:              			shiweiNum = 0;
  0198    1283    CLRB	0x3,5
  0199    01CA    CLR	0x4A
499:              			if(chrgFlag && count1s < 50)
  019A    087A    LD	A,0x7A
  019B    1D03    SNZB	0x3,2
  019C    2989    JP	0x189
500:              			{
501:              				geweiNum = 0;
502:              			}
503:              			else
504:              			{
505:              				geweiNum = numArray[showBatStep];
  019D    0879    LD	A,0x79
  019E    3E01    ADDIA	0x1
  019F    0084    LD	0x4,A
  01A0    2417    CALL	0x417
  01A1    00C9    LD	0x49,A
  01A2    0008    RET
506:              			}
507:              		}
508:              	
509:              	}
510:              	
511:              }
512:              
513:              void setBatStep()
514:              {
515:              	if(lowBatFlag == 1 && lowShanTime == 0 && workStep > 0)
  01A3    1283    CLRB	0x3,5
  01A4    0B2C    SZDECA	0x2C
  01A5    29B4    JP	0x1B4
  01A6    0822    LD	A,0x22
  01A7    0423    ORA	0x23
  01A8    1D03    SNZB	0x3,2
  01A9    29B4    JP	0x1B4
  01AA    0830    LD	A,0x30
  01AB    1903    SZB	0x3,2
  01AC    29B4    JP	0x1B4
  01AD    302C    LDIA	0x2C
516:              	{
517:              		showBatStep = 0;
  01AE    01F9    CLR	0x79
518:              		curBatStep = 0;
  01AF    01A9    CLR	0x29
519:              		lowShanTime = 300;
  01B0    00A2    LD	0x22,A
  01B1    3001    LDIA	0x1
  01B2    00A3    LD	0x23,A
520:              	}
  01B3    0008    RET
521:              	else if(power_ad < 1675)
  01B4    3006    LDIA	0x6
  01B5    0278    SUBA	0x78
  01B6    308B    LDIA	0x8B
  01B7    1903    SZB	0x3,2
  01B8    0277    SUBA	0x77
  01B9    1803    SZB	0x3,0
  01BA    29CE    JP	0x1CE
522:              	{
523:              		if(count1s == 0)
  01BB    0835    LD	A,0x35
  01BC    1D03    SNZB	0x3,2
  01BD    29CB    JP	0x1CB
524:              		{
525:              			if(showBatStep > 1)
  01BE    3002    LDIA	0x2
  01BF    0279    SUBA	0x79
  01C0    1C03    SNZB	0x3,0
  01C1    29C7    JP	0x1C7
526:              			{
527:              				if(chrgFlag == 0)
  01C2    087A    LD	A,0x7A
  01C3    1D03    SNZB	0x3,2
  01C4    29C9    JP	0x1C9
528:              					showBatStep--;
  01C5    03F9    DECR	0x79
  01C6    29C9    JP	0x1C9
529:              			}
530:              			else
531:              			{
532:              				showBatStep = 1;
  01C7    01F9    CLR	0x79
  01C8    0AF9    INCR	0x79
533:              			}
534:              			curBatStep = 1;
  01C9    01A9    CLR	0x29
  01CA    0AA9    INCR	0x29
535:              		}
536:              		curBatStep = 1;
  01CB    01A9    CLR	0x29
  01CC    0AA9    INCR	0x29
537:              	}
  01CD    0008    RET
538:              	else
539:              	{
540:              		if(power_ad < 1875)
  01CE    3007    LDIA	0x7
  01CF    0278    SUBA	0x78
  01D0    3053    LDIA	0x53
  01D1    1903    SZB	0x3,2
  01D2    0277    SUBA	0x77
  01D3    1803    SZB	0x3,0
  01D4    29E3    JP	0x1E3
541:              		{
542:              			curBatStep = (power_ad - 1675)/10;
  01D5    300A    LDIA	0xA
  01D6    00F3    LD	0x73,A
  01D7    01F4    CLR	0x74
  01D8    0877    LD	A,0x77
  01D9    3E75    ADDIA	0x75
  01DA    00F5    LD	0x75,A
  01DB    0878    LD	A,0x78
  01DC    1803    SZB	0x3,0
  01DD    3E01    ADDIA	0x1
  01DE    3EF9    ADDIA	0xF9
  01DF    00F6    LD	0x76,A
  01E0    233F    CALL	0x33F
  01E1    0873    LD	A,0x73
  01E2    29F1    JP	0x1F1
543:              		}
544:              		else
545:              		{
546:              			curBatStep = 10 + ((power_ad - 1875)/5);
  01E3    3005    LDIA	0x5
  01E4    00F3    LD	0x73,A
  01E5    01F4    CLR	0x74
  01E6    0877    LD	A,0x77
  01E7    3EAD    ADDIA	0xAD
  01E8    00F5    LD	0x75,A
  01E9    0878    LD	A,0x78
  01EA    1803    SZB	0x3,0
  01EB    3E01    ADDIA	0x1
  01EC    3EF8    ADDIA	0xF8
  01ED    00F6    LD	0x76,A
  01EE    233F    CALL	0x33F
  01EF    0873    LD	A,0x73
  01F0    3E0A    ADDIA	0xA
  01F1    00A9    LD	0x29,A
547:              		}
548:              		if(curBatStep > 99)
  01F2    3064    LDIA	0x64
  01F3    0229    SUBA	0x29
  01F4    1C03    SNZB	0x3,0
  01F5    29F8    JP	0x1F8
549:              		{
550:              			curBatStep = 99;
  01F6    3063    LDIA	0x63
  01F7    00A9    LD	0x29,A
551:              		}
552:              
553:              		if(chrgFlag)
  01F8    087A    LD	A,0x7A
  01F9    1903    SZB	0x3,2
  01FA    2A1E    JP	0x21E
554:              		{
555:              			if(chrgFullFlag)
  01FB    0833    LD	A,0x33
  01FC    1903    SZB	0x3,2
  01FD    2A17    JP	0x217
556:              			{
557:              				if(++count30s >= 3000 && showBatStep < 99)	//20s
  01FE    0AA0    INCR	0x20
  01FF    1903    SZB	0x3,2
  0200    0AA1    INCR	0x21
  0201    300B    LDIA	0xB
  0202    0221    SUBA	0x21
  0203    30B8    LDIA	0xB8
  0204    2A0B    JP	0x20B
558:              				{	
559:              					count30s = 0;
  0213    01A0    CLR	0x20
  0214    01A1    CLR	0x21
560:              					showBatStep++;
  0215    0AF9    INCR	0x79
  0216    0008    RET
561:              				}
562:              			}
563:              			else if(curBatStep > showBatStep)
  0217    0829    LD	A,0x29
  0218    0279    SUBA	0x79
  0219    1C03    SNZB	0x3,0
  021A    2A05    JP	0x205
564:              			{
565:              				if(++count30s >= 30000 && showBatStep < 99)	//20s
  0205    0AA0    INCR	0x20
  0206    1903    SZB	0x3,2
  0207    0AA1    INCR	0x21
  0208    3075    LDIA	0x75
  0209    0221    SUBA	0x21
  020A    3030    LDIA	0x30
  020B    1903    SZB	0x3,2
  020C    0220    SUBA	0x20
  020D    1C03    SNZB	0x3,0
  020E    0008    RET
  020F    3063    LDIA	0x63
  0210    0279    SUBA	0x79
  0211    1803    SZB	0x3,0
  0212    0008    RET
566:              				{	
567:              					count30s = 0;
568:              					showBatStep++;
569:              				}
570:              				
571:              			}
572:              			else
573:              			{
574:              				count30s = 0;
  021B    01A0    CLR	0x20
  021C    01A1    CLR	0x21
  021D    0008    RET
575:              			}
576:              		}
577:              		else
578:              		{
579:              			if(curBatStep < showBatStep && showBatStep > 1)
  021E    0879    LD	A,0x79
  021F    0229    SUBA	0x29
  0220    1803    SZB	0x3,0
  0221    2A1B    JP	0x21B
  0222    3002    LDIA	0x2
  0223    0279    SUBA	0x79
  0224    1C03    SNZB	0x3,0
  0225    2A1B    JP	0x21B
580:              			{
581:              				if(++count30s >= 1500 && showBatStep > 1)	//10s
  0226    0AA0    INCR	0x20
  0227    1903    SZB	0x3,2
  0228    0AA1    INCR	0x21
  0229    3005    LDIA	0x5
  022A    0221    SUBA	0x21
  022B    30DC    LDIA	0xDC
  022C    1903    SZB	0x3,2
  022D    0220    SUBA	0x20
  022E    1C03    SNZB	0x3,0
  022F    0008    RET
  0230    3002    LDIA	0x2
  0231    0279    SUBA	0x79
  0232    1C03    SNZB	0x3,0
  0233    0008    RET
582:              				{	
583:              					count30s = 0;
  0234    01A0    CLR	0x20
  0235    01A1    CLR	0x21
584:              					showBatStep--;
  0236    03F9    DECR	0x79
  0237    0008    RET
585:              				}
586:              			}
587:              			else
588:              			{
589:              				count30s = 0;
590:              			}
591:              		}
592:              		
593:              	}
594:              }
595:              
596:              
597:              void checkBatAD()
598:              {
599:              	test_adc = ADC_Sample(12, 5);		//测试内部基准1.2V相对电源的AD值
  0401    3005    LDIA	0x5
  0402    00F3    LD	0x73,A
  0403    300C    LDIA	0xC
  0404    2018    CALL	0x18
  0405    00B7    LD	0x37,A
600:              	if (0xA5 == test_adc)
  0406    30A5    LDIA	0xA5
  0407    0637    XORA	0x37
  0408    1D03    SNZB	0x3,2
  0409    2C0F    JP	0x40F
601:              	{
602:              		volatile unsigned long power_temp;
603:              		
604:              		power_ad = adresult;		//通过内部基准电压推出芯片VDD电压
  040A    0827    LD	A,0x27
  040B    00F8    LD	0x78,A
  040C    0826    LD	A,0x26
  040D    00F7    LD	0x77,A
605:              	}
  040E    0008    RET
606:              	else
607:              	{
608:              		ADCON0 = 0;						//如果转换没有完成，需初始化ADCON0,1
  040F    1683    SETB	0x3,5
  0410    0195    CLR	0x15
609:              		ADCON1 = 0;				
  0411    0196    CLR	0x16
610:              		__delay_us(100);				//延时100us(编译器内置函数)
  0412    3085    LDIA	0x85
  0413    00F4    LD	0x74,A
  0414    0BF4    SZDECR	0x74
  0415    2C14    JP	0x414
  0416    0008    RET
611:              	}
612:              	
613:              }
614:              
615:              
616:              
617:              /**********************************************************
618:              函数名称：Init_System
619:              函数功能：系统初始化
620:              入口参数：无
621:              出口参数：无
622:              备    注：
623:              **********************************************************/
624:              void Init_System() 
  03E7    0000    NOP
  03E8    0064    CLRWDT
625:              {
626:              	asm("nop");
627:              	asm("clrwdt");
628:              	OPTION_REG = 0;					//预分频给TMR0 ，Timer0使用内部时钟Focs/4，预分频比为1:2
  03E9    1283    CLRB	0x3,5
  03EA    0181    CLR	0x1
  03EB    0064    CLRWDT
629:              	asm("clrwdt");
630:              	OSCCON = 0X72;					//内部振荡器8M
  03EC    3072    LDIA	0x72
  03ED    1283    CLRB	0x3,5
  03EE    0094    LD	0x14,A
631:              
632:              	WPUA = 0x00;				//配置上拉，1为使能上拉
  03EF    1683    SETB	0x3,5
  03F0    0188    CLR	0x8
633:              	WPDA = 0x00;					//RA1开下拉
  03F1    0187    CLR	0x7
634:              	WPUB = 0x04;
  03F2    3004    LDIA	0x4
  03F3    1283    CLRB	0x3,5
  03F4    0088    LD	0x8,A
635:              
636:              	TRISA = 0x01;				//配置IO状态，0为输出，1为输入
  03F5    3001    LDIA	0x1
  03F6    1683    SETB	0x3,5
637:              	TRISB = 0x37;
638:              
639:              	PORTA = 0X00;
640:              	PORTB = 0X00;
  03F7    22FF    CALL	0x2FF
641:              
642:              //---------------------------------------
643:              //125us中断初始化
644:              	PR2 = 249;					//设定Timer初始值，定时周期是250*2/8M=62.5uS
  03F8    30F9    LDIA	0xF9
  03F9    0091    LD	0x11,A
645:              	TMR2IF = 0;
  03FA    108D    CLRB	0xD,1
646:              	TMR2IE = 1;					//使能Timer2溢出中断
  03FB    148E    SETB	0xE,1
647:              
648:              	T2CON = 0B00000100;			//开启Timer2,设置TMR2的分频比为1:1
  03FC    3004    LDIA	0x4
  03FD    0093    LD	0x13,A
649:              	INTCON = 0XC0;				//开启总中断
  03FE    30C0    LDIA	0xC0
  03FF    008B    LD	0xB,A
  0400    0008    RET
650:              }
651:              
652:              /***********************************************************
653:              中断服务函数
654:              函数名称：AD_Init()
655:              函数功能：AD初始化处理函数
656:              入口参数：
657:              出口参数：
658:              备    注：第一次打开AD允许位ADON，需延时20uS以上才能进入AD采样
659:              			如后继程序不关闭ADON，则不需要延时
660:              ***********************************************************/
661:              void AD_Init() 
662:              {
663:              	/*********** ADCON0 ****************************
664:              		Bit7~Bit6  ADCS<1:0>:  AD转换时钟选择位。
665:              			00=  F HSI /16
666:              			01=  F HSI /32
667:              			10=  F HSI /64
668:              			11=  F HSI /128
669:              		Bit5~Bit2  CHS<3:0>:  模拟通道选择位。与ADCON1寄存器CHS4组合CHS<3:0>
670:              			CHS<4:0>: 
671:              			00000=  AN0
672:              			00001=  AN1
673:              			00010=  AN2
674:              			00011=  AN3
675:              			00100=  AN4
676:              			00101=  AN5
677:              			00110=  保留
678:              			00111=  保留
679:              			01000=  AN8
680:              			… 
681:              			01101=  AN13
682:              			01110=  AN14
683:              			01111=  AN15
684:              			11111=  1.2V（固定参考电压）
685:              			其他=  保留
686:              		Bit1  GO/DONE: AD转换状态位。
687:              			1=  AD转换正在进行。将该位置1启动AD转换。当AD转换完成以后，该位由硬件自动清零。
688:              				当GO/DONE位从1变0或ADIF从0变1时，需至少等待两个TAD时间，才能再次启动AD转换。
689:              			0=  AD转换完成/或不在进行中。
690:              		Bit0  ADON:  ADC使能位。
691:              			1=  使能ADC；
692:              			0=  禁止ADC，不消耗工作电流。
693:              	*********************************************/
694:              	ADCON0 = 0X41;		//ADON开启，AD采样时间选为FSYS/16
  045B    3041    LDIA	0x41
  045C    1683    SETB	0x3,5
  045D    0095    LD	0x15,A
695:              	
696:              	/*********** ADCON1 ****************************
697:              		Bit7  ADFM:  AD转换结果格式选择位；
698:              			1=  右对齐；
699:              			0=  左对齐。
700:              		Bit6  CHS4:  通道选择位
701:              		Bit5~Bit3  未用 
702:              		Bit2  LDO_EN:  内部参考电压使能位。
703:              			1=  使能ADC内部LDO参考电压；
704:              				当选择内部LDO作参考电压时，ADC最大有效精度为8位。
705:              			0=  VDD作为ADC参考电压。
706:              		Bit1~Bit0  LDO_SEL<1:0>:  参考电压选择位
707:              			0X=  2.0V
708:              			10=  2.4V
709:              			11=  3.0V
710:              	*********************************************/
711:              	ADCON1 = 0;
  045E    0196    CLR	0x16
712:              	ANSEL0 = 0X00;
  045F    0193    CLR	0x13
713:              	ANSEL1 = 0x30;	
  0460    3030    LDIA	0x30
  0461    0094    LD	0x14,A
  0462    0008    RET
714:              }
715:              
716:              
717:              void pwmInit()
718:              {
719:              		PWMCON1 = 0B00000000;	//PWM选择D组，死区2禁止，死区1使能，死区时钟源为Fosc/4
  0429    0196    CLR	0x16
720:              		PWMTH = 0X00;			//周期选择为0FF，则周期为（255+1）*1/8M，周期的时钟分频在PWMCON0选择
  042A    0198    CLR	0x18
721:              		PWMTL = 100;			//PWM 周期=[PWMT+1]*Tosc*(CLKDIV 分频值)
  042B    3064    LDIA	0x64
  042C    0097    LD	0x17,A
722:              		
723:              		
724:              		PWMD23H = 0;			//配置PWM1,PWM2的占空比，该值不能超过周期，否者为100%输出
  042D    1683    SETB	0x3,5
  042E    019E    CLR	0x1E
725:              		PWMD2L = 60;			//互补模式，PWM1的占空比与PWM0互补，和设置值无关
  042F    303C    LDIA	0x3C
  0430    009B    LD	0x1B,A
726:              		PWM23DT = 0X00;			//死区设为2uS，计算为（3+1）*1/8M*4
  0431    019D    CLR	0x1D
727:              
728:              		PWMCON0 = 0X64;			//打开PWM3 分频比为8
  0432    3064    LDIA	0x64
  0433    1283    CLRB	0x3,5
  0434    0095    LD	0x15,A
729:              		PWMCON2 =0X00;			//PWM4输出反向
  0435    019D    CLR	0x1D
730:              		motorPwmFlag = 1;
  0436    01AA    CLR	0x2A
  0437    0AAA    INCR	0x2A
  0438    0008    RET
731:              }
732:              
733:              void pwmStop()
734:              {
735:              	PWMCON0 &= 0XFB;
  0463    1115    CLRB	0x15,2
736:              	RB3 = 0;
  0464    1186    CLRB	0x6,3
737:              	motorPwmFlag = 0;
  0465    01AA    CLR	0x2A
  0466    0008    RET
738:              }
739:              
740:              
741:              /***********************************************
742:              函数名称：Sleep_Mode
743:              函数功能：进入休眠模式
744:              入口参数：无
745:              出口参数：无
746:              备注：
747:              ************************************************/
748:              void Sleep_Mode()
749:              {
750:              	INTCON = 0;		
  02C6    018B    CLR	0xB
751:              	
752:              	OPTION_REG = 0;
  02C7    0181    CLR	0x1
753:              
754:              	WPUA  = 0x00;			//RA1 开上拉电阻
  02C8    1683    SETB	0x3,5
  02C9    0188    CLR	0x8
755:              	TRISA = 0x01;				//配置IO状态，0为输出，1为输入
  02CA    3001    LDIA	0x1
756:              	TRISB = 0x37;
757:              
758:              	PORTA = 0X00;
759:              	PORTB = 0X00;
  02CB    22FF    CALL	0x2FF
760:              	WPUB  = 0x04;			//RB2 开上拉电阻
  02CC    3004    LDIA	0x4
  02CD    0088    LD	0x8,A
761:                 			
762:                 	ADCON0 = 0;					//关闭所有模块
  02CE    1683    SETB	0x3,5
  02CF    0195    CLR	0x15
763:              	ADCON1 = 0;
  02D0    0196    CLR	0x16
764:              	
765:              	PWMCON0 = 0;
  02D1    1283    CLRB	0x3,5
  02D2    0195    CLR	0x15
766:              		
767:              	OSCCON = 0X70;				//配置振荡为8M,关闭WDT，需注意芯片工程选项里WDT必须选为DISABLE,否则无法软件关掉WDT
  02D3    3070    LDIA	0x70
  02D4    0094    LD	0x14,A
768:              	
769:              	IOCA = 0B00000000;			//允许RA1的IO电平变化中断
  02D5    1683    SETB	0x3,5
  02D6    0189    CLR	0x9
770:              	IOCB = 0x07;			//允许RB1 RB2的IO口电平变化中断
  02D7    3007    LDIA	0x7
  02D8    1283    CLRB	0x3,5
  02D9    0089    LD	0x9,A
771:              	
772:              	RAIE = 1;					//允许PORTA的IO电平变化中断
  02DA    158E    SETB	0xE,3
773:              	PEIE = 1;					//要用RORTA中断唤醒，则PEIE必须设为1
  02DB    170B    SETB	0xB,6
774:              	RBIE = 1;					//允许PORTB电平变化中断
  02DC    158B    SETB	0xB,3
775:              	GIE = 0;					//唤醒后执行SLEEP后程序;
  02DD    138B    CLRB	0xB,7
776:              	
777:              	PIE1 &= 0X08;				//关闭不需要的中断
  02DE    3008    LDIA	0x8
  02DF    058E    ANDR	0xE
778:              	PIR1 = 0;					//必须清不需要的中断标志位
  02E0    018D    CLR	0xD
779:              	INTCON &= 0XC8;				//必须清不需要的中断标志位
  02E1    30C8    LDIA	0xC8
  02E2    058B    ANDR	0xB
780:              
781:              	PORTA;						//读PORTA值并锁存,用电平变化中断必须执行这一步
  02E3    1683    SETB	0x3,5
  02E4    0806    LD	A,0x6
782:              	RAIF = 0;					//清PORTA中断标志位
  02E5    1283    CLRB	0x3,5
  02E6    118D    CLRB	0xD,3
783:              	PORTB;						//读PORTB值并锁存	
  02E7    0806    LD	A,0x6
784:              	RBIF = 0;					//清PORTB中断标志位		
  02E8    100B    CLRB	0xB,0
  02E9    0064    CLRWDT
  02EA    0063    STOP
  02EB    0000    NOP
  02EC    0064    CLRWDT
  02ED    0000    NOP
  02EE    0000    NOP
  02EF    0000    NOP
  02F0    0000    NOP
  02F1    0000    NOP
785:              	asm("clrwdt");
786:              
787:              	asm("sleep");				//进入休眠模式
788:              	
789:              	asm("nop");
790:              	asm("clrwdt");
791:              	asm("nop");
792:              	asm("nop");
793:              	asm("nop");
794:              	asm("nop");
795:              	asm("nop");
796:              	if(RAIF)  RAIF = 0;			//清中断标志
  02F2    1283    CLRB	0x3,5
  02F3    198D    SZB	0xD,3
  02F4    118D    CLRB	0xD,3
797:              	if(RBIF)  RBIF = 0;			//清中断标志
  02F5    180B    SZB	0xB,0
  02F6    100B    CLRB	0xB,0
798:              	if(TMR2IF) TMR2IF = 0;
  02F7    188D    SZB	0xD,1
  02F8    108D    CLRB	0xD,1
799:              	IOCA = 0B00000000;			//允许RA1的IO电平变化中断
  02F9    1683    SETB	0x3,5
  02FA    0189    CLR	0x9
800:              	IOCB = 0B00000000;			//允许RB3的IO口电平变化中断
  02FB    1283    CLRB	0x3,5
  02FC    0189    CLR	0x9
801:              	Init_System();
  02FD    23E7    CALL	0x3E7
802:              	AD_Init();
  02FE    2C5B    JP	0x45B
803:              }
804:              
805:              
806:              
807:              /**********************************************************
808:              函数名称：AD_Sample
809:              函数功能：AD检测
810:              入口参数：adch - 检测通道
811:              出口参数：无
812:              备    注：采样通道需自行设置为输入口
813:              	      采样10次,取中间八次的平均值为采样结果存于adresult中
814:              
815:              	      adch 为输入AD通道 0-15，31
816:                           31  检测内部1.2V
817:              	
818:               		  adldo =5,开启内部LDO 2V 作为ADC 参考
819:               		  adldo =6,开启内部LDO 2.4V 作为ADC 参考
820:              		  adldo =7,开启内部LDO 3V 作为ADC 参考
821:               		  adldo =0,VDD 作为ADC 参考
822:               		  AD转换结果左对齐
823:               		  ADC参考电压从VDD切换到LDO时需要延时100us以上，才能进行AD转换
824:              **********************************************************/
825:              unsigned char ADC_Sample(unsigned char adch, unsigned char adldo) 
  0018    00BD    LD	0x3D,A
826:              {
827:              	volatile unsigned long adsum = 0;
828:              	volatile unsigned int admin = 0, admax = 0;
  0019    20F2    CALL	0xF2
829:              	volatile unsigned int ad_temp = 0;
  001A    01C7    CLR	0x47
  001B    01C8    CLR	0x48
830:              
831:              	if ((!LDO_EN) && (adldo & 0x04) ) 
  001C    1683    SETB	0x3,5
  001D    1D16    SNZB	0x16,2
  001E    1D73    SNZB	0x73,2
  001F    2829    JP	0x29
832:              	{
833:              								//如果AD参考从VDD换到内部LDO，需要延时100US以上
834:              		ADCON1 = adldo;			//左对齐,AD值取12位
  0020    0873    LD	A,0x73
  0021    0096    LD	0x16,A
835:              		__delay_us(100);		//IDE内置延时函数，延时100us
  0022    3084    LDIA	0x84
  0023    1283    CLRB	0x3,5
  0024    00B8    LD	0x38,A
  0025    0BB8    SZDECR	0x38
  0026    2825    JP	0x25
  0027    2828    JP	0x28
836:              	} 
  0028    282B    JP	0x2B
837:              	else
838:              		ADCON1 = adldo;			//如果ADCON1.7(ADFM)=1为右对齐，,AD值取10位
  0029    0873    LD	A,0x73
  002A    0096    LD	0x16,A
839:              
840:              	if(adch & 0x10) 
  002B    1283    CLRB	0x3,5
  002C    1E3D    SNZB	0x3D,4
  002D    2833    JP	0x33
841:              	{
842:              		CHS4 = 1;
  002E    1683    SETB	0x3,5
  002F    1716    SETB	0x16,6
843:              		adch &= 0x0f;
  0030    300F    LDIA	0xF
  0031    1283    CLRB	0x3,5
  0032    05BD    ANDR	0x3D
844:              	}
845:              	unsigned char i = 0;
846:              	for (i = 0; i < 10; i++) 
  0033    01BE    CLR	0x3E
847:              	{
848:              		ADCON0 = (unsigned char)(0X41 | (adch << 2));	//16分频，如果主频为16M，则必须选16分频或以上
  0034    083D    LD	A,0x3D
  0035    00B8    LD	0x38,A
  0036    3001    LDIA	0x1
  0037    1003    CLRB	0x3,0
  0038    0DB8    RLCR	0x38
  0039    3EFF    ADDIA	0xFF
  003A    1003    CLRB	0x3,0
  003B    1D03    SNZB	0x3,2
  003C    2838    JP	0x38
  003D    0D38    RLCA	0x38
  003E    3841    ORIA	0x41
  003F    1683    SETB	0x3,5
  0040    0095    LD	0x15,A
  0041    0000    NOP
  0042    0000    NOP
  0043    0000    NOP
  0044    0000    NOP
849:              		asm("nop");
850:              		asm("nop");
851:              		asm("nop");
852:              		asm("nop");				//选择通道后需延时1uS以上
853:              		GODONE = 1;				//开始转换
  0045    1683    SETB	0x3,5
  0046    1495    SETB	0x15,1
854:              
855:              		unsigned char j = 0;
  0047    1283    CLRB	0x3,5
  0048    01BC    CLR	0x3C
856:              		while (GODONE) 
  0049    1683    SETB	0x3,5
  004A    1C95    SNZB	0x15,1
  004B    2854    JP	0x54
857:              		{
858:              			__delay_us(2);		//延时2us(编译器内置函数)
  004C    284D    JP	0x4D
  004D    284E    JP	0x4E
  004E    284F    JP	0x4F
  004F    2850    JP	0x50
859:              
860:              			if (0 == (--j))		//延时0.5ms仍没有AD转换结束，跳出程序
  0050    1283    CLRB	0x3,5
  0051    0BBC    SZDECR	0x3C
  0052    2849    JP	0x49
861:              			return 0;
  0053    3400    RET	0x0
862:              		}
863:              
864:              		ad_temp = (unsigned int)((ADRESH << 4) + (ADRESL >> 4));	//计算12位AD值
  0054    0819    LD	A,0x19
  0055    1283    CLRB	0x3,5
  0056    00C7    LD	0x47,A
  0057    01C8    CLR	0x48
  0058    0EC7    SWAPR	0x47
  0059    0EC8    SWAPR	0x48
  005A    30F0    LDIA	0xF0
  005B    05C8    ANDR	0x48
  005C    0847    LD	A,0x47
  005D    390F    ANDIA	0xF
  005E    04C8    ORR	0x48
  005F    30F0    LDIA	0xF0
  0060    05C7    ANDR	0x47
  0061    1683    SETB	0x3,5
  0062    0E18    SWAPA	0x18
  0063    390F    ANDIA	0xF
  0064    1283    CLRB	0x3,5
  0065    07C7    ADDR	0x47
  0066    1803    SZB	0x3,0
  0067    0AC8    INCR	0x48
865:              
866:              		if (0 == admax) 
  0068    0845    LD	A,0x45
  0069    0446    ORA	0x46
  006A    1D03    SNZB	0x3,2
  006B    286E    JP	0x6E
867:              		{
868:              			admax = ad_temp;
  006C    20FB    CALL	0xFB
  006D    2880    JP	0x80
869:              			admin = ad_temp;
870:              		} 
871:              		else if (ad_temp > admax)
  006E    0848    LD	A,0x48
  006F    0246    SUBA	0x46
  0070    1D03    SNZB	0x3,2
  0071    2874    JP	0x74
  0072    0847    LD	A,0x47
  0073    0245    SUBA	0x45
  0074    1803    SZB	0x3,0
  0075    2878    JP	0x78
872:              			admax = ad_temp;				//AD采样最大值
  0076    20FB    CALL	0xFB
  0077    2884    JP	0x84
873:              		else if (ad_temp < admin)
  0078    0844    LD	A,0x44
  0079    0248    SUBA	0x48
  007A    1D03    SNZB	0x3,2
  007B    287E    JP	0x7E
  007C    0843    LD	A,0x43
  007D    0247    SUBA	0x47
  007E    1803    SZB	0x3,0
  007F    2884    JP	0x84
874:              			admin = ad_temp;				//AD采样最小值
  0080    0848    LD	A,0x48
  0081    00C4    LD	0x44,A
  0082    0847    LD	A,0x47
  0083    00C3    LD	0x43,A
875:              
876:              		adsum += ad_temp;
  0084    0847    LD	A,0x47
  0085    00B8    LD	0x38,A
  0086    0848    LD	A,0x48
  0087    00B9    LD	0x39,A
  0088    01BA    CLR	0x3A
  0089    01BB    CLR	0x3B
  008A    0838    LD	A,0x38
  008B    07BF    ADDR	0x3F
  008C    0839    LD	A,0x39
  008D    1103    CLRB	0x3,2
  008E    1803    SZB	0x3,0
  008F    3E01    ADDIA	0x1
  0090    1D03    SNZB	0x3,2
  0091    07C0    ADDR	0x40
  0092    083A    LD	A,0x3A
  0093    1103    CLRB	0x3,2
  0094    1803    SZB	0x3,0
  0095    3E01    ADDIA	0x1
  0096    1D03    SNZB	0x3,2
  0097    07C1    ADDR	0x41
  0098    083B    LD	A,0x3B
  0099    1103    CLRB	0x3,2
  009A    1803    SZB	0x3,0
  009B    3E01    ADDIA	0x1
  009C    1D03    SNZB	0x3,2
  009D    07C2    ADDR	0x42
  009E    300A    LDIA	0xA
  009F    0ABE    INCR	0x3E
  00A0    023E    SUBA	0x3E
  00A1    1C03    SNZB	0x3,0
  00A2    2834    JP	0x34
877:              	}
878:              		adsum -= admax;
  00A3    0845    LD	A,0x45
  00A4    00B8    LD	0x38,A
  00A5    0846    LD	A,0x46
  00A6    20E3    CALL	0xE3
  00A7    1C03    SNZB	0x3,0
  00A8    0F3B    SZINCA	0x3B
  00A9    02C2    SUBR	0x42
879:              		if (adsum >= admin)
  00AA    0843    LD	A,0x43
  00AB    00B8    LD	0x38,A
  00AC    0844    LD	A,0x44
  00AD    00B9    LD	0x39,A
  00AE    01BA    CLR	0x3A
  00AF    01BB    CLR	0x3B
  00B0    083B    LD	A,0x3B
  00B1    0242    SUBA	0x42
  00B2    1D03    SNZB	0x3,2
  00B3    28BE    JP	0xBE
  00B4    083A    LD	A,0x3A
  00B5    0241    SUBA	0x41
  00B6    1D03    SNZB	0x3,2
  00B7    28BE    JP	0xBE
  00B8    0839    LD	A,0x39
  00B9    0240    SUBA	0x40
  00BA    1D03    SNZB	0x3,2
  00BB    28BE    JP	0xBE
  00BC    0838    LD	A,0x38
  00BD    023F    SUBA	0x3F
  00BE    1C03    SNZB	0x3,0
  00BF    28C8    JP	0xC8
880:              			adsum -= admin;
  00C0    0843    LD	A,0x43
  00C1    00B8    LD	0x38,A
  00C2    0844    LD	A,0x44
  00C3    20E3    CALL	0xE3
  00C4    1C03    SNZB	0x3,0
  00C5    0F3B    SZINCA	0x3B
  00C6    02C2    SUBR	0x42
  00C7    28CC    JP	0xCC
881:              		else
882:              			adsum = 0;
  00C8    01BF    CLR	0x3F
  00C9    01C0    CLR	0x40
  00CA    01C1    CLR	0x41
  00CB    01C2    CLR	0x42
883:              
884:              		adresult = adsum >> 3;		//8次平均值作为最终结果
  00CC    083F    LD	A,0x3F
  00CD    00B8    LD	0x38,A
  00CE    0840    LD	A,0x40
  00CF    00B9    LD	0x39,A
  00D0    0841    LD	A,0x41
  00D1    00BA    LD	0x3A,A
  00D2    0842    LD	A,0x42
  00D3    00BB    LD	0x3B,A
  00D4    3003    LDIA	0x3
  00D5    1003    CLRB	0x3,0
  00D6    0CBB    RRCR	0x3B
  00D7    0CBA    RRCR	0x3A
  00D8    0CB9    RRCR	0x39
  00D9    0CB8    RRCR	0x38
  00DA    3EFF    ADDIA	0xFF
  00DB    1D03    SNZB	0x3,2
  00DC    28D5    JP	0xD5
  00DD    0839    LD	A,0x39
  00DE    00A7    LD	0x27,A
  00DF    0838    LD	A,0x38
  00E0    00A6    LD	0x26,A
885:              
886:              		adsum = 0;
887:              		admin = 0;
888:              		admax = 0;
  00E1    20F2    CALL	0xF2
889:              		return 0xA5;
  00E2    34A5    RET	0xA5
890:              		
891:              }
892:              
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\lbmod.c ----------------------------------------------------------------------
1:                // byte unsigned modulus
2:                
3:                unsigned char
4:                __lbmod(unsigned char dividend, unsigned char divisor)
  03B0    00B8    LD	0x38,A
  03B1    3008    LDIA	0x8
  03B2    00B9    LD	0x39,A
  03B3    01BA    CLR	0x3A
  03B4    0838    LD	A,0x38
  03B5    00F4    LD	0x74,A
  03B6    3007    LDIA	0x7
  03B7    1003    CLRB	0x3,0
  03B8    0CF4    RRCR	0x74
  03B9    3EFF    ADDIA	0xFF
  03BA    1003    CLRB	0x3,0
  03BB    1D03    SNZB	0x3,2
  03BC    2BB8    JP	0x3B8
  03BD    0D3A    RLCA	0x3A
  03BE    0474    ORA	0x74
  03BF    00BA    LD	0x3A,A
  03C0    1003    CLRB	0x3,0
  03C1    0DB8    RLCR	0x38
  03C2    0873    LD	A,0x73
  03C3    023A    SUBA	0x3A
  03C4    1C03    SNZB	0x3,0
  03C5    2BC8    JP	0x3C8
  03C6    0873    LD	A,0x73
  03C7    02BA    SUBR	0x3A
  03C8    0BB9    SZDECR	0x39
  03C9    2BB4    JP	0x3B4
  03CA    083A    LD	A,0x3A
  03CB    0008    RET
5:                {
6:                	unsigned char	rem;
7:                	unsigned char	counter;
8:                
9:                	counter = 8;
10:               	rem = 0;
11:               	do {
12:               		rem = (rem << 1) | (dividend >> 7);
13:               		dividend <<= 1;
14:               		if(divisor <= rem)
15:               			rem -= divisor;
16:               	} while(--counter != 0);
17:               	return rem;
18:               }
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\lbdiv.c ----------------------------------------------------------------------
1:                // byte unsigned division
2:                
3:                unsigned char
4:                __lbdiv(unsigned char dividend, unsigned char divisor)
  03CC    00F4    LD	0x74,A
  03CD    01F6    CLR	0x76
  03CE    0873    LD	A,0x73
  03CF    1903    SZB	0x3,2
  03D0    2BE5    JP	0x3E5
  03D1    01F5    CLR	0x75
  03D2    0AF5    INCR	0x75
  03D3    1BF3    SZB	0x73,7
  03D4    2BD8    JP	0x3D8
  03D5    1003    CLRB	0x3,0
  03D6    0DF3    RLCR	0x73
  03D7    2BD2    JP	0x3D2
  03D8    1003    CLRB	0x3,0
  03D9    0DF6    RLCR	0x76
  03DA    0873    LD	A,0x73
  03DB    0274    SUBA	0x74
  03DC    1C03    SNZB	0x3,0
  03DD    2BE2    JP	0x3E2
  03DE    0873    LD	A,0x73
  03DF    02F4    SUBR	0x74
  03E0    1476    SETB	0x76,0
  03E1    1003    CLRB	0x3,0
  03E2    0CF3    RRCR	0x73
  03E3    0BF5    SZDECR	0x75
  03E4    2BD8    JP	0x3D8
  03E5    0876    LD	A,0x76
  03E6    0008    RET
5:                {
6:                	unsigned char	quotient;
7:                	unsigned char	counter;
8:                
9:                	quotient = 0;
10:               	if(divisor != 0) {
11:               		counter = 1;
12:               		while((divisor & 0x80) == 0) {
13:               			divisor <<= 1;
14:               			counter++;
15:               		}
16:               		do {
17:               			quotient <<= 1;
18:               			if(divisor <= dividend) {
19:               				dividend -= divisor;
20:               				quotient |= 1;
21:               			}
22:               			divisor >>= 1;
23:               		} while(--counter != 0);
24:               	}
25:               	return quotient;
26:               }
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\lwdiv.c ----------------------------------------------------------------------
1:                // word unsigned division
2:                
3:                unsigned int
4:                #ifdef __PICC__
5:                #warning TODO: update cgpic and this file to use the other prototype
6:                __lwdiv(unsigned int divisor, unsigned int dividend)
  033F    01B9    CLR	0x39
  0340    01BA    CLR	0x3A
  0341    0873    LD	A,0x73
  0342    0474    ORA	0x74
  0343    1903    SZB	0x3,2
  0344    2B64    JP	0x364
  0345    01B8    CLR	0x38
  0346    0AB8    INCR	0x38
  0347    1BF4    SZB	0x74,7
  0348    2B4D    JP	0x34D
  0349    1003    CLRB	0x3,0
  034A    0DF3    RLCR	0x73
  034B    0DF4    RLCR	0x74
  034C    2B46    JP	0x346
  034D    1003    CLRB	0x3,0
  034E    0DB9    RLCR	0x39
  034F    0DBA    RLCR	0x3A
  0350    0874    LD	A,0x74
  0351    0276    SUBA	0x76
  0352    1D03    SNZB	0x3,2
  0353    2B56    JP	0x356
  0354    0873    LD	A,0x73
  0355    0275    SUBA	0x75
  0356    1C03    SNZB	0x3,0
  0357    2B60    JP	0x360
  0358    0873    LD	A,0x73
  0359    02F5    SUBR	0x75
  035A    0874    LD	A,0x74
  035B    1C03    SNZB	0x3,0
  035C    03F6    DECR	0x76
  035D    02F6    SUBR	0x76
  035E    1439    SETB	0x39,0
  035F    1003    CLRB	0x3,0
  0360    0CF4    RRCR	0x74
  0361    0CF3    RRCR	0x73
  0362    0BB8    SZDECR	0x38
  0363    2B4D    JP	0x34D
  0364    083A    LD	A,0x3A
  0365    00F4    LD	0x74,A
  0366    0839    LD	A,0x39
  0367    00F3    LD	0x73,A
  0368    0008    RET
7:                #else
8:                __lwdiv(unsigned int dividend, unsigned int divisor)
9:                #endif
10:               {
11:               	unsigned int	quotient;
12:               	unsigned char	counter;
13:               
14:               	quotient = 0;
15:               	if(divisor != 0) {
16:               		counter = 1;
17:               		while((divisor & 0x8000) == 0) {
18:               			divisor <<= 1;
19:               			counter++;
20:               		}
21:               		do {
22:               			quotient <<= 1;
23:               			if(divisor <= dividend) {
24:               				dividend -= divisor;
25:               				quotient |= 1;
26:               			}
27:               			divisor >>= 1;
28:               		} while(--counter != 0);
29:               	}
30:               	return quotient;
31:               }
---- stringtab ------------------------------------------------------------------
  0417    3004    LDIA	0x4
  0418    008A    LD	0xA,A
  0419    0804    LD	A,0x4
  041A    0A84    INCR	0x4
  041B    0782    ADDR	0x2
  041C    3400    RET	0x0
---- reset_enter ------------------------------------------------------------------
  0000    280C    JP	0xC
  000C    280D    JP	0xD
---- start_initialization ------------------------------------------------------------------
  000D    3077    LDIA	0x77
  000E    0084    LD	0x4,A
  000F    307B    LDIA	0x7B
  0010    2453    CALL	0x453
  0011    3020    LDIA	0x20
  0012    1383    CLRB	0x3,7
  0013    0084    LD	0x4,A
  0014    3038    LDIA	0x38
  0015    2453    CALL	0x453
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F0    LD	0x70,A
  0007    0804    LD	A,0x4
  0008    00F1    LD	0x71,A
  0009    080A    LD	A,0xA
  000A    00F2    LD	0x72,A
  000B    2B93    JP	0x393
---- common_function ------------------------------------------------------------------
  0016    0183    CLR	0x3
  0017    2B08    JP	0x308
  00E3    00B9    LD	0x39,A
  00E4    01BA    CLR	0x3A
  00E5    01BB    CLR	0x3B
  00E6    0838    LD	A,0x38
  00E7    02BF    SUBR	0x3F
  00E8    0839    LD	A,0x39
  00E9    1C03    SNZB	0x3,0
  00EA    0F39    SZINCA	0x39
  00EB    02C0    SUBR	0x40
  00EC    083A    LD	A,0x3A
  00ED    1C03    SNZB	0x3,0
  00EE    0F3A    SZINCA	0x3A
  00EF    02C1    SUBR	0x41
  00F0    083B    LD	A,0x3B
  00F1    0008    RET
  00F2    01BF    CLR	0x3F
  00F3    01C0    CLR	0x40
  00F4    01C1    CLR	0x41
  00F5    01C2    CLR	0x42
  00F6    01C3    CLR	0x43
  00F7    01C4    CLR	0x44
  00F8    01C5    CLR	0x45
  00F9    01C6    CLR	0x46
  00FA    0008    RET
  00FB    0848    LD	A,0x48
  00FC    00C6    LD	0x46,A
  00FD    0847    LD	A,0x47
  00FE    00C5    LD	0x45,A
  00FF    0008    RET
  02FF    0085    LD	0x5,A
  0300    3037    LDIA	0x37
  0301    1283    CLRB	0x3,5
  0302    0085    LD	0x5,A
  0303    1683    SETB	0x3,5
  0304    0186    CLR	0x6
  0305    1283    CLRB	0x3,5
  0306    0186    CLR	0x6
  0307    0008    RET
  041D    343F    RET	0x3F
  041E    3406    RET	0x6
  041F    345B    RET	0x5B
  0420    344F    RET	0x4F
  0421    3466    RET	0x66
  0422    346D    RET	0x6D
  0423    347D    RET	0x7D
  0424    3407    RET	0x7
  0425    347F    RET	0x7F
  0426    346F    RET	0x6F
  0427    3473    RET	0x73
  0428    3476    RET	0x76
  0439    2AB1    JP	0x2B1
  043A    2A49    JP	0x249
  043B    2A51    JP	0x251
  043C    2A59    JP	0x259
  043D    2A61    JP	0x261
  043E    2A69    JP	0x269
  043F    2A71    JP	0x271
  0440    2A79    JP	0x279
  0441    2A81    JP	0x281
  0442    2A89    JP	0x289
  0443    2A91    JP	0x291
  0444    2A99    JP	0x299
  0445    2AA1    JP	0x2A1
  0446    2AA9    JP	0x2A9
  0453    0064    CLRWDT
  0454    0180    CLR	0x0
  0455    0A84    INCR	0x4
  0456    0604    XORA	0x4
  0457    1903    SZB	0x3,2
  0458    3400    RET	0x0
  0459    0604    XORA	0x4
  045A    2C54    JP	0x454
