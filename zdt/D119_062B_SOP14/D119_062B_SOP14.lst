---- C:\mcuproject\scm\zdt\D119_062B_SOP14\main.c ----------------------------------------------------------------------
1:                /**********************************************************
2:                AD检测范例程序
3:                **********************************************************/
4:                #pragma warning disable 752
5:                #pragma warning disable 373			//屏蔽掉编译的1个警告
6:                #include <sc.h>
7:                
8:                #ifndef _XTAL_FREQ
9:                #define _XTAL_FREQ 16000000			//16MHz,使用内置延时函数必须定义主频，
10:               									//如用FCPU_DIV选择2T，则定时赋值减半
11:               #endif
12:               #define		u8t		unsigned char
13:               #define		u16t	unsigned int
14:               #define     POWER_RATIO  	(4096UL*1.2*1000)
15:               
16:               
17:               #define		A_LED5						 RA1
18:               #define		A_LED4						 RA2
19:               #define		A_LED3						 RA3
20:               #define		A_LED2						 RA4
21:               #define		A_LED1						 RA5
22:               
23:               
24:               #define		A_LED5_OUT					 TRISA	&= 0xFD
25:               #define		A_LED4_OUT					 TRISA	&= 0xFB
26:               #define		A_LED3_OUT					 TRISA	&= 0xF7
27:               #define		A_LED2_OUT					 TRISA	&= 0xEF
28:               #define		A_LED1_OUT					 TRISA	&= 0xDF
29:               
30:               const static unsigned char numArray[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x73,0x76};
31:               
32:               volatile unsigned int adresult;
33:               volatile unsigned int result;
34:               volatile unsigned char test_adc;
35:               volatile unsigned int power_ad;
36:               u8t	intCount;
37:               u8t	count1s;
38:               u8t	IntFlag;
39:               u8t	chrgFlag;
40:               u8t	chrgFullFlag;
41:               u8t	intCount10;
42:               u8t		chrgFullTime;
43:               u8t		workStep = 0;
44:               u8t		ledCnt;
45:               u8t		keyCount;
46:               u8t		longPressFlag;
47:               u8t		firstTime;
48:               u8t		showBatTime;
49:               u8t	ledCntTime;
50:               u16t	lowShanTime;
51:               u16t	count900s;
52:               u8t		lowBatFlag = 0;
53:               u8t		sleepTime;
54:               u8t shiweiNum = 0;	//十位
55:               u8t	geweiNum = 0;	//个位
56:               u8t	baiweiNum = 0;
57:               u8t	motorPwmFlag = 0;
58:               u16t	count30s = 0;
59:               u8t	showBatStep = 0;
60:               u8t		curBatStep = 0;
61:               u8t	lowBatTime = 0;
62:               u8t	startLockFlag = 0;
63:               u8t	lockTime = 0;
64:               u16t out_ad = 0;
65:               u8t	overTime = 0;
66:               u8t	curDuty = 0;
67:               u8t	maxDuty = 0;
68:               
69:               unsigned char ADC_Sample(unsigned char adch, unsigned char adldo);
70:               void DelayXms(unsigned char x);
71:               unsigned char ADC_Result(unsigned char adch);
72:               void Init_System();
73:               void AD_Init();
74:               void Sleep_Mode();
75:               void pwmInit();
76:               void pwmStop();
77:               void chrgCtr();
78:               void checkBatAD();
79:               void checkOutAD();
80:               void ledShow();
81:               void keyCtr();
82:               void workCtr();
83:               void ledCtr();
84:               char keyRead(char keyStatus);
85:               void setBatStep();
86:               
87:               
88:               //#define _DEBUG			//调试程序用
89:               
90:               
91:               /***********************************************************
92:               中断服务函数
93:               函数名称：Isr_Timer()
94:               函数功能：中断处理函数
95:               入口参数：
96:               出口参数：
97:               备    注：125US定时2中断
98:               			所有中断都是在这个函数里面处理
99:               ***********************************************************/
100:              void interrupt Isr_Timer() 
101:              {
102:              	if(TMR2IF) 
  03F3    1283    CLRB	0x3,5
  03F4    1C8D    SNZB	0xD,1
  03F5    2C07    JP	0x407
103:              	{			//若只使能了一个中断源,可以略去判断
104:              		TMR2IF = 0;
  03F6    108D    CLRB	0xD,1
105:              		if(++intCount >= 160)
  03F7    30A0    LDIA	0xA0
  03F8    0ABC    INCR	0x3C
  03F9    023C    SUBA	0x3C
  03FA    1C03    SNZB	0x3,0
  03FB    2C04    JP	0x404
  03FC    3064    LDIA	0x64
106:              		{
107:              			intCount = 0;
  03FD    01BC    CLR	0x3C
108:              			IntFlag = 1;
  03FE    01BA    CLR	0x3A
  03FF    0ABA    INCR	0x3A
109:              			if(++count1s >= 100)
  0400    0ABB    INCR	0x3B
  0401    023B    SUBA	0x3B
  0402    1803    SZB	0x3,0
110:              			{
111:              				count1s = 0;
  0403    01BB    CLR	0x3B
112:              			}
113:              		}
114:              		ledShow();
  0404    2287    CALL	0x287
115:              		intCount10++;
  0405    1283    CLRB	0x3,5
  0406    0AB8    INCR	0x38
  0407    0872    LD	A,0x72
  0408    008A    LD	0xA,A
  0409    0871    LD	A,0x71
  040A    0084    LD	0x4,A
  040B    0E70    SWAPA	0x70
  040C    0083    LD	0x3,A
  040D    0EFE    SWAPR	0x7E
  040E    0E7E    SWAPA	0x7E
  040F    0009    RETI
116:              	}
117:              
118:              }
119:              
120:              
121:              /***********************************************************
122:              main主函数
123:              ***********************************************************/
124:              void main() 
125:              {
126:              	Init_System();
  0357    2463    CALL	0x463
127:              	AD_Init();
  0358    24E1    CALL	0x4E1
128:              	shiweiNum = geweiNum = numArray[8];
129:              	baiweiNum = 1;
  0359    3009    LDIA	0x9
  035A    0084    LD	0x4,A
  035B    24A9    CALL	0x4A9
  035C    1283    CLRB	0x3,5
  035D    00D0    LD	0x50,A
  035E    00D1    LD	0x51,A
130:              	firstTime = 250;
  035F    30FA    LDIA	0xFA
  0360    00D2    LD	0x52,A
131:              	startLockFlag = 1;		//上电默认不让启动，必须要复位才能启动
  0361    01CF    CLR	0x4F
  0362    0ACF    INCR	0x4F
132:              	while (1) 
  0363    0064    CLRWDT
133:              	{
134:              		asm("clrwdt");
135:              		if(intCount10 > 10)
  0364    300B    LDIA	0xB
  0365    1283    CLRB	0x3,5
  0366    0238    SUBA	0x38
  0367    1803    SZB	0x3,0
136:              		{
137:              			intCount10 = 0;
  0368    01B8    CLR	0x38
138:              		}
139:              		if(!IntFlag)
  0369    083A    LD	A,0x3A
  036A    1903    SZB	0x3,2
  036B    2B63    JP	0x363
140:                  		continue;			//10ms执行一次
141:                  	IntFlag = 0;
  036C    01BA    CLR	0x3A
142:              		chrgCtr();
  036D    2396    CALL	0x396
143:              		checkBatAD();
  036E    2493    CALL	0x493
144:              		setBatStep();
  036F    21DD    CALL	0x1DD
145:              		if(lowBatFlag == 0 && firstTime == 0 && chrgFlag == 0)
  0370    0832    LD	A,0x32
  0371    1D03    SNZB	0x3,2
  0372    2B7A    JP	0x37A
  0373    0852    LD	A,0x52
  0374    1D03    SNZB	0x3,2
  0375    2B7A    JP	0x37A
  0376    087A    LD	A,0x7A
  0377    1D03    SNZB	0x3,2
  0378    2B7A    JP	0x37A
146:              		{
147:              			keyCtr();
  0379    242C    CALL	0x42C
148:              		}
149:              		workCtr();
  037A    2100    CALL	0x100
150:              		checkOutAD();
  037B    247D    CALL	0x47D
151:              		if(chrgFlag == 0 && workStep == 0 && firstTime == 0 && showBatTime == 0)
  037C    087A    LD	A,0x7A
  037D    1283    CLRB	0x3,5
  037E    1D03    SNZB	0x3,2
  037F    2B94    JP	0x394
  0380    0836    LD	A,0x36
  0381    1D03    SNZB	0x3,2
  0382    2B93    JP	0x393
  0383    0852    LD	A,0x52
  0384    1D03    SNZB	0x3,2
  0385    2B93    JP	0x393
152:              		{
153:              			baiweiNum = 0;
  0386    0834    LD	A,0x34
  0387    1D03    SNZB	0x3,2
  0388    2B93    JP	0x393
  0389    30C8    LDIA	0xC8
154:              			shiweiNum = geweiNum = 0;
  038A    01D0    CLR	0x50
  038B    01D1    CLR	0x51
155:              			if(++sleepTime >= 200)
  038C    0AB1    INCR	0x31
  038D    0231    SUBA	0x31
  038E    1C03    SNZB	0x3,0
  038F    2B63    JP	0x363
156:              			{
157:              				sleepTime = 0;
  0390    01B1    CLR	0x31
158:              				Sleep_Mode();
  0391    2315    CALL	0x315
  0392    2B63    JP	0x363
159:              			}
160:              		}
161:              		else
162:              		{
163:              			sleepTime = 0;
  0393    1283    CLRB	0x3,5
  0394    01B1    CLR	0x31
  0395    2B63    JP	0x363
164:              		}
165:              	}
166:              }
167:              
168:              void ledShow()
169:              {
170:              	if(++ledCntTime > 5)
  0287    3006    LDIA	0x6
  0288    0AB3    INCR	0x33
  0289    0233    SUBA	0x33
  028A    1C03    SNZB	0x3,0
  028B    0008    RET
  028C    300E    LDIA	0xE
171:              	{
172:              		ledCntTime = 0;
  028D    01B3    CLR	0x33
173:              		if(++ledCnt > 13)
  028E    0AB5    INCR	0x35
  028F    0235    SUBA	0x35
  0290    1803    SZB	0x3,0
174:              		{
175:              			ledCnt = 0;
  0291    01B5    CLR	0x35
176:              		}
177:              		PORTA &= 0xC1;
  0292    30C1    LDIA	0xC1
  0293    1683    SETB	0x3,5
  0294    0586    ANDR	0x6
178:              		TRISA |= 0x3E;
  0295    303E    LDIA	0x3E
  0296    0485    ORR	0x5
179:              		switch(ledCnt)
  0297    2B08    JP	0x308
180:              		{
181:              			case 1:
182:              			if(shiweiNum & 0x01)
  0298    1C51    SNZB	0x51,0
  0299    0008    RET
183:              			{
184:              				A_LED2_OUT;
  029A    1683    SETB	0x3,5
  029B    1205    CLRB	0x5,4
185:              				A_LED1_OUT;
  029C    1285    CLRB	0x5,5
186:              				A_LED2 = 1;
  029D    1606    SETB	0x6,4
187:              				A_LED1 = 0;
  029E    1286    CLRB	0x6,5
  029F    0008    RET
188:              			}
189:              			break;
190:              			case 2:
191:              			if(shiweiNum & 0x02)
  02A0    1CD1    SNZB	0x51,1
  02A1    0008    RET
192:              			{
193:              				A_LED3_OUT;
  02A2    1683    SETB	0x3,5
  02A3    1185    CLRB	0x5,3
194:              				A_LED2_OUT;
  02A4    1205    CLRB	0x5,4
195:              				A_LED2 = 1;
  02A5    1606    SETB	0x6,4
196:              				A_LED3 = 0;
  02A6    1186    CLRB	0x6,3
  02A7    0008    RET
197:              			}
198:              			break;
199:              			case 3:
200:              			if(shiweiNum & 0x04)
  02A8    1D51    SNZB	0x51,2
  02A9    0008    RET
201:              			{
202:              				A_LED3_OUT;
  02AA    1683    SETB	0x3,5
  02AB    1185    CLRB	0x5,3
203:              				A_LED5_OUT;
  02AC    1085    CLRB	0x5,1
204:              				A_LED5 = 1;
  02AD    1486    SETB	0x6,1
205:              				A_LED3 = 0;
  02AE    1186    CLRB	0x6,3
  02AF    0008    RET
206:              			}
207:              			break;
208:              			case 4:
209:              			if(shiweiNum & 0x08)
  02B0    1DD1    SNZB	0x51,3
  02B1    0008    RET
210:              			{
211:              				A_LED4_OUT;
  02B2    1683    SETB	0x3,5
  02B3    1105    CLRB	0x5,2
212:              				A_LED5_OUT;
  02B4    1085    CLRB	0x5,1
213:              				A_LED4 = 1;
  02B5    1506    SETB	0x6,2
214:              				A_LED5 = 0;
  02B6    1086    CLRB	0x6,1
  02B7    0008    RET
215:              			}
216:              			break;
217:              			case 5:
218:              			if(shiweiNum & 0x10)
  02B8    1E51    SNZB	0x51,4
  02B9    0008    RET
219:              			{
220:              				A_LED5_OUT;
  02BA    1683    SETB	0x3,5
  02BB    1085    CLRB	0x5,1
221:              				A_LED4_OUT;
  02BC    1105    CLRB	0x5,2
222:              				A_LED5 = 1;
  02BD    1486    SETB	0x6,1
223:              				A_LED4 = 0;
  02BE    1106    CLRB	0x6,2
  02BF    0008    RET
224:              			}
225:              			break;
226:              			case 6:
227:              			if(shiweiNum & 0x20)
  02C0    1ED1    SNZB	0x51,5
  02C1    0008    RET
228:              			{
229:              				A_LED3_OUT;
  02C2    1683    SETB	0x3,5
  02C3    1185    CLRB	0x5,3
230:              				A_LED4_OUT;
  02C4    1105    CLRB	0x5,2
231:              				A_LED3 = 1;
  02C5    1586    SETB	0x6,3
232:              				A_LED4 = 0;
  02C6    1106    CLRB	0x6,2
  02C7    0008    RET
233:              			}
234:              			break;
235:              			case 7:
236:              			if(shiweiNum & 0x40)
  02C8    1F51    SNZB	0x51,6
  02C9    0008    RET
237:              			{
238:              				A_LED4_OUT;
  02CA    1683    SETB	0x3,5
  02CB    1105    CLRB	0x5,2
239:              				A_LED3_OUT;
  02CC    1185    CLRB	0x5,3
240:              				A_LED4 = 1;
  02CD    1506    SETB	0x6,2
241:              				A_LED3 = 0;
  02CE    1186    CLRB	0x6,3
  02CF    0008    RET
242:              			}
243:              			break;
244:              			case 8:
245:              			if(geweiNum & 0x01)
  02D0    1C50    SNZB	0x50,0
  02D1    0008    RET
246:              			{
247:              				A_LED1_OUT;
  02D2    1683    SETB	0x3,5
  02D3    1285    CLRB	0x5,5
248:              				A_LED2_OUT;
  02D4    1205    CLRB	0x5,4
249:              				A_LED1 = 1;
  02D5    1686    SETB	0x6,5
250:              				A_LED2 = 0;
  02D6    1206    CLRB	0x6,4
  02D7    0008    RET
251:              			}
252:              			break;
253:              			case 9:
254:              			if(geweiNum & 0x02)
  02D8    1CD0    SNZB	0x50,1
  02D9    0008    RET
255:              			{
256:              				A_LED3_OUT;
  02DA    1683    SETB	0x3,5
  02DB    1185    CLRB	0x5,3
257:              				A_LED1_OUT;
  02DC    1285    CLRB	0x5,5
258:              				A_LED3 = 1;
  02DD    1586    SETB	0x6,3
259:              				A_LED1 = 0;
  02DE    1286    CLRB	0x6,5
  02DF    0008    RET
260:              			}
261:              			break;
262:              			case 10:
263:              			if(geweiNum & 0x04)
  02E0    1D50    SNZB	0x50,2
  02E1    0008    RET
264:              			{
265:              				A_LED1_OUT;
  02E2    1683    SETB	0x3,5
  02E3    1285    CLRB	0x5,5
266:              				A_LED5_OUT;
  02E4    1085    CLRB	0x5,1
267:              				A_LED1 = 1;
  02E5    1686    SETB	0x6,5
268:              				A_LED5 = 0;
  02E6    1086    CLRB	0x6,1
  02E7    0008    RET
269:              			}
270:              			break;
271:              			case 11:
272:              			if(geweiNum & 0x08)
  02E8    1DD0    SNZB	0x50,3
  02E9    0008    RET
273:              			{
274:              				A_LED1_OUT;
  02EA    1683    SETB	0x3,5
  02EB    1285    CLRB	0x5,5
275:              				A_LED5_OUT;
  02EC    1085    CLRB	0x5,1
276:              				A_LED5 = 1;
  02ED    1486    SETB	0x6,1
277:              				A_LED1 = 0;
  02EE    1286    CLRB	0x6,5
  02EF    0008    RET
278:              			}
279:              			break;
280:              			case 12:
281:              			if(geweiNum & 0x10)
  02F0    1E50    SNZB	0x50,4
  02F1    0008    RET
282:              			{
283:              				A_LED3_OUT;
  02F2    1683    SETB	0x3,5
  02F3    1185    CLRB	0x5,3
284:              				A_LED5_OUT;
  02F4    1085    CLRB	0x5,1
285:              				A_LED3 = 1;
  02F5    1586    SETB	0x6,3
286:              				A_LED5 = 0;
  02F6    1086    CLRB	0x6,1
  02F7    0008    RET
287:              			}
288:              			break;
289:              			case 13:
290:              			if(geweiNum & 0x20)
  02F8    1ED0    SNZB	0x50,5
  02F9    0008    RET
291:              			{
292:              				A_LED3_OUT;
  02FA    1683    SETB	0x3,5
  02FB    1185    CLRB	0x5,3
293:              				A_LED2_OUT;
  02FC    1205    CLRB	0x5,4
294:              				A_LED3 = 1;
  02FD    1586    SETB	0x6,3
295:              				A_LED2 = 0;
  02FE    1206    CLRB	0x6,4
  02FF    0008    RET
296:              			}
297:              			break;
298:              			case 0:
299:              			if(geweiNum & 0x40)
  0300    1F50    SNZB	0x50,6
  0301    0008    RET
300:              			{
301:              				A_LED1_OUT;
  0302    1683    SETB	0x3,5
  0303    1285    CLRB	0x5,5
302:              				A_LED3_OUT;
  0304    1185    CLRB	0x5,3
303:              				A_LED1 = 1;
  0305    1686    SETB	0x6,5
304:              				A_LED3 = 0;
  0306    1186    CLRB	0x6,3
  0307    0008    RET
  0308    1283    CLRB	0x3,5
  0309    0835    LD	A,0x35
  030A    0084    LD	0x4,A
  030B    300E    LDIA	0xE
  030C    0204    SUBA	0x4
  030D    1803    SZB	0x3,0
  030E    0008    RET
  030F    3004    LDIA	0x4
  0310    008A    LD	0xA,A
  0311    30CB    LDIA	0xCB
  0312    0704    ADDA	0x4
  0313    0082    LD	0x2,A
  0314    0008    RET
305:              			}
306:              			break;
307:              			default:
308:              			break;
309:              		}
310:              	}
311:              	
312:              	
313:              }
314:              
315:              
316:              
317:              
318:              
319:              
320:              void chrgCtr()
321:              {
322:              	if(PORTB & 0x01)
  0396    1C06    SNZB	0x6,0
  0397    2BB3    JP	0x3B3
323:              	{
324:              		chrgFlag = 1;
  0398    01FA    CLR	0x7A
  0399    0AFA    INCR	0x7A
325:              		startLockFlag = 1;	//充电不在0档锁定
  039A    01CF    CLR	0x4F
  039B    0ACF    INCR	0x4F
326:              		workStep = 0;
  039C    01B6    CLR	0x36
327:              		lowBatFlag = 0;
  039D    01B2    CLR	0x32
328:              		if(showBatStep == 0)
  039E    0879    LD	A,0x79
  039F    1D03    SNZB	0x3,2
  03A0    2BA3    JP	0x3A3
329:              		{
330:              			showBatStep = 1;
  03A1    01F9    CLR	0x79
  03A2    0AF9    INCR	0x79
331:              		}
332:              		if(PORTA & 0x01)
  03A3    1683    SETB	0x3,5
  03A4    1C06    SNZB	0x6,0
  03A5    2BA9    JP	0x3A9
333:              		{
334:              			chrgFullTime = 0;
  03A6    1283    CLRB	0x3,5
  03A7    01B7    CLR	0x37
335:              		}
  03A8    0008    RET
336:              		else
337:              		{
338:              			if(++chrgFullTime >= 200)
  03A9    30C8    LDIA	0xC8
  03AA    1283    CLRB	0x3,5
  03AB    0AB7    INCR	0x37
  03AC    0237    SUBA	0x37
  03AD    1C03    SNZB	0x3,0
  03AE    0008    RET
339:              			{
340:              				chrgFullTime = 0;
  03AF    01B7    CLR	0x37
341:              				chrgFullFlag = 1;
  03B0    01B9    CLR	0x39
  03B1    0AB9    INCR	0x39
  03B2    0008    RET
  03B3    3006    LDIA	0x6
342:              			}
343:              		}
344:              	}
345:              	else
346:              	{
347:              		chrgFlag = 0;
  03B4    01FA    CLR	0x7A
348:              		chrgFullFlag = 0;
  03B5    01B9    CLR	0x39
349:              		chrgFullTime = 0;
  03B6    01B7    CLR	0x37
350:              		if(power_ad < 1650)
  03B7    0278    SUBA	0x78
  03B8    3072    LDIA	0x72
  03B9    1903    SZB	0x3,2
  03BA    0277    SUBA	0x77
  03BB    1803    SZB	0x3,0
  03BC    2BC7    JP	0x3C7
351:              		{
352:              			if(++lowBatTime > 200)
  03BD    30C9    LDIA	0xC9
  03BE    0AAE    INCR	0x2E
  03BF    022E    SUBA	0x2E
  03C0    1C03    SNZB	0x3,0
  03C1    0008    RET
353:              			{
354:              				lowBatTime = 0;
  03C2    01AE    CLR	0x2E
355:              				lowBatFlag = 1;
  03C3    01B2    CLR	0x32
  03C4    0AB2    INCR	0x32
356:              				showBatStep = 0;
  03C5    01F9    CLR	0x79
  03C6    0008    RET
357:              			}
358:              		}
359:              		else
360:              		{
361:              			lowBatTime = 0;
  03C7    01AE    CLR	0x2E
  03C8    0008    RET
362:              		}
363:              	}
364:              }
365:              
366:              
367:              
368:              char keyRead(char keyStatus)	
369:              { 
370:              	if(keyStatus)
371:              	{
372:              		keyCount++;
373:              		if(keyCount >= 100)
374:              		{
375:              			keyCount = 100;
376:              			if(!longPressFlag)
377:              			{
378:              				longPressFlag = 1;
379:              				return 2;
380:              			}
381:              		}
382:              	}
383:              	else
384:              	{
385:              		if(keyCount >= 100)
386:              		{
387:              			keyCount = 0;
388:              			longPressFlag = 0;
389:              			return	0;
390:              		}
391:              		else if(keyCount >= 6)
392:              		{
393:              			keyCount = 0;
394:              			return	1;
395:              		}
396:              		keyCount = 0;
397:              	}
398:              	return 0;
399:              }
400:              
401:              
402:              
403:              void keyCtr()
404:              {
405:              	if(PORTB & 0x02)
  042C    1C86    SNZB	0x6,1
  042D    2C3F    JP	0x43F
406:              	{
407:              		lockTime = 0;
  042E    01AD    CLR	0x2D
408:              		if(workStep > 0 || startLockFlag == 0)
  042F    0836    LD	A,0x36
  0430    1D03    SNZB	0x3,2
  0431    2C35    JP	0x435
  0432    084F    LD	A,0x4F
  0433    1D03    SNZB	0x3,2
  0434    0008    RET
409:              		{
410:              			startLockFlag = 1;
  0435    01CF    CLR	0x4F
  0436    0ACF    INCR	0x4F
411:              			if(PORTB & 0x04)
  0437    1D06    SNZB	0x6,2
  0438    2C3C    JP	0x43C
412:              			{
413:              				workStep = 1;
  0439    01B6    CLR	0x36
  043A    0AB6    INCR	0x36
414:              			}
  043B    0008    RET
415:              			else
416:              			{
417:              				workStep = 2;
  043C    3002    LDIA	0x2
  043D    00B6    LD	0x36,A
  043E    0008    RET
  043F    3015    LDIA	0x15
418:              			}
419:              		}
420:              	}
421:              	else
422:              	{
423:              		workStep = 0;
  0440    01B6    CLR	0x36
424:              		if(++lockTime > 20)
  0441    0AAD    INCR	0x2D
  0442    022D    SUBA	0x2D
  0443    1C03    SNZB	0x3,0
  0444    0008    RET
425:              		{
426:              			lockTime = 0;
  0445    01AD    CLR	0x2D
427:              			startLockFlag = 0;
  0446    01CF    CLR	0x4F
  0447    0008    RET
428:              		}
429:              	}
430:              	
431:              	
432:              }
433:              
434:              
435:              void workCtr()
436:              {
437:              	/*
438:              	if(workStep > 0 && count1s == 0 && ++count900s >= 900)
439:              	{
440:              		count900s = 0;
441:              		workStep = 0;
442:              	}
443:              	*/
444:              	if(curDuty < maxDuty)
  0100    082A    LD	A,0x2A
  0101    022B    SUBA	0x2B
  0102    1803    SZB	0x3,0
  0103    2906    JP	0x106
445:              	{
446:              		curDuty++;
  0104    0AAB    INCR	0x2B
447:              	}
  0105    290A    JP	0x10A
448:              	else if(curDuty > maxDuty)
  0106    082B    LD	A,0x2B
  0107    022A    SUBA	0x2A
  0108    1C03    SNZB	0x3,0
449:              	{
450:              		curDuty--;
  0109    03AB    DECR	0x2B
451:              	}
452:              	if(lowShanTime > 0)
  010A    0824    LD	A,0x24
  010B    0425    ORA	0x25
  010C    1903    SZB	0x3,2
  010D    2918    JP	0x118
453:              	{
454:              		if(--lowShanTime == 0)
  010E    3001    LDIA	0x1
  010F    02A4    SUBR	0x24
  0110    3000    LDIA	0x0
  0111    1C03    SNZB	0x3,0
  0112    03A5    DECR	0x25
  0113    02A5    SUBR	0x25
  0114    0824    LD	A,0x24
  0115    0425    ORA	0x25
  0116    1903    SZB	0x3,2
455:              		{
456:              			workStep = 0;
  0117    01B6    CLR	0x36
457:              		}
458:              	}
459:              	if(showBatTime > 0)
  0118    0834    LD	A,0x34
  0119    1D03    SNZB	0x3,2
460:              	{
461:              		showBatTime--;
  011A    03B4    DECR	0x34
462:              	}
463:              	if(firstTime > 0)
  011B    0852    LD	A,0x52
  011C    1903    SZB	0x3,2
  011D    292E    JP	0x12E
464:              	{
465:              		firstTime--;
  011E    03D2    DECR	0x52
466:              		if(showBatStep < curBatStep)
  011F    082F    LD	A,0x2F
  0120    0279    SUBA	0x79
  0121    1803    SZB	0x3,0
  0122    2925    JP	0x125
467:              		{	
468:              			showBatStep = curBatStep;
  0123    082F    LD	A,0x2F
  0124    00F9    LD	0x79,A
469:              		}
470:              		shiweiNum = numArray[8];
  0125    3009    LDIA	0x9
  0126    0084    LD	0x4,A
  0127    24A9    CALL	0x4A9
  0128    00D1    LD	0x51,A
471:              		geweiNum = numArray[8];
  0129    3009    LDIA	0x9
  012A    0084    LD	0x4,A
  012B    24A9    CALL	0x4A9
  012C    00D0    LD	0x50,A
472:              	}
  012D    2997    JP	0x197
473:              	else if(workStep == 0 || (lowShanTime > 0 && count1s < 50))
  012E    0836    LD	A,0x36
  012F    1903    SZB	0x3,2
  0130    2939    JP	0x139
  0131    0824    LD	A,0x24
  0132    0425    ORA	0x25
  0133    1903    SZB	0x3,2
  0134    2946    JP	0x146
  0135    3032    LDIA	0x32
  0136    023B    SUBA	0x3B
  0137    1803    SZB	0x3,0
  0138    2946    JP	0x146
474:              	{
475:              		shiweiNum = 0;
  0139    01D1    CLR	0x51
476:              		geweiNum = 0;
  013A    01D0    CLR	0x50
477:              		maxDuty = 0;
  013B    01AA    CLR	0x2A
478:              		PWMD2L = curDuty;
  013C    082B    LD	A,0x2B
  013D    1683    SETB	0x3,5
  013E    009B    LD	0x1B,A
479:              		if(curDuty < 40)
  013F    3028    LDIA	0x28
  0140    1283    CLRB	0x3,5
  0141    022B    SUBA	0x2B
  0142    1803    SZB	0x3,0
  0143    2997    JP	0x197
480:              		{
481:              			pwmStop();
  0144    24E9    CALL	0x4E9
  0145    2997    JP	0x197
482:              		}
483:              		count900s = 0;
484:              	}
485:              	else if(workStep == 1)
  0146    0B36    SZDECA	0x36
  0147    2967    JP	0x167
486:              	{
487:              		if(chrgFlag == 0)
  0148    087A    LD	A,0x7A
  0149    1D03    SNZB	0x3,2
  014A    2953    JP	0x153
488:              		{
489:              			shiweiNum = numArray[10];
  014B    300B    LDIA	0xB
  014C    0084    LD	0x4,A
  014D    24A9    CALL	0x4A9
  014E    00D1    LD	0x51,A
490:              			geweiNum = numArray[1];
  014F    3002    LDIA	0x2
  0150    0084    LD	0x4,A
  0151    24A9    CALL	0x4A9
  0152    00D0    LD	0x50,A
491:              		}
492:              		if(motorPwmFlag == 0)
  0153    0830    LD	A,0x30
  0154    1D03    SNZB	0x3,2
  0155    2958    JP	0x158
493:              		{
494:              			pwmInit();
  0156    24BB    CALL	0x4BB
495:              			PWMD23H = 0X00;
496:              			PWMD2L = 40;
497:              			curDuty = 40;
  0157    21D6    CALL	0x1D6
498:              		}
499:              		PWMD2L = curDuty;
  0158    082B    LD	A,0x2B
  0159    1683    SETB	0x3,5
  015A    009B    LD	0x1B,A
500:              		maxDuty = 70;
  015B    3046    LDIA	0x46
  015C    1283    CLRB	0x3,5
  015D    00AA    LD	0x2A,A
501:              		if(out_ad > 200)
  015E    3000    LDIA	0x0
  015F    0221    SUBA	0x21
  0160    30C9    LDIA	0xC9
  0161    1903    SZB	0x3,2
  0162    0220    SUBA	0x20
  0163    1803    SZB	0x3,0
  0164    298E    JP	0x18E
502:              		{
503:              			if(++overTime > 10)
504:              			{
505:              				overTime = 0;
  0193    01AC    CLR	0x2C
506:              				workStep = 0;
  0194    01B6    CLR	0x36
507:              				startLockFlag = 1;
  0195    01CF    CLR	0x4F
  0196    0ACF    INCR	0x4F
508:              			}
509:              		}
510:              		else
511:              		{
512:              			overTime = 0;
  0165    01AC    CLR	0x2C
  0166    2997    JP	0x197
513:              		}
514:              	}
515:              	else if(workStep == 2)
  0167    3002    LDIA	0x2
  0168    0636    XORA	0x36
  0169    1D03    SNZB	0x3,2
  016A    2997    JP	0x197
516:              	{
517:              		if(chrgFlag == 0)
  016B    087A    LD	A,0x7A
  016C    1D03    SNZB	0x3,2
  016D    2976    JP	0x176
518:              		{
519:              			shiweiNum = numArray[10];
  016E    300B    LDIA	0xB
  016F    0084    LD	0x4,A
  0170    24A9    CALL	0x4A9
  0171    00D1    LD	0x51,A
520:              			geweiNum = numArray[2];
  0172    3003    LDIA	0x3
  0173    0084    LD	0x4,A
  0174    24A9    CALL	0x4A9
  0175    00D0    LD	0x50,A
521:              		}
522:              		if(motorPwmFlag == 0)
  0176    0830    LD	A,0x30
  0177    1D03    SNZB	0x3,2
  0178    297B    JP	0x17B
523:              		{
524:              			pwmInit();
  0179    24BB    CALL	0x4BB
525:              			PWMD23H = 0X00;
526:              			PWMD2L = 40;
527:              			curDuty = 40;
  017A    21D6    CALL	0x1D6
528:              		}
529:              		if(curDuty >= 99)
  017B    3063    LDIA	0x63
  017C    022B    SUBA	0x2B
  017D    1C03    SNZB	0x3,0
  017E    2981    JP	0x181
530:              		{
531:              			PWMD2L = 102;
  017F    3066    LDIA	0x66
  0180    2982    JP	0x182
532:              		}
533:              		else
534:              		{
535:              			PWMD2L = curDuty;
  0181    082B    LD	A,0x2B
  0182    1683    SETB	0x3,5
  0183    009B    LD	0x1B,A
536:              		}
537:              		maxDuty = 85;
  0184    3055    LDIA	0x55
  0185    1283    CLRB	0x3,5
  0186    00AA    LD	0x2A,A
538:              		if(out_ad > 220)
  0187    3000    LDIA	0x0
  0188    0221    SUBA	0x21
  0189    30DD    LDIA	0xDD
  018A    1903    SZB	0x3,2
  018B    0220    SUBA	0x20
  018C    1C03    SNZB	0x3,0
  018D    2965    JP	0x165
539:              		{
540:              			if(++overTime > 10)
  018E    300B    LDIA	0xB
  018F    0AAC    INCR	0x2C
  0190    022C    SUBA	0x2C
  0191    1C03    SNZB	0x3,0
  0192    2997    JP	0x197
541:              			{
542:              				overTime = 0;
543:              				workStep = 0;
544:              				startLockFlag = 1;
545:              			}
546:              		}
547:              		else
548:              		{	
549:              			overTime = 0;
550:              		}
551:              	}
552:              	if(chrgFlag || showBatTime > 0)
  0197    087A    LD	A,0x7A
  0198    1903    SZB	0x3,2
  0199    0834    LD	A,0x34
  019A    1903    SZB	0x3,2
  019B    0008    RET
553:              	{
554:              		if(showBatStep >=99)
  019C    3063    LDIA	0x63
  019D    0279    SUBA	0x79
  019E    1C03    SNZB	0x3,0
  019F    29A9    JP	0x1A9
555:              		{
556:              			shiweiNum = numArray[9];
  01A0    300A    LDIA	0xA
  01A1    0084    LD	0x4,A
  01A2    24A9    CALL	0x4A9
  01A3    00D1    LD	0x51,A
557:              			geweiNum = numArray[9];
  01A4    300A    LDIA	0xA
  01A5    0084    LD	0x4,A
  01A6    24A9    CALL	0x4A9
  01A7    00D0    LD	0x50,A
558:              		}
  01A8    0008    RET
559:              		else if(showBatStep > 9)
560:              		{
561:              			baiweiNum = 0;
  01A9    300A    LDIA	0xA
  01AA    0279    SUBA	0x79
  01AB    1C03    SNZB	0x3,0
  01AC    29CC    JP	0x1CC
562:              			shiweiNum = numArray[showBatStep/10];
  01AD    300A    LDIA	0xA
  01AE    00F3    LD	0x73,A
  01AF    0879    LD	A,0x79
  01B0    2448    CALL	0x448
  01B1    3E01    ADDIA	0x1
  01B2    0084    LD	0x4,A
  01B3    24A9    CALL	0x4A9
  01B4    00D1    LD	0x51,A
563:              			if(chrgFlag && count1s < 50)
  01B5    087A    LD	A,0x7A
  01B6    1903    SZB	0x3,2
  01B7    29C3    JP	0x1C3
  01B8    3032    LDIA	0x32
  01B9    023B    SUBA	0x3B
  01BA    1C03    SNZB	0x3,0
  01BB    29C1    JP	0x1C1
  01BC    29C3    JP	0x1C3
  01BD    3032    LDIA	0x32
  01BE    023B    SUBA	0x3B
  01BF    1803    SZB	0x3,0
  01C0    29D0    JP	0x1D0
564:              			{
565:              				geweiNum = 0;
  01C1    01D0    CLR	0x50
566:              			}
  01C2    0008    RET
567:              			else
568:              			{
569:              				geweiNum = numArray[showBatStep%10];
  01C3    300A    LDIA	0xA
  01C4    00F3    LD	0x73,A
  01C5    0879    LD	A,0x79
  01C6    2410    CALL	0x410
  01C7    3E01    ADDIA	0x1
  01C8    0084    LD	0x4,A
  01C9    24A9    CALL	0x4A9
  01CA    00D0    LD	0x50,A
  01CB    0008    RET
570:              			}
571:              		}
572:              		else
573:              		{
574:              			baiweiNum = 0;
575:              			shiweiNum = 0;
  01CC    01D1    CLR	0x51
576:              			if(chrgFlag && count1s < 50)
  01CD    087A    LD	A,0x7A
  01CE    1D03    SNZB	0x3,2
  01CF    29BD    JP	0x1BD
577:              			{
578:              				geweiNum = 0;
579:              			}
580:              			else
581:              			{
582:              				geweiNum = numArray[showBatStep];
  01D0    0879    LD	A,0x79
  01D1    3E01    ADDIA	0x1
  01D2    0084    LD	0x4,A
  01D3    24A9    CALL	0x4A9
  01D4    00D0    LD	0x50,A
  01D5    0008    RET
583:              			}
584:              		}
585:              	
586:              	}
587:              	
588:              }
589:              
590:              void setBatStep()
591:              {
592:              	if(lowBatFlag == 1 && lowShanTime == 0 && workStep > 0)
  01DD    1283    CLRB	0x3,5
  01DE    0B32    SZDECA	0x32
  01DF    29EE    JP	0x1EE
  01E0    0824    LD	A,0x24
  01E1    0425    ORA	0x25
  01E2    1D03    SNZB	0x3,2
  01E3    29EE    JP	0x1EE
  01E4    0836    LD	A,0x36
  01E5    1903    SZB	0x3,2
  01E6    29EE    JP	0x1EE
  01E7    302C    LDIA	0x2C
593:              	{
594:              		showBatStep = 0;
  01E8    01F9    CLR	0x79
595:              		curBatStep = 0;
  01E9    01AF    CLR	0x2F
596:              		lowShanTime = 300;
  01EA    00A4    LD	0x24,A
  01EB    3001    LDIA	0x1
  01EC    00A5    LD	0x25,A
597:              	}
  01ED    0008    RET
598:              	else if(power_ad < 1830)
  01EE    3007    LDIA	0x7
  01EF    0278    SUBA	0x78
  01F0    3026    LDIA	0x26
  01F1    1903    SZB	0x3,2
  01F2    0277    SUBA	0x77
  01F3    1803    SZB	0x3,0
  01F4    2A08    JP	0x208
599:              	{
600:              		if(count1s == 0)
  01F5    083B    LD	A,0x3B
  01F6    1D03    SNZB	0x3,2
  01F7    2A05    JP	0x205
601:              		{
602:              			if(showBatStep > 1)
  01F8    3002    LDIA	0x2
  01F9    0279    SUBA	0x79
  01FA    1C03    SNZB	0x3,0
  01FB    2A01    JP	0x201
603:              			{
604:              				if(chrgFlag == 0)
  01FC    087A    LD	A,0x7A
  01FD    1D03    SNZB	0x3,2
  01FE    2A03    JP	0x203
605:              					showBatStep--;
  01FF    03F9    DECR	0x79
  0200    2A03    JP	0x203
606:              			}
607:              			else
608:              			{
609:              				showBatStep = 1;
  0201    01F9    CLR	0x79
  0202    0AF9    INCR	0x79
610:              			}
611:              			curBatStep = 1;
  0203    01AF    CLR	0x2F
  0204    0AAF    INCR	0x2F
612:              		}
613:              		curBatStep = 1;
  0205    01AF    CLR	0x2F
  0206    0AAF    INCR	0x2F
614:              	}
  0207    0008    RET
615:              	else
616:              	{
617:              		if(power_ad < 1990)
  0208    3007    LDIA	0x7
  0209    0278    SUBA	0x78
  020A    30C6    LDIA	0xC6
  020B    1903    SZB	0x3,2
  020C    0277    SUBA	0x77
  020D    1803    SZB	0x3,0
  020E    2A20    JP	0x220
618:              		{
619:              			curBatStep = (power_ad - 1830)/16;
  020F    0877    LD	A,0x77
  0210    3EDA    ADDIA	0xDA
  0211    00C1    LD	0x41,A
  0212    0878    LD	A,0x78
  0213    1803    SZB	0x3,0
  0214    3E01    ADDIA	0x1
  0215    3EF8    ADDIA	0xF8
  0216    00C2    LD	0x42,A
  0217    3004    LDIA	0x4
  0218    1003    CLRB	0x3,0
  0219    0CC2    RRCR	0x42
  021A    0CC1    RRCR	0x41
  021B    3EFF    ADDIA	0xFF
  021C    1D03    SNZB	0x3,2
  021D    2A18    JP	0x218
  021E    0841    LD	A,0x41
  021F    2A44    JP	0x244
620:              		}
621:              		else if(power_ad < 2090)
  0220    3008    LDIA	0x8
  0221    0278    SUBA	0x78
  0222    302A    LDIA	0x2A
  0223    1903    SZB	0x3,2
  0224    0277    SUBA	0x77
  0225    1803    SZB	0x3,0
  0226    2A36    JP	0x236
622:              		{
623:              			curBatStep = 10 + ((power_ad - 1990)/5);
  0227    3005    LDIA	0x5
  0228    00F3    LD	0x73,A
  0229    01F4    CLR	0x74
  022A    0877    LD	A,0x77
  022B    3E3A    ADDIA	0x3A
  022C    00F5    LD	0x75,A
  022D    0878    LD	A,0x78
  022E    1803    SZB	0x3,0
  022F    3E01    ADDIA	0x1
  0230    3EF8    ADDIA	0xF8
  0231    00F6    LD	0x76,A
  0232    23C9    CALL	0x3C9
  0233    0873    LD	A,0x73
  0234    3E0A    ADDIA	0xA
  0235    2A44    JP	0x244
624:              		}
625:              		else
626:              		{
627:              			curBatStep = 30 + ((power_ad - 2090)/3);
  0236    3003    LDIA	0x3
  0237    00F3    LD	0x73,A
  0238    01F4    CLR	0x74
  0239    0877    LD	A,0x77
  023A    3ED6    ADDIA	0xD6
  023B    00F5    LD	0x75,A
  023C    0878    LD	A,0x78
  023D    1803    SZB	0x3,0
  023E    3E01    ADDIA	0x1
  023F    3EF7    ADDIA	0xF7
  0240    00F6    LD	0x76,A
  0241    23C9    CALL	0x3C9
  0242    0873    LD	A,0x73
  0243    3E1E    ADDIA	0x1E
  0244    00AF    LD	0x2F,A
628:              		}
629:              		if(curBatStep > 99)
  0245    3064    LDIA	0x64
  0246    022F    SUBA	0x2F
  0247    1C03    SNZB	0x3,0
  0248    2A4B    JP	0x24B
630:              		{
631:              			curBatStep = 99;
  0249    3063    LDIA	0x63
  024A    00AF    LD	0x2F,A
632:              		}
633:              
634:              		if(chrgFlag)
  024B    087A    LD	A,0x7A
  024C    1903    SZB	0x3,2
  024D    2A6C    JP	0x26C
635:              		{
636:              			if(chrgFullFlag)
  024E    0839    LD	A,0x39
  024F    1903    SZB	0x3,2
  0250    2A65    JP	0x265
637:              			{
638:              				if(++count30s >= 1000 && showBatStep < 99)	//20s
  0251    2281    CALL	0x281
  0252    2A59    JP	0x259
639:              				{	
640:              					count30s = 0;
  0261    01A2    CLR	0x22
  0262    01A3    CLR	0x23
641:              					showBatStep++;
  0263    0AF9    INCR	0x79
  0264    0008    RET
642:              				}
643:              			}
644:              			else if(curBatStep > showBatStep)
  0265    082F    LD	A,0x2F
  0266    0279    SUBA	0x79
  0267    1C03    SNZB	0x3,0
  0268    2A53    JP	0x253
645:              			{
646:              				if(++count30s >= 3000 && showBatStep < 99)	//20s
  0253    0AA2    INCR	0x22
  0254    1903    SZB	0x3,2
  0255    0AA3    INCR	0x23
  0256    300B    LDIA	0xB
  0257    0223    SUBA	0x23
  0258    30B8    LDIA	0xB8
  0259    1903    SZB	0x3,2
  025A    0222    SUBA	0x22
  025B    1C03    SNZB	0x3,0
  025C    0008    RET
  025D    3063    LDIA	0x63
  025E    0279    SUBA	0x79
  025F    1803    SZB	0x3,0
  0260    0008    RET
647:              				{	
648:              					count30s = 0;
649:              					showBatStep++;
650:              				}
651:              				
652:              			}
653:              			else
654:              			{
655:              				count30s = 0;
  0269    01A2    CLR	0x22
  026A    01A3    CLR	0x23
  026B    0008    RET
656:              			}
657:              		}
658:              		else
659:              		{
660:              			if(curBatStep < showBatStep && showBatStep > 1)
  026C    0879    LD	A,0x79
  026D    022F    SUBA	0x2F
  026E    1803    SZB	0x3,0
  026F    2A69    JP	0x269
  0270    3002    LDIA	0x2
  0271    0279    SUBA	0x79
  0272    1C03    SNZB	0x3,0
  0273    2A69    JP	0x269
661:              			{
662:              				if(++count30s >= 1000 && showBatStep > 1)	//10s
  0274    2281    CALL	0x281
  0275    1903    SZB	0x3,2
  0276    0222    SUBA	0x22
  0277    1C03    SNZB	0x3,0
  0278    0008    RET
  0279    3002    LDIA	0x2
  027A    0279    SUBA	0x79
  027B    1C03    SNZB	0x3,0
  027C    0008    RET
663:              				{	
664:              					count30s = 0;
  027D    01A2    CLR	0x22
  027E    01A3    CLR	0x23
665:              					showBatStep--;
  027F    03F9    DECR	0x79
  0280    0008    RET
666:              				}
667:              			}
668:              			else
669:              			{
670:              				count30s = 0;
671:              			}
672:              		}
673:              		
674:              	}
675:              }
676:              
677:              
678:              void checkBatAD()
679:              {
680:              	test_adc = ADC_Sample(12, 5);		//测试内部基准1.2V相对电源的AD值
  0493    3005    LDIA	0x5
  0494    00F3    LD	0x73,A
  0495    300C    LDIA	0xC
  0496    2018    CALL	0x18
  0497    00BD    LD	0x3D,A
681:              	if (0xA5 == test_adc)
  0498    30A5    LDIA	0xA5
  0499    063D    XORA	0x3D
  049A    1D03    SNZB	0x3,2
  049B    2CA1    JP	0x4A1
682:              	{
683:              		volatile unsigned long power_temp;
684:              		
685:              		power_ad = adresult;		//通过内部基准电压推出芯片VDD电压
  049C    0829    LD	A,0x29
  049D    00F8    LD	0x78,A
  049E    0828    LD	A,0x28
  049F    00F7    LD	0x77,A
686:              	}
  04A0    0008    RET
687:              	else
688:              	{
689:              		ADCON0 = 0;						//如果转换没有完成，需初始化ADCON0,1
  04A1    1683    SETB	0x3,5
  04A2    0195    CLR	0x15
690:              		ADCON1 = 0;				
  04A3    0196    CLR	0x16
691:              		__delay_us(100);				//延时100us(编译器内置函数)
  04A4    3085    LDIA	0x85
  04A5    00F4    LD	0x74,A
  04A6    0BF4    SZDECR	0x74
  04A7    2CA6    JP	0x4A6
  04A8    0008    RET
692:              	}
693:              	
694:              }
695:              
696:              void checkOutAD()
697:              {
698:              	test_adc = ADC_Sample(13, 5);		//测试内部基准1.2V相对电源的AD值
  047D    3005    LDIA	0x5
  047E    00F3    LD	0x73,A
  047F    300D    LDIA	0xD
  0480    2018    CALL	0x18
  0481    00BD    LD	0x3D,A
699:              	if (0xA5 == test_adc)
  0482    30A5    LDIA	0xA5
  0483    063D    XORA	0x3D
  0484    1D03    SNZB	0x3,2
  0485    2C8B    JP	0x48B
700:              	{
701:              		volatile unsigned long power_temp;
702:              		
703:              		out_ad = adresult;		//通过内部基准电压推出芯片VDD电压
  0486    0829    LD	A,0x29
  0487    00A1    LD	0x21,A
  0488    0828    LD	A,0x28
  0489    00A0    LD	0x20,A
704:              	}
  048A    0008    RET
705:              	else
706:              	{
707:              		ADCON0 = 0;						//如果转换没有完成，需初始化ADCON0,1
  048B    1683    SETB	0x3,5
  048C    0195    CLR	0x15
708:              		ADCON1 = 0;				
  048D    0196    CLR	0x16
709:              		__delay_us(100);				//延时100us(编译器内置函数)
  048E    3085    LDIA	0x85
  048F    00F4    LD	0x74,A
  0490    0BF4    SZDECR	0x74
  0491    2C90    JP	0x490
  0492    0008    RET
710:              	}
711:              	
712:              }
713:              
714:              
715:              
716:              /**********************************************************
717:              函数名称：Init_System
718:              函数功能：系统初始化
719:              入口参数：无
720:              出口参数：无
721:              备    注：
722:              **********************************************************/
723:              void Init_System() 
  0463    0000    NOP
  0464    0064    CLRWDT
724:              {
725:              	asm("nop");
726:              	asm("clrwdt");
727:              	OPTION_REG = 0;					//预分频给TMR0 ，Timer0使用内部时钟Focs/4，预分频比为1:2
  0465    1283    CLRB	0x3,5
  0466    0181    CLR	0x1
  0467    0064    CLRWDT
728:              	asm("clrwdt");
729:              	OSCCON = 0X72;					//内部振荡器8M
  0468    3072    LDIA	0x72
  0469    1283    CLRB	0x3,5
  046A    0094    LD	0x14,A
730:              
731:              	WPUA = 0x00;				//配置上拉，1为使能上拉
  046B    1683    SETB	0x3,5
  046C    0188    CLR	0x8
732:              	WPDA = 0x00;					//RA1开下拉
  046D    0187    CLR	0x7
733:              	WPUB = 0x04;
  046E    3004    LDIA	0x4
  046F    1283    CLRB	0x3,5
  0470    0088    LD	0x8,A
734:              
735:              	TRISA = 0x01;				//配置IO状态，0为输出，1为输入
  0471    3001    LDIA	0x1
  0472    1683    SETB	0x3,5
736:              	TRISB = 0x37;
737:              
738:              	PORTA = 0X00;
739:              	PORTB = 0X00;
  0473    234E    CALL	0x34E
740:              
741:              //---------------------------------------
742:              //125us中断初始化
743:              	PR2 = 249;					//设定Timer初始值，定时周期是250*2/8M=62.5uS
  0474    30F9    LDIA	0xF9
  0475    0091    LD	0x11,A
744:              	TMR2IF = 0;
  0476    108D    CLRB	0xD,1
745:              	TMR2IE = 1;					//使能Timer2溢出中断
  0477    148E    SETB	0xE,1
746:              
747:              	T2CON = 0B00000100;			//开启Timer2,设置TMR2的分频比为1:1
  0478    3004    LDIA	0x4
  0479    0093    LD	0x13,A
748:              	INTCON = 0XC0;				//开启总中断
  047A    30C0    LDIA	0xC0
  047B    008B    LD	0xB,A
  047C    0008    RET
749:              }
750:              
751:              /***********************************************************
752:              中断服务函数
753:              函数名称：AD_Init()
754:              函数功能：AD初始化处理函数
755:              入口参数：
756:              出口参数：
757:              备    注：第一次打开AD允许位ADON，需延时20uS以上才能进入AD采样
758:              			如后继程序不关闭ADON，则不需要延时
759:              ***********************************************************/
760:              void AD_Init() 
761:              {
762:              	/*********** ADCON0 ****************************
763:              		Bit7~Bit6  ADCS<1:0>:  AD转换时钟选择位。
764:              			00=  F HSI /16
765:              			01=  F HSI /32
766:              			10=  F HSI /64
767:              			11=  F HSI /128
768:              		Bit5~Bit2  CHS<3:0>:  模拟通道选择位。与ADCON1寄存器CHS4组合CHS<3:0>
769:              			CHS<4:0>: 
770:              			00000=  AN0
771:              			00001=  AN1
772:              			00010=  AN2
773:              			00011=  AN3
774:              			00100=  AN4
775:              			00101=  AN5
776:              			00110=  保留
777:              			00111=  保留
778:              			01000=  AN8
779:              			… 
780:              			01101=  AN13
781:              			01110=  AN14
782:              			01111=  AN15
783:              			11111=  1.2V（固定参考电压）
784:              			其他=  保留
785:              		Bit1  GO/DONE: AD转换状态位。
786:              			1=  AD转换正在进行。将该位置1启动AD转换。当AD转换完成以后，该位由硬件自动清零。
787:              				当GO/DONE位从1变0或ADIF从0变1时，需至少等待两个TAD时间，才能再次启动AD转换。
788:              			0=  AD转换完成/或不在进行中。
789:              		Bit0  ADON:  ADC使能位。
790:              			1=  使能ADC；
791:              			0=  禁止ADC，不消耗工作电流。
792:              	*********************************************/
793:              	ADCON0 = 0X41;		//ADON开启，AD采样时间选为FSYS/16
  04E1    3041    LDIA	0x41
  04E2    1683    SETB	0x3,5
  04E3    0095    LD	0x15,A
794:              	
795:              	/*********** ADCON1 ****************************
796:              		Bit7  ADFM:  AD转换结果格式选择位；
797:              			1=  右对齐；
798:              			0=  左对齐。
799:              		Bit6  CHS4:  通道选择位
800:              		Bit5~Bit3  未用 
801:              		Bit2  LDO_EN:  内部参考电压使能位。
802:              			1=  使能ADC内部LDO参考电压；
803:              				当选择内部LDO作参考电压时，ADC最大有效精度为8位。
804:              			0=  VDD作为ADC参考电压。
805:              		Bit1~Bit0  LDO_SEL<1:0>:  参考电压选择位
806:              			0X=  2.0V
807:              			10=  2.4V
808:              			11=  3.0V
809:              	*********************************************/
810:              	ADCON1 = 0;
  04E4    0196    CLR	0x16
811:              	ANSEL0 = 0X00;
  04E5    0193    CLR	0x13
812:              	ANSEL1 = 0x30;	
  04E6    3030    LDIA	0x30
  04E7    0094    LD	0x14,A
  04E8    0008    RET
813:              }
814:              
815:              
816:              void pwmInit()
817:              {
818:              		PWMCON1 = 0B00000000;	//PWM选择D组，死区2禁止，死区1使能，死区时钟源为Fosc/4
  04BB    0196    CLR	0x16
819:              		PWMTH = 0X00;			//周期选择为0FF，则周期为（255+1）*1/8M，周期的时钟分频在PWMCON0选择
  04BC    0198    CLR	0x18
820:              		PWMTL = 100;			//PWM 周期=[PWMT+1]*Tosc*(CLKDIV 分频值)
  04BD    3064    LDIA	0x64
  04BE    0097    LD	0x17,A
821:              		
822:              		
823:              		PWMD23H = 0;			//配置PWM1,PWM2的占空比，该值不能超过周期，否者为100%输出
  04BF    1683    SETB	0x3,5
  04C0    019E    CLR	0x1E
824:              		PWMD2L = 60;			//互补模式，PWM1的占空比与PWM0互补，和设置值无关
  04C1    303C    LDIA	0x3C
  04C2    009B    LD	0x1B,A
825:              		PWM23DT = 0X00;			//死区设为2uS，计算为（3+1）*1/8M*4
  04C3    019D    CLR	0x1D
826:              
827:              		PWMCON0 = 0X64;			//打开PWM3 分频比为8
  04C4    3064    LDIA	0x64
  04C5    1283    CLRB	0x3,5
  04C6    0095    LD	0x15,A
828:              		PWMCON2 =0X00;			//PWM4输出反向
  04C7    019D    CLR	0x1D
829:              		motorPwmFlag = 1;
  04C8    01B0    CLR	0x30
  04C9    0AB0    INCR	0x30
  04CA    0008    RET
830:              }
831:              
832:              void pwmStop()
833:              {
834:              	PWMCON0 &= 0XFB;
  04E9    1115    CLRB	0x15,2
835:              	RB3 = 0;
  04EA    1186    CLRB	0x6,3
836:              	motorPwmFlag = 0;
  04EB    01B0    CLR	0x30
  04EC    0008    RET
837:              }
838:              
839:              
840:              /***********************************************
841:              函数名称：Sleep_Mode
842:              函数功能：进入休眠模式
843:              入口参数：无
844:              出口参数：无
845:              备注：
846:              ************************************************/
847:              void Sleep_Mode()
848:              {
849:              	INTCON = 0;		
  0315    018B    CLR	0xB
850:              	
851:              	OPTION_REG = 0;
  0316    0181    CLR	0x1
852:              
853:              	WPUA  = 0x00;			//RA1 开上拉电阻
  0317    1683    SETB	0x3,5
  0318    0188    CLR	0x8
854:              	TRISA = 0x01;				//配置IO状态，0为输出，1为输入
  0319    3001    LDIA	0x1
855:              	TRISB = 0x37;
856:              
857:              	PORTA = 0X00;
858:              	PORTB = 0X00;
  031A    234E    CALL	0x34E
859:              	WPUB  = 0x04;			//RB2 开上拉电阻
  031B    3004    LDIA	0x4
  031C    0088    LD	0x8,A
860:                 			
861:                 	ADCON0 = 0;					//关闭所有模块
  031D    1683    SETB	0x3,5
  031E    0195    CLR	0x15
862:              	ADCON1 = 0;
  031F    0196    CLR	0x16
863:              	
864:              	PWMCON0 = 0;
  0320    1283    CLRB	0x3,5
  0321    0195    CLR	0x15
865:              		
866:              	OSCCON = 0X70;				//配置振荡为8M,关闭WDT，需注意芯片工程选项里WDT必须选为DISABLE,否则无法软件关掉WDT
  0322    3070    LDIA	0x70
  0323    0094    LD	0x14,A
867:              	
868:              	IOCA = 0B00000000;			//允许RA1的IO电平变化中断
  0324    1683    SETB	0x3,5
  0325    0189    CLR	0x9
869:              	IOCB = 0x07;			//允许RB1 RB2的IO口电平变化中断
  0326    3007    LDIA	0x7
  0327    1283    CLRB	0x3,5
  0328    0089    LD	0x9,A
870:              	
871:              	RAIE = 1;					//允许PORTA的IO电平变化中断
  0329    158E    SETB	0xE,3
872:              	PEIE = 1;					//要用RORTA中断唤醒，则PEIE必须设为1
  032A    170B    SETB	0xB,6
873:              	RBIE = 1;					//允许PORTB电平变化中断
  032B    158B    SETB	0xB,3
874:              	GIE = 0;					//唤醒后执行SLEEP后程序;
  032C    138B    CLRB	0xB,7
875:              	
876:              	PIE1 &= 0X08;				//关闭不需要的中断
  032D    3008    LDIA	0x8
  032E    058E    ANDR	0xE
877:              	PIR1 = 0;					//必须清不需要的中断标志位
  032F    018D    CLR	0xD
878:              	INTCON &= 0XC8;				//必须清不需要的中断标志位
  0330    30C8    LDIA	0xC8
  0331    058B    ANDR	0xB
879:              
880:              	PORTA;						//读PORTA值并锁存,用电平变化中断必须执行这一步
  0332    1683    SETB	0x3,5
  0333    0806    LD	A,0x6
881:              	RAIF = 0;					//清PORTA中断标志位
  0334    1283    CLRB	0x3,5
  0335    118D    CLRB	0xD,3
882:              	PORTB;						//读PORTB值并锁存	
  0336    0806    LD	A,0x6
883:              	RBIF = 0;					//清PORTB中断标志位		
  0337    100B    CLRB	0xB,0
  0338    0064    CLRWDT
  0339    0063    STOP
  033A    0000    NOP
  033B    0064    CLRWDT
  033C    0000    NOP
  033D    0000    NOP
  033E    0000    NOP
  033F    0000    NOP
  0340    0000    NOP
884:              	asm("clrwdt");
885:              
886:              	asm("sleep");				//进入休眠模式
887:              	
888:              	asm("nop");
889:              	asm("clrwdt");
890:              	asm("nop");
891:              	asm("nop");
892:              	asm("nop");
893:              	asm("nop");
894:              	asm("nop");
895:              	if(RAIF)  RAIF = 0;			//清中断标志
  0341    1283    CLRB	0x3,5
  0342    198D    SZB	0xD,3
  0343    118D    CLRB	0xD,3
896:              	if(RBIF)  RBIF = 0;			//清中断标志
  0344    180B    SZB	0xB,0
  0345    100B    CLRB	0xB,0
897:              	if(TMR2IF) TMR2IF = 0;
  0346    188D    SZB	0xD,1
  0347    108D    CLRB	0xD,1
898:              	IOCA = 0B00000000;			//允许RA1的IO电平变化中断
  0348    1683    SETB	0x3,5
  0349    0189    CLR	0x9
899:              	IOCB = 0B00000000;			//允许RB3的IO口电平变化中断
  034A    1283    CLRB	0x3,5
  034B    0189    CLR	0x9
900:              	Init_System();
  034C    2463    CALL	0x463
901:              	AD_Init();
  034D    2CE1    JP	0x4E1
902:              }
903:              
904:              
905:              
906:              /**********************************************************
907:              函数名称：AD_Sample
908:              函数功能：AD检测
909:              入口参数：adch - 检测通道
910:              出口参数：无
911:              备    注：采样通道需自行设置为输入口
912:              	      采样10次,取中间八次的平均值为采样结果存于adresult中
913:              
914:              	      adch 为输入AD通道 0-15，31
915:                           31  检测内部1.2V
916:              	
917:               		  adldo =5,开启内部LDO 2V 作为ADC 参考
918:               		  adldo =6,开启内部LDO 2.4V 作为ADC 参考
919:              		  adldo =7,开启内部LDO 3V 作为ADC 参考
920:               		  adldo =0,VDD 作为ADC 参考
921:               		  AD转换结果左对齐
922:               		  ADC参考电压从VDD切换到LDO时需要延时100us以上，才能进行AD转换
923:              **********************************************************/
924:              unsigned char ADC_Sample(unsigned char adch, unsigned char adldo) 
  0018    00C3    LD	0x43,A
925:              {
926:              	volatile unsigned long adsum = 0;
927:              	volatile unsigned int admin = 0, admax = 0;
  0019    20F2    CALL	0xF2
928:              	volatile unsigned int ad_temp = 0;
  001A    01CD    CLR	0x4D
  001B    01CE    CLR	0x4E
929:              
930:              	if ((!LDO_EN) && (adldo & 0x04) ) 
  001C    1683    SETB	0x3,5
  001D    1D16    SNZB	0x16,2
  001E    1D73    SNZB	0x73,2
  001F    2829    JP	0x29
931:              	{
932:              								//如果AD参考从VDD换到内部LDO，需要延时100US以上
933:              		ADCON1 = adldo;			//左对齐,AD值取12位
  0020    0873    LD	A,0x73
  0021    0096    LD	0x16,A
934:              		__delay_us(100);		//IDE内置延时函数，延时100us
  0022    3084    LDIA	0x84
  0023    1283    CLRB	0x3,5
  0024    00BE    LD	0x3E,A
  0025    0BBE    SZDECR	0x3E
  0026    2825    JP	0x25
  0027    2828    JP	0x28
935:              	} 
  0028    282B    JP	0x2B
936:              	else
937:              		ADCON1 = adldo;			//如果ADCON1.7(ADFM)=1为右对齐，,AD值取10位
  0029    0873    LD	A,0x73
  002A    0096    LD	0x16,A
938:              
939:              	if(adch & 0x10) 
  002B    1283    CLRB	0x3,5
  002C    1E43    SNZB	0x43,4
  002D    2833    JP	0x33
940:              	{
941:              		CHS4 = 1;
  002E    1683    SETB	0x3,5
  002F    1716    SETB	0x16,6
942:              		adch &= 0x0f;
  0030    300F    LDIA	0xF
  0031    1283    CLRB	0x3,5
  0032    05C3    ANDR	0x43
943:              	}
944:              	unsigned char i = 0;
945:              	for (i = 0; i < 10; i++) 
  0033    01C4    CLR	0x44
946:              	{
947:              		ADCON0 = (unsigned char)(0X41 | (adch << 2));	//16分频，如果主频为16M，则必须选16分频或以上
  0034    0843    LD	A,0x43
  0035    00BE    LD	0x3E,A
  0036    3001    LDIA	0x1
  0037    1003    CLRB	0x3,0
  0038    0DBE    RLCR	0x3E
  0039    3EFF    ADDIA	0xFF
  003A    1003    CLRB	0x3,0
  003B    1D03    SNZB	0x3,2
  003C    2838    JP	0x38
  003D    0D3E    RLCA	0x3E
  003E    3841    ORIA	0x41
  003F    1683    SETB	0x3,5
  0040    0095    LD	0x15,A
  0041    0000    NOP
  0042    0000    NOP
  0043    0000    NOP
  0044    0000    NOP
948:              		asm("nop");
949:              		asm("nop");
950:              		asm("nop");
951:              		asm("nop");				//选择通道后需延时1uS以上
952:              		GODONE = 1;				//开始转换
  0045    1683    SETB	0x3,5
  0046    1495    SETB	0x15,1
953:              
954:              		unsigned char j = 0;
  0047    1283    CLRB	0x3,5
  0048    01C2    CLR	0x42
955:              		while (GODONE) 
  0049    1683    SETB	0x3,5
  004A    1C95    SNZB	0x15,1
  004B    2854    JP	0x54
956:              		{
957:              			__delay_us(2);		//延时2us(编译器内置函数)
  004C    284D    JP	0x4D
  004D    284E    JP	0x4E
  004E    284F    JP	0x4F
  004F    2850    JP	0x50
958:              
959:              			if (0 == (--j))		//延时0.5ms仍没有AD转换结束，跳出程序
  0050    1283    CLRB	0x3,5
  0051    0BC2    SZDECR	0x42
  0052    2849    JP	0x49
960:              			return 0;
  0053    3400    RET	0x0
961:              		}
962:              
963:              		ad_temp = (unsigned int)((ADRESH << 4) + (ADRESL >> 4));	//计算12位AD值
  0054    0819    LD	A,0x19
  0055    1283    CLRB	0x3,5
  0056    00CD    LD	0x4D,A
  0057    01CE    CLR	0x4E
  0058    0ECD    SWAPR	0x4D
  0059    0ECE    SWAPR	0x4E
  005A    30F0    LDIA	0xF0
  005B    05CE    ANDR	0x4E
  005C    084D    LD	A,0x4D
  005D    390F    ANDIA	0xF
  005E    04CE    ORR	0x4E
  005F    30F0    LDIA	0xF0
  0060    05CD    ANDR	0x4D
  0061    1683    SETB	0x3,5
  0062    0E18    SWAPA	0x18
  0063    390F    ANDIA	0xF
  0064    1283    CLRB	0x3,5
  0065    07CD    ADDR	0x4D
  0066    1803    SZB	0x3,0
  0067    0ACE    INCR	0x4E
964:              
965:              		if (0 == admax) 
  0068    084B    LD	A,0x4B
  0069    044C    ORA	0x4C
  006A    1D03    SNZB	0x3,2
  006B    286E    JP	0x6E
966:              		{
967:              			admax = ad_temp;
  006C    20FB    CALL	0xFB
  006D    2880    JP	0x80
968:              			admin = ad_temp;
969:              		} 
970:              		else if (ad_temp > admax)
  006E    084E    LD	A,0x4E
  006F    024C    SUBA	0x4C
  0070    1D03    SNZB	0x3,2
  0071    2874    JP	0x74
  0072    084D    LD	A,0x4D
  0073    024B    SUBA	0x4B
  0074    1803    SZB	0x3,0
  0075    2878    JP	0x78
971:              			admax = ad_temp;				//AD采样最大值
  0076    20FB    CALL	0xFB
  0077    2884    JP	0x84
972:              		else if (ad_temp < admin)
  0078    084A    LD	A,0x4A
  0079    024E    SUBA	0x4E
  007A    1D03    SNZB	0x3,2
  007B    287E    JP	0x7E
  007C    0849    LD	A,0x49
  007D    024D    SUBA	0x4D
  007E    1803    SZB	0x3,0
  007F    2884    JP	0x84
973:              			admin = ad_temp;				//AD采样最小值
  0080    084E    LD	A,0x4E
  0081    00CA    LD	0x4A,A
  0082    084D    LD	A,0x4D
  0083    00C9    LD	0x49,A
974:              
975:              		adsum += ad_temp;
  0084    084D    LD	A,0x4D
  0085    00BE    LD	0x3E,A
  0086    084E    LD	A,0x4E
  0087    00BF    LD	0x3F,A
  0088    01C0    CLR	0x40
  0089    01C1    CLR	0x41
  008A    083E    LD	A,0x3E
  008B    07C5    ADDR	0x45
  008C    083F    LD	A,0x3F
  008D    1103    CLRB	0x3,2
  008E    1803    SZB	0x3,0
  008F    3E01    ADDIA	0x1
  0090    1D03    SNZB	0x3,2
  0091    07C6    ADDR	0x46
  0092    0840    LD	A,0x40
  0093    1103    CLRB	0x3,2
  0094    1803    SZB	0x3,0
  0095    3E01    ADDIA	0x1
  0096    1D03    SNZB	0x3,2
  0097    07C7    ADDR	0x47
  0098    0841    LD	A,0x41
  0099    1103    CLRB	0x3,2
  009A    1803    SZB	0x3,0
  009B    3E01    ADDIA	0x1
  009C    1D03    SNZB	0x3,2
  009D    07C8    ADDR	0x48
  009E    300A    LDIA	0xA
  009F    0AC4    INCR	0x44
  00A0    0244    SUBA	0x44
  00A1    1C03    SNZB	0x3,0
  00A2    2834    JP	0x34
976:              	}
977:              		adsum -= admax;
  00A3    084B    LD	A,0x4B
  00A4    00BE    LD	0x3E,A
  00A5    084C    LD	A,0x4C
  00A6    20E3    CALL	0xE3
  00A7    1C03    SNZB	0x3,0
  00A8    0F41    SZINCA	0x41
  00A9    02C8    SUBR	0x48
978:              		if (adsum >= admin)
  00AA    0849    LD	A,0x49
  00AB    00BE    LD	0x3E,A
  00AC    084A    LD	A,0x4A
  00AD    00BF    LD	0x3F,A
  00AE    01C0    CLR	0x40
  00AF    01C1    CLR	0x41
  00B0    0841    LD	A,0x41
  00B1    0248    SUBA	0x48
  00B2    1D03    SNZB	0x3,2
  00B3    28BE    JP	0xBE
  00B4    0840    LD	A,0x40
  00B5    0247    SUBA	0x47
  00B6    1D03    SNZB	0x3,2
  00B7    28BE    JP	0xBE
  00B8    083F    LD	A,0x3F
  00B9    0246    SUBA	0x46
  00BA    1D03    SNZB	0x3,2
  00BB    28BE    JP	0xBE
  00BC    083E    LD	A,0x3E
  00BD    0245    SUBA	0x45
  00BE    1C03    SNZB	0x3,0
  00BF    28C8    JP	0xC8
979:              			adsum -= admin;
  00C0    0849    LD	A,0x49
  00C1    00BE    LD	0x3E,A
  00C2    084A    LD	A,0x4A
  00C3    20E3    CALL	0xE3
  00C4    1C03    SNZB	0x3,0
  00C5    0F41    SZINCA	0x41
  00C6    02C8    SUBR	0x48
  00C7    28CC    JP	0xCC
980:              		else
981:              			adsum = 0;
  00C8    01C5    CLR	0x45
  00C9    01C6    CLR	0x46
  00CA    01C7    CLR	0x47
  00CB    01C8    CLR	0x48
982:              
983:              		adresult = adsum >> 3;		//8次平均值作为最终结果
  00CC    0845    LD	A,0x45
  00CD    00BE    LD	0x3E,A
  00CE    0846    LD	A,0x46
  00CF    00BF    LD	0x3F,A
  00D0    0847    LD	A,0x47
  00D1    00C0    LD	0x40,A
  00D2    0848    LD	A,0x48
  00D3    00C1    LD	0x41,A
  00D4    3003    LDIA	0x3
  00D5    1003    CLRB	0x3,0
  00D6    0CC1    RRCR	0x41
  00D7    0CC0    RRCR	0x40
  00D8    0CBF    RRCR	0x3F
  00D9    0CBE    RRCR	0x3E
  00DA    3EFF    ADDIA	0xFF
  00DB    1D03    SNZB	0x3,2
  00DC    28D5    JP	0xD5
  00DD    083F    LD	A,0x3F
  00DE    00A9    LD	0x29,A
  00DF    083E    LD	A,0x3E
  00E0    00A8    LD	0x28,A
984:              
985:              		adsum = 0;
986:              		admin = 0;
987:              		admax = 0;
  00E1    20F2    CALL	0xF2
988:              		return 0xA5;
  00E2    34A5    RET	0xA5
989:              		
990:              }
991:              
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\lbmod.c ----------------------------------------------------------------------
1:                // byte unsigned modulus
2:                
3:                unsigned char
4:                __lbmod(unsigned char dividend, unsigned char divisor)
  0410    00BE    LD	0x3E,A
  0411    3008    LDIA	0x8
  0412    00BF    LD	0x3F,A
  0413    01C0    CLR	0x40
  0414    083E    LD	A,0x3E
  0415    00F4    LD	0x74,A
  0416    3007    LDIA	0x7
  0417    1003    CLRB	0x3,0
  0418    0CF4    RRCR	0x74
  0419    3EFF    ADDIA	0xFF
  041A    1003    CLRB	0x3,0
  041B    1D03    SNZB	0x3,2
  041C    2C18    JP	0x418
  041D    0D40    RLCA	0x40
  041E    0474    ORA	0x74
  041F    00C0    LD	0x40,A
  0420    1003    CLRB	0x3,0
  0421    0DBE    RLCR	0x3E
  0422    0873    LD	A,0x73
  0423    0240    SUBA	0x40
  0424    1C03    SNZB	0x3,0
  0425    2C28    JP	0x428
  0426    0873    LD	A,0x73
  0427    02C0    SUBR	0x40
  0428    0BBF    SZDECR	0x3F
  0429    2C14    JP	0x414
  042A    0840    LD	A,0x40
  042B    0008    RET
5:                {
6:                	unsigned char	rem;
7:                	unsigned char	counter;
8:                
9:                	counter = 8;
10:               	rem = 0;
11:               	do {
12:               		rem = (rem << 1) | (dividend >> 7);
13:               		dividend <<= 1;
14:               		if(divisor <= rem)
15:               			rem -= divisor;
16:               	} while(--counter != 0);
17:               	return rem;
18:               }
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\lbdiv.c ----------------------------------------------------------------------
1:                // byte unsigned division
2:                
3:                unsigned char
4:                __lbdiv(unsigned char dividend, unsigned char divisor)
  0448    00F4    LD	0x74,A
  0449    01F6    CLR	0x76
  044A    0873    LD	A,0x73
  044B    1903    SZB	0x3,2
  044C    2C61    JP	0x461
  044D    01F5    CLR	0x75
  044E    0AF5    INCR	0x75
  044F    1BF3    SZB	0x73,7
  0450    2C54    JP	0x454
  0451    1003    CLRB	0x3,0
  0452    0DF3    RLCR	0x73
  0453    2C4E    JP	0x44E
  0454    1003    CLRB	0x3,0
  0455    0DF6    RLCR	0x76
  0456    0873    LD	A,0x73
  0457    0274    SUBA	0x74
  0458    1C03    SNZB	0x3,0
  0459    2C5E    JP	0x45E
  045A    0873    LD	A,0x73
  045B    02F4    SUBR	0x74
  045C    1476    SETB	0x76,0
  045D    1003    CLRB	0x3,0
  045E    0CF3    RRCR	0x73
  045F    0BF5    SZDECR	0x75
  0460    2C54    JP	0x454
  0461    0876    LD	A,0x76
  0462    0008    RET
5:                {
6:                	unsigned char	quotient;
7:                	unsigned char	counter;
8:                
9:                	quotient = 0;
10:               	if(divisor != 0) {
11:               		counter = 1;
12:               		while((divisor & 0x80) == 0) {
13:               			divisor <<= 1;
14:               			counter++;
15:               		}
16:               		do {
17:               			quotient <<= 1;
18:               			if(divisor <= dividend) {
19:               				dividend -= divisor;
20:               				quotient |= 1;
21:               			}
22:               			divisor >>= 1;
23:               		} while(--counter != 0);
24:               	}
25:               	return quotient;
26:               }
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\lwdiv.c ----------------------------------------------------------------------
1:                // word unsigned division
2:                
3:                unsigned int
4:                #ifdef __PICC__
5:                #warning TODO: update cgpic and this file to use the other prototype
6:                __lwdiv(unsigned int divisor, unsigned int dividend)
  03C9    01BF    CLR	0x3F
  03CA    01C0    CLR	0x40
  03CB    0873    LD	A,0x73
  03CC    0474    ORA	0x74
  03CD    1903    SZB	0x3,2
  03CE    2BEE    JP	0x3EE
  03CF    01BE    CLR	0x3E
  03D0    0ABE    INCR	0x3E
  03D1    1BF4    SZB	0x74,7
  03D2    2BD7    JP	0x3D7
  03D3    1003    CLRB	0x3,0
  03D4    0DF3    RLCR	0x73
  03D5    0DF4    RLCR	0x74
  03D6    2BD0    JP	0x3D0
  03D7    1003    CLRB	0x3,0
  03D8    0DBF    RLCR	0x3F
  03D9    0DC0    RLCR	0x40
  03DA    0874    LD	A,0x74
  03DB    0276    SUBA	0x76
  03DC    1D03    SNZB	0x3,2
  03DD    2BE0    JP	0x3E0
  03DE    0873    LD	A,0x73
  03DF    0275    SUBA	0x75
  03E0    1C03    SNZB	0x3,0
  03E1    2BEA    JP	0x3EA
  03E2    0873    LD	A,0x73
  03E3    02F5    SUBR	0x75
  03E4    0874    LD	A,0x74
  03E5    1C03    SNZB	0x3,0
  03E6    03F6    DECR	0x76
  03E7    02F6    SUBR	0x76
  03E8    143F    SETB	0x3F,0
  03E9    1003    CLRB	0x3,0
  03EA    0CF4    RRCR	0x74
  03EB    0CF3    RRCR	0x73
  03EC    0BBE    SZDECR	0x3E
  03ED    2BD7    JP	0x3D7
  03EE    0840    LD	A,0x40
  03EF    00F4    LD	0x74,A
  03F0    083F    LD	A,0x3F
  03F1    00F3    LD	0x73,A
  03F2    0008    RET
7:                #else
8:                __lwdiv(unsigned int dividend, unsigned int divisor)
9:                #endif
10:               {
11:               	unsigned int	quotient;
12:               	unsigned char	counter;
13:               
14:               	quotient = 0;
15:               	if(divisor != 0) {
16:               		counter = 1;
17:               		while((divisor & 0x8000) == 0) {
18:               			divisor <<= 1;
19:               			counter++;
20:               		}
21:               		do {
22:               			quotient <<= 1;
23:               			if(divisor <= dividend) {
24:               				dividend -= divisor;
25:               				quotient |= 1;
26:               			}
27:               			divisor >>= 1;
28:               		} while(--counter != 0);
29:               	}
30:               	return quotient;
31:               }
---- stringtab ------------------------------------------------------------------
  04A9    3004    LDIA	0x4
  04AA    008A    LD	0xA,A
  04AB    0804    LD	A,0x4
  04AC    0A84    INCR	0x4
  04AD    0782    ADDR	0x2
  04AE    3400    RET	0x0
---- reset_enter ------------------------------------------------------------------
  0000    280C    JP	0xC
  000C    280D    JP	0xD
---- start_initialization ------------------------------------------------------------------
  000D    3077    LDIA	0x77
  000E    0084    LD	0x4,A
  000F    307B    LDIA	0x7B
  0010    24D9    CALL	0x4D9
  0011    3020    LDIA	0x20
  0012    1383    CLRB	0x3,7
  0013    0084    LD	0x4,A
  0014    303E    LDIA	0x3E
  0015    24D9    CALL	0x4D9
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F0    LD	0x70,A
  0007    0804    LD	A,0x4
  0008    00F1    LD	0x71,A
  0009    080A    LD	A,0xA
  000A    00F2    LD	0x72,A
  000B    2BF3    JP	0x3F3
---- common_function ------------------------------------------------------------------
  0016    0183    CLR	0x3
  0017    2B57    JP	0x357
  00E3    00BF    LD	0x3F,A
  00E4    01C0    CLR	0x40
  00E5    01C1    CLR	0x41
  00E6    083E    LD	A,0x3E
  00E7    02C5    SUBR	0x45
  00E8    083F    LD	A,0x3F
  00E9    1C03    SNZB	0x3,0
  00EA    0F3F    SZINCA	0x3F
  00EB    02C6    SUBR	0x46
  00EC    0840    LD	A,0x40
  00ED    1C03    SNZB	0x3,0
  00EE    0F40    SZINCA	0x40
  00EF    02C7    SUBR	0x47
  00F0    0841    LD	A,0x41
  00F1    0008    RET
  00F2    01C5    CLR	0x45
  00F3    01C6    CLR	0x46
  00F4    01C7    CLR	0x47
  00F5    01C8    CLR	0x48
  00F6    01C9    CLR	0x49
  00F7    01CA    CLR	0x4A
  00F8    01CB    CLR	0x4B
  00F9    01CC    CLR	0x4C
  00FA    0008    RET
  00FB    084E    LD	A,0x4E
  00FC    00CC    LD	0x4C,A
  00FD    084D    LD	A,0x4D
  00FE    00CB    LD	0x4B,A
  00FF    0008    RET
  01D6    1683    SETB	0x3,5
  01D7    019E    CLR	0x1E
  01D8    3028    LDIA	0x28
  01D9    009B    LD	0x1B,A
  01DA    1283    CLRB	0x3,5
  01DB    00AB    LD	0x2B,A
  01DC    0008    RET
  0281    0AA2    INCR	0x22
  0282    1903    SZB	0x3,2
  0283    0AA3    INCR	0x23
  0284    3003    LDIA	0x3
  0285    0223    SUBA	0x23
  0286    34E8    RET	0xE8
  034E    0085    LD	0x5,A
  034F    3037    LDIA	0x37
  0350    1283    CLRB	0x3,5
  0351    0085    LD	0x5,A
  0352    1683    SETB	0x3,5
  0353    0186    CLR	0x6
  0354    1283    CLRB	0x3,5
  0355    0186    CLR	0x6
  0356    0008    RET
  04AF    343F    RET	0x3F
  04B0    3406    RET	0x6
  04B1    345B    RET	0x5B
  04B2    344F    RET	0x4F
  04B3    3466    RET	0x66
  04B4    346D    RET	0x6D
  04B5    347D    RET	0x7D
  04B6    3407    RET	0x7
  04B7    347F    RET	0x7F
  04B8    346F    RET	0x6F
  04B9    3473    RET	0x73
  04BA    3476    RET	0x76
  04CB    2B00    JP	0x300
  04CC    2A98    JP	0x298
  04CD    2AA0    JP	0x2A0
  04CE    2AA8    JP	0x2A8
  04CF    2AB0    JP	0x2B0
  04D0    2AB8    JP	0x2B8
  04D1    2AC0    JP	0x2C0
  04D2    2AC8    JP	0x2C8
  04D3    2AD0    JP	0x2D0
  04D4    2AD8    JP	0x2D8
  04D5    2AE0    JP	0x2E0
  04D6    2AE8    JP	0x2E8
  04D7    2AF0    JP	0x2F0
  04D8    2AF8    JP	0x2F8
  04D9    0064    CLRWDT
  04DA    0180    CLR	0x0
  04DB    0A84    INCR	0x4
  04DC    0604    XORA	0x4
  04DD    1903    SZB	0x3,2
  04DE    3400    RET	0x0
  04DF    0604    XORA	0x4
  04E0    2CDA    JP	0x4DA
