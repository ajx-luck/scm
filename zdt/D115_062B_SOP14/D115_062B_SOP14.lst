---- C:\mcuproject\scm\zdt\D115_062B_SOP14\main.c ----------------------------------------------------------------------
1:                /**********************************************************
2:                AD检测范例程序
3:                **********************************************************/
4:                #pragma warning disable 752
5:                #pragma warning disable 373			//屏蔽掉编译的1个警告
6:                #include <sc.h>
7:                
8:                #ifndef _XTAL_FREQ
9:                #define _XTAL_FREQ 16000000			//16MHz,使用内置延时函数必须定义主频，
10:               									//如用FCPU_DIV选择2T，则定时赋值减半
11:               #endif
12:               #define		u8t		unsigned char
13:               #define		u16t	unsigned int
14:               #define     POWER_RATIO  	(4096UL*1.2*1000)
15:               
16:               #define		A_LED3						 RB7
17:               #define		A_LED2						 RB0
18:               #define		A_LED1						 RB1
19:               
20:               
21:               
22:               #define		A_LED3_OUT					 TRISB	&= 0x7F
23:               #define		A_LED2_OUT					 TRISB	&= 0xFE
24:               #define		A_LED1_OUT					 TRISB	&= 0xFD
25:               
26:               volatile unsigned int adresult;
27:               volatile unsigned int result;
28:               volatile unsigned char test_adc;
29:               volatile unsigned int power_ad;
30:               u8t	intCount;
31:               u8t	count1s;
32:               u8t	IntFlag;
33:               u8t	chrgFlag;
34:               u8t	chrgFullFlag;
35:               u8t	intCount10;
36:               u16t	outADValue;
37:               u16t	batADValue;
38:               u8t		countHalfFull;
39:               u8t		protectFlag;
40:               u8t		workOverOutTime;
41:               u8t		workStep = 0;
42:               u8t		ledCnt;
43:               u8t		ledStep;
44:               u8t		keyCount;
45:               u8t		longPressFlag;
46:               u8t		maxDuty;
47:               u8t		overCount;
48:               u8t		addPowerCount;
49:               u8t		tempDuty;
50:               u8t		startTime;
51:               u8t		firstTime;
52:               u8t		overChrgTime;
53:               u8t		pwStep;
54:               u8t		prePwStep;
55:               u16t	count50s;
56:               u8t		reChrgCount;
57:               u8t		lockLedStep;
58:               u8t		showBatTime;
59:               u8t		chrgMode = 0;
60:               u8t		chrgMaxAD = 0;
61:               u8t		lockCount = 0;
62:               u16t	fullCount = 0;
63:               u8t addTime;
64:               u8t subTime;
65:               u8t chrgWaitTime;
66:               u8t	chrgMaxDuty = 0;
67:               u8t	ledCntTime;
68:               u16t	count5s = 0;
69:               u8t		overWorkTime;
70:               u8t		preLedStep;
71:               u16t	count8s;
72:               u16t	count900s;
73:               u8t		lowBatFlag = 0;
74:               u8t		sleepTime;
75:               u8t		startChrgTime = 0;
76:               u8t		ledTime = 0;
77:               u8t		ledDuty = 0;
78:               u8t		ledBreathTime = 0;
79:               
80:               unsigned char ADC_Sample(unsigned char adch, unsigned char adldo);
81:               void DelayXms(unsigned char x);
82:               unsigned char ADC_Result(unsigned char adch);
83:               void Init_System();
84:               void AD_Init();
85:               void Sleep_Mode();
86:               void pwmInit();
87:               void pwmStop();
88:               void chrgPwmInit();
89:               void chrgPwmStop();
90:               void chrgCtr();
91:               void checkOutA();
92:               void checkBatAD();
93:               void ledShow();
94:               void keyCtr();
95:               void workCtr();
96:               void ledCtr();
97:               char keyRead(char keyStatus);
98:               
99:               
100:              //#define _DEBUG			//调试程序用
101:              
102:              
103:              /***********************************************************
104:              中断服务函数
105:              函数名称：Isr_Timer()
106:              函数功能：中断处理函数
107:              入口参数：
108:              出口参数：
109:              备    注：125US定时2中断
110:              			所有中断都是在这个函数里面处理
111:              ***********************************************************/
112:              void interrupt Isr_Timer() 
113:              {
114:              	if(TMR2IF) 
  040C    1283    CLRB	0x3,5
  040D    1C8D    SNZB	0xD,1
  040E    2C1E    JP	0x41E
115:              	{			//若只使能了一个中断源,可以略去判断
116:              		TMR2IF = 0;
  040F    108D    CLRB	0xD,1
117:              		if(++intCount >= 160)
  0410    30A0    LDIA	0xA0
  0411    0AC4    INCR	0x44
  0412    0244    SUBA	0x44
  0413    1C03    SNZB	0x3,0
  0414    2C1D    JP	0x41D
  0415    3064    LDIA	0x64
118:              		{
119:              			intCount = 0;
  0416    01C4    CLR	0x44
120:              			IntFlag = 1;
  0417    01C2    CLR	0x42
  0418    0AC2    INCR	0x42
121:              			if(++count1s >= 100)
  0419    0AC3    INCR	0x43
  041A    0243    SUBA	0x43
  041B    1803    SZB	0x3,0
122:              			{
123:              				count1s = 0;
  041C    01C3    CLR	0x43
124:              			}
125:              		}
126:              		intCount10++;
  041D    0AC0    INCR	0x40
  041E    0871    LD	A,0x71
  041F    008A    LD	0xA,A
  0420    0E70    SWAPA	0x70
  0421    0083    LD	0x3,A
  0422    0EFE    SWAPR	0x7E
  0423    0E7E    SWAPA	0x7E
  0424    0009    RETI
127:              	}
128:              
129:              }
130:              
131:              
132:              /***********************************************************
133:              main主函数
134:              ***********************************************************/
135:              void main() 
136:              {
137:              	Init_System();
  02FC    2394    CALL	0x394
138:              	AD_Init();
  02FD    243B    CALL	0x43B
139:              	firstTime = 100;
  02FE    3064    LDIA	0x64
  02FF    1283    CLRB	0x3,5
  0300    00D5    LD	0x55,A
140:              	while (1) 
  0301    0064    CLRWDT
141:              	{
142:              		asm("clrwdt");
143:              		if(intCount10 > 10)
  0302    300B    LDIA	0xB
  0303    1283    CLRB	0x3,5
  0304    0240    SUBA	0x40
  0305    1C03    SNZB	0x3,0
  0306    2B09    JP	0x309
144:              		{
145:              			intCount10 = 0;
  0307    01C0    CLR	0x40
146:              			checkOutA();
  0308    20FB    CALL	0xFB
147:              		}
148:              		if(!IntFlag)
  0309    1283    CLRB	0x3,5
  030A    0842    LD	A,0x42
  030B    1903    SZB	0x3,2
  030C    2B01    JP	0x301
149:                  		continue;			//10ms执行一次
150:                  	IntFlag = 0;
  030D    01C2    CLR	0x42
151:              		chrgCtr();
  030E    2277    CALL	0x277
152:              		checkBatAD();
  030F    2214    CALL	0x214
153:              		if(chrgFlag == 0 && lowBatFlag == 0)
  0310    1283    CLRB	0x3,5
  0311    0841    LD	A,0x41
  0312    1D03    SNZB	0x3,2
  0313    2B18    JP	0x318
  0314    0833    LD	A,0x33
  0315    1D03    SNZB	0x3,2
  0316    2B18    JP	0x318
154:              		{
155:              			keyCtr();
  0317    236C    CALL	0x36C
156:              		}
157:              		workCtr();
  0318    2334    CALL	0x334
158:              		ledCtr();
  0319    2189    CALL	0x189
159:              		if(chrgFlag == 0 && workStep == 0 && keyCount == 0 && firstTime == 0 && showBatTime == 0)
  031A    1283    CLRB	0x3,5
  031B    0841    LD	A,0x41
  031C    1D03    SNZB	0x3,2
  031D    2B32    JP	0x332
  031E    087B    LD	A,0x7B
  031F    1D03    SNZB	0x3,2
  0320    2B32    JP	0x332
  0321    083E    LD	A,0x3E
  0322    1D03    SNZB	0x3,2
  0323    2B32    JP	0x332
  0324    0855    LD	A,0x55
  0325    1D03    SNZB	0x3,2
  0326    2B32    JP	0x332
  0327    0836    LD	A,0x36
  0328    1D03    SNZB	0x3,2
  0329    2B32    JP	0x332
160:              		{
161:              			if(++sleepTime >= 200)
  032A    30C8    LDIA	0xC8
  032B    0AB2    INCR	0x32
  032C    0232    SUBA	0x32
  032D    1C03    SNZB	0x3,0
  032E    2B01    JP	0x301
162:              			{
163:              				sleepTime = 0;
  032F    01B2    CLR	0x32
164:              				Sleep_Mode();
  0330    22BC    CALL	0x2BC
  0331    2B01    JP	0x301
165:              			}
166:              		}
167:              		else
168:              		{
169:              			sleepTime = 0;
  0332    01B2    CLR	0x32
  0333    2B01    JP	0x301
170:              		}
171:              	}
172:              }
173:              
174:              
175:              
176:              void ledCtr()
177:              {
178:              	if(firstTime > 0)
  0189    0855    LD	A,0x55
  018A    1903    SZB	0x3,2
  018B    2996    JP	0x196
  018C    3006    LDIA	0x6
179:              	{
180:              		firstTime--;
  018D    03D5    DECR	0x55
181:              		ledStep = 6;
  018E    00FA    LD	0x7A,A
182:              		if(prePwStep < pwStep)
  018F    0838    LD	A,0x38
  0190    0279    SUBA	0x79
  0191    1803    SZB	0x3,0
  0192    29D6    JP	0x1D6
183:              		{
184:              			prePwStep = pwStep;
  0193    0838    LD	A,0x38
  0194    00F9    LD	0x79,A
  0195    29D6    JP	0x1D6
185:              		}
186:              	}
187:              	else if(overWorkTime > 0)
  0196    0835    LD	A,0x35
  0197    1903    SZB	0x3,2
  0198    29A7    JP	0x1A7
  0199    303C    LDIA	0x3C
188:              	{
189:              		overWorkTime--;
  019A    03B5    DECR	0x35
190:              		if(overWorkTime % 60 < 30)
  019B    00F2    LD	0x72,A
  019C    0835    LD	A,0x35
  019D    23D5    CALL	0x3D5
  019E    00F7    LD	0x77,A
  019F    301E    LDIA	0x1E
  01A0    0277    SUBA	0x77
  01A1    1803    SZB	0x3,0
  01A2    29A5    JP	0x1A5
191:              		{
192:              			ledStep = preLedStep;
  01A3    0834    LD	A,0x34
  01A4    29D5    JP	0x1D5
193:              		}
194:              		else
195:              		{
196:              			ledStep = 0;
  01A5    01FA    CLR	0x7A
  01A6    29D6    JP	0x1D6
197:              		}
198:              	}
199:              	else if(showBatTime > 0)
  01A7    0836    LD	A,0x36
  01A8    1903    SZB	0x3,2
  01A9    29C0    JP	0x1C0
  01AA    300E    LDIA	0xE
200:              	{
201:              		showBatTime--;
  01AB    03B6    DECR	0x36
202:              		if(prePwStep >= 14)
  01AC    0279    SUBA	0x79
  01AD    1C03    SNZB	0x3,0
  01AE    29B4    JP	0x1B4
203:              		{
204:              			ledStep = prePwStep/14;
  01AF    300E    LDIA	0xE
  01B0    00F2    LD	0x72,A
  01B1    0879    LD	A,0x79
  01B2    23F1    CALL	0x3F1
  01B3    29D5    JP	0x1D5
205:              		}
206:              		else if(prePwStep > 5)
  01B4    3006    LDIA	0x6
  01B5    0279    SUBA	0x79
  01B6    1C03    SNZB	0x3,0
  01B7    29BB    JP	0x1BB
207:              		{
208:              			ledStep = 1;
  01B8    01FA    CLR	0x7A
  01B9    0AFA    INCR	0x7A
209:              		}
  01BA    29D6    JP	0x1D6
210:              		else
211:              		{
212:              			if(count1s < 50)
  01BB    3032    LDIA	0x32
  01BC    0243    SUBA	0x43
  01BD    1C03    SNZB	0x3,0
  01BE    29B8    JP	0x1B8
  01BF    29A5    JP	0x1A5
213:              			{
214:              				ledStep = 1;
215:              			}
216:              			else
217:              			{
218:              				ledStep = 0;
219:              			}
220:              		}
221:              	}
222:              	else if(workStep > 0)
  01C0    087B    LD	A,0x7B
  01C1    1903    SZB	0x3,2
  01C2    29C5    JP	0x1C5
223:              	{
224:              		ledStep = workStep;
  01C3    087B    LD	A,0x7B
  01C4    29D5    JP	0x1D5
225:              	}
226:              	else if(chrgFlag)
  01C5    0841    LD	A,0x41
  01C6    1903    SZB	0x3,2
  01C7    29A5    JP	0x1A5
227:              	{
228:              		if(count1s % 50 == 0)
  01C8    3032    LDIA	0x32
  01C9    00F2    LD	0x72,A
  01CA    0843    LD	A,0x43
  01CB    23D5    CALL	0x3D5
  01CC    3A00    XORIA	0x0
  01CD    1D03    SNZB	0x3,2
  01CE    29D6    JP	0x1D6
229:              		{
230:              			if(++ledStep > 6)
  01CF    3007    LDIA	0x7
  01D0    0AFA    INCR	0x7A
  01D1    027A    SUBA	0x7A
  01D2    1C03    SNZB	0x3,0
  01D3    29D6    JP	0x1D6
231:              			{
232:              				ledStep = lockLedStep;
  01D4    0837    LD	A,0x37
  01D5    00FA    LD	0x7A,A
233:              			}
234:              		}
235:              	}
236:              	else
237:              	{
238:              		ledStep = 0;
239:              	}
240:              	PORTB |= 0x03;
  01D6    3003    LDIA	0x3
  01D7    0486    ORR	0x6
241:              	PORTA |= 0x3C;
  01D8    303C    LDIA	0x3C
  01D9    1683    SETB	0x3,5
  01DA    0486    ORR	0x6
242:              	if(ledStep > 5)
  01DB    3006    LDIA	0x6
  01DC    027A    SUBA	0x7A
  01DD    1C03    SNZB	0x3,0
  01DE    29E6    JP	0x1E6
243:              	{
244:              		PORTB &= 0xFC;
  01DF    30FC    LDIA	0xFC
  01E0    1283    CLRB	0x3,5
  01E1    0586    ANDR	0x6
245:              		PORTA &= 0xC3;
  01E2    30C3    LDIA	0xC3
  01E3    1683    SETB	0x3,5
  01E4    0586    ANDR	0x6
246:              	}
  01E5    0008    RET
247:              	else if(ledStep > 4)
  01E6    3005    LDIA	0x5
  01E7    027A    SUBA	0x7A
  01E8    1C03    SNZB	0x3,0
  01E9    29F1    JP	0x1F1
248:              	{
249:              		PORTB &= 0xFC;
  01EA    30FC    LDIA	0xFC
  01EB    1283    CLRB	0x3,5
  01EC    0586    ANDR	0x6
250:              		PORTA &= 0xE3;
  01ED    30E3    LDIA	0xE3
  01EE    1683    SETB	0x3,5
  01EF    0586    ANDR	0x6
251:              	}
  01F0    0008    RET
252:              	else if(ledStep > 3)
  01F1    3004    LDIA	0x4
  01F2    027A    SUBA	0x7A
  01F3    1C03    SNZB	0x3,0
  01F4    29FC    JP	0x1FC
253:              	{
254:              		PORTB &= 0xFC;
  01F5    30FC    LDIA	0xFC
  01F6    1283    CLRB	0x3,5
  01F7    0586    ANDR	0x6
255:              		PORTA &= 0xF3;
  01F8    30F3    LDIA	0xF3
  01F9    1683    SETB	0x3,5
  01FA    0586    ANDR	0x6
256:              	}
  01FB    0008    RET
257:              	else if(ledStep > 2)
  01FC    3003    LDIA	0x3
  01FD    027A    SUBA	0x7A
  01FE    1C03    SNZB	0x3,0
  01FF    2A06    JP	0x206
258:              	{
259:              		PORTB &= 0xFC;
  0200    30FC    LDIA	0xFC
  0201    1283    CLRB	0x3,5
  0202    0586    ANDR	0x6
260:              		PORTA &= 0xFB;
  0203    1683    SETB	0x3,5
  0204    1106    CLRB	0x6,2
261:              	}
  0205    0008    RET
262:              	else if(ledStep > 1)
  0206    3002    LDIA	0x2
  0207    027A    SUBA	0x7A
  0208    1C03    SNZB	0x3,0
  0209    2A0E    JP	0x20E
263:              	{
264:              		PORTB &= 0xFC;
  020A    30FC    LDIA	0xFC
  020B    1283    CLRB	0x3,5
  020C    0586    ANDR	0x6
265:              	}
  020D    0008    RET
266:              	else if(ledStep > 0)
  020E    087A    LD	A,0x7A
  020F    1903    SZB	0x3,2
  0210    0008    RET
267:              	{
268:              		PORTB &= 0xFE;
  0211    1283    CLRB	0x3,5
  0212    1006    CLRB	0x6,0
  0213    0008    RET
269:              	}
270:              
271:              }
272:              
273:              
274:              
275:              void chrgCtr()
276:              {
277:              	if(PORTB & 0x04)
  0277    1D06    SNZB	0x6,2
  0278    2AA2    JP	0x2A2
278:              	{
279:              		if(chrgFlag == 0)
  0279    0841    LD	A,0x41
  027A    1D03    SNZB	0x3,2
  027B    2A7F    JP	0x27F
280:              		{
281:              			chrgFlag = 1;
  027C    01C1    CLR	0x41
  027D    0AC1    INCR	0x41
282:              			ledStep = 0;
283:              			chrgMaxDuty = 0;
  027E    01FA    CLR	0x7A
284:              		}
285:              		workStep = 0;
  027F    01FB    CLR	0x7B
286:              		lowBatFlag = 0;
  0280    01B3    CLR	0x33
287:              		if(prePwStep < pwStep)
  0281    0838    LD	A,0x38
  0282    0279    SUBA	0x79
  0283    1803    SZB	0x3,0
  0284    2A93    JP	0x293
288:              		{
289:              			if(++count50s > 7200)
  0285    0AA6    INCR	0x26
  0286    1903    SZB	0x3,2
  0287    0AA7    INCR	0x27
  0288    301C    LDIA	0x1C
  0289    0227    SUBA	0x27
  028A    3021    LDIA	0x21
  028B    1903    SZB	0x3,2
  028C    0226    SUBA	0x26
  028D    1C03    SNZB	0x3,0
  028E    2A95    JP	0x295
290:              			{
291:              				count50s = 0;
  028F    01A6    CLR	0x26
  0290    01A7    CLR	0x27
292:              				prePwStep++;
  0291    0AF9    INCR	0x79
  0292    2A95    JP	0x295
293:              			}
294:              		}
295:              		else
296:              		{
297:              			count50s = 0;
  0293    01A6    CLR	0x26
  0294    01A7    CLR	0x27
298:              		}
299:              		if(prePwStep < 15)
  0295    300F    LDIA	0xF
  0296    0279    SUBA	0x79
  0297    1803    SZB	0x3,0
  0298    2A9B    JP	0x29B
300:              		{
301:              			lockLedStep = 0;
  0299    01B7    CLR	0x37
302:              		}
  029A    0008    RET
303:              		else
304:              		{
305:              			lockLedStep = (prePwStep/14) - 1;
  029B    300E    LDIA	0xE
  029C    00F2    LD	0x72,A
  029D    0879    LD	A,0x79
  029E    23F1    CALL	0x3F1
  029F    3EFF    ADDIA	0xFF
  02A0    00B7    LD	0x37,A
  02A1    0008    RET
306:              		}
307:              	}
308:              	else
309:              	{
310:              		startChrgTime = 0;
311:              		chrgFlag = 0;
312:              		chrgFullFlag = 0;
313:              		protectFlag = 0;
314:              		chrgMode = 0;
315:              		chrgMaxAD = 0;
316:              		chrgMaxDuty = 0;
317:              		lockCount = 0;
  02A2    01C1    CLR	0x41
318:              		lockLedStep = 0;
319:              		chrgWaitTime = 20;
  02A3    01B7    CLR	0x37
320:              		if(prePwStep > 0 && prePwStep > pwStep)
  02A4    0879    LD	A,0x79
  02A5    1903    SZB	0x3,2
  02A6    2AB9    JP	0x2B9
  02A7    0879    LD	A,0x79
  02A8    0238    SUBA	0x38
  02A9    1803    SZB	0x3,0
  02AA    2AB9    JP	0x2B9
321:              		{
322:              			if(++count50s > 2000)
  02AB    0AA6    INCR	0x26
  02AC    1903    SZB	0x3,2
  02AD    0AA7    INCR	0x27
  02AE    3007    LDIA	0x7
  02AF    0227    SUBA	0x27
  02B0    30D1    LDIA	0xD1
  02B1    1903    SZB	0x3,2
  02B2    0226    SUBA	0x26
  02B3    1C03    SNZB	0x3,0
  02B4    0008    RET
323:              			{
324:              				count50s = 0;
  02B5    01A6    CLR	0x26
  02B6    01A7    CLR	0x27
325:              				prePwStep--;
  02B7    03F9    DECR	0x79
  02B8    0008    RET
326:              			}
327:              		}
328:              		else
329:              		{
330:              			count50s = 0;
  02B9    01A6    CLR	0x26
  02BA    01A7    CLR	0x27
  02BB    0008    RET
331:              		}
332:              	}
333:              }
334:              
335:              
336:              
337:              char keyRead(char keyStatus)	
  03B7    00F2    LD	0x72,A
338:              { 
339:              	if(keyStatus)
  03B8    0872    LD	A,0x72
  03B9    3064    LDIA	0x64
  03BA    1903    SZB	0x3,2
  03BB    2BC9    JP	0x3C9
340:              	{
341:              		keyCount++;
  03BC    0ABE    INCR	0x3E
342:              		if(keyCount >= 100)
  03BD    023E    SUBA	0x3E
  03BE    1C03    SNZB	0x3,0
  03BF    3400    RET	0x0
343:              		{
344:              			keyCount = 100;
  03C0    3064    LDIA	0x64
  03C1    00BE    LD	0x3E,A
345:              			if(!longPressFlag)
  03C2    083D    LD	A,0x3D
  03C3    1D03    SNZB	0x3,2
  03C4    3400    RET	0x0
  03C5    3002    LDIA	0x2
346:              			{
347:              				longPressFlag = 1;
  03C6    01BD    CLR	0x3D
  03C7    0ABD    INCR	0x3D
348:              				return 2;
  03C8    0008    RET
349:              			}
350:              		}
351:              	}
352:              	else
353:              	{
354:              		if(keyCount >= 100)
  03C9    023E    SUBA	0x3E
  03CA    1C03    SNZB	0x3,0
  03CB    2BCF    JP	0x3CF
355:              		{
356:              			keyCount = 0;
  03CC    01BE    CLR	0x3E
357:              			longPressFlag = 0;
  03CD    01BD    CLR	0x3D
358:              			return	0;
  03CE    3400    RET	0x0
359:              		}
360:              		else if(keyCount >= 6)
  03CF    3006    LDIA	0x6
  03D0    023E    SUBA	0x3E
361:              		{
362:              			keyCount = 0;
  03D1    01BE    CLR	0x3E
  03D2    1803    SZB	0x3,0
363:              			return	1;
  03D3    3401    RET	0x1
  03D4    3400    RET	0x0
364:              		}
365:              		keyCount = 0;
366:              	}
367:              	return 0;
368:              }
369:              
370:              void keyCtr()
371:              {
372:              	char kclick = keyRead(0x10 & (~PORTB));
  036C    0906    COMA	0x6
  036D    3910    ANDIA	0x10
  036E    23B7    CALL	0x3B7
  036F    00F3    LD	0x73,A
373:              	if(kclick == 1)
  0370    0B73    SZDECA	0x73
  0371    2B86    JP	0x386
374:              	{
375:              		if(workStep > 0)
  0372    087B    LD	A,0x7B
  0373    1903    SZB	0x3,2
  0374    2B7D    JP	0x37D
376:              		{
377:              			if(++workStep > 6)
  0375    3007    LDIA	0x7
  0376    0AFB    INCR	0x7B
  0377    027B    SUBA	0x7B
  0378    1C03    SNZB	0x3,0
  0379    0008    RET
378:              			{
379:              				workStep = 1;
  037A    01FB    CLR	0x7B
  037B    0AFB    INCR	0x7B
  037C    0008    RET
380:              			}
381:              		}
382:              		else if(showBatTime > 0)
  037D    0836    LD	A,0x36
  037E    1903    SZB	0x3,2
  037F    2B82    JP	0x382
383:              		{
384:              			showBatTime = 0;
  0380    01B6    CLR	0x36
385:              		}
  0381    0008    RET
386:              		else
387:              		{
388:              			showBatTime = 200;
  0382    30C8    LDIA	0xC8
  0383    00B6    LD	0x36,A
389:              			count1s = 0;
  0384    01C3    CLR	0x43
  0385    0008    RET
390:              		}
391:              	}
392:              	else if(kclick == 2)
  0386    3002    LDIA	0x2
  0387    0673    XORA	0x73
  0388    1D03    SNZB	0x3,2
  0389    0008    RET
393:              	{
394:              		if(workStep > 0)
  038A    087B    LD	A,0x7B
  038B    1903    SZB	0x3,2
  038C    2B8F    JP	0x38F
395:              		{
396:              			workStep = 0;
  038D    01FB    CLR	0x7B
397:              		}
  038E    0008    RET
  038F    301E    LDIA	0x1E
398:              		else
399:              		{
400:              			workStep = 1;
  0390    01FB    CLR	0x7B
  0391    0AFB    INCR	0x7B
401:              			startTime = 30;
  0392    00B9    LD	0x39,A
  0393    2B80    JP	0x380
402:              			showBatTime = 0;
403:              		}
404:              	}
405:              }
406:              
407:              void workCtr()
408:              {
409:              
410:              	if(startTime > 0)
  0334    0839    LD	A,0x39
  0335    1D03    SNZB	0x3,2
411:              	{
412:              		startTime--;
  0336    03B9    DECR	0x39
413:              	}
414:              	if(workStep > 0)
  0337    087B    LD	A,0x7B
  0338    1903    SZB	0x3,2
  0339    2B68    JP	0x368
415:              	{
416:              		if((PWMCON0 & 0x04) == 0)
  033A    1915    SZB	0x15,2
  033B    2B3D    JP	0x33D
417:              		{
418:              			pwmInit();
  033C    2425    CALL	0x425
419:              		}
420:              		maxDuty = 40 + (workStep*3);
  033D    087B    LD	A,0x7B
  033E    077B    ADDA	0x7B
  033F    077B    ADDA	0x7B
  0340    3E28    ADDIA	0x28
  0341    00BC    LD	0x3C,A
421:              		if(overCount >= 5)
  0342    3005    LDIA	0x5
  0343    023B    SUBA	0x3B
  0344    1C03    SNZB	0x3,0
  0345    2B58    JP	0x358
422:              		{
423:              			if(++count5s > 500)
  0346    0AA4    INCR	0x24
  0347    1903    SZB	0x3,2
  0348    0AA5    INCR	0x25
  0349    3001    LDIA	0x1
  034A    0225    SUBA	0x25
  034B    30F5    LDIA	0xF5
  034C    1903    SZB	0x3,2
  034D    0224    SUBA	0x24
  034E    1C03    SNZB	0x3,0
  034F    2B5A    JP	0x35A
  0350    30B4    LDIA	0xB4
424:              			{
425:              				count5s = 0;
  0351    01A4    CLR	0x24
  0352    01A5    CLR	0x25
426:              				overWorkTime = 180;
  0353    00B5    LD	0x35,A
427:              				preLedStep = workStep;
  0354    087B    LD	A,0x7B
  0355    00B4    LD	0x34,A
428:              				workStep = 0;
  0356    01FB    CLR	0x7B
  0357    2B5A    JP	0x35A
429:              				
430:              			}
431:              		}
432:              		else
433:              		{
434:              			count5s = 0;
  0358    01A4    CLR	0x24
  0359    01A5    CLR	0x25
435:              		}
436:              		if(count1s == 0 && ++count900s >= 900)
  035A    0843    LD	A,0x43
  035B    1D03    SNZB	0x3,2
  035C    0008    RET
  035D    0AA0    INCR	0x20
  035E    1903    SZB	0x3,2
  035F    0AA1    INCR	0x21
  0360    3003    LDIA	0x3
  0361    0221    SUBA	0x21
  0362    3084    LDIA	0x84
  0363    1903    SZB	0x3,2
  0364    0220    SUBA	0x20
  0365    1803    SZB	0x3,0
437:              		{
438:              			workStep = 0;
  0366    01FB    CLR	0x7B
  0367    0008    RET
439:              		}
440:              	}
441:              	else
442:              	{
443:              		pwmStop();
  0368    2442    CALL	0x442
444:              		count900s = 0;
  0369    01A0    CLR	0x20
  036A    01A1    CLR	0x21
  036B    0008    RET
445:              	}
446:              }
447:              
448:              void checkOutA()
449:              {
450:              	test_adc = ADC_Sample(0, 5);		//测试AN0口的AD值，参考电压2V
  00FB    3005    LDIA	0x5
  00FC    00F2    LD	0x72,A
  00FD    3000    LDIA	0x0
  00FE    2015    CALL	0x15
  00FF    00C5    LD	0x45,A
451:              	if (0xA5 == test_adc)				//测试完成，如因其他原因导致AD转换没有完成，则不处理
  0100    30A5    LDIA	0xA5
  0101    0645    XORA	0x45
  0102    1D03    SNZB	0x3,2
  0103    2981    JP	0x181
452:              	{
453:              
454:              		outADValue = adresult;
  0104    0831    LD	A,0x31
  0105    00AB    LD	0x2B,A
  0106    0830    LD	A,0x30
  0107    00AA    LD	0x2A,A
455:              		//电机坏了过载保护
456:                      if(workStep && (outADValue > 800))
  0108    087B    LD	A,0x7B
  0109    1903    SZB	0x3,2
  010A    291A    JP	0x11A
  010B    3003    LDIA	0x3
  010C    022B    SUBA	0x2B
  010D    3021    LDIA	0x21
  010E    1903    SZB	0x3,2
  010F    022A    SUBA	0x2A
  0110    1C03    SNZB	0x3,0
  0111    291A    JP	0x11A
457:                      {
458:                      	if(++workOverOutTime > 50)
  0112    3033    LDIA	0x33
  0113    0ABF    INCR	0x3F
  0114    023F    SUBA	0x3F
  0115    1C03    SNZB	0x3,0
  0116    291B    JP	0x11B
459:                      	{
460:                      		workOverOutTime = 0;
  0117    01BF    CLR	0x3F
461:                      		workStep = 0;
  0118    01FB    CLR	0x7B
  0119    291B    JP	0x11B
462:                      	}
463:                      }
464:              		else
465:              		{
466:              			workOverOutTime = 0;
  011A    01BF    CLR	0x3F
467:              		}
468:              		u8t maxtempV = 200;
469:              		if(workStep < 6 && outADValue > maxtempV)
  011B    3006    LDIA	0x6
  011C    027B    SUBA	0x7B
  011D    1803    SZB	0x3,0
  011E    292E    JP	0x12E
  011F    3000    LDIA	0x0
  0120    022B    SUBA	0x2B
  0121    30C9    LDIA	0xC9
  0122    1903    SZB	0x3,2
  0123    022A    SUBA	0x2A
  0124    1C03    SNZB	0x3,0
  0125    292E    JP	0x12E
470:                      {
471:                      	if(++overCount > 5)
  0126    3006    LDIA	0x6
  0127    0ABB    INCR	0x3B
  0128    023B    SUBA	0x3B
  0129    1C03    SNZB	0x3,0
  012A    297A    JP	0x17A
472:                      	{
473:                      		overCount = 5;
  012B    3005    LDIA	0x5
  012C    00BB    LD	0x3B,A
  012D    297A    JP	0x17A
474:                      	}
475:                      }
476:                      else if(outADValue > (maxtempV+100))
  012E    3001    LDIA	0x1
  012F    022B    SUBA	0x2B
  0130    302D    LDIA	0x2D
  0131    1903    SZB	0x3,2
  0132    022A    SUBA	0x2A
  0133    1803    SZB	0x3,0
  0134    2926    JP	0x126
477:                      {
478:                      	if(++overCount > 5)
  0135    3028    LDIA	0x28
  0136    00D4    LD	0x54,A
479:                      	{
480:                      		overCount = 5;
481:                      	}
482:                      }
483:                      else
484:                      {
485:                      	u8t maxAout = 40;
486:              			if(pwStep < 40)
  0137    0238    SUBA	0x38
  0138    1803    SZB	0x3,0
  0139    293C    JP	0x13C
487:              			{
488:              				maxAout = 37;
  013A    3025    LDIA	0x25
  013B    00D4    LD	0x54,A
489:              			}
490:                      	if(workStep == 1)
  013C    0B7B    SZDECA	0x7B
  013D    2940    JP	0x140
491:                  		{
492:                  			maxAout = maxAout + 1;
  013E    0AD4    INCR	0x54
493:                  		}
  013F    295C    JP	0x15C
494:              			else if(workStep == 2)
  0140    3002    LDIA	0x2
  0141    067B    XORA	0x7B
495:                  		{
496:                  			maxAout = maxAout + 3;
  0142    3003    LDIA	0x3
  0143    1903    SZB	0x3,2
  0144    295B    JP	0x15B
497:                  		}
  0145    067B    XORA	0x7B
  0146    1D03    SNZB	0x3,2
  0147    294A    JP	0x14A
498:              			else if(workStep == 3)
499:                  		{
500:                  			maxAout = maxAout + 5;
  0148    3005    LDIA	0x5
  0149    295B    JP	0x15B
501:                  		}
502:                  		else if(workStep == 4)
  014A    3004    LDIA	0x4
  014B    067B    XORA	0x7B
  014C    1D03    SNZB	0x3,2
  014D    2950    JP	0x150
503:                  		{
504:                  			maxAout = maxAout + 7;
  014E    3007    LDIA	0x7
  014F    295B    JP	0x15B
505:                  		}
506:                  		else if(workStep == 5)
  0150    3005    LDIA	0x5
  0151    067B    XORA	0x7B
  0152    1D03    SNZB	0x3,2
  0153    2956    JP	0x156
507:                  		{
508:                  			maxAout = maxAout + 9;
  0154    3009    LDIA	0x9
  0155    295B    JP	0x15B
509:                  		}
510:                  		else if(workStep == 6)
  0156    3006    LDIA	0x6
  0157    067B    XORA	0x7B
  0158    1D03    SNZB	0x3,2
  0159    295C    JP	0x15C
511:                  		{
512:                  			maxAout = maxAout + 12;
  015A    300C    LDIA	0xC
  015B    07D4    ADDR	0x54
513:                  		}
514:                      	if(overCount > 0)
  015C    083B    LD	A,0x3B
  015D    1D03    SNZB	0x3,2
515:                      	{
516:                      		overCount--;
  015E    03BB    DECR	0x3B
517:                      	}
518:                      	if(outADValue > maxAout)
  015F    0854    LD	A,0x54
  0160    00F7    LD	0x77,A
  0161    01F8    CLR	0x78
  0162    082B    LD	A,0x2B
  0163    0278    SUBA	0x78
  0164    1D03    SNZB	0x3,2
  0165    2968    JP	0x168
  0166    082A    LD	A,0x2A
  0167    0277    SUBA	0x77
  0168    1803    SZB	0x3,0
  0169    2975    JP	0x175
519:                      	{
520:                
521:              					if(startTime == 0)
  016A    0839    LD	A,0x39
  016B    1D03    SNZB	0x3,2
  016C    2972    JP	0x172
522:              					{
523:              						tempDuty = 81 + (workStep*3);
  016D    087B    LD	A,0x7B
  016E    077B    ADDA	0x7B
  016F    077B    ADDA	0x7B
  0170    3E51    ADDIA	0x51
  0171    2973    JP	0x173
524:              					}
525:              					else
526:              					{
527:              						tempDuty = maxDuty;
  0172    083C    LD	A,0x3C
  0173    00BA    LD	0x3A,A
  0174    297A    JP	0x17A
528:              					}
529:              
530:              	        		
531:                      	}
532:                      	else 
533:                      	{
534:                      		addPowerCount = 0;
535:                      		if(tempDuty > maxDuty)
  0175    083A    LD	A,0x3A
  0176    023C    SUBA	0x3C
  0177    1803    SZB	0x3,0
  0178    2972    JP	0x172
536:                      		{
537:                      			tempDuty--;
  0179    03BA    DECR	0x3A
538:                      		}
539:                      		else
540:                      		{
541:                      			tempDuty = maxDuty;
542:                      		}
543:              
544:                      	}
545:                 
546:                      }
547:              		PWMD23H = 0X00;
  017A    1683    SETB	0x3,5
  017B    019E    CLR	0x1E
548:                      PWMD2L = tempDuty;
  017C    1283    CLRB	0x3,5
  017D    083A    LD	A,0x3A
  017E    1683    SETB	0x3,5
  017F    009B    LD	0x1B,A
549:              	}
  0180    0008    RET
550:              	else
551:              	{
552:              		ADCON0 = 0;						//如果转换没有完成，需初始化ADCON0,1
  0181    1683    SETB	0x3,5
  0182    0195    CLR	0x15
553:              		ADCON1 = 0;				
  0183    0196    CLR	0x16
554:              		__delay_us(100);				//延时100us(编译器内置函数)
  0184    3085    LDIA	0x85
  0185    00F7    LD	0x77,A
  0186    0BF7    SZDECR	0x77
  0187    2986    JP	0x186
  0188    0008    RET
555:              	}
556:              }
557:              
558:              void checkBatAD()
559:              {
560:              	test_adc = ADC_Sample(1, 5);		//测试AN2口的AD值，参考电压2V
  0214    3005    LDIA	0x5
  0215    00F2    LD	0x72,A
  0216    3001    LDIA	0x1
  0217    2015    CALL	0x15
  0218    00C5    LD	0x45,A
561:              	if (0xA5 == test_adc)				//测试完成，如因其他原因导致AD转换没有完成，则不处理
  0219    30A5    LDIA	0xA5
  021A    0645    XORA	0x45
  021B    1D03    SNZB	0x3,2
  021C    2A6F    JP	0x26F
562:              	{
563:              		batADValue = adresult;
  021D    0831    LD	A,0x31
  021E    00A9    LD	0x29,A
  021F    0830    LD	A,0x30
  0220    00A8    LD	0x28,A
564:              		if(batADValue < 1117)
  0221    3004    LDIA	0x4
  0222    0229    SUBA	0x29
  0223    305D    LDIA	0x5D
  0224    1903    SZB	0x3,2
  0225    0228    SUBA	0x28
  0226    1803    SZB	0x3,0
  0227    2A41    JP	0x241
565:                      {
566:                      	pwStep = 0;
  0228    01B8    CLR	0x38
567:              			if(++count8s > 800)
  0229    0AA2    INCR	0x22
  022A    1903    SZB	0x3,2
  022B    0AA3    INCR	0x23
  022C    3003    LDIA	0x3
  022D    0223    SUBA	0x23
  022E    3021    LDIA	0x21
  022F    1903    SZB	0x3,2
  0230    0222    SUBA	0x22
  0231    1C03    SNZB	0x3,0
  0232    0008    RET
568:              			{
569:              				count8s = 0;
  0233    01A2    CLR	0x22
  0234    01A3    CLR	0x23
570:              				lowBatFlag = 1;
  0235    01B3    CLR	0x33
  0236    0AB3    INCR	0x33
571:              				if(workStep > 0)
  0237    087B    LD	A,0x7B
  0238    1903    SZB	0x3,2
  0239    2A3E    JP	0x23E
572:              				{
573:              					overWorkTime = 180;
  023A    30B4    LDIA	0xB4
  023B    00B5    LD	0x35,A
574:              					preLedStep = workStep;
  023C    087B    LD	A,0x7B
  023D    00B4    LD	0x34,A
575:              				}
576:              				prePwStep = 0;
  023E    01F9    CLR	0x79
577:              				workStep = 0;
  023F    01FB    CLR	0x7B
  0240    0008    RET
  0241    3005    LDIA	0x5
578:              			}
579:                      }
580:                      else
581:                      {
582:              	        count8s = 0;
  0242    01A2    CLR	0x22
  0243    01A3    CLR	0x23
583:              			if(batADValue >= 1340)
  0244    0229    SUBA	0x29
  0245    303C    LDIA	0x3C
  0246    1903    SZB	0x3,2
  0247    0228    SUBA	0x28
584:              	    	{
585:              	    		pwStep = ((batADValue - 1340) /2) + 13;
  0248    0828    LD	A,0x28
  0249    1C03    SNZB	0x3,0
  024A    2A58    JP	0x258
  024B    3EC4    ADDIA	0xC4
  024C    00F7    LD	0x77,A
  024D    0829    LD	A,0x29
  024E    1803    SZB	0x3,0
  024F    3E01    ADDIA	0x1
  0250    3EFA    ADDIA	0xFA
  0251    00F8    LD	0x78,A
  0252    1003    CLRB	0x3,0
  0253    0CF8    RRCR	0x78
  0254    0CF7    RRCR	0x77
  0255    0877    LD	A,0x77
  0256    3E0D    ADDIA	0xD
  0257    2A67    JP	0x267
586:              	    	}
  0258    3EA3    ADDIA	0xA3
  0259    00F7    LD	0x77,A
  025A    0829    LD	A,0x29
  025B    1803    SZB	0x3,0
  025C    3E01    ADDIA	0x1
  025D    3EFB    ADDIA	0xFB
  025E    00F8    LD	0x78,A
  025F    3004    LDIA	0x4
  0260    1003    CLRB	0x3,0
  0261    0CF8    RRCR	0x78
  0262    0CF7    RRCR	0x77
  0263    3EFF    ADDIA	0xFF
  0264    1D03    SNZB	0x3,2
  0265    2A60    JP	0x260
  0266    0877    LD	A,0x77
  0267    00B8    LD	0x38,A
587:              	    	else
588:              	    	{
589:              	    		pwStep = (batADValue - 1117) / 16;
590:              	    	}
591:              	    	if(pwStep > 99)
  0268    3064    LDIA	0x64
  0269    0238    SUBA	0x38
  026A    1C03    SNZB	0x3,0
  026B    0008    RET
592:              	    	{
593:              	    		pwStep = 99;
  026C    3063    LDIA	0x63
  026D    00B8    LD	0x38,A
  026E    0008    RET
594:              	    	}
595:                  	}
596:              		if(chrgFlag && batADValue > 1861)
597:                      {
598:              	        protectFlag = 1;
599:                      }
600:              	}
601:              	else
602:              	{
603:              		ADCON0 = 0;						//如果转换没有完成，需初始化ADCON0,1
  026F    1683    SETB	0x3,5
  0270    0195    CLR	0x15
604:              		ADCON1 = 0;				
  0271    0196    CLR	0x16
605:              		__delay_us(100);				//延时100us(编译器内置函数)
  0272    3085    LDIA	0x85
  0273    00F7    LD	0x77,A
  0274    0BF7    SZDECR	0x77
  0275    2A74    JP	0x274
  0276    0008    RET
606:              	}
607:              	
608:              }
609:              
610:              
611:              
612:              /**********************************************************
613:              函数名称：Init_System
614:              函数功能：系统初始化
615:              入口参数：无
616:              出口参数：无
617:              备    注：
618:              **********************************************************/
619:              void Init_System() 
  0394    0000    NOP
  0395    0064    CLRWDT
620:              {
621:              	asm("nop");
622:              	asm("clrwdt");
623:              	OPTION_REG = 0;					//预分频给TMR0 ，Timer0使用内部时钟Focs/4，预分频比为1:2
  0396    1283    CLRB	0x3,5
  0397    0181    CLR	0x1
  0398    0064    CLRWDT
624:              	asm("clrwdt");
625:              	OSCCON = 0X72;					//内部振荡器8M
  0399    3072    LDIA	0x72
  039A    1283    CLRB	0x3,5
  039B    0094    LD	0x14,A
626:              
627:              	WPUA = 0B00000000;				//配置上拉，1为使能上拉
  039C    1683    SETB	0x3,5
  039D    0188    CLR	0x8
628:              	WPDA = 0x00;					//RA1开下拉
  039E    0187    CLR	0x7
629:              	WPUB = 0x10;
  039F    3010    LDIA	0x10
  03A0    1283    CLRB	0x3,5
  03A1    0088    LD	0x8,A
630:              
631:              	TRISA = 0x03;				//配置IO状态，0为输出，1为输入
  03A2    3003    LDIA	0x3
  03A3    1683    SETB	0x3,5
  03A4    0085    LD	0x5,A
632:              	TRISB = 0x14;
  03A5    3014    LDIA	0x14
  03A6    1283    CLRB	0x3,5
  03A7    0085    LD	0x5,A
633:              
634:              	PORTA = 0X3C;
  03A8    303C    LDIA	0x3C
  03A9    1683    SETB	0x3,5
  03AA    0086    LD	0x6,A
635:              	PORTB = 0X03;
  03AB    3003    LDIA	0x3
  03AC    1283    CLRB	0x3,5
  03AD    0086    LD	0x6,A
636:              
637:              //---------------------------------------
638:              //125us中断初始化
639:              	PR2 = 249;					//设定Timer初始值，定时周期是250*2/8M=62.5uS
  03AE    30F9    LDIA	0xF9
  03AF    0091    LD	0x11,A
640:              	TMR2IF = 0;
  03B0    108D    CLRB	0xD,1
641:              	TMR2IE = 1;					//使能Timer2溢出中断
  03B1    148E    SETB	0xE,1
642:              
643:              	T2CON = 0B00000100;			//开启Timer2,设置TMR2的分频比为1:1
  03B2    3004    LDIA	0x4
  03B3    0093    LD	0x13,A
644:              	INTCON = 0XC0;				//开启总中断
  03B4    30C0    LDIA	0xC0
  03B5    008B    LD	0xB,A
  03B6    0008    RET
645:              }
646:              
647:              /***********************************************************
648:              中断服务函数
649:              函数名称：AD_Init()
650:              函数功能：AD初始化处理函数
651:              入口参数：
652:              出口参数：
653:              备    注：第一次打开AD允许位ADON，需延时20uS以上才能进入AD采样
654:              			如后继程序不关闭ADON，则不需要延时
655:              ***********************************************************/
656:              void AD_Init() 
657:              {
658:              	/*********** ADCON0 ****************************
659:              		Bit7~Bit6  ADCS<1:0>:  AD转换时钟选择位。
660:              			00=  F HSI /16
661:              			01=  F HSI /32
662:              			10=  F HSI /64
663:              			11=  F HSI /128
664:              		Bit5~Bit2  CHS<3:0>:  模拟通道选择位。与ADCON1寄存器CHS4组合CHS<3:0>
665:              			CHS<4:0>: 
666:              			00000=  AN0
667:              			00001=  AN1
668:              			00010=  AN2
669:              			00011=  AN3
670:              			00100=  AN4
671:              			00101=  AN5
672:              			00110=  保留
673:              			00111=  保留
674:              			01000=  AN8
675:              			… 
676:              			01101=  AN13
677:              			01110=  AN14
678:              			01111=  AN15
679:              			11111=  1.2V（固定参考电压）
680:              			其他=  保留
681:              		Bit1  GO/DONE: AD转换状态位。
682:              			1=  AD转换正在进行。将该位置1启动AD转换。当AD转换完成以后，该位由硬件自动清零。
683:              				当GO/DONE位从1变0或ADIF从0变1时，需至少等待两个TAD时间，才能再次启动AD转换。
684:              			0=  AD转换完成/或不在进行中。
685:              		Bit0  ADON:  ADC使能位。
686:              			1=  使能ADC；
687:              			0=  禁止ADC，不消耗工作电流。
688:              	*********************************************/
689:              	ADCON0 = 0X41;		//ADON开启，AD采样时间选为FSYS/16
  043B    3041    LDIA	0x41
  043C    1683    SETB	0x3,5
  043D    0095    LD	0x15,A
690:              	
691:              	/*********** ADCON1 ****************************
692:              		Bit7  ADFM:  AD转换结果格式选择位；
693:              			1=  右对齐；
694:              			0=  左对齐。
695:              		Bit6  CHS4:  通道选择位
696:              		Bit5~Bit3  未用 
697:              		Bit2  LDO_EN:  内部参考电压使能位。
698:              			1=  使能ADC内部LDO参考电压；
699:              				当选择内部LDO作参考电压时，ADC最大有效精度为8位。
700:              			0=  VDD作为ADC参考电压。
701:              		Bit1~Bit0  LDO_SEL<1:0>:  参考电压选择位
702:              			0X=  2.0V
703:              			10=  2.4V
704:              			11=  3.0V
705:              	*********************************************/
706:              	ADCON1 = 0;
  043E    0196    CLR	0x16
707:              	ANSEL0 = 0X03;	
  043F    3003    LDIA	0x3
  0440    0093    LD	0x13,A
  0441    0008    RET
708:              }
709:              
710:              
711:              void pwmInit()
712:              {
713:              		PWMCON1 = 0B00000000;	//PWM选择D组，死区2禁止，死区1使能，死区时钟源为Fosc/4
  0425    0196    CLR	0x16
714:              		PWMTH = 0X00;			//周期选择为0FF，则周期为（255+1）*1/8M，周期的时钟分频在PWMCON0选择
  0426    0198    CLR	0x18
715:              		PWMTL = 100;			//PWM 周期=[PWMT+1]*Tosc*(CLKDIV 分频值)
  0427    3064    LDIA	0x64
  0428    0097    LD	0x17,A
716:              		
717:              		
718:              		PWMD23H = 0;			//配置PWM1,PWM2的占空比，该值不能超过周期，否者为100%输出
  0429    1683    SETB	0x3,5
  042A    019E    CLR	0x1E
719:              		PWMD2L = 50;			//互补模式，PWM1的占空比与PWM0互补，和设置值无关
  042B    3032    LDIA	0x32
  042C    009B    LD	0x1B,A
720:              		PWM23DT = 0X00;			//死区设为2uS，计算为（3+1）*1/8M*4
  042D    019D    CLR	0x1D
721:              
722:              		PWMCON0 = 0X64;			//打开PWM3 分频比为8
  042E    3064    LDIA	0x64
  042F    1283    CLRB	0x3,5
  0430    0095    LD	0x15,A
723:              		PWMCON2 =0X00;			//PWM4输出反向
  0431    019D    CLR	0x1D
  0432    0008    RET
724:              }
725:              
726:              void pwmStop()
727:              {
728:              	PWMCON0 &= 0XFB;
  0442    1115    CLRB	0x15,2
729:              	RB3 = 0;
  0443    1186    CLRB	0x6,3
  0444    0008    RET
730:              }
731:              
732:              
733:              /***********************************************
734:              函数名称：Sleep_Mode
735:              函数功能：进入休眠模式
736:              入口参数：无
737:              出口参数：无
738:              备注：
739:              ************************************************/
740:              void Sleep_Mode()
741:              {
742:              	INTCON = 0;		
  02BC    018B    CLR	0xB
743:              	
744:              	OPTION_REG = 0;
  02BD    0181    CLR	0x1
745:              
746:              	TRISA = 0x03; 		//关闭所有输出，RA0口做唤醒输入
  02BE    3003    LDIA	0x3
  02BF    1683    SETB	0x3,5
  02C0    0085    LD	0x5,A
747:              	WPUA  = 0B00000000;			//RA0 开上拉电阻
  02C1    0188    CLR	0x8
748:              	PORTA = 0x3C;
  02C2    303C    LDIA	0x3C
  02C3    0086    LD	0x6,A
749:              	TRISB = 0x14;			//关闭所有输出，RB3口做唤醒输入
  02C4    3014    LDIA	0x14
  02C5    1283    CLRB	0x3,5
  02C6    0085    LD	0x5,A
750:              	PORTB = 0x03;
  02C7    3003    LDIA	0x3
  02C8    0086    LD	0x6,A
751:              	WPUB  = 0x10;			//RB2 开上拉电阻
  02C9    3010    LDIA	0x10
  02CA    0088    LD	0x8,A
752:                 			
753:                 	ADCON0 = 0;					//关闭所有模块
  02CB    1683    SETB	0x3,5
  02CC    0195    CLR	0x15
754:              	ADCON1 = 0;
  02CD    0196    CLR	0x16
755:              	
756:              	PWMCON0 = 0;
  02CE    1283    CLRB	0x3,5
  02CF    0195    CLR	0x15
757:              		
758:              	OSCCON = 0X70;				//配置振荡为8M,关闭WDT，需注意芯片工程选项里WDT必须选为DISABLE,否则无法软件关掉WDT
  02D0    3070    LDIA	0x70
  02D1    0094    LD	0x14,A
759:              	
760:              	IOCA = 0B00000000;			//允许RA1的IO电平变化中断
  02D2    1683    SETB	0x3,5
  02D3    0189    CLR	0x9
761:              	IOCB = 0x14;			//允许RB3的IO口电平变化中断
  02D4    3014    LDIA	0x14
  02D5    1283    CLRB	0x3,5
  02D6    0089    LD	0x9,A
762:              	
763:              	RAIE = 1;					//允许PORTA的IO电平变化中断
  02D7    158E    SETB	0xE,3
764:              	PEIE = 1;					//要用RORTA中断唤醒，则PEIE必须设为1
  02D8    170B    SETB	0xB,6
765:              	RBIE = 1;					//允许PORTB电平变化中断
  02D9    158B    SETB	0xB,3
766:              	GIE = 0;					//唤醒后执行SLEEP后程序;
  02DA    138B    CLRB	0xB,7
767:              	
768:              	PIE1 &= 0X08;				//关闭不需要的中断
  02DB    3008    LDIA	0x8
  02DC    058E    ANDR	0xE
769:              	PIR1 = 0;					//必须清不需要的中断标志位
  02DD    018D    CLR	0xD
770:              	INTCON &= 0XC8;				//必须清不需要的中断标志位
  02DE    30C8    LDIA	0xC8
  02DF    058B    ANDR	0xB
771:              
772:              	PORTA;						//读PORTA值并锁存,用电平变化中断必须执行这一步
  02E0    1683    SETB	0x3,5
  02E1    0806    LD	A,0x6
773:              	RAIF = 0;					//清PORTA中断标志位
  02E2    1283    CLRB	0x3,5
  02E3    118D    CLRB	0xD,3
774:              	PORTB;						//读PORTB值并锁存	
  02E4    0806    LD	A,0x6
775:              	RBIF = 0;					//清PORTB中断标志位		
  02E5    100B    CLRB	0xB,0
  02E6    0064    CLRWDT
  02E7    0063    STOP
  02E8    0000    NOP
  02E9    0064    CLRWDT
  02EA    0000    NOP
  02EB    0000    NOP
  02EC    0000    NOP
  02ED    0000    NOP
  02EE    0000    NOP
776:              	asm("clrwdt");
777:              
778:              	asm("sleep");				//进入休眠模式
779:              	
780:              	asm("nop");
781:              	asm("clrwdt");
782:              	asm("nop");
783:              	asm("nop");
784:              	asm("nop");
785:              	asm("nop");
786:              	asm("nop");
787:              	if(RAIF)  RAIF = 0;			//清中断标志
  02EF    1283    CLRB	0x3,5
  02F0    198D    SZB	0xD,3
  02F1    118D    CLRB	0xD,3
788:              	if(RBIF)  RBIF = 0;			//清中断标志
  02F2    180B    SZB	0xB,0
  02F3    100B    CLRB	0xB,0
789:              	if(TMR2IF) TMR2IF = 0;
  02F4    188D    SZB	0xD,1
  02F5    108D    CLRB	0xD,1
790:              	IOCA = 0B00000000;			//允许RA1的IO电平变化中断
  02F6    1683    SETB	0x3,5
  02F7    0189    CLR	0x9
791:              	IOCB = 0B00000000;			//允许RB3的IO口电平变化中断
  02F8    1283    CLRB	0x3,5
  02F9    0189    CLR	0x9
792:              	Init_System();
  02FA    2394    CALL	0x394
793:              	AD_Init();
  02FB    2C3B    JP	0x43B
794:              }
795:              
796:              
797:              
798:              /**********************************************************
799:              函数名称：AD_Sample
800:              函数功能：AD检测
801:              入口参数：adch - 检测通道
802:              出口参数：无
803:              备    注：采样通道需自行设置为输入口
804:              	      采样10次,取中间八次的平均值为采样结果存于adresult中
805:              
806:              	      adch 为输入AD通道 0-15，31
807:                           31  检测内部1.2V
808:              	
809:               		  adldo =5,开启内部LDO 2V 作为ADC 参考
810:               		  adldo =6,开启内部LDO 2.4V 作为ADC 参考
811:              		  adldo =7,开启内部LDO 3V 作为ADC 参考
812:               		  adldo =0,VDD 作为ADC 参考
813:               		  AD转换结果左对齐
814:               		  ADC参考电压从VDD切换到LDO时需要延时100us以上，才能进行AD转换
815:              **********************************************************/
816:              unsigned char ADC_Sample(unsigned char adch, unsigned char adldo) 
  0015    00C7    LD	0x47,A
817:              {
818:              	volatile unsigned long adsum = 0;
819:              	volatile unsigned int admin = 0, admax = 0;
  0016    20ED    CALL	0xED
820:              	volatile unsigned int ad_temp = 0;
  0017    01D1    CLR	0x51
  0018    01D2    CLR	0x52
821:              
822:              	if ((!LDO_EN) && (adldo & 0x04) ) 
  0019    1683    SETB	0x3,5
  001A    1D16    SNZB	0x16,2
  001B    1D72    SNZB	0x72,2
  001C    2824    JP	0x24
823:              	{
824:              								//如果AD参考从VDD换到内部LDO，需要延时100US以上
825:              		ADCON1 = adldo;			//左对齐,AD值取12位
  001D    0872    LD	A,0x72
  001E    0096    LD	0x16,A
826:              		__delay_us(100);		//IDE内置延时函数，延时100us
  001F    3085    LDIA	0x85
  0020    00F3    LD	0x73,A
  0021    0BF3    SZDECR	0x73
  0022    2821    JP	0x21
827:              	} 
  0023    2826    JP	0x26
828:              	else
829:              		ADCON1 = adldo;			//如果ADCON1.7(ADFM)=1为右对齐，,AD值取10位
  0024    0872    LD	A,0x72
  0025    0096    LD	0x16,A
830:              
831:              	if(adch & 0x10) 
  0026    1283    CLRB	0x3,5
  0027    1E47    SNZB	0x47,4
  0028    282E    JP	0x2E
832:              	{
833:              		CHS4 = 1;
  0029    1683    SETB	0x3,5
  002A    1716    SETB	0x16,6
834:              		adch &= 0x0f;
  002B    300F    LDIA	0xF
  002C    1283    CLRB	0x3,5
  002D    05C7    ANDR	0x47
835:              	}
836:              	unsigned char i = 0;
837:              	for (i = 0; i < 10; i++) 
  002E    01C8    CLR	0x48
838:              	{
839:              		ADCON0 = (unsigned char)(0X41 | (adch << 2));	//16分频，如果主频为16M，则必须选16分频或以上
  002F    0847    LD	A,0x47
  0030    00F3    LD	0x73,A
  0031    3001    LDIA	0x1
  0032    1003    CLRB	0x3,0
  0033    0DF3    RLCR	0x73
  0034    3EFF    ADDIA	0xFF
  0035    1003    CLRB	0x3,0
  0036    1D03    SNZB	0x3,2
  0037    2833    JP	0x33
  0038    0D73    RLCA	0x73
  0039    3841    ORIA	0x41
  003A    1683    SETB	0x3,5
  003B    0095    LD	0x15,A
  003C    0000    NOP
  003D    0000    NOP
  003E    0000    NOP
  003F    0000    NOP
840:              		asm("nop");
841:              		asm("nop");
842:              		asm("nop");
843:              		asm("nop");				//选择通道后需延时1uS以上
844:              		GODONE = 1;				//开始转换
  0040    1683    SETB	0x3,5
  0041    1495    SETB	0x15,1
845:              
846:              		unsigned char j = 0;
  0042    1283    CLRB	0x3,5
  0043    01C6    CLR	0x46
847:              		while (GODONE) 
  0044    1683    SETB	0x3,5
  0045    1C95    SNZB	0x15,1
  0046    284F    JP	0x4F
848:              		{
849:              			__delay_us(2);		//延时2us(编译器内置函数)
  0047    2848    JP	0x48
  0048    2849    JP	0x49
  0049    284A    JP	0x4A
  004A    284B    JP	0x4B
850:              
851:              			if (0 == (--j))		//延时0.5ms仍没有AD转换结束，跳出程序
  004B    1283    CLRB	0x3,5
  004C    0BC6    SZDECR	0x46
  004D    2844    JP	0x44
852:              			return 0;
  004E    3400    RET	0x0
853:              		}
854:              
855:              		ad_temp = (unsigned int)((ADRESH << 4) + (ADRESL >> 4));	//计算12位AD值
  004F    0819    LD	A,0x19
  0050    1283    CLRB	0x3,5
  0051    00D1    LD	0x51,A
  0052    01D2    CLR	0x52
  0053    0ED1    SWAPR	0x51
  0054    0ED2    SWAPR	0x52
  0055    30F0    LDIA	0xF0
  0056    05D2    ANDR	0x52
  0057    0851    LD	A,0x51
  0058    390F    ANDIA	0xF
  0059    04D2    ORR	0x52
  005A    30F0    LDIA	0xF0
  005B    05D1    ANDR	0x51
  005C    1683    SETB	0x3,5
  005D    0E18    SWAPA	0x18
  005E    390F    ANDIA	0xF
  005F    1283    CLRB	0x3,5
  0060    07D1    ADDR	0x51
  0061    1803    SZB	0x3,0
  0062    0AD2    INCR	0x52
856:              
857:              		if (0 == admax) 
  0063    084F    LD	A,0x4F
  0064    0450    ORA	0x50
  0065    1D03    SNZB	0x3,2
  0066    2869    JP	0x69
858:              		{
859:              			admax = ad_temp;
  0067    20F6    CALL	0xF6
  0068    287B    JP	0x7B
860:              			admin = ad_temp;
861:              		} 
862:              		else if (ad_temp > admax)
  0069    0852    LD	A,0x52
  006A    0250    SUBA	0x50
  006B    1D03    SNZB	0x3,2
  006C    286F    JP	0x6F
  006D    0851    LD	A,0x51
  006E    024F    SUBA	0x4F
  006F    1803    SZB	0x3,0
  0070    2873    JP	0x73
863:              			admax = ad_temp;				//AD采样最大值
  0071    20F6    CALL	0xF6
  0072    287F    JP	0x7F
864:              		else if (ad_temp < admin)
  0073    084E    LD	A,0x4E
  0074    0252    SUBA	0x52
  0075    1D03    SNZB	0x3,2
  0076    2879    JP	0x79
  0077    084D    LD	A,0x4D
  0078    0251    SUBA	0x51
  0079    1803    SZB	0x3,0
  007A    287F    JP	0x7F
865:              			admin = ad_temp;				//AD采样最小值
  007B    0852    LD	A,0x52
  007C    00CE    LD	0x4E,A
  007D    0851    LD	A,0x51
  007E    00CD    LD	0x4D,A
866:              
867:              		adsum += ad_temp;
  007F    0851    LD	A,0x51
  0080    00F3    LD	0x73,A
  0081    0852    LD	A,0x52
  0082    00F4    LD	0x74,A
  0083    01F5    CLR	0x75
  0084    01F6    CLR	0x76
  0085    0873    LD	A,0x73
  0086    07C9    ADDR	0x49
  0087    0874    LD	A,0x74
  0088    1103    CLRB	0x3,2
  0089    1803    SZB	0x3,0
  008A    3E01    ADDIA	0x1
  008B    1D03    SNZB	0x3,2
  008C    07CA    ADDR	0x4A
  008D    0875    LD	A,0x75
  008E    1103    CLRB	0x3,2
  008F    1803    SZB	0x3,0
  0090    3E01    ADDIA	0x1
  0091    1D03    SNZB	0x3,2
  0092    07CB    ADDR	0x4B
  0093    0876    LD	A,0x76
  0094    1103    CLRB	0x3,2
  0095    1803    SZB	0x3,0
  0096    3E01    ADDIA	0x1
  0097    1D03    SNZB	0x3,2
  0098    07CC    ADDR	0x4C
  0099    300A    LDIA	0xA
  009A    0AC8    INCR	0x48
  009B    0248    SUBA	0x48
  009C    1C03    SNZB	0x3,0
  009D    282F    JP	0x2F
868:              	}
869:              		adsum -= admax;
  009E    084F    LD	A,0x4F
  009F    00F3    LD	0x73,A
  00A0    0850    LD	A,0x50
  00A1    20DE    CALL	0xDE
  00A2    1C03    SNZB	0x3,0
  00A3    0F76    SZINCA	0x76
  00A4    02CC    SUBR	0x4C
870:              		if (adsum >= admin)
  00A5    084D    LD	A,0x4D
  00A6    00F3    LD	0x73,A
  00A7    084E    LD	A,0x4E
  00A8    00F4    LD	0x74,A
  00A9    01F5    CLR	0x75
  00AA    01F6    CLR	0x76
  00AB    0876    LD	A,0x76
  00AC    024C    SUBA	0x4C
  00AD    1D03    SNZB	0x3,2
  00AE    28B9    JP	0xB9
  00AF    0875    LD	A,0x75
  00B0    024B    SUBA	0x4B
  00B1    1D03    SNZB	0x3,2
  00B2    28B9    JP	0xB9
  00B3    0874    LD	A,0x74
  00B4    024A    SUBA	0x4A
  00B5    1D03    SNZB	0x3,2
  00B6    28B9    JP	0xB9
  00B7    0873    LD	A,0x73
  00B8    0249    SUBA	0x49
  00B9    1C03    SNZB	0x3,0
  00BA    28C3    JP	0xC3
871:              			adsum -= admin;
  00BB    084D    LD	A,0x4D
  00BC    00F3    LD	0x73,A
  00BD    084E    LD	A,0x4E
  00BE    20DE    CALL	0xDE
  00BF    1C03    SNZB	0x3,0
  00C0    0F76    SZINCA	0x76
  00C1    02CC    SUBR	0x4C
  00C2    28C7    JP	0xC7
872:              		else
873:              			adsum = 0;
  00C3    01C9    CLR	0x49
  00C4    01CA    CLR	0x4A
  00C5    01CB    CLR	0x4B
  00C6    01CC    CLR	0x4C
874:              
875:              		adresult = adsum >> 3;		//8次平均值作为最终结果
  00C7    0849    LD	A,0x49
  00C8    00F3    LD	0x73,A
  00C9    084A    LD	A,0x4A
  00CA    00F4    LD	0x74,A
  00CB    084B    LD	A,0x4B
  00CC    00F5    LD	0x75,A
  00CD    084C    LD	A,0x4C
  00CE    00F6    LD	0x76,A
  00CF    3003    LDIA	0x3
  00D0    1003    CLRB	0x3,0
  00D1    0CF6    RRCR	0x76
  00D2    0CF5    RRCR	0x75
  00D3    0CF4    RRCR	0x74
  00D4    0CF3    RRCR	0x73
  00D5    3EFF    ADDIA	0xFF
  00D6    1D03    SNZB	0x3,2
  00D7    28D0    JP	0xD0
  00D8    0874    LD	A,0x74
  00D9    00B1    LD	0x31,A
  00DA    0873    LD	A,0x73
  00DB    00B0    LD	0x30,A
876:              
877:              		adsum = 0;
878:              		admin = 0;
879:              		admax = 0;
  00DC    20ED    CALL	0xED
880:              		return 0xA5;
  00DD    34A5    RET	0xA5
881:              		
882:              }
883:              
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\lbmod.c ----------------------------------------------------------------------
1:                // byte unsigned modulus
2:                
3:                unsigned char
4:                __lbmod(unsigned char dividend, unsigned char divisor)
  03D5    00F4    LD	0x74,A
  03D6    3008    LDIA	0x8
  03D7    00F5    LD	0x75,A
  03D8    01F6    CLR	0x76
  03D9    0874    LD	A,0x74
  03DA    00F3    LD	0x73,A
  03DB    3007    LDIA	0x7
  03DC    1003    CLRB	0x3,0
  03DD    0CF3    RRCR	0x73
  03DE    3EFF    ADDIA	0xFF
  03DF    1003    CLRB	0x3,0
  03E0    1D03    SNZB	0x3,2
  03E1    2BDD    JP	0x3DD
  03E2    0D76    RLCA	0x76
  03E3    0473    ORA	0x73
  03E4    00F6    LD	0x76,A
  03E5    1003    CLRB	0x3,0
  03E6    0DF4    RLCR	0x74
  03E7    0872    LD	A,0x72
  03E8    0276    SUBA	0x76
  03E9    1C03    SNZB	0x3,0
  03EA    2BED    JP	0x3ED
  03EB    0872    LD	A,0x72
  03EC    02F6    SUBR	0x76
  03ED    0BF5    SZDECR	0x75
  03EE    2BD9    JP	0x3D9
  03EF    0876    LD	A,0x76
  03F0    0008    RET
5:                {
6:                	unsigned char	rem;
7:                	unsigned char	counter;
8:                
9:                	counter = 8;
10:               	rem = 0;
11:               	do {
12:               		rem = (rem << 1) | (dividend >> 7);
13:               		dividend <<= 1;
14:               		if(divisor <= rem)
15:               			rem -= divisor;
16:               	} while(--counter != 0);
17:               	return rem;
18:               }
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\lbdiv.c ----------------------------------------------------------------------
1:                // byte unsigned division
2:                
3:                unsigned char
4:                __lbdiv(unsigned char dividend, unsigned char divisor)
  03F1    00F3    LD	0x73,A
  03F2    01F5    CLR	0x75
  03F3    0872    LD	A,0x72
  03F4    1903    SZB	0x3,2
  03F5    2C0A    JP	0x40A
  03F6    01F4    CLR	0x74
  03F7    0AF4    INCR	0x74
  03F8    1BF2    SZB	0x72,7
  03F9    2BFD    JP	0x3FD
  03FA    1003    CLRB	0x3,0
  03FB    0DF2    RLCR	0x72
  03FC    2BF7    JP	0x3F7
  03FD    1003    CLRB	0x3,0
  03FE    0DF5    RLCR	0x75
  03FF    0872    LD	A,0x72
  0400    0273    SUBA	0x73
  0401    1C03    SNZB	0x3,0
  0402    2C07    JP	0x407
  0403    0872    LD	A,0x72
  0404    02F3    SUBR	0x73
  0405    1475    SETB	0x75,0
  0406    1003    CLRB	0x3,0
  0407    0CF2    RRCR	0x72
  0408    0BF4    SZDECR	0x74
  0409    2BFD    JP	0x3FD
  040A    0875    LD	A,0x75
  040B    0008    RET
5:                {
6:                	unsigned char	quotient;
7:                	unsigned char	counter;
8:                
9:                	quotient = 0;
10:               	if(divisor != 0) {
11:               		counter = 1;
12:               		while((divisor & 0x80) == 0) {
13:               			divisor <<= 1;
14:               			counter++;
15:               		}
16:               		do {
17:               			quotient <<= 1;
18:               			if(divisor <= dividend) {
19:               				dividend -= divisor;
20:               				quotient |= 1;
21:               			}
22:               			divisor >>= 1;
23:               		} while(--counter != 0);
24:               	}
25:               	return quotient;
26:               }
---- stringtab ------------------------------------------------------------------
---- reset_enter ------------------------------------------------------------------
  0000    280A    JP	0xA
  000A    280B    JP	0xB
---- start_initialization ------------------------------------------------------------------
  000B    3020    LDIA	0x20
  000C    01F9    CLR	0x79
  000D    01FA    CLR	0x7A
  000E    01FB    CLR	0x7B
  000F    1383    CLRB	0x3,7
  0010    0084    LD	0x4,A
  0011    3046    LDIA	0x46
  0012    2433    CALL	0x433
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F0    LD	0x70,A
  0007    080A    LD	A,0xA
  0008    00F1    LD	0x71,A
  0009    2C0C    JP	0x40C
---- common_function ------------------------------------------------------------------
  0013    0183    CLR	0x3
  0014    2AFC    JP	0x2FC
  00DE    00F4    LD	0x74,A
  00DF    01F5    CLR	0x75
  00E0    01F6    CLR	0x76
  00E1    0873    LD	A,0x73
  00E2    02C9    SUBR	0x49
  00E3    0874    LD	A,0x74
  00E4    1C03    SNZB	0x3,0
  00E5    0F74    SZINCA	0x74
  00E6    02CA    SUBR	0x4A
  00E7    0875    LD	A,0x75
  00E8    1C03    SNZB	0x3,0
  00E9    0F75    SZINCA	0x75
  00EA    02CB    SUBR	0x4B
  00EB    0876    LD	A,0x76
  00EC    0008    RET
  00ED    01C9    CLR	0x49
  00EE    01CA    CLR	0x4A
  00EF    01CB    CLR	0x4B
  00F0    01CC    CLR	0x4C
  00F1    01CD    CLR	0x4D
  00F2    01CE    CLR	0x4E
  00F3    01CF    CLR	0x4F
  00F4    01D0    CLR	0x50
  00F5    0008    RET
  00F6    0852    LD	A,0x52
  00F7    00D0    LD	0x50,A
  00F8    0851    LD	A,0x51
  00F9    00CF    LD	0x4F,A
  00FA    0008    RET
  0433    0064    CLRWDT
  0434    0180    CLR	0x0
  0435    0A84    INCR	0x4
  0436    0604    XORA	0x4
  0437    1903    SZB	0x3,2
  0438    3400    RET	0x0
  0439    0604    XORA	0x4
  043A    2C34    JP	0x434
