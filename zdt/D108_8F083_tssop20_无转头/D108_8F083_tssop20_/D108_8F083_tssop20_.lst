---- C:\mcuproject\scm\zdt\D108_8F083_tssop20_无转头\D108_8F083_tssop20_\main.c ----------------------------------------------------------------------
1:                #include <sc.h>
2:                #include "Touch_Kscan_Library.h"
3:                
4:                #ifndef _XTAL_FREQ
5:                #define _XTAL_FREQ 8000000			//8MHz,使用内置延时函数必须定义主频，
6:                									//如用16M需改此参数为16000000
7:                #endif
8:                #define     POWER_RATIO  	(4096UL*1.2*1000)
9:                
10:               #define		uchar		unsigned char
11:               #define		u8t		unsigned char
12:               #define		uint			unsigned int
13:               #define		u16t			unsigned int
14:               #define		ulong		unsigned long
15:               #define		MOT1		RA5
16:               #define		MOT2		RA6
17:               #define		MOT3		RA7
18:               #define		MOT4		RB7
19:               
20:               volatile unsigned char MainTime;
21:               volatile bit	B_MainLoop,B_OnOff;
22:               u8t	count1s = 0;
23:               u8t	workStep = 0;
24:               u8t	wuhuaFlag = 0;
25:               u16t		shanshuoTime = 0;
26:               u16t		shanshuoTime2 = 0;
27:               u16t		shanshuoTime3 = 0;
28:               u16t		fanValue = 0;
29:               u16t		wuhuaValue = 0;
30:               u8t	fanDuty = 0;
31:               u8t	count10s = 0;
32:               u8t	fanOverTime = 0;
33:               u8t	firstTime = 0;
34:               u16t	checkTime = 0;
35:               u16t	lowWaterTime = 0;
36:               u8t		chrgFlag = 0;
37:               u8t		chrgFullFlag = 0;
38:               u8t		chrgFullTime = 0;
39:               u8t		firstLock = 0;
40:               u8t		lowBatLock = 0;
41:               u16t		lowBatTime = 0;	
42:               u8t		lowFanTime = 0;//风扇降低为1档的时间
43:               u8t		bujinFlag = 0;	
44:               u16t	motorStep = 0;
45:               u16t	maxMotorStep = 0;
46:               u8t		powerFlag = 0;
47:               u8t		longKeyFlag = 0;
48:               u16t		keyCount = 0;
49:               u8t		closeTime = 0;
50:               
51:               volatile unsigned int adresult;
52:               volatile unsigned int result;
53:               volatile unsigned char test_adc;
54:               volatile unsigned int power_ad;
55:               
56:               void chrgCtr();
57:               unsigned char ADC_Sample(unsigned char adch, unsigned char adldo);
58:               
59:               //系统初始化
60:               void Init_System()
  0020    0000    NOP
  0021    0064    CLRWDT
61:               {
62:               	asm("nop");
63:               	asm("clrwdt");
64:               	INTCON = 0;				//禁止中断
  0022    018B    CLR	0xB
65:               	OSCCON = 0X72;			//配置振荡为8M
  0023    3072    LDIA	0x72
  0024    1283    CLRB	0x3,5
  0025    1303    CLRB	0x3,6
  0026    0094    LD	0x14,A
66:               	OPTION_REG = 0;
  0027    0181    CLR	0x1
67:               	
68:               	
69:               	//延时等待电源电压稳定
70:               	//DelayXms(200);
71:               	TRISA = 0x04;
  0028    3004    LDIA	0x4
  0029    1683    SETB	0x3,5
  002A    0085    LD	0x5,A
72:               	PORTA = 0;
  002B    0186    CLR	0x6
73:               	TRISB = 0x20;
  002C    3020    LDIA	0x20
  002D    1283    CLRB	0x3,5
  002E    0085    LD	0x5,A
74:               	PORTB = 0;
  002F    0186    CLR	0x6
75:               	WPUB = 0x00;
  0030    0188    CLR	0x8
76:               	TRISC = 0;
  0031    1703    SETB	0x3,6
  0032    0185    CLR	0x5
77:               	PORTC = 0;
  0033    0186    CLR	0x6
78:               
79:               	PIE1 = 2;
  0034    3002    LDIA	0x2
  0035    1303    CLRB	0x3,6
  0036    008E    LD	0xE,A
80:               	PR2 = 250;				//8M下将TMR2设置为125us中断
  0037    30FA    LDIA	0xFA
  0038    0091    LD	0x11,A
81:               	T2CON = 4;				//使能定时器2
  0039    3004    LDIA	0x4
  003A    0093    LD	0x13,A
82:               
83:               	INTCON = 0XC0;			//使能中断
  003B    30C0    LDIA	0xC0
  003C    008B    LD	0xB,A
84:               	ADCON0 = 0X41;
85:               	ADON = 1;
86:               	ADCON1 = 0x00;
  003D    2BE4    JP	0x3E4
87:               }
88:               
89:               
90:               /**********************************************************
91:               函数名称：Refurbish_Sfr
92:               函数功能：刷新一些特殊功能寄存器
93:               入口参数：无
94:               出口参数：无
95:               备    注：每隔一定时间刷新一次SFR可增强抗干扰能力
96:               **********************************************************/
97:               void Refurbish_Sfr() 
98:               {
99:               	//刷新中断相关控制寄存器
100:              	PIE1 = 2;
  0384    3002    LDIA	0x2
  0385    1283    CLRB	0x3,5
  0386    008E    LD	0xE,A
101:              	PR2 = 250;
  0387    30FA    LDIA	0xFA
  0388    0091    LD	0x11,A
102:              	INTCON = 0XC0;
  0389    30C0    LDIA	0xC0
  038A    008B    LD	0xB,A
103:              	if (4 != T2CON)
  038B    3004    LDIA	0x4
  038C    0613    XORA	0x13
  038D    1903    SZB	0x3,2
  038E    0008    RET
104:              		T2CON = 4;
  038F    3004    LDIA	0x4
  0390    0093    LD	0x13,A
  0391    0008    RET
105:              }
106:              
107:              
108:              /***********************************************************
109:              键处理函数
110:              ***********************************************************/
111:              void KeyServer() 
112:              {
113:              	static unsigned char KeyOldFlag = 0;
114:              	if (KeyFlag[0]) 
  0EF8    0832    LD	A,0x32
  0EF9    1903    SZB	0x3,2
  0EFA    2F6C    JP	0x76C
115:              	{
116:              		if (KeyFlag[0] != KeyOldFlag) 
  0EFB    0832    LD	A,0x32
  0EFC    063A    XORA	0x3A
  0EFD    1903    SZB	0x3,2
  0EFE    2F48    JP	0x748
117:              		{
118:              			//确定状态改变的按键
119:              			KeyOldFlag ^= KeyFlag[0];
  0EFF    0832    LD	A,0x32
  0F00    06BA    XORR	0x3A
120:              			if ((KeyOldFlag & 0x1) && (KeyFlag[0] & 0x1) && firstLock == 0 && powerFlag > 0) 
  0F01    183A    SZB	0x3A,0
  0F02    1C32    SNZB	0x32,0
  0F03    2F24    JP	0x724
  0F04    1683    SETB	0x3,5
  0F05    084B    LD	A,0x4B
  0F06    1D03    SNZB	0x3,2
  0F07    2F24    JP	0x724
  0F08    1283    CLRB	0x3,5
  0F09    083E    LD	A,0x3E
  0F0A    1903    SZB	0x3,2
  0F0B    2F24    JP	0x724
121:              			{
122:              				//KEY1被按下
123:              				if(lowBatLock == 1)
  0F0C    0B41    SZDECA	0x41
  0F0D    2F13    JP	0x713
124:              				{
125:              					shanshuoTime2 = 450;
  0F0E    30C2    LDIA	0xC2
  0F0F    00AE    LD	0x2E,A
  0F10    3001    LDIA	0x1
  0F11    00AF    LD	0x2F,A
126:              				}
  0F12    2F18    JP	0x718
127:              				else if(++wuhuaFlag > 2)
  0F13    3003    LDIA	0x3
  0F14    0AC8    INCR	0x48
  0F15    0248    SUBA	0x48
  0F16    1803    SZB	0x3,0
128:              				{
129:              					wuhuaFlag = 0;
  0F17    01C8    CLR	0x48
130:              				}
131:              				if(wuhuaFlag >= 2)
  0F18    3002    LDIA	0x2
  0F19    0248    SUBA	0x48
  0F1A    1C03    SNZB	0x3,0
  0F1B    2F22    JP	0x722
132:              				{
133:              					shanshuoTime2 = 450;
  0F1C    30C2    LDIA	0xC2
  0F1D    00AE    LD	0x2E,A
  0F1E    3001    LDIA	0x1
  0F1F    00AF    LD	0x2F,A
134:              					count10s = 0;
  0F20    01C6    CLR	0x46
135:              				}
  0F21    2F24    JP	0x724
136:              				else
137:              				{
138:              					shanshuoTime2 = 0;
  0F22    01AE    CLR	0x2E
  0F23    01AF    CLR	0x2F
139:              				}
140:              			}
141:              			if ((KeyOldFlag & 0x2) && (KeyFlag[0] & 0x2) && firstLock == 0 && powerFlag > 0) 
  0F24    1283    CLRB	0x3,5
  0F25    18BA    SZB	0x3A,1
  0F26    1CB2    SNZB	0x32,1
  0F27    2F45    JP	0x745
  0F28    1683    SETB	0x3,5
  0F29    084B    LD	A,0x4B
  0F2A    1D03    SNZB	0x3,2
  0F2B    2F45    JP	0x745
  0F2C    1283    CLRB	0x3,5
  0F2D    083E    LD	A,0x3E
  0F2E    1903    SZB	0x3,2
  0F2F    2F45    JP	0x745
142:              			{
143:              				//KEY2被按下
144:              				if(lowBatLock == 1)
  0F30    0B41    SZDECA	0x41
  0F31    2F35    JP	0x735
145:              				{
146:              					shanshuoTime = 450;
  0F32    2771    CALL	0x771
  0F33    158A    SETB	0xA,3
147:              				}
  0F34    2F3C    JP	0x73C
148:              				else if(++workStep > 3)
  0F35    3004    LDIA	0x4
  0F36    0AFB    INCR	0x7B
  0F37    027B    SUBA	0x7B
  0F38    1C03    SNZB	0x3,0
  0F39    2F3C    JP	0x73C
149:              				{
150:              					workStep = 0;
  0F3A    01FB    CLR	0x7B
151:              					bujinFlag = 0;
  0F3B    01BF    CLR	0x3F
152:              				}
153:              				if(workStep >= 2)
  0F3C    3002    LDIA	0x2
  0F3D    027B    SUBA	0x7B
  0F3E    1C03    SNZB	0x3,0
  0F3F    2F43    JP	0x743
154:              				{
155:              					shanshuoTime = 450;
  0F40    2771    CALL	0x771
  0F41    158A    SETB	0xA,3
156:              				}
  0F42    2F45    JP	0x745
157:              				else
158:              				{
159:              					shanshuoTime = 0;
  0F43    01B0    CLR	0x30
  0F44    01B1    CLR	0x31
160:              				}
161:              				
162:              			}
163:              
164:              			KeyOldFlag = KeyFlag[0];
  0F45    1283    CLRB	0x3,5
  0F46    0832    LD	A,0x32
  0F47    00BA    LD	0x3A,A
165:              		}
166:              		if(firstLock == 0 && KeyOldFlag & 0x4)
  0F48    1683    SETB	0x3,5
  0F49    084B    LD	A,0x4B
  0F4A    1D03    SNZB	0x3,2
  0F4B    0008    RET
  0F4C    1283    CLRB	0x3,5
  0F4D    1D3A    SNZB	0x3A,2
  0F4E    0008    RET
167:              		{
168:              			if(++keyCount >= 400)
  0F4F    0AA4    INCR	0x24
  0F50    1903    SZB	0x3,2
  0F51    0AA5    INCR	0x25
  0F52    3001    LDIA	0x1
  0F53    0225    SUBA	0x25
  0F54    3090    LDIA	0x90
  0F55    1903    SZB	0x3,2
  0F56    0224    SUBA	0x24
  0F57    1C03    SNZB	0x3,0
  0F58    0008    RET
169:              			{
170:              				keyCount = 0;
  0F59    01A4    CLR	0x24
  0F5A    01A5    CLR	0x25
171:              				if(longKeyFlag == 0)
  0F5B    083D    LD	A,0x3D
  0F5C    1D03    SNZB	0x3,2
  0F5D    0008    RET
172:              				{
173:              					longKeyFlag = 1;
  0F5E    01BD    CLR	0x3D
  0F5F    0ABD    INCR	0x3D
174:              					if(powerFlag > 0)
  0F60    083E    LD	A,0x3E
  0F61    1903    SZB	0x3,2
  0F62    2F67    JP	0x767
175:              					{
176:              						powerFlag = 0;
  0F63    01BE    CLR	0x3E
177:              						workStep = 0;
  0F64    01FB    CLR	0x7B
178:              						wuhuaFlag = 0;
  0F65    01C8    CLR	0x48
179:              					}
  0F66    0008    RET
180:              					else
181:              					{
182:              						powerFlag = 1;
  0F67    01BE    CLR	0x3E
  0F68    0ABE    INCR	0x3E
183:              						workStep = 1;
  0F69    01FB    CLR	0x7B
  0F6A    0AFB    INCR	0x7B
  0F6B    0008    RET
184:              					}
185:              				}
186:              			}
187:              		}
188:              	} 
189:              	else 
190:              	{
191:              		KeyOldFlag = 0;
  0F6C    01BA    CLR	0x3A
192:              		longKeyFlag = 0;
  0F6D    01BD    CLR	0x3D
193:              		keyCount = 0;
  0F6E    01A4    CLR	0x24
  0F6F    01A5    CLR	0x25
  0F70    0008    RET
194:              	}
195:              }
196:              
197:              
198:              /***********************************************************
199:              中断服务函数
200:              ***********************************************************/
201:              void interrupt Isr_Timer()
202:              {
203:              	if(TMR2IF)				//若只使能了一个中断源,可以略去判断
  0E62    1283    CLRB	0x3,5
  0E63    1303    CLRB	0x3,6
  0E64    1C8D    SNZB	0xD,1
  0E65    2E75    JP	0x675
204:              	{
205:              		TMR2IF = 0;
  0E66    108D    CLRB	0xD,1
206:              		if(++MainTime >= 32)	//需根据你选择的触摸路数和触摸电容选择扫描一次按键的时间
  0E67    3020    LDIA	0x20
  0E68    0ACA    INCR	0x4A
  0E69    024A    SUBA	0x4A
  0E6A    1C03    SNZB	0x3,0
  0E6B    2E76    JP	0x676
207:              		{						//一般103电容，8路触摸，8M主频检测时间约4ms，故扫描一次的时间可选5ms
208:              			MainTime = 0;
  0E6C    01CA    CLR	0x4A
209:              			B_MainLoop = 1;
  0E6D    1778    SETB	0x78,6
210:              			if(++count1s >= 250)
  0E6E    30FA    LDIA	0xFA
  0E6F    0AC9    INCR	0x49
  0E70    0249    SUBA	0x49
  0E71    1C03    SNZB	0x3,0
  0E72    2E76    JP	0x676
211:              			{
212:              				count1s = 0;
  0E73    01C9    CLR	0x49
  0E74    2E76    JP	0x676
213:              			}
214:              		}
215:              	}
216:              	else
217:              	{
218:              		PIR1 = 0;
  0E75    018D    CLR	0xD
  0E76    0871    LD	A,0x71
  0E77    008A    LD	0xA,A
  0E78    0E70    SWAPA	0x70
  0E79    0083    LD	0x3,A
  0E7A    0EFE    SWAPR	0x7E
  0E7B    0E7E    SWAPA	0x7E
  0E7C    0009    RETI
219:              	}
220:              	
221:              }
222:              
223:              void WorkSleep()
224:              {
225:              #if (0 != C_KEY_WAKEUP)
226:              	static unsigned char time;
227:              	
228:              	if(B_OnOff)time = 0;
  003E    1AF8    SZB	0x78,5
  003F    01B9    CLR	0x39
229:              	
230:              	if(++time >= 125)
  0040    307D    LDIA	0x7D
  0041    0AB9    INCR	0x39
  0042    0239    SUBA	0x39
  0043    1C03    SNZB	0x3,0
  0044    0008    RET
231:              	{
232:              		time = 0;
  0045    01B9    CLR	0x39
233:              		INTCON = 0;			//;关断ADC模块及中断使能；
  0046    018B    CLR	0xB
234:              		PIE1 = 0;
  0047    018E    CLR	0xE
235:              		PIE2 = 0;
  0048    1703    SETB	0x3,6
  0049    0190    CLR	0x10
236:              		PIR1 = 0;
  004A    1303    CLRB	0x3,6
  004B    018D    CLR	0xD
237:              		PIR2 = 0;
  004C    1703    SETB	0x3,6
  004D    018F    CLR	0xF
238:              		T2CON = 0;
  004E    1303    CLRB	0x3,6
  004F    0193    CLR	0x13
239:              		ADCON1 = 0;
  0050    1683    SETB	0x3,5
  0051    0196    CLR	0x16
240:              
241:              		//进入休眠前关掉所有功能模块,以降低休眠电流
242:              		ADCON0 = 0;
  0052    0195    CLR	0x15
243:              	
244:              		//进入休眠前,必须固定口线电平,这儿全部输出低电平,并关闭所有上拉电阻
245:              		PORTA = 0x01;
  0053    3001    LDIA	0x1
  0054    0086    LD	0x6,A
246:              		PORTB = 0x02;
  0055    3002    LDIA	0x2
  0056    1283    CLRB	0x3,5
  0057    0086    LD	0x6,A
247:              		TRISC = 0;
  0058    1703    SETB	0x3,6
  0059    0185    CLR	0x5
248:              		PORTC = 0x03;
  005A    3003    LDIA	0x3
  005B    0086    LD	0x6,A
249:              
250:              		TRISB5 =1;//输入
  005C    1303    CLRB	0x3,6
  005D    1685    SETB	0x5,5
251:              		//WPUB7 = 1;//上拉			
252:              		RBIF = 0;//清标志
  005E    100B    CLRB	0xB,0
253:              		RBIE = 1; //允许PB口电平变化中断
  005F    158B    SETB	0xB,3
254:              		IOCB5= 1;//允许PB0电平变化中断
  0060    1689    SETB	0x9,5
255:              		PORTB;//读一次PB口
  0061    0806    LD	A,0x6
256:              		PORTB &= 0xFD;	
  0062    1086    CLRB	0x6,1
257:              /****如需要PA口中断唤醒，使能下列程序并按需修改****
258:              			TRISA0 =1;	//输入
259:              			WPUA0 = 1;	//上拉			
260:              			RAIF = 0;	//清标志
261:              			RAIE = 1;	//允许PA口电平变化中断
262:              			IOCA0 = 1;	//允许PA0电平变化中断
263:              			PEIE = 1;	//允许外设中断
264:              			PORTA;		//读一次PA口			
265:              ************************************/	
266:              
267:              		//进入休眠模式,触摸允许唤醒的按键后恢复正常工作
268:              		SystemEnterSleep();
  0063    209A    CALL	0x9A
  0064    118A    CLRB	0xA,3
269:              		if(RAIF) 
  0065    1D8D    SNZB	0xD,3
  0066    286A    JP	0x6A
270:              		{
271:              			RAIF = 0;
  0067    118D    CLRB	0xD,3
272:              			PORTA;
  0068    1683    SETB	0x3,5
  0069    0806    LD	A,0x6
273:              		}
274:              		//休眠被唤醒,重新配置中断等SFR,使系统进入正常工作
275:              		Refurbish_Sfr();
  006A    2384    CALL	0x384
  006B    118A    CLRB	0xA,3
276:              		ADCON0 = 0X41;
277:              		ADON = 1;
278:              		ADCON1 = 0x00;
  006C    2BE4    JP	0x3E4
279:              	}
280:              #endif
281:              }
282:              
283:              
284:              /**********************************************************
285:              函数名称：AD_Sample
286:              函数功能：AD检测
287:              入口参数：adch - 检测通道
288:              出口参数：无
289:              备    注：采样通道需自行设置为输入口
290:              	      采样10次,取中间八次的平均值为采样结果存于adresult中
291:              
292:              	      adch 为输入AD通道 0-15，31
293:                           31  检测内部1.2V
294:              	
295:               		  adldo =5,开启内部LDO 2V 作为ADC 参考
296:               		  adldo =6,开启内部LDO 2.4V 作为ADC 参考
297:              		  adldo =7,开启内部LDO 3V 作为ADC 参考
298:               		  adldo =0,VDD 作为ADC 参考
299:               		  AD转换结果左对齐
300:               		  ADC参考电压从VDD切换到LDO时需要延时100us以上，才能进行AD转换
301:              **********************************************************/
302:              unsigned char ADC_Sample(unsigned char adch, unsigned char adldo) 
  0582    1283    CLRB	0x3,5
  0583    00CE    LD	0x4E,A
303:              {
304:              	volatile unsigned long adsum = 0;
305:              	volatile unsigned int admin = 0, admax = 0;
  0584    27AE    CALL	0x7AE
  0585    118A    CLRB	0xA,3
306:              	volatile unsigned int ad_temp = 0;
  0586    01D8    CLR	0x58
  0587    01D9    CLR	0x59
307:              
308:              	if ((!LDO_EN) && (adldo & 0x04) ) 
  0588    1683    SETB	0x3,5
  0589    1D16    SNZB	0x16,2
  058A    1D72    SNZB	0x72,2
  058B    2D94    JP	0x594
309:              	{
310:              								//如果AD参考从VDD换到内部LDO，需要延时100US以上
311:              		ADCON1 = adldo;			//左对齐,AD值取12位
  058C    0872    LD	A,0x72
  058D    0096    LD	0x16,A
312:              		__delay_us(100);		//IDE内置延时函数，延时100us
  058E    3042    LDIA	0x42
  058F    00F3    LD	0x73,A
  0590    0BF3    SZDECR	0x73
  0591    2D90    JP	0x590
  0592    0000    NOP
313:              	} 
  0593    2D96    JP	0x596
314:              	else
315:              		ADCON1 = adldo;			//如果ADCON1.7(ADFM)=1为右对齐，,AD值取10位
  0594    0872    LD	A,0x72
  0595    0096    LD	0x16,A
316:              
317:              	if(adch & 0x10) 
  0596    1283    CLRB	0x3,5
  0597    1303    CLRB	0x3,6
  0598    1E4E    SNZB	0x4E,4
  0599    2D9F    JP	0x59F
318:              	{
319:              		CHS4 = 1;
  059A    1683    SETB	0x3,5
  059B    1716    SETB	0x16,6
320:              		adch &= 0x0f;
  059C    300F    LDIA	0xF
  059D    1283    CLRB	0x3,5
  059E    05CE    ANDR	0x4E
321:              	}
322:              	unsigned char i = 0;
323:              	for (i = 0; i < 10; i++) 
  059F    01CF    CLR	0x4F
324:              	{
325:              		ADCON0 = (unsigned char)(0X41 | (adch << 2));	//16分频，如果主频为16M，则必须选16分频或以上
  05A0    084E    LD	A,0x4E
  05A1    00F3    LD	0x73,A
  05A2    3001    LDIA	0x1
  05A3    1003    CLRB	0x3,0
  05A4    0DF3    RLCR	0x73
  05A5    3EFF    ADDIA	0xFF
  05A6    1003    CLRB	0x3,0
  05A7    1D03    SNZB	0x3,2
  05A8    2DA4    JP	0x5A4
  05A9    0D73    RLCA	0x73
  05AA    3841    ORIA	0x41
  05AB    1683    SETB	0x3,5
  05AC    0095    LD	0x15,A
  05AD    0000    NOP
  05AE    0000    NOP
  05AF    0000    NOP
  05B0    0000    NOP
326:              		asm("nop");
327:              		asm("nop");
328:              		asm("nop");
329:              		asm("nop");				//选择通道后需延时1uS以上
330:              		GODONE = 1;				//开始转换
  05B1    1683    SETB	0x3,5
  05B2    1303    CLRB	0x3,6
  05B3    1495    SETB	0x15,1
331:              
332:              		unsigned char j = 0;
  05B4    1283    CLRB	0x3,5
  05B5    01CD    CLR	0x4D
333:              		while (GODONE) 
  05B6    1683    SETB	0x3,5
  05B7    1C95    SNZB	0x15,1
  05B8    2DC0    JP	0x5C0
334:              		{
335:              			__delay_us(2);		//延时2us(编译器内置函数)
  05B9    2DBA    JP	0x5BA
  05BA    2DBB    JP	0x5BB
336:              
337:              			if (0 == (--j))		//延时0.5ms仍没有AD转换结束，跳出程序
  05BB    1283    CLRB	0x3,5
  05BC    1303    CLRB	0x3,6
  05BD    0BCD    SZDECR	0x4D
  05BE    2DB6    JP	0x5B6
338:              			return 0;
  05BF    3400    RET	0x0
339:              		}
340:              
341:              		ad_temp = (unsigned int)((ADRESH << 4) + (ADRESL >> 4));	//计算12位AD值
  05C0    0819    LD	A,0x19
  05C1    1283    CLRB	0x3,5
  05C2    00D8    LD	0x58,A
  05C3    01D9    CLR	0x59
  05C4    0ED8    SWAPR	0x58
  05C5    0ED9    SWAPR	0x59
  05C6    30F0    LDIA	0xF0
  05C7    05D9    ANDR	0x59
  05C8    0858    LD	A,0x58
  05C9    390F    ANDIA	0xF
  05CA    04D9    ORR	0x59
  05CB    30F0    LDIA	0xF0
  05CC    05D8    ANDR	0x58
  05CD    1683    SETB	0x3,5
  05CE    0E18    SWAPA	0x18
  05CF    390F    ANDIA	0xF
  05D0    1283    CLRB	0x3,5
  05D1    07D8    ADDR	0x58
  05D2    1803    SZB	0x3,0
  05D3    0AD9    INCR	0x59
342:              
343:              		if (0 == admax) 
  05D4    0856    LD	A,0x56
  05D5    0457    ORA	0x57
  05D6    1D03    SNZB	0x3,2
  05D7    2DDB    JP	0x5DB
344:              		{
345:              			admax = ad_temp;
  05D8    27C3    CALL	0x7C3
  05D9    118A    CLRB	0xA,3
  05DA    2DEE    JP	0x5EE
346:              			admin = ad_temp;
347:              		} 
348:              		else if (ad_temp > admax)
  05DB    0859    LD	A,0x59
  05DC    0257    SUBA	0x57
  05DD    1D03    SNZB	0x3,2
  05DE    2DE1    JP	0x5E1
  05DF    0858    LD	A,0x58
  05E0    0256    SUBA	0x56
  05E1    1803    SZB	0x3,0
  05E2    2DE6    JP	0x5E6
349:              			admax = ad_temp;				//AD采样最大值
  05E3    27C3    CALL	0x7C3
  05E4    118A    CLRB	0xA,3
  05E5    2DF2    JP	0x5F2
350:              		else if (ad_temp < admin)
  05E6    0855    LD	A,0x55
  05E7    0259    SUBA	0x59
  05E8    1D03    SNZB	0x3,2
  05E9    2DEC    JP	0x5EC
  05EA    0854    LD	A,0x54
  05EB    0258    SUBA	0x58
  05EC    1803    SZB	0x3,0
  05ED    2DF2    JP	0x5F2
351:              			admin = ad_temp;				//AD采样最小值
  05EE    0859    LD	A,0x59
  05EF    00D5    LD	0x55,A
  05F0    0858    LD	A,0x58
  05F1    00D4    LD	0x54,A
352:              
353:              		adsum += ad_temp;
  05F2    0858    LD	A,0x58
  05F3    00F3    LD	0x73,A
  05F4    0859    LD	A,0x59
  05F5    00F4    LD	0x74,A
  05F6    01F5    CLR	0x75
  05F7    01F6    CLR	0x76
  05F8    0873    LD	A,0x73
  05F9    07D0    ADDR	0x50
  05FA    0874    LD	A,0x74
  05FB    1103    CLRB	0x3,2
  05FC    1803    SZB	0x3,0
  05FD    3E01    ADDIA	0x1
  05FE    1D03    SNZB	0x3,2
  05FF    07D1    ADDR	0x51
  0600    0875    LD	A,0x75
  0601    1103    CLRB	0x3,2
  0602    1803    SZB	0x3,0
  0603    3E01    ADDIA	0x1
  0604    1D03    SNZB	0x3,2
  0605    07D2    ADDR	0x52
  0606    0876    LD	A,0x76
  0607    1103    CLRB	0x3,2
  0608    1803    SZB	0x3,0
  0609    3E01    ADDIA	0x1
  060A    1D03    SNZB	0x3,2
  060B    07D3    ADDR	0x53
  060C    300A    LDIA	0xA
  060D    0ACF    INCR	0x4F
  060E    024F    SUBA	0x4F
  060F    1C03    SNZB	0x3,0
  0610    2DA0    JP	0x5A0
354:              	}
355:              		adsum -= admax;
  0611    0856    LD	A,0x56
  0612    00F3    LD	0x73,A
  0613    0857    LD	A,0x57
  0614    279F    CALL	0x79F
  0615    118A    CLRB	0xA,3
  0616    1C03    SNZB	0x3,0
  0617    0F76    SZINCA	0x76
  0618    02D3    SUBR	0x53
356:              		if (adsum >= admin)
  0619    0854    LD	A,0x54
  061A    00F3    LD	0x73,A
  061B    0855    LD	A,0x55
  061C    00F4    LD	0x74,A
  061D    01F5    CLR	0x75
  061E    01F6    CLR	0x76
  061F    0876    LD	A,0x76
  0620    0253    SUBA	0x53
  0621    1D03    SNZB	0x3,2
  0622    2E2D    JP	0x62D
  0623    0875    LD	A,0x75
  0624    0252    SUBA	0x52
  0625    1D03    SNZB	0x3,2
  0626    2E2D    JP	0x62D
  0627    0874    LD	A,0x74
  0628    0251    SUBA	0x51
  0629    1D03    SNZB	0x3,2
  062A    2E2D    JP	0x62D
  062B    0873    LD	A,0x73
  062C    0250    SUBA	0x50
  062D    1C03    SNZB	0x3,0
  062E    2E38    JP	0x638
357:              			adsum -= admin;
  062F    0854    LD	A,0x54
  0630    00F3    LD	0x73,A
  0631    0855    LD	A,0x55
  0632    279F    CALL	0x79F
  0633    118A    CLRB	0xA,3
  0634    1C03    SNZB	0x3,0
  0635    0F76    SZINCA	0x76
  0636    02D3    SUBR	0x53
  0637    2E3C    JP	0x63C
358:              		else
359:              			adsum = 0;
  0638    01D0    CLR	0x50
  0639    01D1    CLR	0x51
  063A    01D2    CLR	0x52
  063B    01D3    CLR	0x53
360:              
361:              		adresult = adsum >> 3;		//8次平均值作为最终结果
  063C    0850    LD	A,0x50
  063D    00F3    LD	0x73,A
  063E    0851    LD	A,0x51
  063F    00F4    LD	0x74,A
  0640    0852    LD	A,0x52
  0641    00F5    LD	0x75,A
  0642    0853    LD	A,0x53
  0643    00F6    LD	0x76,A
  0644    3003    LDIA	0x3
  0645    1003    CLRB	0x3,0
  0646    0CF6    RRCR	0x76
  0647    0CF5    RRCR	0x75
  0648    0CF4    RRCR	0x74
  0649    0CF3    RRCR	0x73
  064A    3EFF    ADDIA	0xFF
  064B    1D03    SNZB	0x3,2
  064C    2E45    JP	0x645
  064D    0874    LD	A,0x74
  064E    00CC    LD	0x4C,A
  064F    0873    LD	A,0x73
  0650    00CB    LD	0x4B,A
362:              
363:              		adsum = 0;
364:              		admin = 0;
365:              		admax = 0;
  0651    27AE    CALL	0x7AE
366:              		return 0xA5;
  0652    34A5    RET	0xA5
367:              		
368:              }
369:              
370:              
371:              void chrgCtr()
372:              {
373:              	if(PORTB & 0x20)
  07CC    1283    CLRB	0x3,5
  07CD    1303    CLRB	0x3,6
  07CE    1E86    SNZB	0x6,5
  07CF    2FE8    JP	0x7E8
374:              	{
375:              		chrgFlag = 1;
  07D0    01C4    CLR	0x44
  07D1    0AC4    INCR	0x44
376:              		firstLock = 0;
  07D2    1683    SETB	0x3,5
  07D3    01CB    CLR	0x4B
377:              		lowBatLock = 0;
  07D4    1283    CLRB	0x3,5
  07D5    3010    LDIA	0x10
  07D6    01C1    CLR	0x41
378:              		if(power_ad > 4140)
  07D7    0223    SUBA	0x23
  07D8    302D    LDIA	0x2D
  07D9    1903    SZB	0x3,2
  07DA    0222    SUBA	0x22
  07DB    1C03    SNZB	0x3,0
  07DC    2FE6    JP	0x7E6
379:              		{
380:              			if(++chrgFullTime > 200)
  07DD    30C9    LDIA	0xC9
  07DE    0AC2    INCR	0x42
  07DF    0242    SUBA	0x42
  07E0    1C03    SNZB	0x3,0
  07E1    0008    RET
381:              			{
382:              				chrgFullTime = 0;
  07E2    01C2    CLR	0x42
383:              				chrgFullFlag = 1;
  07E3    01C3    CLR	0x43
  07E4    0AC3    INCR	0x43
  07E5    0008    RET
384:              			}
385:              		}
386:              		else
387:              		{
388:              			chrgFullTime = 0;
  07E6    01C2    CLR	0x42
  07E7    0008    RET
389:              		}
390:              
391:              	}
392:              	else
393:              	{
394:              		chrgFlag = 0;
  07E8    01C4    CLR	0x44
395:              		chrgFullTime = 0;
  07E9    01C2    CLR	0x42
396:              		chrgFullFlag = 0;
  07EA    01C3    CLR	0x43
  07EB    0008    RET
397:              		
398:              	}
399:              }
400:              
401:              void keyLedCtr()
402:              {
403:              	if(shanshuoTime > 0)
  06F5    1283    CLRB	0x3,5
  06F6    0830    LD	A,0x30
  06F7    0431    ORA	0x31
  06F8    1903    SZB	0x3,2
  06F9    2F13    JP	0x713
404:              	{
405:              		shanshuoTime--;
  06FA    3001    LDIA	0x1
  06FB    02B0    SUBR	0x30
  06FC    3000    LDIA	0x0
  06FD    1C03    SNZB	0x3,0
  06FE    03B1    DECR	0x31
  06FF    02B1    SUBR	0x31
406:              		if((shanshuoTime % 150) < 75)
  0700    3096    LDIA	0x96
  0701    00F2    LD	0x72,A
  0702    01F3    CLR	0x73
  0703    0831    LD	A,0x31
  0704    00F5    LD	0x75,A
  0705    0830    LD	A,0x30
  0706    00F4    LD	0x74,A
  0707    276A    CALL	0x76A
  0708    118A    CLRB	0xA,3
  0709    3000    LDIA	0x0
  070A    0273    SUBA	0x73
  070B    304B    LDIA	0x4B
  070C    1903    SZB	0x3,2
  070D    0272    SUBA	0x72
  070E    1803    SZB	0x3,0
  070F    2F16    JP	0x716
407:              		{
408:              			PORTC |= 0x01;
  0710    1703    SETB	0x3,6
  0711    1406    SETB	0x6,0
409:              		}
  0712    2F18    JP	0x718
410:              		else
411:              		{
412:              			PORTC &= 0xFE;
  0716    1703    SETB	0x3,6
  0717    1006    CLRB	0x6,0
413:              		}
414:              	}
415:              	else if(workStep > 0)
  0713    087B    LD	A,0x7B
  0714    1903    SZB	0x3,2
  0715    2F10    JP	0x710
416:              	{
417:              		PORTC &= 0xFE;
418:              	}
419:              	else
420:              	{
421:              		PORTC |= 0x01;
422:              	}
423:              	
424:              	if(shanshuoTime2 > 0)
  0718    1303    CLRB	0x3,6
  0719    082E    LD	A,0x2E
  071A    042F    ORA	0x2F
  071B    1903    SZB	0x3,2
  071C    2F36    JP	0x736
425:              	{
426:              		shanshuoTime2--;
  071D    3001    LDIA	0x1
  071E    02AE    SUBR	0x2E
  071F    3000    LDIA	0x0
  0720    1C03    SNZB	0x3,0
  0721    03AF    DECR	0x2F
  0722    02AF    SUBR	0x2F
427:              		if((shanshuoTime2 % 150) < 75)
  0723    3096    LDIA	0x96
  0724    00F2    LD	0x72,A
  0725    01F3    CLR	0x73
  0726    082F    LD	A,0x2F
  0727    00F5    LD	0x75,A
  0728    082E    LD	A,0x2E
  0729    00F4    LD	0x74,A
  072A    276A    CALL	0x76A
  072B    118A    CLRB	0xA,3
  072C    3000    LDIA	0x0
  072D    0273    SUBA	0x73
  072E    304B    LDIA	0x4B
  072F    1903    SZB	0x3,2
  0730    0272    SUBA	0x72
  0731    1803    SZB	0x3,0
  0732    2F39    JP	0x739
428:              		{
429:              			PORTC |= 0x02;
  0733    1703    SETB	0x3,6
  0734    1486    SETB	0x6,1
430:              		}
  0735    2F3B    JP	0x73B
431:              		else
432:              		{
433:              			PORTC &= 0xFD;
  0739    1703    SETB	0x3,6
  073A    1086    CLRB	0x6,1
434:              		}
435:              	}
436:              	else if(wuhuaFlag > 0)
  0736    0848    LD	A,0x48
  0737    1903    SZB	0x3,2
  0738    2F33    JP	0x733
437:              	{
438:              		PORTC &= 0xFD;
439:              	}
440:              	else
441:              	{
442:              		PORTC |= 0x02;
443:              	}
444:              	if(shanshuoTime3 > 0)
  073B    1303    CLRB	0x3,6
  073C    082C    LD	A,0x2C
  073D    042D    ORA	0x2D
  073E    1903    SZB	0x3,2
  073F    2F5C    JP	0x75C
445:              	{
446:              		shanshuoTime3--;
  0740    3001    LDIA	0x1
  0741    02AC    SUBR	0x2C
  0742    3000    LDIA	0x0
  0743    1C03    SNZB	0x3,0
  0744    03AD    DECR	0x2D
  0745    02AD    SUBR	0x2D
447:              		if((shanshuoTime3 % 150) < 75)
  0746    3096    LDIA	0x96
  0747    00F2    LD	0x72,A
  0748    01F3    CLR	0x73
  0749    082D    LD	A,0x2D
  074A    00F5    LD	0x75,A
  074B    082C    LD	A,0x2C
  074C    00F4    LD	0x74,A
  074D    276A    CALL	0x76A
  074E    118A    CLRB	0xA,3
  074F    3000    LDIA	0x0
  0750    0273    SUBA	0x73
  0751    304B    LDIA	0x4B
  0752    1903    SZB	0x3,2
  0753    0272    SUBA	0x72
  0754    1803    SZB	0x3,0
  0755    2F59    JP	0x759
448:              		{
449:              			PORTA |= 0x01;
  0756    1683    SETB	0x3,5
  0757    1406    SETB	0x6,0
450:              		}
  0758    0008    RET
451:              		else
452:              		{
453:              			PORTA &= 0xFE;
  0759    1683    SETB	0x3,5
  075A    1006    CLRB	0x6,0
  075B    0008    RET
454:              		}
455:              	}
456:              	else if(powerFlag)
  075C    083E    LD	A,0x3E
  075D    1D03    SNZB	0x3,2
  075E    2F59    JP	0x759
457:              	{
458:              		PORTA &= 0xFE;
459:              	}
460:              	else if(chrgFlag)
  075F    0844    LD	A,0x44
  0760    1903    SZB	0x3,2
  0761    2F56    JP	0x756
461:              	{
462:              		if(chrgFullFlag || count1s < 50)
  0762    0843    LD	A,0x43
  0763    1D03    SNZB	0x3,2
  0764    2F59    JP	0x759
  0765    3032    LDIA	0x32
  0766    0249    SUBA	0x49
  0767    1C03    SNZB	0x3,0
  0768    2F59    JP	0x759
  0769    2F56    JP	0x756
463:              		{
464:              			PORTA &= 0xFE;
465:              		}
466:              		else
467:              		{
468:              			PORTA |= 0x01;
469:              		}
470:              	}
471:              	else
472:              	{
473:              		PORTA |= 0x01;
474:              	}
475:              	
476:              }
477:              
478:              void pwmInit()
479:              {
480:              
481:              	PWMTH = 0x00;
  0EA5    0198    CLR	0x18
482:              	PWMTL = 73;
  0EA6    3049    LDIA	0x49
  0EA7    0097    LD	0x17,A
483:              	PWMD23H = 0x00;
  0EA8    1683    SETB	0x3,5
  0EA9    019E    CLR	0x1E
484:              	PWMD3L = 32;
  0EAA    3020    LDIA	0x20
  0EAB    009C    LD	0x1C,A
485:              	PWMCON1 = 0xC0;
  0EAC    30C0    LDIA	0xC0
  0EAD    1283    CLRB	0x3,5
  0EAE    0096    LD	0x16,A
486:              	PWMCON2 = 0x00;
  0EAF    019D    CLR	0x1D
487:              	PWMCON0 |= 0x28;
  0EB0    3028    LDIA	0x28
  0EB1    0495    ORR	0x15
  0EB2    0008    RET
488:              }
489:              
490:              void pwmStop()
491:              {
492:              	PWMD3L = 0;
  0EB3    1683    SETB	0x3,5
  0EB4    019C    CLR	0x1C
493:              	PWMCON0 &= 0xF7;
  0EB5    1283    CLRB	0x3,5
  0EB6    1195    CLRB	0x15,3
494:              	PORTA &= 0xF7;
  0EB7    1683    SETB	0x3,5
  0EB8    1186    CLRB	0x6,3
  0EB9    0008    RET
495:              }
496:              
497:              void fanInit()
498:              {
499:              
500:              	PWMTH = 0x00;
  078E    0198    CLR	0x18
501:              	PWMT4L = 73;
  078F    3049    LDIA	0x49
  0790    009C    LD	0x1C,A
502:              	PWMD4L = fanDuty;
  0791    0847    LD	A,0x47
  0792    009B    LD	0x1B,A
503:              	PWMCON1 = 0xC0;
  0793    30C0    LDIA	0xC0
  0794    0096    LD	0x16,A
504:              	PWMCON2 = 0x00;
  0795    019D    CLR	0x1D
505:              	PWMCON0 |= 0x30;
  0796    3030    LDIA	0x30
  0797    0495    ORR	0x15
  0798    0008    RET
506:              }
507:              
508:              void fanStop()
509:              {
510:              	PWMD4L = 0;
  0799    1283    CLRB	0x3,5
  079A    019B    CLR	0x1B
511:              	PWMCON0 &= 0xEF;
  079B    1215    CLRB	0x15,4
512:              	PORTA &= 0xEF;
  079C    1683    SETB	0x3,5
  079D    1206    CLRB	0x6,4
  079E    0008    RET
513:              }
514:              
515:              void fanCtr()
516:              {
517:              	if(workStep > 0)
  0653    087B    LD	A,0x7B
  0654    1903    SZB	0x3,2
  0655    2EBC    JP	0x6BC
518:              	{
519:              		PORTA |= 0x02;
  0656    1486    SETB	0x6,1
520:              		u8t maxFanValue = 52;
  0657    3034    LDIA	0x34
  0658    1283    CLRB	0x3,5
  0659    00DA    LD	0x5A,A
521:              		if(workStep == 1)
  065A    0B7B    SZDECA	0x7B
  065B    2E5E    JP	0x65E
522:              		{	
523:              			maxFanValue = 40;
  065C    3028    LDIA	0x28
  065D    00DA    LD	0x5A,A
524:              		}
525:              		if(power_ad < 3150)
  065E    300C    LDIA	0xC
  065F    0223    SUBA	0x23
  0660    304E    LDIA	0x4E
  0661    1903    SZB	0x3,2
  0662    0222    SUBA	0x22
  0663    1803    SZB	0x3,0
  0664    2E67    JP	0x667
526:              		{
527:              			maxFanValue = 32;
  0665    3020    LDIA	0x20
  0666    00DA    LD	0x5A,A
528:              		}
529:              		if(workStep == 3)
  0667    3003    LDIA	0x3
  0668    067B    XORA	0x7B
  0669    1D03    SNZB	0x3,2
  066A    2E6D    JP	0x66D
530:              		{
531:              			maxFanValue = 10;
  066B    300A    LDIA	0xA
  066C    00DA    LD	0x5A,A
  066D    3002    LDIA	0x2
532:              		}
533:              		test_adc = ADC_Sample(2, 0);
  066E    01F2    CLR	0x72
  066F    2582    CALL	0x582
  0670    118A    CLRB	0xA,3
  0671    00BB    LD	0x3B,A
534:              		if (0xA5 == test_adc)
  0672    30A5    LDIA	0xA5
  0673    063B    XORA	0x3B
  0674    1D03    SNZB	0x3,2
  0675    2E9D    JP	0x69D
535:              		{
536:              			volatile unsigned long fan_temp;
537:              			if(power_ad > 0)
  0676    0822    LD	A,0x22
  0677    0423    ORA	0x23
  0678    1903    SZB	0x3,2
  0679    2E9D    JP	0x69D
538:              			{
539:              				fan_temp = ((unsigned long)1UL*adresult * power_ad)/4096;
  067A    084B    LD	A,0x4B
  067B    00CD    LD	0x4D,A
  067C    084C    LD	A,0x4C
  067D    00CE    LD	0x4E,A
  067E    01CF    CLR	0x4F
  067F    01D0    CLR	0x50
  0680    0822    LD	A,0x22
  0681    00D1    LD	0x51,A
  0682    0823    LD	A,0x23
  0683    00D2    LD	0x52,A
  0684    01D3    CLR	0x53
  0685    01D4    CLR	0x54
  0686    26C2    CALL	0x6C2
  0687    118A    CLRB	0xA,3
  0688    0850    LD	A,0x50
  0689    00DE    LD	0x5E,A
  068A    084F    LD	A,0x4F
  068B    00DD    LD	0x5D,A
  068C    084E    LD	A,0x4E
  068D    00DC    LD	0x5C,A
  068E    084D    LD	A,0x4D
  068F    00DB    LD	0x5B,A
  0690    300C    LDIA	0xC
  0691    1003    CLRB	0x3,0
  0692    0CDE    RRCR	0x5E
  0693    0CDD    RRCR	0x5D
  0694    0CDC    RRCR	0x5C
  0695    0CDB    RRCR	0x5B
  0696    3EFF    ADDIA	0xFF
  0697    1D03    SNZB	0x3,2
  0698    2E91    JP	0x691
540:              				fanValue = (unsigned int)(fan_temp);
  0699    085C    LD	A,0x5C
  069A    00AB    LD	0x2B,A
  069B    085B    LD	A,0x5B
  069C    00AA    LD	0x2A,A
541:              			}
542:              		}
543:              		if(fanValue > 1300)
  069D    3005    LDIA	0x5
  069E    022B    SUBA	0x2B
  069F    3015    LDIA	0x15
  06A0    1903    SZB	0x3,2
  06A1    022A    SUBA	0x2A
  06A2    1C03    SNZB	0x3,0
  06A3    2EB0    JP	0x6B0
544:              		{
545:              			if(++fanOverTime > 50)
  06A4    3033    LDIA	0x33
  06A5    0AC5    INCR	0x45
  06A6    0245    SUBA	0x45
  06A7    1C03    SNZB	0x3,0
  06A8    2EB1    JP	0x6B1
  06A9    30C2    LDIA	0xC2
546:              			{
547:              				fanOverTime = 0;
  06AA    01C5    CLR	0x45
548:              				workStep = 0;
  06AB    01FB    CLR	0x7B
549:              				shanshuoTime = 450;
  06AC    00B0    LD	0x30,A
  06AD    3001    LDIA	0x1
  06AE    00B1    LD	0x31,A
  06AF    2EB1    JP	0x6B1
550:              			}
551:              		}
552:              		else
553:              		{
554:              			fanOverTime = 0;
  06B0    01C5    CLR	0x45
555:              		}
556:              		if(fanDuty < maxFanValue)
  06B1    085A    LD	A,0x5A
  06B2    0247    SUBA	0x47
  06B3    1803    SZB	0x3,0
  06B4    2EB7    JP	0x6B7
557:              		{
558:              			fanDuty++;
  06B5    0AC7    INCR	0x47
559:              		}
  06B6    2EBB    JP	0x6BB
560:              		else if(fanDuty > maxFanValue)
  06B7    0847    LD	A,0x47
  06B8    025A    SUBA	0x5A
  06B9    1C03    SNZB	0x3,0
561:              		{
562:              			fanDuty--;
  06BA    03C7    DECR	0x47
563:              		}
564:              		fanInit();
  06BB    2F8E    JP	0x78E
565:              	}
566:              	else
567:              	{
568:              		fanStop();
  06BC    2799    CALL	0x799
569:              		fanDuty = 0;
  06BD    1283    CLRB	0x3,5
  06BE    01C7    CLR	0x47
570:              		PORTA &= 0xFD;
  06BF    1683    SETB	0x3,5
  06C0    1086    CLRB	0x6,1
  06C1    0008    RET
571:              	}
572:              }
573:              
574:              void wuhuaCtr()
575:              {
576:              	if(count1s == 0)
  0E7D    1283    CLRB	0x3,5
  0E7E    0849    LD	A,0x49
  0E7F    1D03    SNZB	0x3,2
  0E80    2E98    JP	0x698
577:              	{
578:              		if(++count10s >= 20)
  0E81    3014    LDIA	0x14
  0E82    0AC6    INCR	0x46
  0E83    0246    SUBA	0x46
  0E84    1803    SZB	0x3,0
579:              		{
580:              			count10s = 0;
  0E85    01C6    CLR	0x46
581:              		}
582:              		if(workStep == 0 && wuhuaFlag == 0 && powerFlag > 0)
  0E86    087B    LD	A,0x7B
  0E87    1D03    SNZB	0x3,2
  0E88    2E97    JP	0x697
  0E89    0848    LD	A,0x48
  0E8A    1D03    SNZB	0x3,2
  0E8B    2E97    JP	0x697
  0E8C    083E    LD	A,0x3E
  0E8D    1903    SZB	0x3,2
  0E8E    2E97    JP	0x697
583:              		{
584:              			if(++closeTime > 200)
  0E8F    30C9    LDIA	0xC9
  0E90    0ABC    INCR	0x3C
  0E91    023C    SUBA	0x3C
  0E92    1C03    SNZB	0x3,0
  0E93    2E98    JP	0x698
585:              			{
586:              				closeTime = 0;
  0E94    01BC    CLR	0x3C
587:              				powerFlag = 0;
  0E95    01BE    CLR	0x3E
  0E96    2E98    JP	0x698
588:              			}
589:              		}
590:              		else
591:              		{
592:              			closeTime = 0;
  0E97    01BC    CLR	0x3C
593:              		}
594:              	}
595:              	if(wuhuaFlag == 1 || (wuhuaFlag == 2 && count10s < 10))
  0E98    0348    DECA	0x48
  0E99    1903    SZB	0x3,2
  0E9A    2EA3    JP	0x6A3
  0E9B    3002    LDIA	0x2
  0E9C    0648    XORA	0x48
  0E9D    1D03    SNZB	0x3,2
  0E9E    2EA4    JP	0x6A4
  0E9F    300A    LDIA	0xA
  0EA0    0246    SUBA	0x46
  0EA1    1803    SZB	0x3,0
  0EA2    2EA4    JP	0x6A4
596:              	{
597:              		pwmInit();
  0EA3    2EA5    JP	0x6A5
598:              		/*
599:              		if(++checkTime > 200)
600:              		{
601:              			if(lowWaterTime > 110)
602:              			{
603:              				//干烧状态
604:              				wuhuaFlag = 0;
605:              				shanshuoTime2 = 450;
606:              			}
607:              			checkTime = 0;
608:              			lowWaterTime = 0;
609:              		}
610:              		
611:              		test_adc = ADC_Sample(2, 0);
612:              		if (0xA5 == test_adc)
613:              		{
614:              			volatile unsigned long wuhua_temp;
615:              			if(power_ad > 0)
616:              			{
617:              				wuhua_temp = (unsigned long)(1UL*adresult * power_ad)/4096;
618:              				wuhuaValue = (unsigned int)(wuhua_temp);
619:              			}
620:              		}
621:              		if(wuhuaValue < 7)
622:              		{
623:              			lowWaterTime++;
624:              		}
625:              		*/
626:              	}
627:              	else
628:              	{
629:              		pwmStop();
  0EA4    2EB3    JP	0x6B3
630:              	}
631:              }
632:              
633:              void bujinCtr()
634:              {
635:              	if(bujinFlag || motorStep > 0)
  0F76    1283    CLRB	0x3,5
  0F77    083F    LD	A,0x3F
  0F78    1D03    SNZB	0x3,2
  0F79    2F7E    JP	0x77E
  0F7A    0828    LD	A,0x28
  0F7B    0429    ORA	0x29
  0F7C    1903    SZB	0x3,2
  0F7D    2FEA    JP	0x7EA
636:              	{
637:              		if(bujinFlag == 1)
  0F7E    0B3F    SZDECA	0x3F
  0F7F    2F82    JP	0x782
638:              		{
639:              			maxMotorStep = 512;
  0F80    3002    LDIA	0x2
  0F81    2F87    JP	0x787
640:              		}
641:              		else if(bujinFlag == 2)
  0F82    3002    LDIA	0x2
  0F83    063F    XORA	0x3F
  0F84    1D03    SNZB	0x3,2
  0F85    2F89    JP	0x789
642:              		{
643:              			maxMotorStep = 1024;
  0F86    3004    LDIA	0x4
  0F87    01A6    CLR	0x26
  0F88    2F90    JP	0x790
644:              		}
645:              		else if(bujinFlag == 3)
  0F89    3003    LDIA	0x3
  0F8A    063F    XORA	0x3F
  0F8B    1D03    SNZB	0x3,2
  0F8C    2F91    JP	0x791
646:              		{
647:              			maxMotorStep = 1360;
  0F8D    3050    LDIA	0x50
  0F8E    00A6    LD	0x26,A
  0F8F    3005    LDIA	0x5
  0F90    00A7    LD	0x27,A
648:              		}
649:              		if(++motorStep >= (maxMotorStep*2))
  0F91    0827    LD	A,0x27
  0F92    00F3    LD	0x73,A
  0F93    0826    LD	A,0x26
  0F94    00F2    LD	0x72,A
  0F95    1003    CLRB	0x3,0
  0F96    0DF2    RLCR	0x72
  0F97    0DF3    RLCR	0x73
  0F98    0AA8    INCR	0x28
  0F99    1903    SZB	0x3,2
  0F9A    0AA9    INCR	0x29
  0F9B    0873    LD	A,0x73
  0F9C    0229    SUBA	0x29
  0F9D    1D03    SNZB	0x3,2
  0F9E    2FA1    JP	0x7A1
  0F9F    0872    LD	A,0x72
  0FA0    0228    SUBA	0x28
  0FA1    1C03    SNZB	0x3,0
  0FA2    2FA5    JP	0x7A5
650:              		{
651:              			motorStep = 0;
  0FA3    01A8    CLR	0x28
  0FA4    01A9    CLR	0x29
652:              		}
653:              		u8t	tempStep = motorStep % 8;
  0FA5    0828    LD	A,0x28
  0FA6    00F4    LD	0x74,A
  0FA7    3007    LDIA	0x7
  0FA8    05F4    ANDR	0x74
654:              		if(motorStep < maxMotorStep)
  0FA9    0827    LD	A,0x27
  0FAA    0229    SUBA	0x29
  0FAB    1D03    SNZB	0x3,2
  0FAC    2FAF    JP	0x7AF
  0FAD    0826    LD	A,0x26
  0FAE    0228    SUBA	0x28
  0FAF    1C03    SNZB	0x3,0
  0FB0    2FD2    JP	0x7D2
  0FB1    2FDE    JP	0x7DE
655:              		{
656:              			//正转
657:              			switch(tempStep)
658:              			{
659:              				case 0:
660:              				MOT1 = 1;MOT2 = 0;MOT3 = 0;MOT4 = 0;
  0FB2    1683    SETB	0x3,5
  0FB3    1686    SETB	0x6,5
  0FB4    1306    CLRB	0x6,6
  0FB5    1386    CLRB	0x6,7
  0FB6    1283    CLRB	0x3,5
  0FB7    1386    CLRB	0x6,7
661:              				break;
  0FB8    0008    RET
662:              				case 1:
663:              				MOT1 = 1;MOT2 = 1;MOT3 = 0;MOT4 = 0;
  0FB9    1683    SETB	0x3,5
  0FBA    1686    SETB	0x6,5
664:              				break;
  0FBB    2FF5    JP	0x7F5
665:              				case 2:
666:              				MOT1 = 0;MOT2 = 1;MOT3 = 0;MOT4 = 0;
  0FBC    1683    SETB	0x3,5
  0FBD    1286    CLRB	0x6,5
667:              				break;
  0FBE    2FF5    JP	0x7F5
668:              				case 3:
669:              				MOT1 = 0;MOT2 = 1;MOT3 = 1;MOT4 = 0;
  0FBF    1683    SETB	0x3,5
  0FC0    1286    CLRB	0x6,5
  0FC1    1706    SETB	0x6,6
  0FC2    1786    SETB	0x6,7
  0FC3    1283    CLRB	0x3,5
  0FC4    1386    CLRB	0x6,7
670:              				break;
  0FC5    0008    RET
671:              				case 4:
672:              				MOT1 = 0;MOT2 = 0;MOT3 = 1;MOT4 = 0;
  0FC6    27FA    CALL	0x7FA
  0FC7    1386    CLRB	0x6,7
673:              				break;
  0FC8    0008    RET
674:              				case 5:
675:              				MOT1 = 0;MOT2 = 0;MOT3 = 1;MOT4 = 1;
  0FC9    27FA    CALL	0x7FA
  0FCA    1786    SETB	0x6,7
676:              				break;
  0FCB    0008    RET
677:              				case 6:
678:              				MOT1 = 0;MOT2 = 0;MOT3 = 0;MOT4 = 1;
  0FCC    1683    SETB	0x3,5
  0FCD    1286    CLRB	0x6,5
679:              				break;
  0FCE    2FF0    JP	0x7F0
680:              				case 7:
681:              				MOT1 = 1;MOT2 = 0;MOT3 = 0;MOT4 = 1;
  0FCF    1683    SETB	0x3,5
  0FD0    1686    SETB	0x6,5
682:              				break;
  0FD1    2FF0    JP	0x7F0
  0FD2    0874    LD	A,0x74
  0FD3    0084    LD	0x4,A
  0FD4    3008    LDIA	0x8
  0FD5    0204    SUBA	0x4
  0FD6    1803    SZB	0x3,0
  0FD7    0008    RET
  0FD8    3007    LDIA	0x7
  0FD9    008A    LD	0xA,A
  0FDA    1003    CLRB	0x3,0
  0FDB    0D04    RLCA	0x4
  0FDC    3EEC    ADDIA	0xEC
  0FDD    0082    LD	0x2,A
  0FDE    0874    LD	A,0x74
  0FDF    0084    LD	0x4,A
  0FE0    3008    LDIA	0x8
  0FE1    0204    SUBA	0x4
  0FE2    1803    SZB	0x3,0
  0FE3    0008    RET
  0FE4    3008    LDIA	0x8
  0FE5    008A    LD	0xA,A
  0FE6    1003    CLRB	0x3,0
  0FE7    0D04    RLCA	0x4
  0FE8    3E17    ADDIA	0x17
  0FE9    0082    LD	0x2,A
683:              			}
684:              		}
685:              		else
686:              		{
687:              			//反转
688:              			switch(tempStep)
689:              			{
690:              				case 7:
691:              				MOT1 = 1;MOT2 = 0;MOT3 = 0;MOT4 = 0;
692:              				break;
693:              				case 6:
694:              				MOT1 = 1;MOT2 = 1;MOT3 = 0;MOT4 = 0;
695:              				break;
696:              				case 5:
697:              				MOT1 = 0;MOT2 = 1;MOT3 = 0;MOT4 = 0;
698:              				break;
699:              				case 4:
700:              				MOT1 = 0;MOT2 = 1;MOT3 = 1;MOT4 = 0;
701:              				break;
702:              				case 3:
703:              				MOT1 = 0;MOT2 = 0;MOT3 = 1;MOT4 = 0;
704:              				break;
705:              				case 2:
706:              				MOT1 = 0;MOT2 = 0;MOT3 = 1;MOT4 = 1;
707:              				break;
708:              				case 1:
709:              				MOT1 = 0;MOT2 = 0;MOT3 = 0;MOT4 = 1;
710:              				break;
711:              				case 0:
712:              				MOT1 = 1;MOT2 = 0;MOT3 = 0;MOT4 = 1;
713:              				break;
714:              			}
715:              		}
716:              	}
717:              	else
718:              	{
719:              		PORTA &= 0x1F;
  0FEA    301F    LDIA	0x1F
  0FEB    1683    SETB	0x3,5
  0FEC    0586    ANDR	0x6
720:              		PORTB &= 0x7F;
  0FED    1283    CLRB	0x3,5
  0FEE    1386    CLRB	0x6,7
  0FEF    0008    RET
721:              	}
722:              }
723:              
724:              
725:              void workCtr()
  03FA    301F    LDIA	0x1F
726:              {
727:              	test_adc = ADC_Sample(31, 0);		//测试内部基准1.2V相对电源的AD值
  03FB    01F2    CLR	0x72
  03FC    2582    CALL	0x582
  03FD    118A    CLRB	0xA,3
  03FE    00BB    LD	0x3B,A
728:              	if (0xA5 == test_adc)
  03FF    30A5    LDIA	0xA5
  0400    063B    XORA	0x3B
  0401    1D03    SNZB	0x3,2
  0402    2C34    JP	0x434
729:              	{
730:              		volatile unsigned long power_temp;
731:              			
732:              		power_temp = (unsigned long)((POWER_RATIO)/adresult);		//1.2*4096/AD=VDD，参数放大1000倍 
  0403    3096    LDIA	0x96
  0404    01D6    CLR	0x56
  0405    00D7    LD	0x57,A
  0406    304A    LDIA	0x4A
  0407    00D8    LD	0x58,A
  0408    084C    LD	A,0x4C
  0409    00D1    LD	0x51,A
  040A    084B    LD	A,0x4B
  040B    00D0    LD	0x50,A
  040C    2534    CALL	0x534
  040D    118A    CLRB	0xA,3
  040E    0850    LD	A,0x50
  040F    00D3    LD	0x53,A
  0410    0851    LD	A,0x51
  0411    00D4    LD	0x54,A
  0412    0852    LD	A,0x52
  0413    00D5    LD	0x55,A
  0414    2479    CALL	0x479
  0415    118A    CLRB	0xA,3
  0416    0853    LD	A,0x53
  0417    00E2    LD	0x62,A
  0418    0854    LD	A,0x54
  0419    00E3    LD	0x63,A
  041A    0855    LD	A,0x55
  041B    00E4    LD	0x64,A
  041C    24DB    CALL	0x4DB
  041D    118A    CLRB	0xA,3
  041E    0865    LD	A,0x65
  041F    1683    SETB	0x3,5
  0420    00CA    LD	0x4A,A
  0421    1283    CLRB	0x3,5
  0422    0864    LD	A,0x64
  0423    1683    SETB	0x3,5
  0424    00C9    LD	0x49,A
  0425    1283    CLRB	0x3,5
  0426    0863    LD	A,0x63
  0427    1683    SETB	0x3,5
  0428    00C8    LD	0x48,A
  0429    1283    CLRB	0x3,5
  042A    0862    LD	A,0x62
  042B    1683    SETB	0x3,5
  042C    00C7    LD	0x47,A
733:              		power_ad = (unsigned int)(power_temp);		//通过内部基准电压推出芯片VDD电压
  042D    0848    LD	A,0x48
  042E    1283    CLRB	0x3,5
  042F    00A3    LD	0x23,A
  0430    1683    SETB	0x3,5
  0431    0847    LD	A,0x47
  0432    1283    CLRB	0x3,5
  0433    00A2    LD	0x22,A
734:              	}
735:              	if(workStep == 2 && power_ad < 3300)
  0434    3002    LDIA	0x2
  0435    067B    XORA	0x7B
  0436    1D03    SNZB	0x3,2
  0437    2C48    JP	0x448
  0438    300C    LDIA	0xC
  0439    0223    SUBA	0x23
  043A    30E4    LDIA	0xE4
  043B    1903    SZB	0x3,2
  043C    0222    SUBA	0x22
  043D    1803    SZB	0x3,0
  043E    2C48    JP	0x448
736:              	{
737:              		if(++lowFanTime > 200)
  043F    30C9    LDIA	0xC9
  0440    0AC0    INCR	0x40
  0441    0240    SUBA	0x40
  0442    1C03    SNZB	0x3,0
  0443    2C49    JP	0x449
738:              		{
739:              			lowFanTime = 0;
  0444    01C0    CLR	0x40
740:              			workStep = 1;
  0445    01FB    CLR	0x7B
  0446    0AFB    INCR	0x7B
  0447    2C49    JP	0x449
741:              		}
742:              	}
743:              	else
744:              	{
745:              		lowFanTime = 0;
  0448    01C0    CLR	0x40
746:              	}	
747:              	if(power_ad < 2900)
  0449    300B    LDIA	0xB
  044A    0223    SUBA	0x23
  044B    3054    LDIA	0x54
  044C    1903    SZB	0x3,2
  044D    0222    SUBA	0x22
  044E    1803    SZB	0x3,0
  044F    2C64    JP	0x464
748:              	{
749:              		if(++lowBatTime > 1000)
  0450    1683    SETB	0x3,5
  0451    0AC5    INCR	0x45
  0452    1903    SZB	0x3,2
  0453    0AC6    INCR	0x46
  0454    3003    LDIA	0x3
  0455    0246    SUBA	0x46
  0456    30E9    LDIA	0xE9
  0457    1903    SZB	0x3,2
  0458    0245    SUBA	0x45
  0459    1C03    SNZB	0x3,0
  045A    2C67    JP	0x467
750:              		{
751:              			lowBatTime = 0;
  045B    01C5    CLR	0x45
  045C    01C6    CLR	0x46
752:              			lowBatLock = 1;
  045D    1283    CLRB	0x3,5
  045E    01C1    CLR	0x41
  045F    0AC1    INCR	0x41
753:              			workStep = 0;
  0460    01FB    CLR	0x7B
754:              			wuhuaFlag = 0;
  0461    01C8    CLR	0x48
755:              			bujinFlag = 0;
  0462    01BF    CLR	0x3F
  0463    2C67    JP	0x467
756:              		}
757:              	}
758:              	else
759:              	{
760:              		lowBatTime = 0;
  0464    1683    SETB	0x3,5
  0465    01C5    CLR	0x45
  0466    01C6    CLR	0x46
761:              	}
762:              	if(firstTime > 0)
  0467    1683    SETB	0x3,5
  0468    084C    LD	A,0x4C
  0469    1903    SZB	0x3,2
  046A    2C71    JP	0x471
763:              	{
764:              		firstTime--;
  046B    03CC    DECR	0x4C
765:              		PORTB = 0x00;
  046C    1283    CLRB	0x3,5
  046D    0186    CLR	0x6
766:              		PORTA = 0x00;
  046E    1683    SETB	0x3,5
  046F    0186    CLR	0x6
767:              	}
  0470    0008    RET
768:              	else
769:              	{
770:              		keyLedCtr();
  0471    26F5    CALL	0x6F5
  0472    118A    CLRB	0xA,3
771:              		fanCtr();
  0473    2653    CALL	0x653
772:              		wuhuaCtr();
  0474    158A    SETB	0xA,3
  0475    267D    CALL	0x67D
  0476    118A    CLRB	0xA,3
773:              		bujinCtr();
  0477    158A    SETB	0xA,3
  0478    2F76    JP	0x776
774:              	}
775:              	
776:              }
777:              
778:              /***********************************************************
779:              主循环
780:              ***********************************************************/
781:              void main()
782:              {
783:              	Init_System();
  0EBA    118A    CLRB	0xA,3
  0EBB    2020    CALL	0x20
  0EBC    158A    SETB	0xA,3
  0EBD    30C8    LDIA	0xC8
784:              	firstLock = 1;
  0EBE    01CB    CLR	0x4B
  0EBF    0ACB    INCR	0x4B
785:              	firstTime = 200;
  0EC0    00CC    LD	0x4C,A
786:              	while(1)
787:              	{
788:              		if(B_MainLoop)
  0EC1    1F78    SNZB	0x78,6
  0EC2    2EC1    JP	0x6C1
789:              		{
790:              			B_MainLoop = 0;
  0EC3    1378    CLRB	0x78,6
  0EC4    0064    CLRWDT
791:              			CLRWDT();
792:              			
793:              			CheckTouchKey();
  0EC5    118A    CLRB	0xA,3
  0EC6    206D    CALL	0x6D
  0EC7    158A    SETB	0xA,3
794:              			chrgCtr();
  0EC8    118A    CLRB	0xA,3
  0EC9    27CC    CALL	0x7CC
  0ECA    158A    SETB	0xA,3
795:              			Refurbish_Sfr();
  0ECB    118A    CLRB	0xA,3
  0ECC    2384    CALL	0x384
  0ECD    158A    SETB	0xA,3
796:              			KeyServer();
  0ECE    158A    SETB	0xA,3
  0ECF    26F8    CALL	0x6F8
  0ED0    158A    SETB	0xA,3
797:              			workCtr();
  0ED1    118A    CLRB	0xA,3
  0ED2    23FA    CALL	0x3FA
  0ED3    158A    SETB	0xA,3
798:              			if(firstTime == 0 && chrgFlag == 0 && workStep == 0 && powerFlag == 0 && keyCount == 0 && wuhuaFlag == 0 && bujinFlag == 0 && shanshuoTime == 0 && shanshuoTime2 == 0)
  0ED4    1683    SETB	0x3,5
  0ED5    084C    LD	A,0x4C
  0ED6    1D03    SNZB	0x3,2
  0ED7    2EC1    JP	0x6C1
  0ED8    1283    CLRB	0x3,5
  0ED9    0844    LD	A,0x44
  0EDA    1D03    SNZB	0x3,2
  0EDB    2EC1    JP	0x6C1
  0EDC    087B    LD	A,0x7B
  0EDD    1D03    SNZB	0x3,2
  0EDE    2EC1    JP	0x6C1
  0EDF    083E    LD	A,0x3E
  0EE0    1D03    SNZB	0x3,2
  0EE1    2EC1    JP	0x6C1
  0EE2    0824    LD	A,0x24
  0EE3    0425    ORA	0x25
  0EE4    1D03    SNZB	0x3,2
  0EE5    2EC1    JP	0x6C1
  0EE6    0848    LD	A,0x48
  0EE7    1D03    SNZB	0x3,2
  0EE8    2EC1    JP	0x6C1
  0EE9    083F    LD	A,0x3F
  0EEA    1D03    SNZB	0x3,2
  0EEB    2EC1    JP	0x6C1
  0EEC    0830    LD	A,0x30
  0EED    0431    ORA	0x31
  0EEE    1D03    SNZB	0x3,2
  0EEF    2EC1    JP	0x6C1
  0EF0    082E    LD	A,0x2E
  0EF1    042F    ORA	0x2F
  0EF2    1D03    SNZB	0x3,2
  0EF3    2EC1    JP	0x6C1
799:              			{
800:              				WorkSleep();
  0EF4    118A    CLRB	0xA,3
  0EF5    203E    CALL	0x3E
  0EF6    158A    SETB	0xA,3
  0EF7    2EC1    JP	0x6C1
801:              			}
802:              		}
803:              	}
804:              }
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\ftdiv.c ----------------------------------------------------------------------
1:                /*	Floating point routines.
2:                
3:                	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:                */
5:                
6:                // this is bigendian code right now. Need to parameterise it.
7:                
8:                #include	"ftarith.h"
9:                
10:               #define	f1_as_dividend	(*(unsigned short long *)&f1)
11:               #define	f2_as_divisor	(*(unsigned short long *)&f2)
12:               #define	f3_as_quot	(*(unsigned short long *)&f3)
13:               
14:               // floating addition
15:               #ifdef _OLDLIB
16:               #define	cntr		sign2
17:               float
18:               #ifdef _PIC18
19:               __ftdiv(float f1, float f2)
20:               #else
21:               __ftdiv(float f2, float f1)
22:               #endif
23:               {
24:               	unsigned char	exp1, exp2, sign1, sign2;
25:               	float	f3;
26:               	
27:               	f3_as_quot = 0;
28:               	sign1 = __ftunpack(&f1_as_dividend, &exp1);
29:               	if(exp1 == 0)
30:               		return f3;
31:               	sign2 = __ftunpack(&f2_as_divisor, &exp2);
32:               	if(exp2 == 0)
33:               		return f3;
34:               	exp1 -= exp2-127+8;	// compute new exponent
35:               	sign1 ^= sign2;
36:               	cntr = 16+8;
37:               	do {
38:               		f3_as_quot <<= 1;
39:               		if(f1_as_dividend >= f2_as_divisor) {
40:               			f1_as_dividend -= f2_as_divisor;
41:               			f3_as_quot |= 1;
42:               		}
43:               		f1_as_dividend <<= 1;
44:               	} while(--cntr != 0);
45:               	__ftpack(&f3_as_quot, exp1);
46:               	if(sign1)
47:               		f3_as_quot |= 0x800000;
48:               	return f3;
49:               }
50:               #else
51:               #define	exp2	sign
52:               float
53:               #ifdef _PIC18
54:               __ftdiv(float f1, float f2)
55:               #else
56:               __ftdiv(float f2, float f1)
  0479    0856    LD	A,0x56
  047A    00D9    LD	0x59,A
  047B    0857    LD	A,0x57
  047C    00DA    LD	0x5A,A
  047D    0858    LD	A,0x58
  047E    00DB    LD	0x5B,A
  047F    1003    CLRB	0x3,0
  0480    0D5A    RLCA	0x5A
  0481    0D5B    RLCA	0x5B
  0482    00E0    LD	0x60,A
  0483    0860    LD	A,0x60
  0484    1D03    SNZB	0x3,2
  0485    2C87    JP	0x487
  0486    2FC8    JP	0x7C8
  0487    0853    LD	A,0x53
  0488    00D9    LD	0x59,A
  0489    0854    LD	A,0x54
  048A    00DA    LD	0x5A,A
  048B    0855    LD	A,0x55
  048C    00DB    LD	0x5B,A
  048D    1003    CLRB	0x3,0
  048E    0D5A    RLCA	0x5A
  048F    0D5B    RLCA	0x5B
  0490    00E1    LD	0x61,A
  0491    0861    LD	A,0x61
  0492    1D03    SNZB	0x3,2
  0493    2C95    JP	0x495
  0494    2FC8    JP	0x7C8
  0495    3089    LDIA	0x89
  0496    01DD    CLR	0x5D
  0497    01DE    CLR	0x5E
  0498    01DF    CLR	0x5F
  0499    0761    ADDA	0x61
  049A    00D9    LD	0x59,A
  049B    02E0    SUBR	0x60
  049C    0858    LD	A,0x58
  049D    00E1    LD	0x61,A
  049E    0855    LD	A,0x55
  049F    06E1    XORR	0x61
  04A0    3080    LDIA	0x80
  04A1    05E1    ANDR	0x61
  04A2    3018    LDIA	0x18
  04A3    17D7    SETB	0x57,7
  04A4    01D8    CLR	0x58
  04A5    17D4    SETB	0x54,7
  04A6    01D5    CLR	0x55
  04A7    00DC    LD	0x5C,A
  04A8    1003    CLRB	0x3,0
  04A9    0DDD    RLCR	0x5D
  04AA    0DDE    RLCR	0x5E
  04AB    0DDF    RLCR	0x5F
  04AC    0855    LD	A,0x55
  04AD    0258    SUBA	0x58
  04AE    1D03    SNZB	0x3,2
  04AF    2CB6    JP	0x4B6
  04B0    0854    LD	A,0x54
  04B1    0257    SUBA	0x57
  04B2    1D03    SNZB	0x3,2
  04B3    2CB6    JP	0x4B6
  04B4    0853    LD	A,0x53
  04B5    0256    SUBA	0x56
  04B6    1C03    SNZB	0x3,0
  04B7    2CC4    JP	0x4C4
  04B8    0853    LD	A,0x53
  04B9    02D6    SUBR	0x56
  04BA    0854    LD	A,0x54
  04BB    1C03    SNZB	0x3,0
  04BC    0F54    SZINCA	0x54
  04BD    02D7    SUBR	0x57
  04BE    0855    LD	A,0x55
  04BF    1C03    SNZB	0x3,0
  04C0    0A55    INCA	0x55
  04C1    02D8    SUBR	0x58
  04C2    145D    SETB	0x5D,0
  04C3    1003    CLRB	0x3,0
  04C4    0DD6    RLCR	0x56
  04C5    0DD7    RLCR	0x57
  04C6    0DD8    RLCR	0x58
  04C7    0BDC    SZDECR	0x5C
  04C8    2CA8    JP	0x4A8
  04C9    085D    LD	A,0x5D
  04CA    00F2    LD	0x72,A
  04CB    085E    LD	A,0x5E
  04CC    00F3    LD	0x73,A
  04CD    085F    LD	A,0x5F
  04CE    00F4    LD	0x74,A
  04CF    0860    LD	A,0x60
  04D0    00F5    LD	0x75,A
  04D1    0861    LD	A,0x61
  04D2    00F6    LD	0x76,A
  04D3    2544    CALL	0x544
  04D4    0872    LD	A,0x72
  04D5    00D3    LD	0x53,A
  04D6    0873    LD	A,0x73
  04D7    00D4    LD	0x54,A
  04D8    0874    LD	A,0x74
  04D9    00D5    LD	0x55,A
  04DA    0008    RET
57:               #endif
58:               {
59:               	unsigned char	exp, sign, cntr;
60:               	float	f3;
61:               	
62:               	// unpack the operands
63:               	if((exp = f1_as_dividend >> 15) == 0)
64:               		return 0.0;
65:               	if((exp2 = f2_as_divisor >> 15) == 0)
66:               		return 0.0;
67:               	f3_as_quot = 0;
68:               	exp -= exp2-127+8;	// compute new exponent
69:               	sign = f1_as_dividend >> 16;
70:               	sign ^= (unsigned char)(f2_as_divisor >> 16);
71:               	sign &= 0x80;
72:               	f1_as_dividend |= 0x8000UL;
73:               	f1_as_dividend &= 0xFFFFUL;
74:               	f2_as_divisor |= 0x8000UL;
75:               	f2_as_divisor &= 0xFFFFUL;
76:               	cntr = 16+8;
77:               	do {
78:               		f3_as_quot <<= 1;
79:               		if(f1_as_dividend >= f2_as_divisor) {
80:               			f1_as_dividend -= f2_as_divisor;
81:               			f3_as_quot |= 1;
82:               		}
83:               		f1_as_dividend <<= 1;
84:               	} while(--cntr != 0);
85:               	return __ftpack(f3_as_quot, exp, sign);
86:               }
87:               #endif	
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\fttol.c ----------------------------------------------------------------------
1:                /*	Floating point routines.
2:                
3:                	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:                */
5:                
6:                // this is bigendian code right now. Need to parameterise it.
7:                
8:                #include	"ftarith.h"
9:                
10:               #define	f1_as_mant1	(*(unsigned short long *)&f1)
11:               
12:               // Convert float to long
13:               
14:               #ifdef _OLDLIB
15:               long
16:               __fttol(float f1)
17:               {
18:               	unsigned char	sign1, exp1;
19:               	unsigned long	lval;
20:               
21:               	sign1 = __ftunpack(&f1_as_mant1, &exp1);
22:               	lval = f1_as_mant1;
23:               	exp1 -= 127+15;
24:               	if((signed char)exp1 < 0) {
25:               		if((signed char)exp1 < -15)
26:               			return 0;
27:               		do
28:               			lval >>= 1;
29:               		while(++exp1 != 0);
30:               	} else {
31:               		if(exp1 >= 32)
32:               			return 00;
33:               		while(exp1 != 0) {
34:               			lval <<= 1;
35:               			exp1--;
36:               		}
37:               	}
38:               	if(sign1)
39:               		lval = -lval;
40:               	return lval;
41:               }
42:               #else
43:               long
44:               __fttol(float f1)
  04DB    27B7    CALL	0x7B7
  04DC    118A    CLRB	0xA,3
  04DD    1003    CLRB	0x3,0
  04DE    0D67    RLCA	0x67
  04DF    0D68    RLCA	0x68
  04E0    00EE    LD	0x6E,A
  04E1    086E    LD	A,0x6E
  04E2    1D03    SNZB	0x3,2
  04E3    2CE9    JP	0x4E9
  04E4    01E2    CLR	0x62
  04E5    01E3    CLR	0x63
  04E6    01E4    CLR	0x64
  04E7    01E5    CLR	0x65
  04E8    0008    RET
  04E9    27B7    CALL	0x7B7
  04EA    118A    CLRB	0xA,3
  04EB    3017    LDIA	0x17
  04EC    1003    CLRB	0x3,0
  04ED    0CE8    RRCR	0x68
  04EE    0CE7    RRCR	0x67
  04EF    0CE6    RRCR	0x66
  04F0    3EFF    ADDIA	0xFF
  04F1    1D03    SNZB	0x3,2
  04F2    2CEC    JP	0x4EC
  04F3    0866    LD	A,0x66
  04F4    00E9    LD	0x69,A
  04F5    17E3    SETB	0x63,7
  04F6    01E4    CLR	0x64
  04F7    0862    LD	A,0x62
  04F8    00EA    LD	0x6A,A
  04F9    0863    LD	A,0x63
  04FA    00EB    LD	0x6B,A
  04FB    0864    LD	A,0x64
  04FC    00EC    LD	0x6C,A
  04FD    308E    LDIA	0x8E
  04FE    01ED    CLR	0x6D
  04FF    02EE    SUBR	0x6E
  0500    1FEE    SNZB	0x6E,7
  0501    2D0F    JP	0x50F
  0502    086E    LD	A,0x6E
  0503    3A80    XORIA	0x80
  0504    3E8F    ADDIA	0x8F
  0505    1C03    SNZB	0x3,0
  0506    2CE4    JP	0x4E4
  0507    1003    CLRB	0x3,0
  0508    0CED    RRCR	0x6D
  0509    0CEC    RRCR	0x6C
  050A    0CEB    RRCR	0x6B
  050B    0CEA    RRCR	0x6A
  050C    0FEE    SZINCR	0x6E
  050D    2D07    JP	0x507
  050E    2D1D    JP	0x51D
  050F    3018    LDIA	0x18
  0510    026E    SUBA	0x6E
  0511    1803    SZB	0x3,0
  0512    2CE4    JP	0x4E4
  0513    086E    LD	A,0x6E
  0514    1903    SZB	0x3,2
  0515    2D1D    JP	0x51D
  0516    1003    CLRB	0x3,0
  0517    0DEA    RLCR	0x6A
  0518    0DEB    RLCR	0x6B
  0519    0DEC    RLCR	0x6C
  051A    0DED    RLCR	0x6D
  051B    03EE    DECR	0x6E
  051C    2D13    JP	0x513
  051D    0869    LD	A,0x69
  051E    1903    SZB	0x3,2
  051F    2D2B    JP	0x52B
  0520    09EA    COMR	0x6A
  0521    09EB    COMR	0x6B
  0522    09EC    COMR	0x6C
  0523    09ED    COMR	0x6D
  0524    0AEA    INCR	0x6A
  0525    1903    SZB	0x3,2
  0526    0AEB    INCR	0x6B
  0527    1903    SZB	0x3,2
  0528    0AEC    INCR	0x6C
  0529    1903    SZB	0x3,2
  052A    0AED    INCR	0x6D
  052B    086D    LD	A,0x6D
  052C    00E5    LD	0x65,A
  052D    086C    LD	A,0x6C
  052E    00E4    LD	0x64,A
  052F    086B    LD	A,0x6B
  0530    00E3    LD	0x63,A
  0531    086A    LD	A,0x6A
  0532    00E2    LD	0x62,A
  0533    0008    RET
45:               {
46:               	unsigned char	sign1, exp1;
47:               	unsigned long	lval;
48:               
49:               	if((exp1 = f1_as_mant1 >> 15) == 0)
50:               		return 0;
51:               	sign1 = f1_as_mant1 >> 23;
52:               	f1_as_mant1 |= 0x8000UL;
53:               	f1_as_mant1 &= 0xFFFFUL;
54:               	lval = f1_as_mant1;
55:               	exp1 -= 127+15;
56:               	if((signed char)exp1 < 0) {
57:               		if((signed char)exp1 < -15)
58:               			return 0;
59:               		do
60:               			lval >>= 1;
61:               		while(++exp1 != 0);
62:               	} else {
63:               		if(exp1 >= 24)
64:               			return 0;
65:               		while(exp1 != 0) {
66:               			lval <<= 1;
67:               			exp1--;
68:               		}
69:               	}
70:               	if(sign1)
71:               		lval = -lval;
72:               	return lval;
73:               }
74:               #endif
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\lwtoft.c ----------------------------------------------------------------------
1:                /*	Floating point routines.
2:                
3:                	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:                */
5:                
6:                // this is bigendian code right now. Need to parameterise it.
7:                
8:                #include	"ftarith.h"
9:                
10:               
11:               // Convert unsigned int to float
12:               
13:               #ifdef _OLDLIB
14:               #define	f1_as_mant1	(*(unsigned short long *)&f1)
15:               float
16:               __lwtoft(unsigned int c)
17:               {
18:               	float	f1;
19:               	
20:               	if(c == 0)
21:               		return 0.0;
22:               	f1_as_mant1 = c;
23:               	__ftpack(&f1_as_mant1, 127+15);
24:               	return f1;
25:               }
26:               #else
27:               float
28:               __lwtoft(unsigned int c)
  0534    0850    LD	A,0x50
  0535    00F2    LD	0x72,A
  0536    0851    LD	A,0x51
  0537    00F3    LD	0x73,A
  0538    308E    LDIA	0x8E
  0539    01F4    CLR	0x74
  053A    00F5    LD	0x75,A
  053B    01F6    CLR	0x76
  053C    2544    CALL	0x544
  053D    0872    LD	A,0x72
  053E    00D0    LD	0x50,A
  053F    0873    LD	A,0x73
  0540    00D1    LD	0x51,A
  0541    0874    LD	A,0x74
  0542    00D2    LD	0x52,A
  0543    0008    RET
29:               {
30:               	return __ftpack(c, 127+15, 0);
31:               }
32:               #endif
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\float.c ----------------------------------------------------------------------
1:                /*	Floating point routines.
2:                
3:                	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:                */
5:                
6:                #include	"ftarith.h"
7:                
8:                
9:                //	unpack the operand pointed to. Store the exponent into the location pointed to by exp,
10:               //	and return the sign (zero is positive)
11:               
12:               #ifdef _OLDLIB
13:               
14:               unsigned char
15:               __ftunpack(unsigned short long * arg, unsigned char * exp)
16:               {
17:               	unsigned char	sign;
18:               
19:               	*exp = sign = *arg >> 15;
20:               	if(sign == 0) {
21:               		*arg = 0;
22:               		return 0;
23:               	}
24:               	sign = 0;
25:               	*arg |= 0x8000;
26:               	if(*arg & 0x800000)
27:               		sign++;
28:               	*arg &= 0xFFFF;
29:               	return sign;
30:               }
31:               
32:               // normalize and pack the supplied argument into floating point format
33:               
34:               void
35:               __ftpack(unsigned short long * arg, unsigned char exp)
36:               {
37:               	if(exp == 0 || *arg == 0) {
38:               		*arg = 0;
39:               		return;
40:               	}
41:               	while(*arg & 0xFE0000UL) {
42:               		exp++;
43:               		*arg >>= 1;
44:               	}
45:               	while(*arg & 0xFF0000UL) {
46:               		exp++;
47:               		(*arg)++;
48:               		*arg >>= 1;
49:               	}
50:               	while(!(*arg & 0x8000UL)) {
51:               		exp--;
52:               		*arg <<= 1;
53:               	}
54:               	if(!(exp & 1))
55:               		*arg &= ~0x8000L;
56:               	exp >>= 1;
57:               	*arg |= (unsigned short long)exp << 16;
58:               }
59:               
60:               #else
61:               float
62:               __ftpack(unsigned short long arg, unsigned char exp, unsigned char sign)
  0544    0875    LD	A,0x75
  0545    1903    SZB	0x3,2
  0546    2D4C    JP	0x54C
  0547    0874    LD	A,0x74
  0548    0473    ORA	0x73
  0549    0472    ORA	0x72
  054A    1D03    SNZB	0x3,2
  054B    2D53    JP	0x553
  054C    01F2    CLR	0x72
  054D    01F3    CLR	0x73
  054E    01F4    CLR	0x74
  054F    0008    RET
  0550    0AF5    INCR	0x75
  0551    27BE    CALL	0x7BE
  0552    118A    CLRB	0xA,3
  0553    30FE    LDIA	0xFE
  0554    0574    ANDA	0x74
  0555    1903    SZB	0x3,2
  0556    2D60    JP	0x560
  0557    2D50    JP	0x550
  0558    0AF5    INCR	0x75
  0559    0AF2    INCR	0x72
  055A    1903    SZB	0x3,2
  055B    0AF3    INCR	0x73
  055C    1903    SZB	0x3,2
  055D    0AF4    INCR	0x74
  055E    27BE    CALL	0x7BE
  055F    118A    CLRB	0xA,3
  0560    30FF    LDIA	0xFF
  0561    0574    ANDA	0x74
  0562    1903    SZB	0x3,2
  0563    2D6E    JP	0x56E
  0564    2D58    JP	0x558
  0565    3002    LDIA	0x2
  0566    0275    SUBA	0x75
  0567    1C03    SNZB	0x3,0
  0568    2D70    JP	0x570
  0569    03F5    DECR	0x75
  056A    1003    CLRB	0x3,0
  056B    0DF2    RLCR	0x72
  056C    0DF3    RLCR	0x73
  056D    0DF4    RLCR	0x74
  056E    1FF3    SNZB	0x73,7
  056F    2D65    JP	0x565
  0570    1C75    SNZB	0x75,0
  0571    13F3    CLRB	0x73,7
  0572    1003    CLRB	0x3,0
  0573    0CF5    RRCR	0x75
  0574    0875    LD	A,0x75
  0575    00CF    LD	0x4F,A
  0576    01CE    CLR	0x4E
  0577    01CD    CLR	0x4D
  0578    084D    LD	A,0x4D
  0579    04F2    ORR	0x72
  057A    084E    LD	A,0x4E
  057B    04F3    ORR	0x73
  057C    084F    LD	A,0x4F
  057D    04F4    ORR	0x74
  057E    0876    LD	A,0x76
  057F    1D03    SNZB	0x3,2
  0580    17F4    SETB	0x74,7
  0581    0008    RET
63:               {
64:               	if(exp == 0 || arg == 0)
65:               		return 0.0;
66:               	while(arg & 0xFE0000UL) {
67:               		exp++;
68:               		arg >>= 1;
69:               	}
70:               	while(arg & 0xFF0000UL) {
71:               		exp++;
72:               		(arg)++;
73:               		arg >>= 1;
74:               	}
75:               	while(!(arg & 0x8000UL) && exp > 1) {
76:               		exp--;
77:               		arg <<= 1;
78:               	}
79:               	if(!(exp & 1))
80:               		arg &= ~0x8000L;
81:               	exp >>= 1;
82:               	arg |= (unsigned short long)exp << 16;
83:               	if (sign)
84:               		arg |= 0x800000UL;
85:                  return *(float*)&arg;	
86:               }
87:               
88:               #endif
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\Umul32.c ----------------------------------------------------------------------
1:                // 32 x 32 bit multiplication with 32 bit result
2:                #ifdef _PIC18
3:                #define _Has_hardware_multiply 1
4:                #else
5:                #define _Has_hardware_multiply 0
6:                #endif
7:                
8:                #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:                #define _Has_large_call_stack 1
10:               #else
11:               #define _Has_large_call_stack 0
12:               #endif
13:               
14:               unsigned long
15:               __lmul(unsigned long multiplier, unsigned long multiplicand)
  06C2    01F2    CLR	0x72
  06C3    01F3    CLR	0x73
  06C4    01F4    CLR	0x74
  06C5    01F5    CLR	0x75
  06C6    1C4D    SNZB	0x4D,0
  06C7    2EDC    JP	0x6DC
  06C8    0851    LD	A,0x51
  06C9    07F2    ADDR	0x72
  06CA    0852    LD	A,0x52
  06CB    1103    CLRB	0x3,2
  06CC    1803    SZB	0x3,0
  06CD    3E01    ADDIA	0x1
  06CE    1D03    SNZB	0x3,2
  06CF    07F3    ADDR	0x73
  06D0    0853    LD	A,0x53
  06D1    1103    CLRB	0x3,2
  06D2    1803    SZB	0x3,0
  06D3    3E01    ADDIA	0x1
  06D4    1D03    SNZB	0x3,2
  06D5    07F4    ADDR	0x74
  06D6    0854    LD	A,0x54
  06D7    1103    CLRB	0x3,2
  06D8    1803    SZB	0x3,0
  06D9    3E01    ADDIA	0x1
  06DA    1D03    SNZB	0x3,2
  06DB    07F5    ADDR	0x75
  06DC    1003    CLRB	0x3,0
  06DD    0DD1    RLCR	0x51
  06DE    0DD2    RLCR	0x52
  06DF    0DD3    RLCR	0x53
  06E0    0DD4    RLCR	0x54
  06E1    1003    CLRB	0x3,0
  06E2    0CD0    RRCR	0x50
  06E3    0CCF    RRCR	0x4F
  06E4    0CCE    RRCR	0x4E
  06E5    0CCD    RRCR	0x4D
  06E6    0850    LD	A,0x50
  06E7    044F    ORA	0x4F
  06E8    044E    ORA	0x4E
  06E9    044D    ORA	0x4D
  06EA    1D03    SNZB	0x3,2
  06EB    2EC6    JP	0x6C6
  06EC    0875    LD	A,0x75
  06ED    00D0    LD	0x50,A
  06EE    0874    LD	A,0x74
  06EF    00CF    LD	0x4F,A
  06F0    0873    LD	A,0x73
  06F1    00CE    LD	0x4E,A
  06F2    0872    LD	A,0x72
  06F3    00CD    LD	0x4D,A
  06F4    0008    RET
16:               {
17:               	unsigned long product;
18:               
19:               #define LOWBYTE(x)  (*(unsigned char *)(&x))
20:               #define LMIDBYTE(x) (*(((unsigned char *)(&x))+1))
21:               #define HMIDBYTE(x) (*(((unsigned char *)(&x))+2))
22:               #define HIGHBYTE(x) (*(((unsigned char *)(&x))+3))
23:               
24:               #if (_Has_hardware_multiply || _Has_large_call_stack) && defined(__OPTIMIZE_SPEED__)
25:               	{
26:               
27:               #define USE_SHRINK
28:               
29:               /*
30:               a 32-bit multiply can be decomposed into the sum of ten 8-bit multiplies
31:                            a  b  c  d
32:               *            e  f  g  h
33:               -----------------------
34:                          |         dh
35:                          |      ch  0
36:                          |   bh  0  0
37:                          |ah  0  0  0
38:                          |      dg  0
39:                          |   cg  0  0
40:                          |bg  0  0  0
41:                        ag| 0  0  0  0 (we ignore this intermediate product
42:                                        because it does not affect the low 32 bits of the result)
43:                          |   df  0  0
44:                          |cf  0  0  0
45:                        bf| 0  0  0  0 (ignore)
46:                     af  0| 0  0  0  0 (ignore)
47:                          |de  0  0  0
48:                        ce| 0  0  0  0 (ignore)
49:                     be  0| 0  0  0  0 (ignore)
50:               +  ae  0  0| 0  0  0  0 (ignore)
51:               =======================
52:                */
53:               		product =  (unsigned int)LOWBYTE(multiplier) * LOWBYTE(multiplicand);
54:               
55:               #if defined(USE_MASKS)
56:               		product += ((unsigned long)
57:               			     ((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand))
58:               			     +
59:               			     ((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
60:               			<< 8;
61:               
62:               		product += ((unsigned long)
63:               			    ((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand))
64:               			    +
65:               			    ((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
66:               			    +
67:               			    ((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
68:               			<< 16;
69:               
70:               		/* cast to smaller type to avoid adding high bits just to discard */
71:               		product += ((unsigned long)
72:               			    (unsigned char)
73:               			    ((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand))
74:               			    +
75:               			    (unsigned char)
76:               			    ((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand))
77:               			    +
78:               			    (unsigned char)
79:               			    ((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
80:               			    +
81:               			    (unsigned char)
82:               			    ((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand)))
83:               			<< 24;
84:               
85:               #elif defined(USE_SHRINK)
86:               		/* add direct to upper bytes, rather than shift and add all bytes */
87:               		*((unsigned short long*)(((unsigned char*)&product)+1)) +=
88:               			((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand));
89:               		*((unsigned short long*)(((unsigned char*)&product)+1)) +=
90:               			((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand));
91:               
92:               
93:               		*((unsigned int*)(((unsigned char*)&product)+2)) +=
94:               			((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand));
95:               		*((unsigned int*)(((unsigned char*)&product)+2)) +=
96:               			((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
97:               		*((unsigned int*)(((unsigned char*)&product)+2)) +=
98:               			((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand));
99:               
100:              		*(((unsigned char*)&product)+3) +=
101:              			(unsigned char)
102:              			((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand));
103:              		*(((unsigned char*)&product)+3) +=
104:              			(unsigned char)
105:              			((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand));
106:              		*(((unsigned char*)&product)+3) +=
107:              			(unsigned char)
108:              			((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
109:              		*(((unsigned char*)&product)+3) +=
110:              			(unsigned char)
111:              			((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand));
112:              
113:              #else
114:              #error No method chosen
115:              #endif
116:              	}
117:              #else
118:              
119:              	product = 0;
120:              	do {
121:              		if(multiplier & 1)
122:              			product += multiplicand;
123:              		multiplicand <<= 1;
124:              		multiplier >>= 1;
125:              	} while(multiplier != 0);
126:              
127:              #endif
128:              	return product;
129:              }
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\lwmod.c ----------------------------------------------------------------------
1:                // word unsigned modulus
2:                
3:                unsigned int
4:                #ifdef __PICC__
5:                #warning TODO: update cgpic and this file to use the other prototype
6:                __lwmod(unsigned int divisor, unsigned int dividend)
  076A    0872    LD	A,0x72
  076B    0473    ORA	0x73
  076C    1903    SZB	0x3,2
  076D    2F89    JP	0x789
  076E    01F6    CLR	0x76
  076F    0AF6    INCR	0x76
  0770    1BF3    SZB	0x73,7
  0771    2F76    JP	0x776
  0772    1003    CLRB	0x3,0
  0773    0DF2    RLCR	0x72
  0774    0DF3    RLCR	0x73
  0775    2F6F    JP	0x76F
  0776    0873    LD	A,0x73
  0777    0275    SUBA	0x75
  0778    1D03    SNZB	0x3,2
  0779    2F7C    JP	0x77C
  077A    0872    LD	A,0x72
  077B    0274    SUBA	0x74
  077C    1C03    SNZB	0x3,0
  077D    2F85    JP	0x785
  077E    0872    LD	A,0x72
  077F    02F4    SUBR	0x74
  0780    0873    LD	A,0x73
  0781    1C03    SNZB	0x3,0
  0782    03F5    DECR	0x75
  0783    02F5    SUBR	0x75
  0784    1003    CLRB	0x3,0
  0785    0CF3    RRCR	0x73
  0786    0CF2    RRCR	0x72
  0787    0BF6    SZDECR	0x76
  0788    2F76    JP	0x776
  0789    0875    LD	A,0x75
  078A    00F3    LD	0x73,A
  078B    0874    LD	A,0x74
  078C    00F2    LD	0x72,A
  078D    0008    RET
7:                #else
8:                __lwmod(unsigned int dividend, unsigned int divisor)
9:                #endif
10:               {
11:               	unsigned char	counter;
12:               
13:               	if(divisor != 0) {
14:               		counter = 1;
15:               		while((divisor & 0x8000) == 0) {
16:               			divisor <<= 1;
17:               			counter++;
18:               		}
19:               		do {
20:               			if(divisor <= dividend)
21:               				dividend -= divisor;
22:               			divisor >>= 1;
23:               		} while(--counter != 0);
24:               	}
25:               	return dividend;
26:               }
---- library_code ------------------------------------------------------------------
  006D    1A78    SZB	0x78,4
  006E    287B    JP	0x7B
  006F    212A    CALL	0x12A
  0070    118A    CLRB	0xA,3
  0071    3008    LDIA	0x8
  0072    1283    CLRB	0x3,5
  0073    1303    CLRB	0x3,6
  0074    0AB8    INCR	0x38
  0075    0238    SUBA	0x38
  0076    1C03    SNZB	0x3,0
  0077    2899    JP	0x99
  0078    01B8    CLR	0x38
  0079    1678    SETB	0x78,4
  007A    2899    JP	0x99
  007B    19F8    SZB	0x78,3
  007C    2893    JP	0x93
  007D    2199    CALL	0x199
  007E    118A    CLRB	0xA,3
  007F    232B    CALL	0x32B
  0080    118A    CLRB	0xA,3
  0081    15F8    SETB	0x78,3
  0082    18F8    SZB	0x78,1
  0083    288A    JP	0x8A
  0084    3002    LDIA	0x2
  0085    1283    CLRB	0x3,5
  0086    1303    CLRB	0x3,6
  0087    0238    SUBA	0x38
  0088    1C03    SNZB	0x3,0
  0089    288F    JP	0x8F
  008A    2315    CALL	0x315
  008B    118A    CLRB	0xA,3
  008C    10F8    CLRB	0x78,1
  008D    1278    CLRB	0x78,4
  008E    11F8    CLRB	0x78,3
  008F    1283    CLRB	0x3,5
  0090    1303    CLRB	0x3,6
  0091    01B8    CLR	0x38
  0092    2899    JP	0x99
  0093    22B1    CALL	0x2B1
  0094    118A    CLRB	0xA,3
  0095    218A    CALL	0x18A
  0096    118A    CLRB	0xA,3
  0097    1278    CLRB	0x78,4
  0098    11F8    CLRB	0x78,3
  0099    2B5E    JP	0x35E
  009A    0064    CLRWDT
  009B    1683    SETB	0x3,5
  009C    1303    CLRB	0x3,6
  009D    0181    CLR	0x1
  009E    3007    LDIA	0x7
  009F    1283    CLRB	0x3,5
  00A0    0481    ORR	0x1
  00A1    1581    SETB	0x1,3
  00A2    0064    CLRWDT
  00A3    300A    LDIA	0xA
  00A4    1283    CLRB	0x3,5
  00A5    1303    CLRB	0x3,6
  00A6    0081    LD	0x1,A
  00A7    0064    CLRWDT
  00A8    1283    CLRB	0x3,5
  00A9    1703    SETB	0x3,6
  00AA    0191    CLR	0x11
  00AB    0193    CLR	0x13
  00AC    3002    LDIA	0x2
  00AD    1303    CLRB	0x3,6
  00AE    0094    LD	0x14,A
  00AF    0063    STOP
  00B0    0000    NOP
  00B1    0064    CLRWDT
  00B2    3072    LDIA	0x72
  00B3    1283    CLRB	0x3,5
  00B4    1303    CLRB	0x3,6
  00B5    0094    LD	0x14,A
  00B6    3079    LDIA	0x79
  00B7    1703    SETB	0x3,6
  00B8    0093    LD	0x13,A
  00B9    218A    CALL	0x18A
  00BA    118A    CLRB	0xA,3
  00BB    1478    SETB	0x78,0
  00BC    212A    CALL	0x12A
  00BD    118A    CLRB	0xA,3
  00BE    1283    CLRB	0x3,5
  00BF    1303    CLRB	0x3,6
  00C0    23F0    CALL	0x3F0
  00C1    118A    CLRB	0xA,3
  00C2    1C0B    SNZB	0xB,0
  00C3    188B    SZB	0xB,1
  00C4    28C7    JP	0xC7
  00C5    1D8D    SNZB	0xD,3
  00C6    28CE    JP	0xCE
  00C7    218A    CALL	0x18A
  00C8    1283    CLRB	0x3,5
  00C9    1303    CLRB	0x3,6
  00CA    01B8    CLR	0x38
  00CB    1278    CLRB	0x78,4
  00CC    11F8    CLRB	0x78,3
  00CD    0008    RET
  00CE    0853    LD	A,0x53
  00CF    3907    ANDIA	0x7
  00D0    1003    CLRB	0x3,0
  00D1    1903    SZB	0x3,2
  00D2    2924    JP	0x124
  00D3    0D55    RLCA	0x55
  00D4    3EB8    ADDIA	0xB8
  00D5    0084    LD	0x4,A
  00D6    1383    CLRB	0x3,7
  00D7    0800    LD	A,0x0
  00D8    00D1    LD	0x51,A
  00D9    0A84    INCR	0x4
  00DA    0800    LD	A,0x0
  00DB    00D2    LD	0x52,A
  00DC    00D0    LD	0x50,A
  00DD    0851    LD	A,0x51
  00DE    00CF    LD	0x4F,A
  00DF    0851    LD	A,0x51
  00E0    0452    ORA	0x52
  00E1    1903    SZB	0x3,2
  00E2    2923    JP	0x123
  00E3    0855    LD	A,0x55
  00E4    3E09    ADDIA	0x9
  00E5    0084    LD	0x4,A
  00E6    158A    SETB	0xA,3
  00E7    2000    CALL	0x0
  00E8    118A    CLRB	0xA,3
  00E9    07CF    ADDR	0x4F
  00EA    1803    SZB	0x3,0
  00EB    0AD0    INCR	0x50
  00EC    1003    CLRB	0x3,0
  00ED    0D55    RLCA	0x55
  00EE    3EA6    ADDIA	0xA6
  00EF    23CF    CALL	0x3CF
  00F0    118A    CLRB	0xA,3
  00F1    0850    LD	A,0x50
  00F2    024E    SUBA	0x4E
  00F3    1D03    SNZB	0x3,2
  00F4    28F7    JP	0xF7
  00F5    084F    LD	A,0x4F
  00F6    024D    SUBA	0x4D
  00F7    1C03    SNZB	0x3,0
  00F8    290B    JP	0x10B
  00F9    23F0    CALL	0x3F0
  00FA    118A    CLRB	0xA,3
  00FB    0853    LD	A,0x53
  00FC    3907    ANDIA	0x7
  00FD    1D03    SNZB	0x3,2
  00FE    2902    JP	0x102
  00FF    0855    LD	A,0x55
  0100    228E    CALL	0x28E
  0101    118A    CLRB	0xA,3
  0102    1283    CLRB	0x3,5
  0103    3003    LDIA	0x3
  0104    1303    CLRB	0x3,6
  0105    1003    CLRB	0x3,0
  0106    23F5    CALL	0x3F5
  0107    118A    CLRB	0xA,3
  0108    1803    SZB	0x3,0
  0109    28C7    JP	0xC7
  010A    28FB    JP	0xFB
  010B    0D55    RLCA	0x55
  010C    3EAC    ADDIA	0xAC
  010D    23CF    CALL	0x3CF
  010E    118A    CLRB	0xA,3
  010F    1003    CLRB	0x3,0
  0110    0D55    RLCA	0x55
  0111    3EA6    ADDIA	0xA6
  0112    23B9    CALL	0x3B9
  0113    118A    CLRB	0xA,3
  0114    0800    LD	A,0x0
  0115    00CD    LD	0x4D,A
  0116    0A84    INCR	0x4
  0117    0800    LD	A,0x0
  0118    00CE    LD	0x4E,A
  0119    1003    CLRB	0x3,0
  011A    0D55    RLCA	0x55
  011B    3EAC    ADDIA	0xAC
  011C    23B9    CALL	0x3B9
  011D    118A    CLRB	0xA,3
  011E    0851    LD	A,0x51
  011F    0080    LD	0x0,A
  0120    0A84    INCR	0x4
  0121    0852    LD	A,0x52
  0122    0080    LD	0x0,A
  0123    1003    CLRB	0x3,0
  0124    3003    LDIA	0x3
  0125    23F5    CALL	0x3F5
  0126    118A    CLRB	0xA,3
  0127    1803    SZB	0x3,0
  0128    289A    JP	0x9A
  0129    28CE    JP	0xCE
  012A    01F7    CLR	0x77
  012B    01F5    CLR	0x75
  012C    0AF5    INCR	0x75
  012D    01F6    CLR	0x76
  012E    1C78    SNZB	0x78,0
  012F    2934    JP	0x134
  0130    0875    LD	A,0x75
  0131    3907    ANDIA	0x7
  0132    1903    SZB	0x3,2
  0133    2980    JP	0x180
  0134    1283    CLRB	0x3,5
  0135    1703    SETB	0x3,6
  0136    0191    CLR	0x11
  0137    0192    CLR	0x12
  0138    3079    LDIA	0x79
  0139    0093    LD	0x13,A
  013A    1303    CLRB	0x3,6
  013B    1305    CLRB	0x5,6
  013C    1306    CLRB	0x6,6
  013D    0000    NOP
  013E    0000    NOP
  013F    0000    NOP
  0140    0000    NOP
  0141    0000    NOP
  0142    0000    NOP
  0143    0000    NOP
  0144    0000    NOP
  0145    1283    CLRB	0x3,5
  0146    1303    CLRB	0x3,6
  0147    1705    SETB	0x5,6
  0148    0877    LD	A,0x77
  0149    3E0C    ADDIA	0xC
  014A    0084    LD	0x4,A
  014B    158A    SETB	0xA,3
  014C    2000    CALL	0x0
  014D    118A    CLRB	0xA,3
  014E    1703    SETB	0x3,6
  014F    0091    LD	0x11,A
  0150    0877    LD	A,0x77
  0151    3E0F    ADDIA	0xF
  0152    0084    LD	0x4,A
  0153    158A    SETB	0xA,3
  0154    2000    CALL	0x0
  0155    118A    CLRB	0xA,3
  0156    0092    LD	0x12,A
  0157    0000    NOP
  0158    0000    NOP
  0159    0000    NOP
  015A    0000    NOP
  015B    1283    CLRB	0x3,5
  015C    1703    SETB	0x3,6
  015D    1411    SETB	0x11,0
  015E    30D0    LDIA	0xD0
  015F    00F3    LD	0x73,A
  0160    3007    LDIA	0x7
  0161    00F4    LD	0x74,A
  0162    1B91    SZB	0x11,7
  0163    2970    JP	0x170
  0164    3001    LDIA	0x1
  0165    02F3    SUBR	0x73
  0166    1C03    SNZB	0x3,0
  0167    03F4    DECR	0x74
  0168    0873    LD	A,0x73
  0169    0474    ORA	0x74
  016A    1D03    SNZB	0x3,2
  016B    2962    JP	0x162
  016C    30FF    LDIA	0xFF
  016D    1303    CLRB	0x3,6
  016E    00B8    LD	0x38,A
  016F    298A    JP	0x18A
  0170    1003    CLRB	0x3,0
  0171    0D77    RLCA	0x77
  0172    3EB8    ADDIA	0xB8
  0173    0084    LD	0x4,A
  0174    0816    LD	A,0x16
  0175    1383    CLRB	0x3,7
  0176    0780    ADDR	0x0
  0177    0F84    SZINCR	0x4
  0178    0800    LD	A,0x0
  0179    1803    SZB	0x3,0
  017A    0A00    INCA	0x0
  017B    00FF    LD	0x7F,A
  017C    0817    LD	A,0x17
  017D    077F    ADDA	0x7F
  017E    0080    LD	0x0,A
  017F    0384    DECR	0x4
  0180    3003    LDIA	0x3
  0181    1003    CLRB	0x3,0
  0182    0DF5    RLCR	0x75
  0183    0DF6    RLCR	0x76
  0184    0AF7    INCR	0x77
  0185    0277    SUBA	0x77
  0186    1C03    SNZB	0x3,0
  0187    292E    JP	0x12E
  0188    1078    CLRB	0x78,0
  0189    0008    RET
  018A    01F2    CLR	0x72
  018B    1003    CLRB	0x3,0
  018C    0D72    RLCA	0x72
  018D    3EB8    ADDIA	0xB8
  018E    0084    LD	0x4,A
  018F    3003    LDIA	0x3
  0190    1383    CLRB	0x3,7
  0191    0180    CLR	0x0
  0192    0A84    INCR	0x4
  0193    0180    CLR	0x0
  0194    0AF2    INCR	0x72
  0195    0272    SUBA	0x72
  0196    1803    SZB	0x3,0
  0197    0008    RET
  0198    298B    JP	0x18B
  0199    1283    CLRB	0x3,5
  019A    1303    CLRB	0x3,6
  019B    01D9    CLR	0x59
  019C    01F9    CLR	0x79
  019D    01FA    CLR	0x7A
  019E    01B7    CLR	0x37
  019F    0859    LD	A,0x59
  01A0    3907    ANDIA	0x7
  01A1    3E01    ADDIA	0x1
  01A2    0084    LD	0x4,A
  01A3    158A    SETB	0xA,3
  01A4    2000    CALL	0x0
  01A5    118A    CLRB	0xA,3
  01A6    00D3    LD	0x53,A
  01A7    1003    CLRB	0x3,0
  01A8    0D59    RLCA	0x59
  01A9    3EB8    ADDIA	0xB8
  01AA    0084    LD	0x4,A
  01AB    3003    LDIA	0x3
  01AC    0A84    INCR	0x4
  01AD    1003    CLRB	0x3,0
  01AE    1383    CLRB	0x3,7
  01AF    0C80    RRCR	0x0
  01B0    0384    DECR	0x4
  01B1    0C80    RRCR	0x0
  01B2    3EFF    ADDIA	0xFF
  01B3    1D03    SNZB	0x3,2
  01B4    29AC    JP	0x1AC
  01B5    1003    CLRB	0x3,0
  01B6    0D59    RLCA	0x59
  01B7    3EB8    ADDIA	0xB8
  01B8    0084    LD	0x4,A
  01B9    0800    LD	A,0x0
  01BA    00D7    LD	0x57,A
  01BB    0A84    INCR	0x4
  01BC    0800    LD	A,0x0
  01BD    00D8    LD	0x58,A
  01BE    0859    LD	A,0x59
  01BF    3E09    ADDIA	0x9
  01C0    0084    LD	0x4,A
  01C1    158A    SETB	0xA,3
  01C2    2000    CALL	0x0
  01C3    118A    CLRB	0xA,3
  01C4    00D6    LD	0x56,A
  01C5    00D4    LD	0x54,A
  01C6    01D5    CLR	0x55
  01C7    0857    LD	A,0x57
  01C8    07D4    ADDR	0x54
  01C9    1803    SZB	0x3,0
  01CA    0AD5    INCR	0x55
  01CB    0858    LD	A,0x58
  01CC    07D5    ADDR	0x55
  01CD    0859    LD	A,0x59
  01CE    227A    CALL	0x27A
  01CF    118A    CLRB	0xA,3
  01D0    3A00    XORIA	0x0
  01D1    1003    CLRB	0x3,0
  01D2    1D03    SNZB	0x3,2
  01D3    2A2E    JP	0x22E
  01D4    0D59    RLCA	0x59
  01D5    3EA6    ADDIA	0xA6
  01D6    0084    LD	0x4,A
  01D7    1383    CLRB	0x3,7
  01D8    0800    LD	A,0x0
  01D9    00D1    LD	0x51,A
  01DA    0A84    INCR	0x4
  01DB    0800    LD	A,0x0
  01DC    00D2    LD	0x52,A
  01DD    1003    CLRB	0x3,0
  01DE    0D59    RLCA	0x59
  01DF    3EA0    ADDIA	0xA0
  01E0    23B2    CALL	0x3B2
  01E1    118A    CLRB	0xA,3
  01E2    0255    SUBA	0x55
  01E3    1D03    SNZB	0x3,2
  01E4    29E7    JP	0x1E7
  01E5    084D    LD	A,0x4D
  01E6    0254    SUBA	0x54
  01E7    1803    SZB	0x3,0
  01E8    29F6    JP	0x1F6
  01E9    1003    CLRB	0x3,0
  01EA    0D59    RLCA	0x59
  01EB    3EA0    ADDIA	0xA0
  01EC    23B2    CALL	0x3B2
  01ED    118A    CLRB	0xA,3
  01EE    0857    LD	A,0x57
  01EF    024D    SUBA	0x4D
  01F0    00D7    LD	0x57,A
  01F1    0858    LD	A,0x58
  01F2    1C03    SNZB	0x3,0
  01F3    0A58    INCA	0x58
  01F4    024E    SUBA	0x4E
  01F5    2A1A    JP	0x21A
  01F6    0852    LD	A,0x52
  01F7    0255    SUBA	0x55
  01F8    1D03    SNZB	0x3,2
  01F9    29FC    JP	0x1FC
  01FA    0851    LD	A,0x51
  01FB    0254    SUBA	0x54
  01FC    1803    SZB	0x3,0
  01FD    2A72    JP	0x272
  01FE    1003    CLRB	0x3,0
  01FF    0D59    RLCA	0x59
  0200    3EAC    ADDIA	0xAC
  0201    23B2    CALL	0x3B2
  0202    118A    CLRB	0xA,3
  0203    0255    SUBA	0x55
  0204    1D03    SNZB	0x3,2
  0205    2A08    JP	0x208
  0206    084D    LD	A,0x4D
  0207    0254    SUBA	0x54
  0208    1803    SZB	0x3,0
  0209    2A72    JP	0x272
  020A    1003    CLRB	0x3,0
  020B    0D59    RLCA	0x59
  020C    3EA0    ADDIA	0xA0
  020D    0084    LD	0x4,A
  020E    0851    LD	A,0x51
  020F    0080    LD	0x0,A
  0210    0A84    INCR	0x4
  0211    0852    LD	A,0x52
  0212    0080    LD	0x0,A
  0213    0857    LD	A,0x57
  0214    0251    SUBA	0x51
  0215    00D7    LD	0x57,A
  0216    0858    LD	A,0x58
  0217    1C03    SNZB	0x3,0
  0218    0A58    INCA	0x58
  0219    0252    SUBA	0x52
  021A    00D8    LD	0x58,A
  021B    0859    LD	A,0x59
  021C    3EBE    ADDIA	0xBE
  021D    0084    LD	0x4,A
  021E    0180    CLR	0x0
  021F    0858    LD	A,0x58
  0220    1903    SZB	0x3,2
  0221    2A24    JP	0x224
  0222    30FF    LDIA	0xFF
  0223    2A25    JP	0x225
  0224    0857    LD	A,0x57
  0225    00D6    LD	0x56,A
  0226    0237    SUBA	0x37
  0227    1803    SZB	0x3,0
  0228    2A2C    JP	0x22C
  0229    0856    LD	A,0x56
  022A    00B7    LD	0x37,A
  022B    2A6C    JP	0x26C
  022C    0AB8    INCR	0x38
  022D    2A72    JP	0x272
  022E    0D59    RLCA	0x59
  022F    3EA0    ADDIA	0xA0
  0230    0084    LD	0x4,A
  0231    1383    CLRB	0x3,7
  0232    0800    LD	A,0x0
  0233    00CD    LD	0x4D,A
  0234    0A84    INCR	0x4
  0235    0800    LD	A,0x0
  0236    00CE    LD	0x4E,A
  0237    084D    LD	A,0x4D
  0238    3E01    ADDIA	0x1
  0239    00CF    LD	0x4F,A
  023A    084E    LD	A,0x4E
  023B    1803    SZB	0x3,0
  023C    3E01    ADDIA	0x1
  023D    00D0    LD	0x50,A
  023E    0855    LD	A,0x55
  023F    0250    SUBA	0x50
  0240    1D03    SNZB	0x3,2
  0241    2A44    JP	0x244
  0242    0854    LD	A,0x54
  0243    024F    SUBA	0x4F
  0244    1C03    SNZB	0x3,0
  0245    2A72    JP	0x272
  0246    1003    CLRB	0x3,0
  0247    0D59    RLCA	0x59
  0248    3EA6    ADDIA	0xA6
  0249    0084    LD	0x4,A
  024A    0800    LD	A,0x0
  024B    23A0    CALL	0x3A0
  024C    118A    CLRB	0xA,3
  024D    1C03    SNZB	0x3,0
  024E    2A58    JP	0x258
  024F    1003    CLRB	0x3,0
  0250    0D59    RLCA	0x59
  0251    3EAC    ADDIA	0xAC
  0252    0084    LD	0x4,A
  0253    0800    LD	A,0x0
  0254    23A0    CALL	0x3A0
  0255    118A    CLRB	0xA,3
  0256    1803    SZB	0x3,0
  0257    2A64    JP	0x264
  0258    0859    LD	A,0x59
  0259    3EBE    ADDIA	0xBE
  025A    0084    LD	0x4,A
  025B    3009    LDIA	0x9
  025C    0A80    INCR	0x0
  025D    0200    SUBA	0x0
  025E    1C03    SNZB	0x3,0
  025F    2A68    JP	0x268
  0260    0859    LD	A,0x59
  0261    228E    CALL	0x28E
  0262    118A    CLRB	0xA,3
  0263    2A72    JP	0x272
  0264    0859    LD	A,0x59
  0265    3EBE    ADDIA	0xBE
  0266    0084    LD	0x4,A
  0267    0180    CLR	0x0
  0268    087A    LD	A,0x7A
  0269    0479    ORA	0x79
  026A    1D03    SNZB	0x3,2
  026B    2A72    JP	0x272
  026C    0853    LD	A,0x53
  026D    00F2    LD	0x72,A
  026E    01F3    CLR	0x73
  026F    0859    LD	A,0x59
  0270    22A3    CALL	0x2A3
  0271    118A    CLRB	0xA,3
  0272    3003    LDIA	0x3
  0273    1283    CLRB	0x3,5
  0274    1303    CLRB	0x3,6
  0275    0AD9    INCR	0x59
  0276    0259    SUBA	0x59
  0277    1803    SZB	0x3,0
  0278    0008    RET
  0279    299F    JP	0x19F
  027A    00F3    LD	0x73,A
  027B    3907    ANDIA	0x7
  027C    3E01    ADDIA	0x1
  027D    0084    LD	0x4,A
  027E    158A    SETB	0xA,3
  027F    2000    CALL	0x0
  0280    118A    CLRB	0xA,3
  0281    00F2    LD	0x72,A
  0282    1DF3    SNZB	0x73,3
  0283    2A88    JP	0x288
  0284    1283    CLRB	0x3,5
  0285    1303    CLRB	0x3,6
  0286    0833    LD	A,0x33
  0287    2A8B    JP	0x28B
  0288    1283    CLRB	0x3,5
  0289    1303    CLRB	0x3,6
  028A    0832    LD	A,0x32
  028B    05F2    ANDR	0x72
  028C    0872    LD	A,0x72
  028D    0008    RET
  028E    00F2    LD	0x72,A
  028F    1003    CLRB	0x3,0
  0290    0D72    RLCA	0x72
  0291    3EB2    ADDIA	0xB2
  0292    0084    LD	0x4,A
  0293    1383    CLRB	0x3,7
  0294    23DE    CALL	0x3DE
  0295    118A    CLRB	0xA,3
  0296    3EAC    ADDIA	0xAC
  0297    0084    LD	0x4,A
  0298    23DE    CALL	0x3DE
  0299    118A    CLRB	0xA,3
  029A    3EA6    ADDIA	0xA6
  029B    0084    LD	0x4,A
  029C    23DE    CALL	0x3DE
  029D    3EA0    ADDIA	0xA0
  029E    0084    LD	0x4,A
  029F    0180    CLR	0x0
  02A0    0A84    INCR	0x4
  02A1    0180    CLR	0x0
  02A2    0008    RET
  02A3    00F4    LD	0x74,A
  02A4    1283    CLRB	0x3,5
  02A5    1303    CLRB	0x3,6
  02A6    0AB8    INCR	0x38
  02A7    01F9    CLR	0x79
  02A8    01FA    CLR	0x7A
  02A9    1DF4    SNZB	0x74,3
  02AA    2AAE    JP	0x2AE
  02AB    0872    LD	A,0x72
  02AC    00FA    LD	0x7A,A
  02AD    0008    RET
  02AE    0872    LD	A,0x72
  02AF    00F9    LD	0x79,A
  02B0    0008    RET
  02B1    1283    CLRB	0x3,5
  02B2    3004    LDIA	0x4
  02B3    1303    CLRB	0x3,6
  02B4    01D1    CLR	0x51
  02B5    0AB6    INCR	0x36
  02B6    0236    SUBA	0x36
  02B7    1C03    SNZB	0x3,0
  02B8    0008    RET
  02B9    01B6    CLR	0x36
  02BA    1003    CLRB	0x3,0
  02BB    0D51    RLCA	0x51
  02BC    3EB8    ADDIA	0xB8
  02BD    0084    LD	0x4,A
  02BE    1383    CLRB	0x3,7
  02BF    0800    LD	A,0x0
  02C0    00CD    LD	0x4D,A
  02C1    0A84    INCR	0x4
  02C2    0800    LD	A,0x0
  02C3    00CE    LD	0x4E,A
  02C4    0851    LD	A,0x51
  02C5    227A    CALL	0x27A
  02C6    118A    CLRB	0xA,3
  02C7    3A00    XORIA	0x0
  02C8    1003    CLRB	0x3,0
  02C9    1D03    SNZB	0x3,2
  02CA    2AFF    JP	0x2FF
  02CB    0D51    RLCA	0x51
  02CC    3EB2    ADDIA	0xB2
  02CD    0084    LD	0x4,A
  02CE    1383    CLRB	0x3,7
  02CF    2392    CALL	0x392
  02D0    118A    CLRB	0xA,3
  02D1    1903    SZB	0x3,2
  02D2    024F    SUBA	0x4F
  02D3    1C03    SNZB	0x3,0
  02D4    2ADB    JP	0x2DB
  02D5    0F4F    SZINCA	0x4F
  02D6    2AFE    JP	0x2FE
  02D7    0A50    INCA	0x50
  02D8    1003    CLRB	0x3,0
  02D9    1D03    SNZB	0x3,2
  02DA    2AFF    JP	0x2FF
  02DB    0D51    RLCA	0x51
  02DC    3EAC    ADDIA	0xAC
  02DD    0084    LD	0x4,A
  02DE    2392    CALL	0x392
  02DF    118A    CLRB	0xA,3
  02E0    1903    SZB	0x3,2
  02E1    024F    SUBA	0x4F
  02E2    1C03    SNZB	0x3,0
  02E3    2AEA    JP	0x2EA
  02E4    0F4F    SZINCA	0x4F
  02E5    2AFE    JP	0x2FE
  02E6    0A50    INCA	0x50
  02E7    1003    CLRB	0x3,0
  02E8    1D03    SNZB	0x3,2
  02E9    2AFF    JP	0x2FF
  02EA    0D51    RLCA	0x51
  02EB    3EA6    ADDIA	0xA6
  02EC    0084    LD	0x4,A
  02ED    2392    CALL	0x392
  02EE    118A    CLRB	0xA,3
  02EF    1903    SZB	0x3,2
  02F0    024F    SUBA	0x4F
  02F1    1C03    SNZB	0x3,0
  02F2    2AF9    JP	0x2F9
  02F3    0F4F    SZINCA	0x4F
  02F4    2AFE    JP	0x2FE
  02F5    0A50    INCA	0x50
  02F6    1003    CLRB	0x3,0
  02F7    1D03    SNZB	0x3,2
  02F8    2AFF    JP	0x2FF
  02F9    0D51    RLCA	0x51
  02FA    3EA0    ADDIA	0xA0
  02FB    0084    LD	0x4,A
  02FC    23EA    CALL	0x3EA
  02FD    118A    CLRB	0xA,3
  02FE    1003    CLRB	0x3,0
  02FF    0D51    RLCA	0x51
  0300    3EAC    ADDIA	0xAC
  0301    0084    LD	0x4,A
  0302    1383    CLRB	0x3,7
  0303    23D6    CALL	0x3D6
  0304    118A    CLRB	0xA,3
  0305    3EA6    ADDIA	0xA6
  0306    23C4    CALL	0x3C4
  0307    118A    CLRB	0xA,3
  0308    23D6    CALL	0x3D6
  0309    118A    CLRB	0xA,3
  030A    3EAC    ADDIA	0xAC
  030B    23C4    CALL	0x3C4
  030C    118A    CLRB	0xA,3
  030D    23EA    CALL	0x3EA
  030E    118A    CLRB	0xA,3
  030F    3003    LDIA	0x3
  0310    0AD1    INCR	0x51
  0311    0251    SUBA	0x51
  0312    1803    SZB	0x3,0
  0313    0008    RET
  0314    2ABA    JP	0x2BA
  0315    1283    CLRB	0x3,5
  0316    1303    CLRB	0x3,6
  0317    01B2    CLR	0x32
  0318    01B3    CLR	0x33
  0319    01F3    CLR	0x73
  031A    1003    CLRB	0x3,0
  031B    0D73    RLCA	0x73
  031C    3EB8    ADDIA	0xB8
  031D    0084    LD	0x4,A
  031E    1383    CLRB	0x3,7
  031F    0180    CLR	0x0
  0320    0A84    INCR	0x4
  0321    0180    CLR	0x0
  0322    0873    LD	A,0x73
  0323    228E    CALL	0x28E
  0324    118A    CLRB	0xA,3
  0325    3003    LDIA	0x3
  0326    0AF3    INCR	0x73
  0327    0273    SUBA	0x73
  0328    1803    SZB	0x3,0
  0329    0008    RET
  032A    2B1A    JP	0x31A
  032B    087A    LD	A,0x7A
  032C    0479    ORA	0x79
  032D    1903    SZB	0x3,2
  032E    2B4F    JP	0x34F
  032F    1283    CLRB	0x3,5
  0330    1303    CLRB	0x3,6
  0331    01B4    CLR	0x34
  0332    0879    LD	A,0x79
  0333    0620    XORA	0x20
  0334    1D03    SNZB	0x3,2
  0335    2B48    JP	0x348
  0336    087A    LD	A,0x7A
  0337    0621    XORA	0x21
  0338    1D03    SNZB	0x3,2
  0339    2B48    JP	0x348
  033A    3002    LDIA	0x2
  033B    0AB5    INCR	0x35
  033C    0235    SUBA	0x35
  033D    1C03    SNZB	0x3,0
  033E    0008    RET
  033F    01B5    CLR	0x35
  0340    0879    LD	A,0x79
  0341    00B2    LD	0x32,A
  0342    087A    LD	A,0x7A
  0343    00B3    LD	0x33,A
  0344    1978    SZB	0x78,2
  0345    0008    RET
  0346    1578    SETB	0x78,2
  0347    2B74    JP	0x374
  0348    1178    CLRB	0x78,2
  0349    0879    LD	A,0x79
  034A    00A0    LD	0x20,A
  034B    087A    LD	A,0x7A
  034C    00A1    LD	0x21,A
  034D    01B5    CLR	0x35
  034E    0008    RET
  034F    1283    CLRB	0x3,5
  0350    1303    CLRB	0x3,6
  0351    01B5    CLR	0x35
  0352    01A0    CLR	0x20
  0353    01A1    CLR	0x21
  0354    3002    LDIA	0x2
  0355    0AB4    INCR	0x34
  0356    0234    SUBA	0x34
  0357    1C03    SNZB	0x3,0
  0358    0008    RET
  0359    01B4    CLR	0x34
  035A    01B2    CLR	0x32
  035B    01B3    CLR	0x33
  035C    1178    CLRB	0x78,2
  035D    0008    RET
  035E    1283    CLRB	0x3,5
  035F    1303    CLRB	0x3,6
  0360    0833    LD	A,0x33
  0361    0432    ORA	0x32
  0362    1903    SZB	0x3,2
  0363    2B70    JP	0x370
  0364    1683    SETB	0x3,5
  0365    0AC1    INCR	0x41
  0366    1903    SZB	0x3,2
  0367    0AC2    INCR	0x42
  0368    303A    LDIA	0x3A
  0369    0242    SUBA	0x42
  036A    3098    LDIA	0x98
  036B    1903    SZB	0x3,2
  036C    0241    SUBA	0x41
  036D    1C03    SNZB	0x3,0
  036E    0008    RET
  036F    14F8    SETB	0x78,1
  0370    1683    SETB	0x3,5
  0371    01C1    CLR	0x41
  0372    01C2    CLR	0x42
  0373    0008    RET
  0374    01F4    CLR	0x74
  0375    0874    LD	A,0x74
  0376    227A    CALL	0x27A
  0377    118A    CLRB	0xA,3
  0378    3A00    XORIA	0x0
  0379    1D03    SNZB	0x3,2
  037A    2B7E    JP	0x37E
  037B    0874    LD	A,0x74
  037C    228E    CALL	0x28E
  037D    118A    CLRB	0xA,3
  037E    3003    LDIA	0x3
  037F    0AF4    INCR	0x74
  0380    0274    SUBA	0x74
  0381    1803    SZB	0x3,0
  0382    0008    RET
  0383    2B75    JP	0x375
---- stringtab ------------------------------------------------------------------
  0800    3008    LDIA	0x8
  0801    008A    LD	0xA,A
  0802    0804    LD	A,0x4
  0803    0A84    INCR	0x4
  0804    0782    ADDR	0x2
  0805    3400    RET	0x0
---- reset_enter ------------------------------------------------------------------
  0000    118A    CLRB	0xA,3
  0001    280B    JP	0xB
  000B    118A    CLRB	0xA,3
  000C    280D    JP	0xD
---- start_initialization ------------------------------------------------------------------
  000D    3020    LDIA	0x20
  000E    01F8    CLR	0x78
  000F    01F9    CLR	0x79
  0010    01FA    CLR	0x7A
  0011    01FB    CLR	0x7B
  0012    1383    CLRB	0x3,7
  0013    0084    LD	0x4,A
  0014    304D    LDIA	0x4D
  0015    158A    SETB	0xA,3
  0016    265A    CALL	0x65A
  0017    118A    CLRB	0xA,3
  0018    30A0    LDIA	0xA0
  0019    0084    LD	0x4,A
  001A    30C7    LDIA	0xC7
  001B    158A    SETB	0xA,3
  001C    265A    CALL	0x65A
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F0    LD	0x70,A
  0007    080A    LD	A,0xA
  0008    00F1    LD	0x71,A
  0009    158A    SETB	0xA,3
  000A    2E62    JP	0x662
---- common_function ------------------------------------------------------------------
  001D    0183    CLR	0x3
  001E    158A    SETB	0xA,3
  001F    2EBA    JP	0x6BA
  0392    0800    LD	A,0x0
  0393    00CF    LD	0x4F,A
  0394    0A84    INCR	0x4
  0395    0800    LD	A,0x0
  0396    00D0    LD	0x50,A
  0397    084D    LD	A,0x4D
  0398    02CF    SUBR	0x4F
  0399    084E    LD	A,0x4E
  039A    1C03    SNZB	0x3,0
  039B    03D0    DECR	0x50
  039C    02D0    SUBR	0x50
  039D    3000    LDIA	0x0
  039E    0250    SUBA	0x50
  039F    3402    RET	0x2
  03A0    00CD    LD	0x4D,A
  03A1    0A84    INCR	0x4
  03A2    0800    LD	A,0x0
  03A3    00CE    LD	0x4E,A
  03A4    0856    LD	A,0x56
  03A5    074D    ADDA	0x4D
  03A6    00CF    LD	0x4F,A
  03A7    084E    LD	A,0x4E
  03A8    1803    SZB	0x3,0
  03A9    0A4E    INCA	0x4E
  03AA    00D0    LD	0x50,A
  03AB    0858    LD	A,0x58
  03AC    0250    SUBA	0x50
  03AD    1D03    SNZB	0x3,2
  03AE    0008    RET
  03AF    0857    LD	A,0x57
  03B0    024F    SUBA	0x4F
  03B1    0008    RET
  03B2    0084    LD	0x4,A
  03B3    0800    LD	A,0x0
  03B4    00CD    LD	0x4D,A
  03B5    0A84    INCR	0x4
  03B6    0800    LD	A,0x0
  03B7    00CE    LD	0x4E,A
  03B8    0008    RET
  03B9    0084    LD	0x4,A
  03BA    084D    LD	A,0x4D
  03BB    0080    LD	0x0,A
  03BC    0A84    INCR	0x4
  03BD    084E    LD	A,0x4E
  03BE    0080    LD	0x0,A
  03BF    1003    CLRB	0x3,0
  03C0    0D55    RLCA	0x55
  03C1    3EB2    ADDIA	0xB2
  03C2    0084    LD	0x4,A
  03C3    0008    RET
  03C4    0084    LD	0x4,A
  03C5    0874    LD	A,0x74
  03C6    0080    LD	0x0,A
  03C7    0A84    INCR	0x4
  03C8    0875    LD	A,0x75
  03C9    0080    LD	0x0,A
  03CA    1003    CLRB	0x3,0
  03CB    0D51    RLCA	0x51
  03CC    3EB2    ADDIA	0xB2
  03CD    0084    LD	0x4,A
  03CE    0008    RET
  03CF    0084    LD	0x4,A
  03D0    0800    LD	A,0x0
  03D1    00CD    LD	0x4D,A
  03D2    0A84    INCR	0x4
  03D3    0800    LD	A,0x0
  03D4    00CE    LD	0x4E,A
  03D5    0008    RET
  03D6    0800    LD	A,0x0
  03D7    00F4    LD	0x74,A
  03D8    0A84    INCR	0x4
  03D9    0800    LD	A,0x0
  03DA    00F5    LD	0x75,A
  03DB    1003    CLRB	0x3,0
  03DC    0D51    RLCA	0x51
  03DD    0008    RET
  03DE    0180    CLR	0x0
  03DF    0A84    INCR	0x4
  03E0    0180    CLR	0x0
  03E1    1003    CLRB	0x3,0
  03E2    0D72    RLCA	0x72
  03E3    0008    RET
  03E4    3041    LDIA	0x41
  03E5    1683    SETB	0x3,5
  03E6    0095    LD	0x15,A
  03E7    1415    SETB	0x15,0
  03E8    0196    CLR	0x16
  03E9    0008    RET
  03EA    084D    LD	A,0x4D
  03EB    0080    LD	0x0,A
  03EC    0A84    INCR	0x4
  03ED    084E    LD	A,0x4E
  03EE    0080    LD	0x0,A
  03EF    0008    RET
  03F0    01D5    CLR	0x55
  03F1    01D3    CLR	0x53
  03F2    0AD3    INCR	0x53
  03F3    01D4    CLR	0x54
  03F4    0008    RET
  03F5    0DD3    RLCR	0x53
  03F6    0DD4    RLCR	0x54
  03F7    0AD5    INCR	0x55
  03F8    0255    SUBA	0x55
  03F9    0008    RET
  079F    00F4    LD	0x74,A
  07A0    01F5    CLR	0x75
  07A1    01F6    CLR	0x76
  07A2    0873    LD	A,0x73
  07A3    02D0    SUBR	0x50
  07A4    0874    LD	A,0x74
  07A5    1C03    SNZB	0x3,0
  07A6    0F74    SZINCA	0x74
  07A7    02D1    SUBR	0x51
  07A8    0875    LD	A,0x75
  07A9    1C03    SNZB	0x3,0
  07AA    0F75    SZINCA	0x75
  07AB    02D2    SUBR	0x52
  07AC    0876    LD	A,0x76
  07AD    0008    RET
  07AE    01D0    CLR	0x50
  07AF    01D1    CLR	0x51
  07B0    01D2    CLR	0x52
  07B1    01D3    CLR	0x53
  07B2    01D4    CLR	0x54
  07B3    01D5    CLR	0x55
  07B4    01D6    CLR	0x56
  07B5    01D7    CLR	0x57
  07B6    0008    RET
  07B7    0862    LD	A,0x62
  07B8    00E6    LD	0x66,A
  07B9    0863    LD	A,0x63
  07BA    00E7    LD	0x67,A
  07BB    0864    LD	A,0x64
  07BC    00E8    LD	0x68,A
  07BD    0008    RET
  07BE    1003    CLRB	0x3,0
  07BF    0CF4    RRCR	0x74
  07C0    0CF3    RRCR	0x73
  07C1    0CF2    RRCR	0x72
  07C2    0008    RET
  07C3    0859    LD	A,0x59
  07C4    00D7    LD	0x57,A
  07C5    0858    LD	A,0x58
  07C6    00D6    LD	0x56,A
  07C7    0008    RET
  07C8    01D3    CLR	0x53
  07C9    01D4    CLR	0x54
  07CA    01D5    CLR	0x55
  07CB    0008    RET
  07EC    158A    SETB	0xA,3
  07ED    2FB2    JP	0x7B2
  07EE    158A    SETB	0xA,3
  07EF    2FB9    JP	0x7B9
  07F0    158A    SETB	0xA,3
  07F1    2FBC    JP	0x7BC
  07F2    158A    SETB	0xA,3
  07F3    2FBF    JP	0x7BF
  07F4    158A    SETB	0xA,3
  07F5    2FC6    JP	0x7C6
  07F6    158A    SETB	0xA,3
  07F7    2FC9    JP	0x7C9
  07F8    158A    SETB	0xA,3
  07F9    2FCC    JP	0x7CC
  07FA    158A    SETB	0xA,3
  07FB    2FCF    JP	0x7CF
  0806    3401    RET	0x1
  0807    3402    RET	0x2
  0808    3404    RET	0x4
  0809    3408    RET	0x8
  080A    3410    RET	0x10
  080B    3420    RET	0x20
  080C    3440    RET	0x40
  080D    3480    RET	0x80
  080E    340A    RET	0xA
  080F    340A    RET	0xA
  0810    340A    RET	0xA
  0811    3402    RET	0x2
  0812    3402    RET	0x2
  0813    3402    RET	0x2
  0814    3444    RET	0x44
  0815    3443    RET	0x43
  0816    3442    RET	0x42
  0817    158A    SETB	0xA,3
  0818    2FCF    JP	0x7CF
  0819    158A    SETB	0xA,3
  081A    2FCC    JP	0x7CC
  081B    158A    SETB	0xA,3
  081C    2FC9    JP	0x7C9
  081D    158A    SETB	0xA,3
  081E    2FC6    JP	0x7C6
  081F    158A    SETB	0xA,3
  0820    2FBF    JP	0x7BF
  0821    158A    SETB	0xA,3
  0822    2FBC    JP	0x7BC
  0823    158A    SETB	0xA,3
  0824    2FB9    JP	0x7B9
  0825    158A    SETB	0xA,3
  0826    2FB2    JP	0x7B2
  0E5A    0064    CLRWDT
  0E5B    0180    CLR	0x0
  0E5C    0A84    INCR	0x4
  0E5D    0604    XORA	0x4
  0E5E    1903    SZB	0x3,2
  0E5F    3400    RET	0x0
  0E60    0604    XORA	0x4
  0E61    2E5B    JP	0x65B
  0F71    30C2    LDIA	0xC2
  0F72    00B0    LD	0x30,A
  0F73    3001    LDIA	0x1
  0F74    00B1    LD	0x31,A
  0F75    0008    RET
  0FF0    1306    CLRB	0x6,6
  0FF1    1386    CLRB	0x6,7
  0FF2    1283    CLRB	0x3,5
  0FF3    1786    SETB	0x6,7
  0FF4    0008    RET
  0FF5    1706    SETB	0x6,6
  0FF6    1386    CLRB	0x6,7
  0FF7    1283    CLRB	0x3,5
  0FF8    1386    CLRB	0x6,7
  0FF9    0008    RET
  0FFA    1683    SETB	0x3,5
  0FFB    1286    CLRB	0x6,5
  0FFC    1306    CLRB	0x6,6
  0FFD    1786    SETB	0x6,7
  0FFE    1283    CLRB	0x3,5
