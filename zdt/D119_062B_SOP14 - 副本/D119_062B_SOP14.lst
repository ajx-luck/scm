---- C:\mcuproject\scm\zdt\D119_062B_SOP14 - 副本\main.c ----------------------------------------------------------------------
1:                /**********************************************************
2:                AD检测范例程序
3:                **********************************************************/
4:                #pragma warning disable 752
5:                #pragma warning disable 373			//屏蔽掉编译的1个警告
6:                #include <sc.h>
7:                
8:                #ifndef _XTAL_FREQ
9:                #define _XTAL_FREQ 16000000			//16MHz,使用内置延时函数必须定义主频，
10:               									//如用FCPU_DIV选择2T，则定时赋值减半
11:               #endif
12:               #define		u8t		unsigned char
13:               #define		u16t	unsigned int
14:               #define     POWER_RATIO  	(4096UL*1.2*1000)
15:               
16:               
17:               #define		A_LED5						 RA1
18:               #define		A_LED4						 RA2
19:               #define		A_LED3						 RA3
20:               #define		A_LED2						 RA4
21:               #define		A_LED1						 RA5
22:               
23:               
24:               #define		A_LED5_OUT					 TRISA	&= 0xFD
25:               #define		A_LED4_OUT					 TRISA	&= 0xFB
26:               #define		A_LED3_OUT					 TRISA	&= 0xF7
27:               #define		A_LED2_OUT					 TRISA	&= 0xEF
28:               #define		A_LED1_OUT					 TRISA	&= 0xDF
29:               
30:               const static unsigned char numArray[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x73,0x76};
31:               
32:               volatile unsigned int adresult;
33:               volatile unsigned int result;
34:               volatile unsigned char test_adc;
35:               volatile unsigned int power_ad;
36:               u8t	intCount;
37:               u8t	count1s;
38:               u8t	IntFlag;
39:               u8t	chrgFlag;
40:               u8t	chrgFullFlag;
41:               u8t	intCount10;
42:               u8t		chrgFullTime;
43:               u8t		workStep = 0;
44:               u8t		ledCnt;
45:               u8t		keyCount;
46:               u8t		longPressFlag;
47:               u8t		firstTime;
48:               u8t		showBatTime;
49:               u8t	ledCntTime;
50:               u16t	lowShanTime;
51:               u16t	count900s;
52:               u8t		lowBatFlag = 0;
53:               u8t		sleepTime;
54:               u8t shiweiNum = 0;	//十位
55:               u8t	geweiNum = 0;	//个位
56:               u8t	baiweiNum = 0;
57:               u8t	motorPwmFlag = 0;
58:               u16t	count30s = 0;
59:               u8t	showBatStep = 0;
60:               u8t		curBatStep = 0;
61:               u8t	lowBatTime = 0;
62:               
63:               unsigned char ADC_Sample(unsigned char adch, unsigned char adldo);
64:               void DelayXms(unsigned char x);
65:               unsigned char ADC_Result(unsigned char adch);
66:               void Init_System();
67:               void AD_Init();
68:               void Sleep_Mode();
69:               void pwmInit();
70:               void pwmStop();
71:               void chrgCtr();
72:               void checkBatAD();
73:               void ledShow();
74:               void keyCtr();
75:               void workCtr();
76:               void ledCtr();
77:               char keyRead(char keyStatus);
78:               void setBatStep();
79:               
80:               
81:               //#define _DEBUG			//调试程序用
82:               
83:               
84:               /***********************************************************
85:               中断服务函数
86:               函数名称：Isr_Timer()
87:               函数功能：中断处理函数
88:               入口参数：
89:               出口参数：
90:               备    注：125US定时2中断
91:               			所有中断都是在这个函数里面处理
92:               ***********************************************************/
93:               void interrupt Isr_Timer() 
94:               {
95:               	if(TMR2IF) 
  0397    1283    CLRB	0x3,5
  0398    1C8D    SNZB	0xD,1
  0399    2BAB    JP	0x3AB
96:               	{			//若只使能了一个中断源,可以略去判断
97:               		TMR2IF = 0;
  039A    108D    CLRB	0xD,1
98:               		if(++intCount >= 160)
  039B    30A0    LDIA	0xA0
  039C    0AB6    INCR	0x36
  039D    0236    SUBA	0x36
  039E    1C03    SNZB	0x3,0
  039F    2BA8    JP	0x3A8
  03A0    3064    LDIA	0x64
99:               		{
100:              			intCount = 0;
  03A1    01B6    CLR	0x36
101:              			IntFlag = 1;
  03A2    01B4    CLR	0x34
  03A3    0AB4    INCR	0x34
102:              			if(++count1s >= 100)
  03A4    0AB5    INCR	0x35
  03A5    0235    SUBA	0x35
  03A6    1803    SZB	0x3,0
103:              			{
104:              				count1s = 0;
  03A7    01B5    CLR	0x35
105:              			}
106:              		}
107:              		ledShow();
  03A8    2238    CALL	0x238
108:              		intCount10++;
  03A9    1283    CLRB	0x3,5
  03AA    0AB2    INCR	0x32
  03AB    0872    LD	A,0x72
  03AC    008A    LD	0xA,A
  03AD    0871    LD	A,0x71
  03AE    0084    LD	0x4,A
  03AF    0E70    SWAPA	0x70
  03B0    0083    LD	0x3,A
  03B1    0EFE    SWAPR	0x7E
  03B2    0E7E    SWAPA	0x7E
  03B3    0009    RETI
109:              	}
110:              
111:              }
112:              
113:              
114:              /***********************************************************
115:              main主函数
116:              ***********************************************************/
117:              void main() 
118:              {
119:              	Init_System();
  0308    23EB    CALL	0x3EB
120:              	AD_Init();
  0309    245F    CALL	0x45F
121:              	shiweiNum = geweiNum = numArray[8];
122:              	baiweiNum = 1;
  030A    3009    LDIA	0x9
  030B    0084    LD	0x4,A
  030C    241B    CALL	0x41B
  030D    1283    CLRB	0x3,5
  030E    00C9    LD	0x49,A
  030F    00CA    LD	0x4A,A
123:              	firstTime = 250;
  0310    30FA    LDIA	0xFA
  0311    00CB    LD	0x4B,A
124:              	while (1) 
  0312    0064    CLRWDT
125:              	{
126:              		asm("clrwdt");
127:              		if(intCount10 > 10)
  0313    300B    LDIA	0xB
  0314    1283    CLRB	0x3,5
  0315    0232    SUBA	0x32
  0316    1803    SZB	0x3,0
128:              		{
129:              			intCount10 = 0;
  0317    01B2    CLR	0x32
130:              		}
131:              		if(!IntFlag)
  0318    0834    LD	A,0x34
  0319    1903    SZB	0x3,2
  031A    2B12    JP	0x312
132:                  		continue;			//10ms执行一次
133:                  	IntFlag = 0;
  031B    01B4    CLR	0x34
134:              		chrgCtr();
  031C    2342    CALL	0x342
135:              		checkBatAD();
  031D    2405    CALL	0x405
136:              		setBatStep();
  031E    21A3    CALL	0x1A3
137:              		if(lowBatFlag == 0 && firstTime == 0 && chrgFlag == 0)
  031F    082C    LD	A,0x2C
  0320    1D03    SNZB	0x3,2
  0321    2B29    JP	0x329
  0322    084B    LD	A,0x4B
  0323    1D03    SNZB	0x3,2
  0324    2B29    JP	0x329
  0325    087A    LD	A,0x7A
  0326    1D03    SNZB	0x3,2
  0327    2B29    JP	0x329
138:              		{
139:              			keyCtr();
  0328    244B    CALL	0x44B
140:              		}
141:              		workCtr();
  0329    2100    CALL	0x100
142:              		if(chrgFlag == 0 && workStep == 0 && firstTime == 0 && showBatTime == 0)
  032A    087A    LD	A,0x7A
  032B    1D03    SNZB	0x3,2
  032C    2B40    JP	0x340
  032D    0830    LD	A,0x30
  032E    1D03    SNZB	0x3,2
  032F    2B40    JP	0x340
  0330    084B    LD	A,0x4B
  0331    1D03    SNZB	0x3,2
  0332    2B40    JP	0x340
143:              		{
144:              			baiweiNum = 0;
  0333    082E    LD	A,0x2E
  0334    1D03    SNZB	0x3,2
  0335    2B40    JP	0x340
  0336    30C8    LDIA	0xC8
145:              			shiweiNum = geweiNum = 0;
  0337    01C9    CLR	0x49
  0338    01CA    CLR	0x4A
146:              			if(++sleepTime >= 200)
  0339    0AAB    INCR	0x2B
  033A    022B    SUBA	0x2B
  033B    1C03    SNZB	0x3,0
  033C    2B12    JP	0x312
147:              			{
148:              				sleepTime = 0;
  033D    01AB    CLR	0x2B
149:              				Sleep_Mode();
  033E    22C6    CALL	0x2C6
  033F    2B12    JP	0x312
150:              			}
151:              		}
152:              		else
153:              		{
154:              			sleepTime = 0;
  0340    01AB    CLR	0x2B
  0341    2B12    JP	0x312
155:              		}
156:              	}
157:              }
158:              
159:              void ledShow()
160:              {
161:              	if(++ledCntTime > 5)
  0238    3006    LDIA	0x6
  0239    0AAD    INCR	0x2D
  023A    022D    SUBA	0x2D
  023B    1C03    SNZB	0x3,0
  023C    0008    RET
  023D    300E    LDIA	0xE
162:              	{
163:              		ledCntTime = 0;
  023E    01AD    CLR	0x2D
164:              		if(++ledCnt > 13)
  023F    0AAF    INCR	0x2F
  0240    022F    SUBA	0x2F
  0241    1803    SZB	0x3,0
165:              		{
166:              			ledCnt = 0;
  0242    01AF    CLR	0x2F
167:              		}
168:              		PORTA &= 0xC1;
  0243    30C1    LDIA	0xC1
  0244    1683    SETB	0x3,5
  0245    0586    ANDR	0x6
169:              		TRISA |= 0x3E;
  0246    303E    LDIA	0x3E
  0247    0485    ORR	0x5
170:              		switch(ledCnt)
  0248    2AB9    JP	0x2B9
171:              		{
172:              			case 1:
173:              			if(geweiNum & 0x08)
  0249    1DC9    SNZB	0x49,3
  024A    0008    RET
174:              			{
175:              				A_LED5_OUT;
  024B    1683    SETB	0x3,5
  024C    1085    CLRB	0x5,1
176:              				A_LED1_OUT;
  024D    1285    CLRB	0x5,5
177:              				A_LED5 = 1;
  024E    1486    SETB	0x6,1
178:              				A_LED1 = 0;
  024F    1286    CLRB	0x6,5
  0250    0008    RET
179:              			}
180:              			break;
181:              			case 2:
182:              			if(geweiNum & 0x10)
  0251    1E49    SNZB	0x49,4
  0252    0008    RET
183:              			{
184:              				A_LED3_OUT;
  0253    1683    SETB	0x3,5
  0254    1185    CLRB	0x5,3
185:              				A_LED5_OUT;
  0255    1085    CLRB	0x5,1
186:              				A_LED5 = 1;
  0256    1486    SETB	0x6,1
187:              				A_LED3 = 0;
  0257    1186    CLRB	0x6,3
  0258    0008    RET
188:              			}
189:              			break;
190:              			case 3:
191:              			if(geweiNum & 0x20)
  0259    1EC9    SNZB	0x49,5
  025A    0008    RET
192:              			{
193:              				A_LED3_OUT;
  025B    1683    SETB	0x3,5
  025C    1185    CLRB	0x5,3
194:              				A_LED2_OUT;
  025D    1205    CLRB	0x5,4
195:              				A_LED2 = 1;
  025E    1606    SETB	0x6,4
196:              				A_LED3 = 0;
  025F    1186    CLRB	0x6,3
  0260    0008    RET
197:              			}
198:              			break;
199:              			case 4:
200:              			if(geweiNum & 0x01)
  0261    1C49    SNZB	0x49,0
  0262    0008    RET
201:              			{
202:              				A_LED2_OUT;
  0263    1683    SETB	0x3,5
  0264    1205    CLRB	0x5,4
203:              				A_LED1_OUT;
  0265    1285    CLRB	0x5,5
204:              				A_LED1 = 1;
  0266    1686    SETB	0x6,5
205:              				A_LED2 = 0;
  0267    1206    CLRB	0x6,4
  0268    0008    RET
206:              			}
207:              			break;
208:              			case 5:
209:              			if(geweiNum & 0x02)
  0269    1CC9    SNZB	0x49,1
  026A    0008    RET
210:              			{
211:              				A_LED1_OUT;
  026B    1683    SETB	0x3,5
  026C    1285    CLRB	0x5,5
212:              				A_LED3_OUT;
  026D    1185    CLRB	0x5,3
213:              				A_LED3 = 1;
  026E    1586    SETB	0x6,3
214:              				A_LED1 = 0;
  026F    1286    CLRB	0x6,5
  0270    0008    RET
215:              			}
216:              			break;
217:              			case 6:
218:              			if(geweiNum & 0x04)
  0271    1D49    SNZB	0x49,2
  0272    0008    RET
219:              			{
220:              				A_LED1_OUT;
  0273    1683    SETB	0x3,5
  0274    1285    CLRB	0x5,5
221:              				A_LED5_OUT;
  0275    1085    CLRB	0x5,1
222:              				A_LED1 = 1;
  0276    1686    SETB	0x6,5
223:              				A_LED5 = 0;
  0277    1086    CLRB	0x6,1
  0278    0008    RET
224:              			}
225:              			break;
226:              			case 7:
227:              			if(geweiNum & 0x40)
  0279    1F49    SNZB	0x49,6
  027A    0008    RET
228:              			{
229:              				A_LED1_OUT;
  027B    1683    SETB	0x3,5
  027C    1285    CLRB	0x5,5
230:              				A_LED3_OUT;
  027D    1185    CLRB	0x5,3
231:              				A_LED1 = 1;
  027E    1686    SETB	0x6,5
232:              				A_LED3 = 0;
  027F    1186    CLRB	0x6,3
  0280    0008    RET
233:              			}
234:              			break;
235:              			case 8:
236:              			if(shiweiNum & 0x08)
  0281    1DCA    SNZB	0x4A,3
  0282    0008    RET
237:              			{
238:              				A_LED4_OUT;
  0283    1683    SETB	0x3,5
  0284    1105    CLRB	0x5,2
239:              				A_LED5_OUT;
  0285    1085    CLRB	0x5,1
240:              				A_LED4 = 1;
  0286    1506    SETB	0x6,2
241:              				A_LED5 = 0;
  0287    1086    CLRB	0x6,1
  0288    0008    RET
242:              			}
243:              			break;
244:              			case 9:
245:              			if(shiweiNum & 0x10)
  0289    1E4A    SNZB	0x4A,4
  028A    0008    RET
246:              			{
247:              				A_LED5_OUT;
  028B    1683    SETB	0x3,5
  028C    1085    CLRB	0x5,1
248:              				A_LED4_OUT;
  028D    1105    CLRB	0x5,2
249:              				A_LED5 = 1;
  028E    1486    SETB	0x6,1
250:              				A_LED4 = 0;
  028F    1106    CLRB	0x6,2
  0290    0008    RET
251:              			}
252:              			break;
253:              			case 10:
254:              			if(shiweiNum & 0x20)
  0291    1ECA    SNZB	0x4A,5
  0292    0008    RET
255:              			{
256:              				A_LED4_OUT;
  0293    1683    SETB	0x3,5
  0294    1105    CLRB	0x5,2
257:              				A_LED3_OUT;
  0295    1185    CLRB	0x5,3
258:              				A_LED3 = 1;
  0296    1586    SETB	0x6,3
259:              				A_LED4 = 0;
  0297    1106    CLRB	0x6,2
  0298    0008    RET
260:              			}
261:              			break;
262:              			case 11:
263:              			if(shiweiNum & 0x01)
  0299    1C4A    SNZB	0x4A,0
  029A    0008    RET
264:              			{
265:              				A_LED1_OUT;
  029B    1683    SETB	0x3,5
  029C    1285    CLRB	0x5,5
266:              				A_LED2_OUT;
  029D    1205    CLRB	0x5,4
267:              				A_LED2 = 1;
  029E    1606    SETB	0x6,4
268:              				A_LED1 = 0;
  029F    1286    CLRB	0x6,5
  02A0    0008    RET
269:              			}
270:              			break;
271:              			case 12:
272:              			if(shiweiNum & 0x02)
  02A1    1CCA    SNZB	0x4A,1
  02A2    0008    RET
273:              			{
274:              				A_LED3_OUT;
  02A3    1683    SETB	0x3,5
  02A4    1185    CLRB	0x5,3
275:              				A_LED2_OUT;
  02A5    1205    CLRB	0x5,4
276:              				A_LED3 = 1;
  02A6    1586    SETB	0x6,3
277:              				A_LED2 = 0;
  02A7    1206    CLRB	0x6,4
  02A8    0008    RET
278:              			}
279:              			break;
280:              			case 13:
281:              			if(shiweiNum & 0x04)
  02A9    1D4A    SNZB	0x4A,2
  02AA    0008    RET
282:              			{
283:              				A_LED3_OUT;
  02AB    1683    SETB	0x3,5
  02AC    1185    CLRB	0x5,3
284:              				A_LED5_OUT;
  02AD    1085    CLRB	0x5,1
285:              				A_LED3 = 1;
  02AE    1586    SETB	0x6,3
286:              				A_LED5 = 0;
  02AF    1086    CLRB	0x6,1
  02B0    0008    RET
287:              			}
288:              			break;
289:              			case 0:
290:              			if(shiweiNum & 0x40)
  02B1    1F4A    SNZB	0x4A,6
  02B2    0008    RET
291:              			{
292:              				A_LED4_OUT;
  02B3    1683    SETB	0x3,5
  02B4    1105    CLRB	0x5,2
293:              				A_LED3_OUT;
  02B5    1185    CLRB	0x5,3
294:              				A_LED4 = 1;
  02B6    1506    SETB	0x6,2
295:              				A_LED3 = 0;
  02B7    1186    CLRB	0x6,3
  02B8    0008    RET
  02B9    1283    CLRB	0x3,5
  02BA    082F    LD	A,0x2F
  02BB    0084    LD	0x4,A
  02BC    300E    LDIA	0xE
  02BD    0204    SUBA	0x4
  02BE    1803    SZB	0x3,0
  02BF    0008    RET
  02C0    3004    LDIA	0x4
  02C1    008A    LD	0xA,A
  02C2    303D    LDIA	0x3D
  02C3    0704    ADDA	0x4
  02C4    0082    LD	0x2,A
  02C5    0008    RET
296:              			}
297:              			break;
298:              			default:
299:              			break;
300:              		}
301:              	}
302:              	
303:              	
304:              }
305:              
306:              
307:              
308:              
309:              
310:              
311:              void chrgCtr()
312:              {
313:              	if(PORTB & 0x01)
  0342    1C06    SNZB	0x6,0
  0343    2B58    JP	0x358
314:              	{
315:              		chrgFlag = 1;
  0344    01FA    CLR	0x7A
  0345    0AFA    INCR	0x7A
316:              		workStep = 0;
  0346    01B0    CLR	0x30
317:              		lowBatFlag = 0;
  0347    01AC    CLR	0x2C
318:              		if(PORTA & 0x01)
  0348    1683    SETB	0x3,5
  0349    1C06    SNZB	0x6,0
  034A    2B4E    JP	0x34E
319:              		{
320:              			chrgFullTime = 0;
  034B    1283    CLRB	0x3,5
  034C    01B1    CLR	0x31
321:              		}
  034D    0008    RET
322:              		else
323:              		{
324:              			if(++chrgFullTime >= 200)
  034E    30C8    LDIA	0xC8
  034F    1283    CLRB	0x3,5
  0350    0AB1    INCR	0x31
  0351    0231    SUBA	0x31
  0352    1C03    SNZB	0x3,0
  0353    0008    RET
325:              			{
326:              				chrgFullTime = 0;
  0354    01B1    CLR	0x31
327:              				chrgFullFlag = 1;
  0355    01B3    CLR	0x33
  0356    0AB3    INCR	0x33
  0357    0008    RET
  0358    3006    LDIA	0x6
328:              			}
329:              		}
330:              	}
331:              	else
332:              	{
333:              		chrgFlag = 0;
  0359    01FA    CLR	0x7A
334:              		chrgFullFlag = 0;
  035A    01B3    CLR	0x33
335:              		chrgFullTime = 0;
  035B    01B1    CLR	0x31
336:              		if(power_ad < 1563)
  035C    0278    SUBA	0x78
  035D    301B    LDIA	0x1B
  035E    1903    SZB	0x3,2
  035F    0277    SUBA	0x77
  0360    1803    SZB	0x3,0
  0361    2B6B    JP	0x36B
337:              		{
338:              			if(++lowBatTime > 200)
  0362    30C9    LDIA	0xC9
  0363    0AA8    INCR	0x28
  0364    0228    SUBA	0x28
  0365    1C03    SNZB	0x3,0
  0366    0008    RET
339:              			{
340:              				lowBatTime = 0;
  0367    01A8    CLR	0x28
341:              				lowBatFlag = 1;
  0368    01AC    CLR	0x2C
  0369    0AAC    INCR	0x2C
  036A    0008    RET
342:              			}
343:              		}
344:              		else
345:              		{
346:              			lowBatTime = 0;
  036B    01A8    CLR	0x28
  036C    0008    RET
347:              		}
348:              	}
349:              }
350:              
351:              
352:              
353:              char keyRead(char keyStatus)	
354:              { 
355:              	if(keyStatus)
356:              	{
357:              		keyCount++;
358:              		if(keyCount >= 100)
359:              		{
360:              			keyCount = 100;
361:              			if(!longPressFlag)
362:              			{
363:              				longPressFlag = 1;
364:              				return 2;
365:              			}
366:              		}
367:              	}
368:              	else
369:              	{
370:              		if(keyCount >= 100)
371:              		{
372:              			keyCount = 0;
373:              			longPressFlag = 0;
374:              			return	0;
375:              		}
376:              		else if(keyCount >= 6)
377:              		{
378:              			keyCount = 0;
379:              			return	1;
380:              		}
381:              		keyCount = 0;
382:              	}
383:              	return 0;
384:              }
385:              
386:              
387:              
388:              void keyCtr()
389:              {
390:              	if(PORTB & 0x02)
  044B    1C86    SNZB	0x6,1
  044C    2C55    JP	0x455
391:              	{
392:              		if(PORTB & 0x04)
  044D    1D06    SNZB	0x6,2
  044E    2C52    JP	0x452
393:              		{
394:              			workStep = 1;
  044F    01B0    CLR	0x30
  0450    0AB0    INCR	0x30
395:              		}
  0451    0008    RET
396:              		else
397:              		{
398:              			workStep = 2;
  0452    3002    LDIA	0x2
  0453    00B0    LD	0x30,A
  0454    0008    RET
399:              		}
400:              	}
401:              	else
402:              	{
403:              		workStep = 0;
  0455    01B0    CLR	0x30
  0456    0008    RET
404:              	}
405:              	
406:              	
407:              }
408:              
409:              
410:              void workCtr()
411:              {
412:              	/*
413:              	if(workStep > 0 && count1s == 0 && ++count900s >= 900)
414:              	{
415:              		count900s = 0;
416:              		workStep = 0;
417:              	}
418:              	*/
419:              	if(lowShanTime > 0)
  0100    0822    LD	A,0x22
  0101    0423    ORA	0x23
  0102    1903    SZB	0x3,2
  0103    290E    JP	0x10E
420:              	{
421:              		if(--lowShanTime == 0)
  0104    3001    LDIA	0x1
  0105    02A2    SUBR	0x22
  0106    3000    LDIA	0x0
  0107    1C03    SNZB	0x3,0
  0108    03A3    DECR	0x23
  0109    02A3    SUBR	0x23
  010A    0822    LD	A,0x22
  010B    0423    ORA	0x23
  010C    1903    SZB	0x3,2
422:              		{
423:              			workStep = 0;
  010D    01B0    CLR	0x30
424:              		}
425:              	}
426:              	if(showBatTime > 0)
  010E    082E    LD	A,0x2E
  010F    1D03    SNZB	0x3,2
427:              	{
428:              		showBatTime--;
  0110    03AE    DECR	0x2E
429:              	}
430:              	if(firstTime > 0)
  0111    084B    LD	A,0x4B
  0112    1903    SZB	0x3,2
  0113    2924    JP	0x124
431:              	{
432:              		firstTime--;
  0114    03CB    DECR	0x4B
433:              		if(showBatStep < curBatStep)
  0115    0829    LD	A,0x29
  0116    0279    SUBA	0x79
  0117    1803    SZB	0x3,0
  0118    291B    JP	0x11B
434:              		{	
435:              			showBatStep = curBatStep;
  0119    0829    LD	A,0x29
  011A    00F9    LD	0x79,A
436:              		}
437:              		shiweiNum = numArray[8];
  011B    3009    LDIA	0x9
  011C    0084    LD	0x4,A
  011D    241B    CALL	0x41B
  011E    00CA    LD	0x4A,A
438:              		geweiNum = numArray[8];
  011F    3009    LDIA	0x9
  0120    0084    LD	0x4,A
  0121    241B    CALL	0x41B
  0122    00C9    LD	0x49,A
439:              	}
  0123    295F    JP	0x15F
440:              	else if(workStep == 0 || (lowShanTime > 0 && count1s < 50))
  0124    0830    LD	A,0x30
  0125    1903    SZB	0x3,2
  0126    292F    JP	0x12F
  0127    0822    LD	A,0x22
  0128    0423    ORA	0x23
  0129    1903    SZB	0x3,2
  012A    2933    JP	0x133
  012B    3032    LDIA	0x32
  012C    0235    SUBA	0x35
  012D    1803    SZB	0x3,0
  012E    2933    JP	0x133
441:              	{
442:              		shiweiNum = 0;
  012F    01CA    CLR	0x4A
443:              		geweiNum = 0;
  0130    01C9    CLR	0x49
444:              		pwmStop();
445:              		count900s = 0;
  0131    2467    CALL	0x467
446:              	}
  0132    295F    JP	0x15F
447:              	else if(workStep == 1)
  0133    0B30    SZDECA	0x30
  0134    2948    JP	0x148
448:              	{
449:              		if(chrgFlag == 0)
  0135    087A    LD	A,0x7A
  0136    1D03    SNZB	0x3,2
  0137    2940    JP	0x140
450:              		{
451:              			shiweiNum = numArray[10];
  0138    300B    LDIA	0xB
  0139    0084    LD	0x4,A
  013A    241B    CALL	0x41B
  013B    00CA    LD	0x4A,A
452:              			geweiNum = numArray[1];
  013C    3002    LDIA	0x2
  013D    0084    LD	0x4,A
  013E    241B    CALL	0x41B
  013F    00C9    LD	0x49,A
453:              		}
454:              		if(motorPwmFlag == 0)
  0140    082A    LD	A,0x2A
  0141    1D03    SNZB	0x3,2
  0142    2944    JP	0x144
455:              		{
456:              			pwmInit();
  0143    242D    CALL	0x42D
457:              		}
458:              		PWMD23H = 0X00;
  0144    1683    SETB	0x3,5
  0145    019E    CLR	0x1E
459:              		PWMD2L = 60;
  0146    303C    LDIA	0x3C
  0147    295E    JP	0x15E
460:              	}
461:              	else if(workStep == 2)
  0148    3002    LDIA	0x2
  0149    0630    XORA	0x30
  014A    1D03    SNZB	0x3,2
  014B    295F    JP	0x15F
462:              	{
463:              		if(chrgFlag == 0)
  014C    087A    LD	A,0x7A
  014D    1D03    SNZB	0x3,2
  014E    2957    JP	0x157
464:              		{
465:              			shiweiNum = numArray[10];
  014F    300B    LDIA	0xB
  0150    0084    LD	0x4,A
  0151    241B    CALL	0x41B
  0152    00CA    LD	0x4A,A
466:              			geweiNum = numArray[2];
  0153    3003    LDIA	0x3
  0154    0084    LD	0x4,A
  0155    241B    CALL	0x41B
  0156    00C9    LD	0x49,A
467:              		}
468:              		if(motorPwmFlag == 0)
  0157    082A    LD	A,0x2A
  0158    1D03    SNZB	0x3,2
  0159    295B    JP	0x15B
469:              		{
470:              			pwmInit();
  015A    242D    CALL	0x42D
471:              		}
472:              		PWMD23H = 0X00;
  015B    1683    SETB	0x3,5
  015C    019E    CLR	0x1E
473:              		PWMD2L = 80;
  015D    3050    LDIA	0x50
  015E    009B    LD	0x1B,A
474:              		
475:              	}
476:              	if(chrgFlag || showBatTime > 0)
  015F    087A    LD	A,0x7A
  0160    1D03    SNZB	0x3,2
  0161    2966    JP	0x166
  0162    1283    CLRB	0x3,5
  0163    082E    LD	A,0x2E
  0164    1903    SZB	0x3,2
  0165    0008    RET
477:              	{
478:              		if(showBatStep >=99)
  0166    3063    LDIA	0x63
  0167    0279    SUBA	0x79
  0168    1C03    SNZB	0x3,0
  0169    2974    JP	0x174
479:              		{
480:              			shiweiNum = numArray[9];
  016A    300A    LDIA	0xA
  016B    0084    LD	0x4,A
  016C    241B    CALL	0x41B
  016D    1283    CLRB	0x3,5
  016E    00CA    LD	0x4A,A
481:              			geweiNum = numArray[9];
  016F    300A    LDIA	0xA
  0170    0084    LD	0x4,A
  0171    241B    CALL	0x41B
  0172    00C9    LD	0x49,A
482:              		}
  0173    0008    RET
483:              		else if(showBatStep > 9)
484:              		{
485:              			baiweiNum = 0;
  0174    300A    LDIA	0xA
  0175    0279    SUBA	0x79
  0176    1C03    SNZB	0x3,0
  0177    2998    JP	0x198
486:              			shiweiNum = numArray[showBatStep/10];
  0178    300A    LDIA	0xA
  0179    00F3    LD	0x73,A
  017A    0879    LD	A,0x79
  017B    23D0    CALL	0x3D0
  017C    3E01    ADDIA	0x1
  017D    0084    LD	0x4,A
  017E    241B    CALL	0x41B
  017F    1283    CLRB	0x3,5
  0180    00CA    LD	0x4A,A
487:              			if(chrgFlag && count1s < 50)
  0181    087A    LD	A,0x7A
  0182    1903    SZB	0x3,2
  0183    298F    JP	0x18F
  0184    3032    LDIA	0x32
  0185    0235    SUBA	0x35
  0186    1C03    SNZB	0x3,0
  0187    298D    JP	0x18D
  0188    298F    JP	0x18F
  0189    3032    LDIA	0x32
  018A    0235    SUBA	0x35
  018B    1803    SZB	0x3,0
  018C    299D    JP	0x19D
488:              			{
489:              				geweiNum = 0;
  018D    01C9    CLR	0x49
490:              			}
  018E    0008    RET
491:              			else
492:              			{
493:              				geweiNum = numArray[showBatStep%10];
  018F    300A    LDIA	0xA
  0190    00F3    LD	0x73,A
  0191    0879    LD	A,0x79
  0192    23B4    CALL	0x3B4
  0193    3E01    ADDIA	0x1
  0194    0084    LD	0x4,A
  0195    241B    CALL	0x41B
  0196    00C9    LD	0x49,A
  0197    0008    RET
494:              			}
495:              		}
496:              		else
497:              		{
498:              			baiweiNum = 0;
499:              			shiweiNum = 0;
  0198    1283    CLRB	0x3,5
  0199    01CA    CLR	0x4A
500:              			if(chrgFlag && count1s < 50)
  019A    087A    LD	A,0x7A
  019B    1D03    SNZB	0x3,2
  019C    2989    JP	0x189
501:              			{
502:              				geweiNum = 0;
503:              			}
504:              			else
505:              			{
506:              				geweiNum = numArray[showBatStep];
  019D    0879    LD	A,0x79
  019E    3E01    ADDIA	0x1
  019F    0084    LD	0x4,A
  01A0    241B    CALL	0x41B
  01A1    00C9    LD	0x49,A
  01A2    0008    RET
507:              			}
508:              		}
509:              	
510:              	}
511:              	
512:              }
513:              
514:              void setBatStep()
515:              {
516:              	if(lowBatFlag == 1 && lowShanTime == 0 && workStep > 0)
  01A3    1283    CLRB	0x3,5
  01A4    0B2C    SZDECA	0x2C
  01A5    29B4    JP	0x1B4
  01A6    0822    LD	A,0x22
  01A7    0423    ORA	0x23
  01A8    1D03    SNZB	0x3,2
  01A9    29B4    JP	0x1B4
  01AA    0830    LD	A,0x30
  01AB    1903    SZB	0x3,2
  01AC    29B4    JP	0x1B4
  01AD    302C    LDIA	0x2C
517:              	{
518:              		showBatStep = 0;
  01AE    01F9    CLR	0x79
519:              		curBatStep = 0;
  01AF    01A9    CLR	0x29
520:              		lowShanTime = 300;
  01B0    00A2    LD	0x22,A
  01B1    3001    LDIA	0x1
  01B2    00A3    LD	0x23,A
521:              	}
  01B3    0008    RET
522:              	else if(power_ad < 1675)
  01B4    3006    LDIA	0x6
  01B5    0278    SUBA	0x78
  01B6    308B    LDIA	0x8B
  01B7    1903    SZB	0x3,2
  01B8    0277    SUBA	0x77
  01B9    1803    SZB	0x3,0
  01BA    29CE    JP	0x1CE
523:              	{
524:              		if(count1s == 0)
  01BB    0835    LD	A,0x35
  01BC    1D03    SNZB	0x3,2
  01BD    29CB    JP	0x1CB
525:              		{
526:              			if(showBatStep > 1)
  01BE    3002    LDIA	0x2
  01BF    0279    SUBA	0x79
  01C0    1C03    SNZB	0x3,0
  01C1    29C7    JP	0x1C7
527:              			{
528:              				if(chrgFlag == 0)
  01C2    087A    LD	A,0x7A
  01C3    1D03    SNZB	0x3,2
  01C4    29C9    JP	0x1C9
529:              					showBatStep--;
  01C5    03F9    DECR	0x79
  01C6    29C9    JP	0x1C9
530:              			}
531:              			else
532:              			{
533:              				showBatStep = 1;
  01C7    01F9    CLR	0x79
  01C8    0AF9    INCR	0x79
534:              			}
535:              			curBatStep = 1;
  01C9    01A9    CLR	0x29
  01CA    0AA9    INCR	0x29
536:              		}
537:              		curBatStep = 1;
  01CB    01A9    CLR	0x29
  01CC    0AA9    INCR	0x29
538:              	}
  01CD    0008    RET
539:              	else
540:              	{
541:              		if(power_ad < 1875)
  01CE    3007    LDIA	0x7
  01CF    0278    SUBA	0x78
  01D0    3053    LDIA	0x53
  01D1    1903    SZB	0x3,2
  01D2    0277    SUBA	0x77
  01D3    1803    SZB	0x3,0
  01D4    29E3    JP	0x1E3
542:              		{
543:              			curBatStep = (power_ad - 1675)/10;
  01D5    300A    LDIA	0xA
  01D6    00F3    LD	0x73,A
  01D7    01F4    CLR	0x74
  01D8    0877    LD	A,0x77
  01D9    3E75    ADDIA	0x75
  01DA    00F5    LD	0x75,A
  01DB    0878    LD	A,0x78
  01DC    1803    SZB	0x3,0
  01DD    3E01    ADDIA	0x1
  01DE    3EF9    ADDIA	0xF9
  01DF    00F6    LD	0x76,A
  01E0    236D    CALL	0x36D
  01E1    0873    LD	A,0x73
  01E2    29F1    JP	0x1F1
544:              		}
545:              		else
546:              		{
547:              			curBatStep = 10 + ((power_ad - 1875)/5);
  01E3    3005    LDIA	0x5
  01E4    00F3    LD	0x73,A
  01E5    01F4    CLR	0x74
  01E6    0877    LD	A,0x77
  01E7    3EAD    ADDIA	0xAD
  01E8    00F5    LD	0x75,A
  01E9    0878    LD	A,0x78
  01EA    1803    SZB	0x3,0
  01EB    3E01    ADDIA	0x1
  01EC    3EF8    ADDIA	0xF8
  01ED    00F6    LD	0x76,A
  01EE    236D    CALL	0x36D
  01EF    0873    LD	A,0x73
  01F0    3E0A    ADDIA	0xA
  01F1    00A9    LD	0x29,A
548:              		}
549:              		if(curBatStep > 99)
  01F2    3064    LDIA	0x64
  01F3    0229    SUBA	0x29
  01F4    1C03    SNZB	0x3,0
  01F5    29F8    JP	0x1F8
550:              		{
551:              			curBatStep = 99;
  01F6    3063    LDIA	0x63
  01F7    00A9    LD	0x29,A
552:              		}
553:              
554:              		if(chrgFlag)
  01F8    087A    LD	A,0x7A
  01F9    1903    SZB	0x3,2
  01FA    2A1E    JP	0x21E
555:              		{
556:              			if(chrgFullFlag)
  01FB    0833    LD	A,0x33
  01FC    1903    SZB	0x3,2
  01FD    2A17    JP	0x217
557:              			{
558:              				if(++count30s >= 3000 && showBatStep < 99)	//20s
  01FE    0AA0    INCR	0x20
  01FF    1903    SZB	0x3,2
  0200    0AA1    INCR	0x21
  0201    300B    LDIA	0xB
  0202    0221    SUBA	0x21
  0203    30B8    LDIA	0xB8
  0204    2A0B    JP	0x20B
559:              				{	
560:              					count30s = 0;
  0213    01A0    CLR	0x20
  0214    01A1    CLR	0x21
561:              					showBatStep++;
  0215    0AF9    INCR	0x79
  0216    0008    RET
562:              				}
563:              			}
564:              			else if(curBatStep > showBatStep)
  0217    0829    LD	A,0x29
  0218    0279    SUBA	0x79
  0219    1C03    SNZB	0x3,0
  021A    2A05    JP	0x205
565:              			{
566:              				if(++count30s >= 30000 && showBatStep < 99)	//20s
  0205    0AA0    INCR	0x20
  0206    1903    SZB	0x3,2
  0207    0AA1    INCR	0x21
  0208    3075    LDIA	0x75
  0209    0221    SUBA	0x21
  020A    3030    LDIA	0x30
  020B    1903    SZB	0x3,2
  020C    0220    SUBA	0x20
  020D    1C03    SNZB	0x3,0
  020E    0008    RET
  020F    3063    LDIA	0x63
  0210    0279    SUBA	0x79
  0211    1803    SZB	0x3,0
  0212    0008    RET
567:              				{	
568:              					count30s = 0;
569:              					showBatStep++;
570:              				}
571:              				
572:              			}
573:              			else
574:              			{
575:              				count30s = 0;
  021B    01A0    CLR	0x20
  021C    01A1    CLR	0x21
  021D    0008    RET
576:              			}
577:              		}
578:              		else
579:              		{
580:              			if(curBatStep < showBatStep && showBatStep > 1)
  021E    0879    LD	A,0x79
  021F    0229    SUBA	0x29
  0220    1803    SZB	0x3,0
  0221    2A1B    JP	0x21B
  0222    3002    LDIA	0x2
  0223    0279    SUBA	0x79
  0224    1C03    SNZB	0x3,0
  0225    2A1B    JP	0x21B
581:              			{
582:              				if(++count30s >= 1500 && showBatStep > 1)	//10s
  0226    0AA0    INCR	0x20
  0227    1903    SZB	0x3,2
  0228    0AA1    INCR	0x21
  0229    3005    LDIA	0x5
  022A    0221    SUBA	0x21
  022B    30DC    LDIA	0xDC
  022C    1903    SZB	0x3,2
  022D    0220    SUBA	0x20
  022E    1C03    SNZB	0x3,0
  022F    0008    RET
  0230    3002    LDIA	0x2
  0231    0279    SUBA	0x79
  0232    1C03    SNZB	0x3,0
  0233    0008    RET
583:              				{	
584:              					count30s = 0;
  0234    01A0    CLR	0x20
  0235    01A1    CLR	0x21
585:              					showBatStep--;
  0236    03F9    DECR	0x79
  0237    0008    RET
586:              				}
587:              			}
588:              			else
589:              			{
590:              				count30s = 0;
591:              			}
592:              		}
593:              		
594:              	}
595:              }
596:              
597:              
598:              void checkBatAD()
599:              {
600:              	test_adc = ADC_Sample(12, 5);		//测试内部基准1.2V相对电源的AD值
  0405    3005    LDIA	0x5
  0406    00F3    LD	0x73,A
  0407    300C    LDIA	0xC
  0408    2018    CALL	0x18
  0409    00B7    LD	0x37,A
601:              	if (0xA5 == test_adc)
  040A    30A5    LDIA	0xA5
  040B    0637    XORA	0x37
  040C    1D03    SNZB	0x3,2
  040D    2C13    JP	0x413
602:              	{
603:              		volatile unsigned long power_temp;
604:              		
605:              		power_ad = adresult;		//通过内部基准电压推出芯片VDD电压
  040E    0827    LD	A,0x27
  040F    00F8    LD	0x78,A
  0410    0826    LD	A,0x26
  0411    00F7    LD	0x77,A
606:              	}
  0412    0008    RET
607:              	else
608:              	{
609:              		ADCON0 = 0;						//如果转换没有完成，需初始化ADCON0,1
  0413    1683    SETB	0x3,5
  0414    0195    CLR	0x15
610:              		ADCON1 = 0;				
  0415    0196    CLR	0x16
611:              		__delay_us(100);				//延时100us(编译器内置函数)
  0416    3085    LDIA	0x85
  0417    00F4    LD	0x74,A
  0418    0BF4    SZDECR	0x74
  0419    2C18    JP	0x418
  041A    0008    RET
612:              	}
613:              	
614:              }
615:              
616:              
617:              
618:              /**********************************************************
619:              函数名称：Init_System
620:              函数功能：系统初始化
621:              入口参数：无
622:              出口参数：无
623:              备    注：
624:              **********************************************************/
625:              void Init_System() 
  03EB    0000    NOP
  03EC    0064    CLRWDT
626:              {
627:              	asm("nop");
628:              	asm("clrwdt");
629:              	OPTION_REG = 0;					//预分频给TMR0 ，Timer0使用内部时钟Focs/4，预分频比为1:2
  03ED    1283    CLRB	0x3,5
  03EE    0181    CLR	0x1
  03EF    0064    CLRWDT
630:              	asm("clrwdt");
631:              	OSCCON = 0X72;					//内部振荡器8M
  03F0    3072    LDIA	0x72
  03F1    1283    CLRB	0x3,5
  03F2    0094    LD	0x14,A
632:              
633:              	WPUA = 0x00;				//配置上拉，1为使能上拉
  03F3    1683    SETB	0x3,5
  03F4    0188    CLR	0x8
634:              	WPDA = 0x00;					//RA1开下拉
  03F5    0187    CLR	0x7
635:              	WPUB = 0x04;
  03F6    3004    LDIA	0x4
  03F7    1283    CLRB	0x3,5
  03F8    0088    LD	0x8,A
636:              
637:              	TRISA = 0x01;				//配置IO状态，0为输出，1为输入
  03F9    3001    LDIA	0x1
  03FA    1683    SETB	0x3,5
638:              	TRISB = 0x37;
639:              
640:              	PORTA = 0X00;
641:              	PORTB = 0X00;
  03FB    22FF    CALL	0x2FF
642:              
643:              //---------------------------------------
644:              //125us中断初始化
645:              	PR2 = 249;					//设定Timer初始值，定时周期是250*2/8M=62.5uS
  03FC    30F9    LDIA	0xF9
  03FD    0091    LD	0x11,A
646:              	TMR2IF = 0;
  03FE    108D    CLRB	0xD,1
647:              	TMR2IE = 1;					//使能Timer2溢出中断
  03FF    148E    SETB	0xE,1
648:              
649:              	T2CON = 0B00000100;			//开启Timer2,设置TMR2的分频比为1:1
  0400    3004    LDIA	0x4
  0401    0093    LD	0x13,A
650:              	INTCON = 0XC0;				//开启总中断
  0402    30C0    LDIA	0xC0
  0403    008B    LD	0xB,A
  0404    0008    RET
651:              }
652:              
653:              /***********************************************************
654:              中断服务函数
655:              函数名称：AD_Init()
656:              函数功能：AD初始化处理函数
657:              入口参数：
658:              出口参数：
659:              备    注：第一次打开AD允许位ADON，需延时20uS以上才能进入AD采样
660:              			如后继程序不关闭ADON，则不需要延时
661:              ***********************************************************/
662:              void AD_Init() 
663:              {
664:              	/*********** ADCON0 ****************************
665:              		Bit7~Bit6  ADCS<1:0>:  AD转换时钟选择位。
666:              			00=  F HSI /16
667:              			01=  F HSI /32
668:              			10=  F HSI /64
669:              			11=  F HSI /128
670:              		Bit5~Bit2  CHS<3:0>:  模拟通道选择位。与ADCON1寄存器CHS4组合CHS<3:0>
671:              			CHS<4:0>: 
672:              			00000=  AN0
673:              			00001=  AN1
674:              			00010=  AN2
675:              			00011=  AN3
676:              			00100=  AN4
677:              			00101=  AN5
678:              			00110=  保留
679:              			00111=  保留
680:              			01000=  AN8
681:              			… 
682:              			01101=  AN13
683:              			01110=  AN14
684:              			01111=  AN15
685:              			11111=  1.2V（固定参考电压）
686:              			其他=  保留
687:              		Bit1  GO/DONE: AD转换状态位。
688:              			1=  AD转换正在进行。将该位置1启动AD转换。当AD转换完成以后，该位由硬件自动清零。
689:              				当GO/DONE位从1变0或ADIF从0变1时，需至少等待两个TAD时间，才能再次启动AD转换。
690:              			0=  AD转换完成/或不在进行中。
691:              		Bit0  ADON:  ADC使能位。
692:              			1=  使能ADC；
693:              			0=  禁止ADC，不消耗工作电流。
694:              	*********************************************/
695:              	ADCON0 = 0X41;		//ADON开启，AD采样时间选为FSYS/16
  045F    3041    LDIA	0x41
  0460    1683    SETB	0x3,5
  0461    0095    LD	0x15,A
696:              	
697:              	/*********** ADCON1 ****************************
698:              		Bit7  ADFM:  AD转换结果格式选择位；
699:              			1=  右对齐；
700:              			0=  左对齐。
701:              		Bit6  CHS4:  通道选择位
702:              		Bit5~Bit3  未用 
703:              		Bit2  LDO_EN:  内部参考电压使能位。
704:              			1=  使能ADC内部LDO参考电压；
705:              				当选择内部LDO作参考电压时，ADC最大有效精度为8位。
706:              			0=  VDD作为ADC参考电压。
707:              		Bit1~Bit0  LDO_SEL<1:0>:  参考电压选择位
708:              			0X=  2.0V
709:              			10=  2.4V
710:              			11=  3.0V
711:              	*********************************************/
712:              	ADCON1 = 0;
  0462    0196    CLR	0x16
713:              	ANSEL0 = 0X00;
  0463    0193    CLR	0x13
714:              	ANSEL1 = 0x30;	
  0464    3030    LDIA	0x30
  0465    0094    LD	0x14,A
  0466    0008    RET
715:              }
716:              
717:              
718:              void pwmInit()
719:              {
720:              		PWMCON1 = 0B00000000;	//PWM选择D组，死区2禁止，死区1使能，死区时钟源为Fosc/4
  042D    0196    CLR	0x16
721:              		PWMTH = 0X00;			//周期选择为0FF，则周期为（255+1）*1/8M，周期的时钟分频在PWMCON0选择
  042E    0198    CLR	0x18
722:              		PWMTL = 100;			//PWM 周期=[PWMT+1]*Tosc*(CLKDIV 分频值)
  042F    3064    LDIA	0x64
  0430    0097    LD	0x17,A
723:              		
724:              		
725:              		PWMD23H = 0;			//配置PWM1,PWM2的占空比，该值不能超过周期，否者为100%输出
  0431    1683    SETB	0x3,5
  0432    019E    CLR	0x1E
726:              		PWMD2L = 60;			//互补模式，PWM1的占空比与PWM0互补，和设置值无关
  0433    303C    LDIA	0x3C
  0434    009B    LD	0x1B,A
727:              		PWM23DT = 0X00;			//死区设为2uS，计算为（3+1）*1/8M*4
  0435    019D    CLR	0x1D
728:              
729:              		PWMCON0 = 0X64;			//打开PWM3 分频比为8
  0436    3064    LDIA	0x64
  0437    1283    CLRB	0x3,5
  0438    0095    LD	0x15,A
730:              		PWMCON2 =0X00;			//PWM4输出反向
  0439    019D    CLR	0x1D
731:              		motorPwmFlag = 1;
  043A    01AA    CLR	0x2A
  043B    0AAA    INCR	0x2A
  043C    0008    RET
732:              }
733:              
734:              void pwmStop()
735:              {
736:              	PWMCON0 &= 0XFB;
  0467    1115    CLRB	0x15,2
737:              	RB3 = 0;
  0468    1186    CLRB	0x6,3
738:              	motorPwmFlag = 0;
  0469    01AA    CLR	0x2A
  046A    0008    RET
739:              }
740:              
741:              
742:              /***********************************************
743:              函数名称：Sleep_Mode
744:              函数功能：进入休眠模式
745:              入口参数：无
746:              出口参数：无
747:              备注：
748:              ************************************************/
749:              void Sleep_Mode()
750:              {
751:              	INTCON = 0;		
  02C6    018B    CLR	0xB
752:              	
753:              	OPTION_REG = 0;
  02C7    0181    CLR	0x1
754:              
755:              	WPUA  = 0x00;			//RA1 开上拉电阻
  02C8    1683    SETB	0x3,5
  02C9    0188    CLR	0x8
756:              	TRISA = 0x01;				//配置IO状态，0为输出，1为输入
  02CA    3001    LDIA	0x1
757:              	TRISB = 0x37;
758:              
759:              	PORTA = 0X00;
760:              	PORTB = 0X00;
  02CB    22FF    CALL	0x2FF
761:              	WPUB  = 0x04;			//RB2 开上拉电阻
  02CC    3004    LDIA	0x4
  02CD    0088    LD	0x8,A
762:                 			
763:                 	ADCON0 = 0;					//关闭所有模块
  02CE    1683    SETB	0x3,5
  02CF    0195    CLR	0x15
764:              	ADCON1 = 0;
  02D0    0196    CLR	0x16
765:              	
766:              	PWMCON0 = 0;
  02D1    1283    CLRB	0x3,5
  02D2    0195    CLR	0x15
767:              		
768:              	OSCCON = 0X70;				//配置振荡为8M,关闭WDT，需注意芯片工程选项里WDT必须选为DISABLE,否则无法软件关掉WDT
  02D3    3070    LDIA	0x70
  02D4    0094    LD	0x14,A
769:              	
770:              	IOCA = 0B00000000;			//允许RA1的IO电平变化中断
  02D5    1683    SETB	0x3,5
  02D6    0189    CLR	0x9
771:              	IOCB = 0x07;			//允许RB1 RB2的IO口电平变化中断
  02D7    3007    LDIA	0x7
  02D8    1283    CLRB	0x3,5
  02D9    0089    LD	0x9,A
772:              	
773:              	RAIE = 1;					//允许PORTA的IO电平变化中断
  02DA    158E    SETB	0xE,3
774:              	PEIE = 1;					//要用RORTA中断唤醒，则PEIE必须设为1
  02DB    170B    SETB	0xB,6
775:              	RBIE = 1;					//允许PORTB电平变化中断
  02DC    158B    SETB	0xB,3
776:              	GIE = 0;					//唤醒后执行SLEEP后程序;
  02DD    138B    CLRB	0xB,7
777:              	
778:              	PIE1 &= 0X08;				//关闭不需要的中断
  02DE    3008    LDIA	0x8
  02DF    058E    ANDR	0xE
779:              	PIR1 = 0;					//必须清不需要的中断标志位
  02E0    018D    CLR	0xD
780:              	INTCON &= 0XC8;				//必须清不需要的中断标志位
  02E1    30C8    LDIA	0xC8
  02E2    058B    ANDR	0xB
781:              
782:              	PORTA;						//读PORTA值并锁存,用电平变化中断必须执行这一步
  02E3    1683    SETB	0x3,5
  02E4    0806    LD	A,0x6
783:              	RAIF = 0;					//清PORTA中断标志位
  02E5    1283    CLRB	0x3,5
  02E6    118D    CLRB	0xD,3
784:              	PORTB;						//读PORTB值并锁存	
  02E7    0806    LD	A,0x6
785:              	RBIF = 0;					//清PORTB中断标志位		
  02E8    100B    CLRB	0xB,0
  02E9    0064    CLRWDT
  02EA    0063    STOP
  02EB    0000    NOP
  02EC    0064    CLRWDT
  02ED    0000    NOP
  02EE    0000    NOP
  02EF    0000    NOP
  02F0    0000    NOP
  02F1    0000    NOP
786:              	asm("clrwdt");
787:              
788:              	asm("sleep");				//进入休眠模式
789:              	
790:              	asm("nop");
791:              	asm("clrwdt");
792:              	asm("nop");
793:              	asm("nop");
794:              	asm("nop");
795:              	asm("nop");
796:              	asm("nop");
797:              	if(RAIF)  RAIF = 0;			//清中断标志
  02F2    1283    CLRB	0x3,5
  02F3    198D    SZB	0xD,3
  02F4    118D    CLRB	0xD,3
798:              	if(RBIF)  RBIF = 0;			//清中断标志
  02F5    180B    SZB	0xB,0
  02F6    100B    CLRB	0xB,0
799:              	if(TMR2IF) TMR2IF = 0;
  02F7    188D    SZB	0xD,1
  02F8    108D    CLRB	0xD,1
800:              	IOCA = 0B00000000;			//允许RA1的IO电平变化中断
  02F9    1683    SETB	0x3,5
  02FA    0189    CLR	0x9
801:              	IOCB = 0B00000000;			//允许RB3的IO口电平变化中断
  02FB    1283    CLRB	0x3,5
  02FC    0189    CLR	0x9
802:              	Init_System();
  02FD    23EB    CALL	0x3EB
803:              	AD_Init();
  02FE    2C5F    JP	0x45F
804:              }
805:              
806:              
807:              
808:              /**********************************************************
809:              函数名称：AD_Sample
810:              函数功能：AD检测
811:              入口参数：adch - 检测通道
812:              出口参数：无
813:              备    注：采样通道需自行设置为输入口
814:              	      采样10次,取中间八次的平均值为采样结果存于adresult中
815:              
816:              	      adch 为输入AD通道 0-15，31
817:                           31  检测内部1.2V
818:              	
819:               		  adldo =5,开启内部LDO 2V 作为ADC 参考
820:               		  adldo =6,开启内部LDO 2.4V 作为ADC 参考
821:              		  adldo =7,开启内部LDO 3V 作为ADC 参考
822:               		  adldo =0,VDD 作为ADC 参考
823:               		  AD转换结果左对齐
824:               		  ADC参考电压从VDD切换到LDO时需要延时100us以上，才能进行AD转换
825:              **********************************************************/
826:              unsigned char ADC_Sample(unsigned char adch, unsigned char adldo) 
  0018    00BD    LD	0x3D,A
827:              {
828:              	volatile unsigned long adsum = 0;
829:              	volatile unsigned int admin = 0, admax = 0;
  0019    20F2    CALL	0xF2
830:              	volatile unsigned int ad_temp = 0;
  001A    01C7    CLR	0x47
  001B    01C8    CLR	0x48
831:              
832:              	if ((!LDO_EN) && (adldo & 0x04) ) 
  001C    1683    SETB	0x3,5
  001D    1D16    SNZB	0x16,2
  001E    1D73    SNZB	0x73,2
  001F    2829    JP	0x29
833:              	{
834:              								//如果AD参考从VDD换到内部LDO，需要延时100US以上
835:              		ADCON1 = adldo;			//左对齐,AD值取12位
  0020    0873    LD	A,0x73
  0021    0096    LD	0x16,A
836:              		__delay_us(100);		//IDE内置延时函数，延时100us
  0022    3084    LDIA	0x84
  0023    1283    CLRB	0x3,5
  0024    00B8    LD	0x38,A
  0025    0BB8    SZDECR	0x38
  0026    2825    JP	0x25
  0027    2828    JP	0x28
837:              	} 
  0028    282B    JP	0x2B
838:              	else
839:              		ADCON1 = adldo;			//如果ADCON1.7(ADFM)=1为右对齐，,AD值取10位
  0029    0873    LD	A,0x73
  002A    0096    LD	0x16,A
840:              
841:              	if(adch & 0x10) 
  002B    1283    CLRB	0x3,5
  002C    1E3D    SNZB	0x3D,4
  002D    2833    JP	0x33
842:              	{
843:              		CHS4 = 1;
  002E    1683    SETB	0x3,5
  002F    1716    SETB	0x16,6
844:              		adch &= 0x0f;
  0030    300F    LDIA	0xF
  0031    1283    CLRB	0x3,5
  0032    05BD    ANDR	0x3D
845:              	}
846:              	unsigned char i = 0;
847:              	for (i = 0; i < 10; i++) 
  0033    01BE    CLR	0x3E
848:              	{
849:              		ADCON0 = (unsigned char)(0X41 | (adch << 2));	//16分频，如果主频为16M，则必须选16分频或以上
  0034    083D    LD	A,0x3D
  0035    00B8    LD	0x38,A
  0036    3001    LDIA	0x1
  0037    1003    CLRB	0x3,0
  0038    0DB8    RLCR	0x38
  0039    3EFF    ADDIA	0xFF
  003A    1003    CLRB	0x3,0
  003B    1D03    SNZB	0x3,2
  003C    2838    JP	0x38
  003D    0D38    RLCA	0x38
  003E    3841    ORIA	0x41
  003F    1683    SETB	0x3,5
  0040    0095    LD	0x15,A
  0041    0000    NOP
  0042    0000    NOP
  0043    0000    NOP
  0044    0000    NOP
850:              		asm("nop");
851:              		asm("nop");
852:              		asm("nop");
853:              		asm("nop");				//选择通道后需延时1uS以上
854:              		GODONE = 1;				//开始转换
  0045    1683    SETB	0x3,5
  0046    1495    SETB	0x15,1
855:              
856:              		unsigned char j = 0;
  0047    1283    CLRB	0x3,5
  0048    01BC    CLR	0x3C
857:              		while (GODONE) 
  0049    1683    SETB	0x3,5
  004A    1C95    SNZB	0x15,1
  004B    2854    JP	0x54
858:              		{
859:              			__delay_us(2);		//延时2us(编译器内置函数)
  004C    284D    JP	0x4D
  004D    284E    JP	0x4E
  004E    284F    JP	0x4F
  004F    2850    JP	0x50
860:              
861:              			if (0 == (--j))		//延时0.5ms仍没有AD转换结束，跳出程序
  0050    1283    CLRB	0x3,5
  0051    0BBC    SZDECR	0x3C
  0052    2849    JP	0x49
862:              			return 0;
  0053    3400    RET	0x0
863:              		}
864:              
865:              		ad_temp = (unsigned int)((ADRESH << 4) + (ADRESL >> 4));	//计算12位AD值
  0054    0819    LD	A,0x19
  0055    1283    CLRB	0x3,5
  0056    00C7    LD	0x47,A
  0057    01C8    CLR	0x48
  0058    0EC7    SWAPR	0x47
  0059    0EC8    SWAPR	0x48
  005A    30F0    LDIA	0xF0
  005B    05C8    ANDR	0x48
  005C    0847    LD	A,0x47
  005D    390F    ANDIA	0xF
  005E    04C8    ORR	0x48
  005F    30F0    LDIA	0xF0
  0060    05C7    ANDR	0x47
  0061    1683    SETB	0x3,5
  0062    0E18    SWAPA	0x18
  0063    390F    ANDIA	0xF
  0064    1283    CLRB	0x3,5
  0065    07C7    ADDR	0x47
  0066    1803    SZB	0x3,0
  0067    0AC8    INCR	0x48
866:              
867:              		if (0 == admax) 
  0068    0845    LD	A,0x45
  0069    0446    ORA	0x46
  006A    1D03    SNZB	0x3,2
  006B    286E    JP	0x6E
868:              		{
869:              			admax = ad_temp;
  006C    20FB    CALL	0xFB
  006D    2880    JP	0x80
870:              			admin = ad_temp;
871:              		} 
872:              		else if (ad_temp > admax)
  006E    0848    LD	A,0x48
  006F    0246    SUBA	0x46
  0070    1D03    SNZB	0x3,2
  0071    2874    JP	0x74
  0072    0847    LD	A,0x47
  0073    0245    SUBA	0x45
  0074    1803    SZB	0x3,0
  0075    2878    JP	0x78
873:              			admax = ad_temp;				//AD采样最大值
  0076    20FB    CALL	0xFB
  0077    2884    JP	0x84
874:              		else if (ad_temp < admin)
  0078    0844    LD	A,0x44
  0079    0248    SUBA	0x48
  007A    1D03    SNZB	0x3,2
  007B    287E    JP	0x7E
  007C    0843    LD	A,0x43
  007D    0247    SUBA	0x47
  007E    1803    SZB	0x3,0
  007F    2884    JP	0x84
875:              			admin = ad_temp;				//AD采样最小值
  0080    0848    LD	A,0x48
  0081    00C4    LD	0x44,A
  0082    0847    LD	A,0x47
  0083    00C3    LD	0x43,A
876:              
877:              		adsum += ad_temp;
  0084    0847    LD	A,0x47
  0085    00B8    LD	0x38,A
  0086    0848    LD	A,0x48
  0087    00B9    LD	0x39,A
  0088    01BA    CLR	0x3A
  0089    01BB    CLR	0x3B
  008A    0838    LD	A,0x38
  008B    07BF    ADDR	0x3F
  008C    0839    LD	A,0x39
  008D    1103    CLRB	0x3,2
  008E    1803    SZB	0x3,0
  008F    3E01    ADDIA	0x1
  0090    1D03    SNZB	0x3,2
  0091    07C0    ADDR	0x40
  0092    083A    LD	A,0x3A
  0093    1103    CLRB	0x3,2
  0094    1803    SZB	0x3,0
  0095    3E01    ADDIA	0x1
  0096    1D03    SNZB	0x3,2
  0097    07C1    ADDR	0x41
  0098    083B    LD	A,0x3B
  0099    1103    CLRB	0x3,2
  009A    1803    SZB	0x3,0
  009B    3E01    ADDIA	0x1
  009C    1D03    SNZB	0x3,2
  009D    07C2    ADDR	0x42
  009E    300A    LDIA	0xA
  009F    0ABE    INCR	0x3E
  00A0    023E    SUBA	0x3E
  00A1    1C03    SNZB	0x3,0
  00A2    2834    JP	0x34
878:              	}
879:              		adsum -= admax;
  00A3    0845    LD	A,0x45
  00A4    00B8    LD	0x38,A
  00A5    0846    LD	A,0x46
  00A6    20E3    CALL	0xE3
  00A7    1C03    SNZB	0x3,0
  00A8    0F3B    SZINCA	0x3B
  00A9    02C2    SUBR	0x42
880:              		if (adsum >= admin)
  00AA    0843    LD	A,0x43
  00AB    00B8    LD	0x38,A
  00AC    0844    LD	A,0x44
  00AD    00B9    LD	0x39,A
  00AE    01BA    CLR	0x3A
  00AF    01BB    CLR	0x3B
  00B0    083B    LD	A,0x3B
  00B1    0242    SUBA	0x42
  00B2    1D03    SNZB	0x3,2
  00B3    28BE    JP	0xBE
  00B4    083A    LD	A,0x3A
  00B5    0241    SUBA	0x41
  00B6    1D03    SNZB	0x3,2
  00B7    28BE    JP	0xBE
  00B8    0839    LD	A,0x39
  00B9    0240    SUBA	0x40
  00BA    1D03    SNZB	0x3,2
  00BB    28BE    JP	0xBE
  00BC    0838    LD	A,0x38
  00BD    023F    SUBA	0x3F
  00BE    1C03    SNZB	0x3,0
  00BF    28C8    JP	0xC8
881:              			adsum -= admin;
  00C0    0843    LD	A,0x43
  00C1    00B8    LD	0x38,A
  00C2    0844    LD	A,0x44
  00C3    20E3    CALL	0xE3
  00C4    1C03    SNZB	0x3,0
  00C5    0F3B    SZINCA	0x3B
  00C6    02C2    SUBR	0x42
  00C7    28CC    JP	0xCC
882:              		else
883:              			adsum = 0;
  00C8    01BF    CLR	0x3F
  00C9    01C0    CLR	0x40
  00CA    01C1    CLR	0x41
  00CB    01C2    CLR	0x42
884:              
885:              		adresult = adsum >> 3;		//8次平均值作为最终结果
  00CC    083F    LD	A,0x3F
  00CD    00B8    LD	0x38,A
  00CE    0840    LD	A,0x40
  00CF    00B9    LD	0x39,A
  00D0    0841    LD	A,0x41
  00D1    00BA    LD	0x3A,A
  00D2    0842    LD	A,0x42
  00D3    00BB    LD	0x3B,A
  00D4    3003    LDIA	0x3
  00D5    1003    CLRB	0x3,0
  00D6    0CBB    RRCR	0x3B
  00D7    0CBA    RRCR	0x3A
  00D8    0CB9    RRCR	0x39
  00D9    0CB8    RRCR	0x38
  00DA    3EFF    ADDIA	0xFF
  00DB    1D03    SNZB	0x3,2
  00DC    28D5    JP	0xD5
  00DD    0839    LD	A,0x39
  00DE    00A7    LD	0x27,A
  00DF    0838    LD	A,0x38
  00E0    00A6    LD	0x26,A
886:              
887:              		adsum = 0;
888:              		admin = 0;
889:              		admax = 0;
  00E1    20F2    CALL	0xF2
890:              		return 0xA5;
  00E2    34A5    RET	0xA5
891:              		
892:              }
893:              
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\lbmod.c ----------------------------------------------------------------------
1:                // byte unsigned modulus
2:                
3:                unsigned char
4:                __lbmod(unsigned char dividend, unsigned char divisor)
  03B4    00B8    LD	0x38,A
  03B5    3008    LDIA	0x8
  03B6    00B9    LD	0x39,A
  03B7    01BA    CLR	0x3A
  03B8    0838    LD	A,0x38
  03B9    00F4    LD	0x74,A
  03BA    3007    LDIA	0x7
  03BB    1003    CLRB	0x3,0
  03BC    0CF4    RRCR	0x74
  03BD    3EFF    ADDIA	0xFF
  03BE    1003    CLRB	0x3,0
  03BF    1D03    SNZB	0x3,2
  03C0    2BBC    JP	0x3BC
  03C1    0D3A    RLCA	0x3A
  03C2    0474    ORA	0x74
  03C3    00BA    LD	0x3A,A
  03C4    1003    CLRB	0x3,0
  03C5    0DB8    RLCR	0x38
  03C6    0873    LD	A,0x73
  03C7    023A    SUBA	0x3A
  03C8    1C03    SNZB	0x3,0
  03C9    2BCC    JP	0x3CC
  03CA    0873    LD	A,0x73
  03CB    02BA    SUBR	0x3A
  03CC    0BB9    SZDECR	0x39
  03CD    2BB8    JP	0x3B8
  03CE    083A    LD	A,0x3A
  03CF    0008    RET
5:                {
6:                	unsigned char	rem;
7:                	unsigned char	counter;
8:                
9:                	counter = 8;
10:               	rem = 0;
11:               	do {
12:               		rem = (rem << 1) | (dividend >> 7);
13:               		dividend <<= 1;
14:               		if(divisor <= rem)
15:               			rem -= divisor;
16:               	} while(--counter != 0);
17:               	return rem;
18:               }
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\lbdiv.c ----------------------------------------------------------------------
1:                // byte unsigned division
2:                
3:                unsigned char
4:                __lbdiv(unsigned char dividend, unsigned char divisor)
  03D0    00F4    LD	0x74,A
  03D1    01F6    CLR	0x76
  03D2    0873    LD	A,0x73
  03D3    1903    SZB	0x3,2
  03D4    2BE9    JP	0x3E9
  03D5    01F5    CLR	0x75
  03D6    0AF5    INCR	0x75
  03D7    1BF3    SZB	0x73,7
  03D8    2BDC    JP	0x3DC
  03D9    1003    CLRB	0x3,0
  03DA    0DF3    RLCR	0x73
  03DB    2BD6    JP	0x3D6
  03DC    1003    CLRB	0x3,0
  03DD    0DF6    RLCR	0x76
  03DE    0873    LD	A,0x73
  03DF    0274    SUBA	0x74
  03E0    1C03    SNZB	0x3,0
  03E1    2BE6    JP	0x3E6
  03E2    0873    LD	A,0x73
  03E3    02F4    SUBR	0x74
  03E4    1476    SETB	0x76,0
  03E5    1003    CLRB	0x3,0
  03E6    0CF3    RRCR	0x73
  03E7    0BF5    SZDECR	0x75
  03E8    2BDC    JP	0x3DC
  03E9    0876    LD	A,0x76
  03EA    0008    RET
5:                {
6:                	unsigned char	quotient;
7:                	unsigned char	counter;
8:                
9:                	quotient = 0;
10:               	if(divisor != 0) {
11:               		counter = 1;
12:               		while((divisor & 0x80) == 0) {
13:               			divisor <<= 1;
14:               			counter++;
15:               		}
16:               		do {
17:               			quotient <<= 1;
18:               			if(divisor <= dividend) {
19:               				dividend -= divisor;
20:               				quotient |= 1;
21:               			}
22:               			divisor >>= 1;
23:               		} while(--counter != 0);
24:               	}
25:               	return quotient;
26:               }
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\lwdiv.c ----------------------------------------------------------------------
1:                // word unsigned division
2:                
3:                unsigned int
4:                #ifdef __PICC__
5:                #warning TODO: update cgpic and this file to use the other prototype
6:                __lwdiv(unsigned int divisor, unsigned int dividend)
  036D    01B9    CLR	0x39
  036E    01BA    CLR	0x3A
  036F    0873    LD	A,0x73
  0370    0474    ORA	0x74
  0371    1903    SZB	0x3,2
  0372    2B92    JP	0x392
  0373    01B8    CLR	0x38
  0374    0AB8    INCR	0x38
  0375    1BF4    SZB	0x74,7
  0376    2B7B    JP	0x37B
  0377    1003    CLRB	0x3,0
  0378    0DF3    RLCR	0x73
  0379    0DF4    RLCR	0x74
  037A    2B74    JP	0x374
  037B    1003    CLRB	0x3,0
  037C    0DB9    RLCR	0x39
  037D    0DBA    RLCR	0x3A
  037E    0874    LD	A,0x74
  037F    0276    SUBA	0x76
  0380    1D03    SNZB	0x3,2
  0381    2B84    JP	0x384
  0382    0873    LD	A,0x73
  0383    0275    SUBA	0x75
  0384    1C03    SNZB	0x3,0
  0385    2B8E    JP	0x38E
  0386    0873    LD	A,0x73
  0387    02F5    SUBR	0x75
  0388    0874    LD	A,0x74
  0389    1C03    SNZB	0x3,0
  038A    03F6    DECR	0x76
  038B    02F6    SUBR	0x76
  038C    1439    SETB	0x39,0
  038D    1003    CLRB	0x3,0
  038E    0CF4    RRCR	0x74
  038F    0CF3    RRCR	0x73
  0390    0BB8    SZDECR	0x38
  0391    2B7B    JP	0x37B
  0392    083A    LD	A,0x3A
  0393    00F4    LD	0x74,A
  0394    0839    LD	A,0x39
  0395    00F3    LD	0x73,A
  0396    0008    RET
7:                #else
8:                __lwdiv(unsigned int dividend, unsigned int divisor)
9:                #endif
10:               {
11:               	unsigned int	quotient;
12:               	unsigned char	counter;
13:               
14:               	quotient = 0;
15:               	if(divisor != 0) {
16:               		counter = 1;
17:               		while((divisor & 0x8000) == 0) {
18:               			divisor <<= 1;
19:               			counter++;
20:               		}
21:               		do {
22:               			quotient <<= 1;
23:               			if(divisor <= dividend) {
24:               				dividend -= divisor;
25:               				quotient |= 1;
26:               			}
27:               			divisor >>= 1;
28:               		} while(--counter != 0);
29:               	}
30:               	return quotient;
31:               }
---- stringtab ------------------------------------------------------------------
  041B    3004    LDIA	0x4
  041C    008A    LD	0xA,A
  041D    0804    LD	A,0x4
  041E    0A84    INCR	0x4
  041F    0782    ADDR	0x2
  0420    3400    RET	0x0
---- reset_enter ------------------------------------------------------------------
  0000    280C    JP	0xC
  000C    280D    JP	0xD
---- start_initialization ------------------------------------------------------------------
  000D    3077    LDIA	0x77
  000E    0084    LD	0x4,A
  000F    307B    LDIA	0x7B
  0010    2457    CALL	0x457
  0011    3020    LDIA	0x20
  0012    1383    CLRB	0x3,7
  0013    0084    LD	0x4,A
  0014    3038    LDIA	0x38
  0015    2457    CALL	0x457
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F0    LD	0x70,A
  0007    0804    LD	A,0x4
  0008    00F1    LD	0x71,A
  0009    080A    LD	A,0xA
  000A    00F2    LD	0x72,A
  000B    2B97    JP	0x397
---- common_function ------------------------------------------------------------------
  0016    0183    CLR	0x3
  0017    2B08    JP	0x308
  00E3    00B9    LD	0x39,A
  00E4    01BA    CLR	0x3A
  00E5    01BB    CLR	0x3B
  00E6    0838    LD	A,0x38
  00E7    02BF    SUBR	0x3F
  00E8    0839    LD	A,0x39
  00E9    1C03    SNZB	0x3,0
  00EA    0F39    SZINCA	0x39
  00EB    02C0    SUBR	0x40
  00EC    083A    LD	A,0x3A
  00ED    1C03    SNZB	0x3,0
  00EE    0F3A    SZINCA	0x3A
  00EF    02C1    SUBR	0x41
  00F0    083B    LD	A,0x3B
  00F1    0008    RET
  00F2    01BF    CLR	0x3F
  00F3    01C0    CLR	0x40
  00F4    01C1    CLR	0x41
  00F5    01C2    CLR	0x42
  00F6    01C3    CLR	0x43
  00F7    01C4    CLR	0x44
  00F8    01C5    CLR	0x45
  00F9    01C6    CLR	0x46
  00FA    0008    RET
  00FB    0848    LD	A,0x48
  00FC    00C6    LD	0x46,A
  00FD    0847    LD	A,0x47
  00FE    00C5    LD	0x45,A
  00FF    0008    RET
  02FF    0085    LD	0x5,A
  0300    3037    LDIA	0x37
  0301    1283    CLRB	0x3,5
  0302    0085    LD	0x5,A
  0303    1683    SETB	0x3,5
  0304    0186    CLR	0x6
  0305    1283    CLRB	0x3,5
  0306    0186    CLR	0x6
  0307    0008    RET
  0421    343F    RET	0x3F
  0422    3406    RET	0x6
  0423    345B    RET	0x5B
  0424    344F    RET	0x4F
  0425    3466    RET	0x66
  0426    346D    RET	0x6D
  0427    347D    RET	0x7D
  0428    3407    RET	0x7
  0429    347F    RET	0x7F
  042A    346F    RET	0x6F
  042B    3473    RET	0x73
  042C    3476    RET	0x76
  043D    2AB1    JP	0x2B1
  043E    2A49    JP	0x249
  043F    2A51    JP	0x251
  0440    2A59    JP	0x259
  0441    2A61    JP	0x261
  0442    2A69    JP	0x269
  0443    2A71    JP	0x271
  0444    2A79    JP	0x279
  0445    2A81    JP	0x281
  0446    2A89    JP	0x289
  0447    2A91    JP	0x291
  0448    2A99    JP	0x299
  0449    2AA1    JP	0x2A1
  044A    2AA9    JP	0x2A9
  0457    0064    CLRWDT
  0458    0180    CLR	0x0
  0459    0A84    INCR	0x4
  045A    0604    XORA	0x4
  045B    1903    SZB	0x3,2
  045C    3400    RET	0x0
  045D    0604    XORA	0x4
  045E    2C58    JP	0x458
