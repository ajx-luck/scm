
# 1 "C:\mcuproject\scm\zdt\C212-FS_062B_SOP14\main.c"


# 4
#pragma warning disable 752
#pragma warning disable 373

# 26 "C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\include\htc.h"
extern const char __xc8_OPTIM_SPEED;

extern double __fpnormalize(double);


# 13 "C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\include\xc8debug.h"
#pragma intrinsic(__builtin_software_breakpoint)
extern void __builtin_software_breakpoint(void);

# 5 "C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\include\SC8P062BD.h"
volatile unsigned char INDF @ 0x00;
volatile unsigned char OPTION_REG @ 0x01;
volatile unsigned char PCL @ 0x02;
volatile unsigned char STATUS @ 0x03;
volatile unsigned char FSR @ 0x04;
volatile unsigned char TRISB @ 0x05;
volatile unsigned char PORTB @ 0x06;
volatile unsigned char WPDB @ 0x07;
volatile unsigned char WPUB @ 0x08;
volatile unsigned char IOCB @ 0x09;
volatile unsigned char PCLATH @ 0x0A;
volatile unsigned char INTCON @ 0x0B;
volatile unsigned char ODCONB @ 0x0C;
volatile unsigned char PIR1 @ 0x0D;
volatile unsigned char PIE1 @ 0x0E;
volatile unsigned char CMPCON0 @ 0x0F;
volatile unsigned char CMPCON1 @ 0x10;
volatile unsigned char PR2 @ 0x11;
volatile unsigned char TMR2 @ 0x12;
volatile unsigned char T2CON @ 0x13;
volatile unsigned char OSCCON @ 0x14;
volatile unsigned char PWMCON0 @ 0x15;
volatile unsigned char PWMCON1 @ 0x16;
volatile unsigned char PWMTL @ 0x17;
volatile unsigned char PWMTH @ 0x18;
volatile unsigned char PWMD0L @ 0x19;
volatile unsigned char PWMD1L @ 0x1A;
volatile unsigned char PWMD4L @ 0x1B;
volatile unsigned char PWMT4L @ 0x1C;
volatile unsigned char PWMCON2 @ 0x1D;
volatile unsigned char PWMD01H @ 0x1E;
volatile unsigned char PWM01DT @ 0x1F;
volatile unsigned char TMR0 @ 0x81;
volatile unsigned char TRISA @ 0x85;
volatile unsigned char PORTA @ 0x86;
volatile unsigned char WPDA @ 0x87;
volatile unsigned char WPUA @ 0x88;
volatile unsigned char IOCA @ 0x89;
volatile unsigned char ODCONA @ 0x8C;
volatile unsigned char ANSEL0 @ 0x93;
volatile unsigned char ANSEL1 @ 0x94;
volatile unsigned char ADCON0 @ 0x95;
volatile unsigned char ADCON1 @ 0x96;
volatile unsigned char ADRESL @ 0x98;
volatile unsigned char ADRESH @ 0x99;
volatile unsigned char PWMD2L @ 0x9B;
volatile unsigned char PWMD3L @ 0x9C;
volatile unsigned char PWM23DT @ 0x9D;
volatile unsigned char PWMD23H @ 0x9E;

volatile bit T0LSE_EN @ ((unsigned)&OPTION_REG*8)+7;
volatile bit INTEDG @ ((unsigned)&OPTION_REG*8)+6;
volatile bit T0CS @ ((unsigned)&OPTION_REG*8)+5;
volatile bit T0SE @ ((unsigned)&OPTION_REG*8)+4;
volatile bit PSA @ ((unsigned)&OPTION_REG*8)+3;
volatile bit PS2 @ ((unsigned)&OPTION_REG*8)+2;
volatile bit PS1 @ ((unsigned)&OPTION_REG*8)+1;
volatile bit PS0 @ ((unsigned)&OPTION_REG*8)+0;


volatile bit IRP @ ((unsigned)&STATUS*8)+7;
volatile bit RP1 @ ((unsigned)&STATUS*8)+6;
volatile bit RP0 @ ((unsigned)&STATUS*8)+5;
volatile bit TO @ ((unsigned)&STATUS*8)+4;
volatile bit PD @ ((unsigned)&STATUS*8)+3;
volatile bit Z @ ((unsigned)&STATUS*8)+2;
volatile bit DC @ ((unsigned)&STATUS*8)+1;
volatile bit C @ ((unsigned)&STATUS*8)+0;


volatile bit TRISB7 @ ((unsigned)&TRISB*8)+7;
volatile bit TRISB6 @ ((unsigned)&TRISB*8)+6;
volatile bit TRISB5 @ ((unsigned)&TRISB*8)+5;
volatile bit TRISB4 @ ((unsigned)&TRISB*8)+4;
volatile bit TRISB3 @ ((unsigned)&TRISB*8)+3;
volatile bit TRISB2 @ ((unsigned)&TRISB*8)+2;
volatile bit TRISB1 @ ((unsigned)&TRISB*8)+1;
volatile bit TRISB0 @ ((unsigned)&TRISB*8)+0;


volatile bit RB7 @ ((unsigned)&PORTB*8)+7;
volatile bit RB6 @ ((unsigned)&PORTB*8)+6;
volatile bit RB5 @ ((unsigned)&PORTB*8)+5;
volatile bit RB4 @ ((unsigned)&PORTB*8)+4;
volatile bit RB3 @ ((unsigned)&PORTB*8)+3;
volatile bit RB2 @ ((unsigned)&PORTB*8)+2;
volatile bit RB1 @ ((unsigned)&PORTB*8)+1;
volatile bit RB0 @ ((unsigned)&PORTB*8)+0;


volatile bit WPDB7 @ ((unsigned)&WPDB*8)+7;
volatile bit WPDB6 @ ((unsigned)&WPDB*8)+6;
volatile bit WPDB5 @ ((unsigned)&WPDB*8)+5;
volatile bit WPDB4 @ ((unsigned)&WPDB*8)+4;
volatile bit WPDB3 @ ((unsigned)&WPDB*8)+3;
volatile bit WPDB1 @ ((unsigned)&WPDB*8)+1;
volatile bit WPDB0 @ ((unsigned)&WPDB*8)+0;


volatile bit WPUB7 @ ((unsigned)&WPUB*8)+7;
volatile bit WPUB6 @ ((unsigned)&WPUB*8)+6;
volatile bit WPUB5 @ ((unsigned)&WPUB*8)+5;
volatile bit WPUB4 @ ((unsigned)&WPUB*8)+4;
volatile bit WPUB3 @ ((unsigned)&WPUB*8)+3;
volatile bit WPUB2 @ ((unsigned)&WPUB*8)+2;
volatile bit WPUB1 @ ((unsigned)&WPUB*8)+1;
volatile bit WPUB0 @ ((unsigned)&WPUB*8)+0;


volatile bit IOCB7 @ ((unsigned)&IOCB*8)+7;
volatile bit IOCB6 @ ((unsigned)&IOCB*8)+6;
volatile bit IOCB5 @ ((unsigned)&IOCB*8)+5;
volatile bit IOCB4 @ ((unsigned)&IOCB*8)+4;
volatile bit IOCB3 @ ((unsigned)&IOCB*8)+3;
volatile bit IOCB2 @ ((unsigned)&IOCB*8)+2;
volatile bit IOCB1 @ ((unsigned)&IOCB*8)+1;
volatile bit IOCB0 @ ((unsigned)&IOCB*8)+0;


volatile bit GIE @ ((unsigned)&INTCON*8)+7;
volatile bit PEIE @ ((unsigned)&INTCON*8)+6;
volatile bit T0IE @ ((unsigned)&INTCON*8)+5;
volatile bit INTE @ ((unsigned)&INTCON*8)+4;
volatile bit RBIE @ ((unsigned)&INTCON*8)+3;
volatile bit T0IF @ ((unsigned)&INTCON*8)+2;
volatile bit INTF @ ((unsigned)&INTCON*8)+1;
volatile bit RBIF @ ((unsigned)&INTCON*8)+0;


volatile bit ODCONB7 @ ((unsigned)&ODCONB*8)+7;
volatile bit ODCONB6 @ ((unsigned)&ODCONB*8)+6;
volatile bit ODCONB5 @ ((unsigned)&ODCONB*8)+5;
volatile bit ODCONB4 @ ((unsigned)&ODCONB*8)+4;
volatile bit ODCONB3 @ ((unsigned)&ODCONB*8)+3;
volatile bit ODCONB1 @ ((unsigned)&ODCONB*8)+1;
volatile bit ODCONB0 @ ((unsigned)&ODCONB*8)+0;


volatile bit CMPIF @ ((unsigned)&PIR1*8)+5;
volatile bit PWMIF @ ((unsigned)&PIR1*8)+4;
volatile bit RAIF @ ((unsigned)&PIR1*8)+3;
volatile bit TMR2IF @ ((unsigned)&PIR1*8)+1;
volatile bit ADIF @ ((unsigned)&PIR1*8)+0;


volatile bit CMPIE @ ((unsigned)&PIE1*8)+5;
volatile bit PWMIE @ ((unsigned)&PIE1*8)+4;
volatile bit RAIE @ ((unsigned)&PIE1*8)+3;
volatile bit TMR2IE @ ((unsigned)&PIE1*8)+1;
volatile bit ADIE @ ((unsigned)&PIE1*8)+0;


volatile bit CMPEN @ ((unsigned)&CMPCON0*8)+7;
volatile bit CMPPS @ ((unsigned)&CMPCON0*8)+6;
volatile bit CMPNS2 @ ((unsigned)&CMPCON0*8)+5;
volatile bit CMPNS1 @ ((unsigned)&CMPCON0*8)+4;
volatile bit CMPNS0 @ ((unsigned)&CMPCON0*8)+3;
volatile bit CMPNV @ ((unsigned)&CMPCON0*8)+2;
volatile bit CMPOUT @ ((unsigned)&CMPCON0*8)+1;
volatile bit CMPOEN @ ((unsigned)&CMPCON0*8)+0;


volatile bit CMPIM @ ((unsigned)&CMPCON1*8)+7;
volatile bit AN_EN @ ((unsigned)&CMPCON1*8)+6;
volatile bit RBIAS_H @ ((unsigned)&CMPCON1*8)+5;
volatile bit RBIAS_L @ ((unsigned)&CMPCON1*8)+4;
volatile bit LVDS3 @ ((unsigned)&CMPCON1*8)+3;
volatile bit LVDS2 @ ((unsigned)&CMPCON1*8)+2;
volatile bit LVDS1 @ ((unsigned)&CMPCON1*8)+1;
volatile bit LVDS0 @ ((unsigned)&CMPCON1*8)+0;


volatile bit CLK_SEL @ ((unsigned)&T2CON*8)+7;
volatile bit TOUTPS3 @ ((unsigned)&T2CON*8)+6;
volatile bit TOUTPS2 @ ((unsigned)&T2CON*8)+5;
volatile bit TOUTPS1 @ ((unsigned)&T2CON*8)+4;
volatile bit TOUTPS0 @ ((unsigned)&T2CON*8)+3;
volatile bit TMR2ON @ ((unsigned)&T2CON*8)+2;
volatile bit T2CKPS1 @ ((unsigned)&T2CON*8)+1;
volatile bit T2CKPS0 @ ((unsigned)&T2CON*8)+0;


volatile bit IRCF2 @ ((unsigned)&OSCCON*8)+6;
volatile bit IRCF1 @ ((unsigned)&OSCCON*8)+5;
volatile bit IRCF0 @ ((unsigned)&OSCCON*8)+4;
volatile bit SWDTEN @ ((unsigned)&OSCCON*8)+1;


volatile bit CLKDIV2 @ ((unsigned)&PWMCON0*8)+7;
volatile bit CLKDIV1 @ ((unsigned)&PWMCON0*8)+6;
volatile bit CLKDIV0 @ ((unsigned)&PWMCON0*8)+5;
volatile bit PWM4EN @ ((unsigned)&PWMCON0*8)+4;
volatile bit PWM3EN @ ((unsigned)&PWMCON0*8)+3;
volatile bit PWM2EN @ ((unsigned)&PWMCON0*8)+2;
volatile bit PWM1EN @ ((unsigned)&PWMCON0*8)+1;
volatile bit PWM0EN @ ((unsigned)&PWMCON0*8)+0;


volatile bit PWMIO_SEL1 @ ((unsigned)&PWMCON1*8)+7;
volatile bit PWMIO_SEL0 @ ((unsigned)&PWMCON1*8)+6;
volatile bit PWM2DTEN @ ((unsigned)&PWMCON1*8)+5;
volatile bit PWM0DTEN @ ((unsigned)&PWMCON1*8)+4;
volatile bit DT_DIV1 @ ((unsigned)&PWMCON1*8)+1;
volatile bit DT_DIV0 @ ((unsigned)&PWMCON1*8)+0;


volatile bit PWM4D9 @ ((unsigned)&PWMTH*8)+5;
volatile bit PWM4D8 @ ((unsigned)&PWMTH*8)+4;
volatile bit PWM4T9 @ ((unsigned)&PWMTH*8)+3;
volatile bit PWM4T8 @ ((unsigned)&PWMTH*8)+2;
volatile bit PWMT9 @ ((unsigned)&PWMTH*8)+1;
volatile bit PWMT8 @ ((unsigned)&PWMTH*8)+0;


volatile bit PWM4DIR @ ((unsigned)&PWMCON2*8)+4;
volatile bit PWM3DIR @ ((unsigned)&PWMCON2*8)+3;
volatile bit PWM2DIR @ ((unsigned)&PWMCON2*8)+2;
volatile bit PWM1DIR @ ((unsigned)&PWMCON2*8)+1;
volatile bit PWM0DIR @ ((unsigned)&PWMCON2*8)+0;


volatile bit PWMD19 @ ((unsigned)&PWMD01H*8)+5;
volatile bit PWMD18 @ ((unsigned)&PWMD01H*8)+4;
volatile bit PWMD09 @ ((unsigned)&PWMD01H*8)+1;
volatile bit PWMD08 @ ((unsigned)&PWMD01H*8)+0;


volatile bit PWM01DT5 @ ((unsigned)&PWM01DT*8)+5;
volatile bit PWM01DT4 @ ((unsigned)&PWM01DT*8)+4;
volatile bit PWM01DT3 @ ((unsigned)&PWM01DT*8)+3;
volatile bit PWM01DT2 @ ((unsigned)&PWM01DT*8)+2;
volatile bit PWM01DT1 @ ((unsigned)&PWM01DT*8)+1;
volatile bit PWM01DT0 @ ((unsigned)&PWM01DT*8)+0;


volatile bit TRISA5 @ ((unsigned)&TRISA*8)+5;
volatile bit TRISA4 @ ((unsigned)&TRISA*8)+4;
volatile bit TRISA3 @ ((unsigned)&TRISA*8)+3;
volatile bit TRISA2 @ ((unsigned)&TRISA*8)+2;
volatile bit TRISA1 @ ((unsigned)&TRISA*8)+1;
volatile bit TRISA0 @ ((unsigned)&TRISA*8)+0;


volatile bit RA5 @ ((unsigned)&PORTA*8)+5;
volatile bit RA4 @ ((unsigned)&PORTA*8)+4;
volatile bit RA3 @ ((unsigned)&PORTA*8)+3;
volatile bit RA2 @ ((unsigned)&PORTA*8)+2;
volatile bit RA1 @ ((unsigned)&PORTA*8)+1;
volatile bit RA0 @ ((unsigned)&PORTA*8)+0;


volatile bit WPDA5 @ ((unsigned)&WPDA*8)+5;
volatile bit WPDA4 @ ((unsigned)&WPDA*8)+4;
volatile bit WPDA3 @ ((unsigned)&WPDA*8)+3;
volatile bit WPDA2 @ ((unsigned)&WPDA*8)+2;
volatile bit WPDA1 @ ((unsigned)&WPDA*8)+1;
volatile bit WPDA0 @ ((unsigned)&WPDA*8)+0;


volatile bit WPUA5 @ ((unsigned)&WPUA*8)+5;
volatile bit WPUA4 @ ((unsigned)&WPUA*8)+4;
volatile bit WPUA3 @ ((unsigned)&WPUA*8)+3;
volatile bit WPUA2 @ ((unsigned)&WPUA*8)+2;
volatile bit WPUA1 @ ((unsigned)&WPUA*8)+1;
volatile bit WPUA0 @ ((unsigned)&WPUA*8)+0;


volatile bit IOCA5 @ ((unsigned)&IOCA*8)+5;
volatile bit IOCA4 @ ((unsigned)&IOCA*8)+4;
volatile bit IOCA3 @ ((unsigned)&IOCA*8)+3;
volatile bit IOCA2 @ ((unsigned)&IOCA*8)+2;
volatile bit IOCA1 @ ((unsigned)&IOCA*8)+1;
volatile bit IOCA0 @ ((unsigned)&IOCA*8)+0;


volatile bit ODCONA5 @ ((unsigned)&ODCONA*8)+5;
volatile bit ODCONA4 @ ((unsigned)&ODCONA*8)+4;
volatile bit ODCONA3 @ ((unsigned)&ODCONA*8)+3;
volatile bit ODCONA2 @ ((unsigned)&ODCONA*8)+2;
volatile bit ODCONA1 @ ((unsigned)&ODCONA*8)+1;
volatile bit ODCONA0 @ ((unsigned)&ODCONA*8)+0;


volatile bit ANS5 @ ((unsigned)&ANSEL0*8)+5;
volatile bit ANS4 @ ((unsigned)&ANSEL0*8)+4;
volatile bit ANS3 @ ((unsigned)&ANSEL0*8)+3;
volatile bit ANS2 @ ((unsigned)&ANSEL0*8)+2;
volatile bit ANS1 @ ((unsigned)&ANSEL0*8)+1;
volatile bit ANS0 @ ((unsigned)&ANSEL0*8)+0;


volatile bit ANS15 @ ((unsigned)&ANSEL1*8)+7;
volatile bit ANS14 @ ((unsigned)&ANSEL1*8)+6;
volatile bit ANS13 @ ((unsigned)&ANSEL1*8)+5;
volatile bit ANS12 @ ((unsigned)&ANSEL1*8)+4;
volatile bit ANS11 @ ((unsigned)&ANSEL1*8)+3;
volatile bit ANS9 @ ((unsigned)&ANSEL1*8)+1;
volatile bit ANS8 @ ((unsigned)&ANSEL1*8)+0;


volatile bit ADCS1 @ ((unsigned)&ADCON0*8)+7;
volatile bit ADCS0 @ ((unsigned)&ADCON0*8)+6;
volatile bit CHS3 @ ((unsigned)&ADCON0*8)+5;
volatile bit CHS2 @ ((unsigned)&ADCON0*8)+4;
volatile bit CHS1 @ ((unsigned)&ADCON0*8)+3;
volatile bit CHS0 @ ((unsigned)&ADCON0*8)+2;
volatile bit GODONE @ ((unsigned)&ADCON0*8)+1;
volatile bit ADON @ ((unsigned)&ADCON0*8)+0;


volatile bit ADFM @ ((unsigned)&ADCON1*8)+7;
volatile bit CHS4 @ ((unsigned)&ADCON1*8)+6;
volatile bit LDO_EN @ ((unsigned)&ADCON1*8)+2;
volatile bit LDO_SEL1 @ ((unsigned)&ADCON1*8)+1;
volatile bit LDO_SEL0 @ ((unsigned)&ADCON1*8)+0;


volatile bit PWMD39 @ ((unsigned)&PWMD23H*8)+5;
volatile bit PWMD38 @ ((unsigned)&PWMD23H*8)+4;
volatile bit PWMD29 @ ((unsigned)&PWMD23H*8)+1;
volatile bit PWMD28 @ ((unsigned)&PWMD23H*8)+0;


# 27 "C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\include\sc.h"
#pragma intrinsic(__nop)
extern void __nop(void);

# 76
extern unsigned int flash_read(unsigned short addr);


# 149
#pragma intrinsic(_delay)
extern __nonreentrant void _delay(unsigned long);

# 184
extern unsigned char __resetbits;
extern __bit __powerdown;
extern __bit __timeout;

# 16 "C:\mcuproject\scm\zdt\C212-FS_062B_SOP14\main.c"
volatile unsigned int adresult;
volatile unsigned int result;
volatile unsigned char test_adc;
volatile unsigned int power_ad;
unsigned char intCount;
unsigned char count1s;
unsigned char IntFlag;
unsigned char chrgFlag;
unsigned char chrgFullFlag;
unsigned char intCount10;
unsigned int outADValue;
unsigned int batADValue;
unsigned char countHalfFull;
unsigned char protectFlag;
unsigned char workOverOutTime;
unsigned char workStep = 0;
unsigned char ledCnt;
unsigned char ledStep;
unsigned char keyCount;
unsigned char longPressFlag;
unsigned char maxDuty;
unsigned char overCount;
unsigned char addPowerCount;
unsigned char tempDuty;
unsigned char startTime;
unsigned char firstTime;
unsigned char overChrgTime;
unsigned char pwStep;
unsigned char prePwStep;
unsigned int count50s;
unsigned char reChrgCount;
unsigned char lockLedStep;
unsigned char showBatTime;
unsigned char chrgMode = 0;
unsigned char chrgMaxAD = 0;
unsigned char lockCount = 0;
unsigned int fullCount = 0;
unsigned char addTime;
unsigned char subTime;
unsigned char chrgWaitTime;
unsigned char chrgMaxDuty = 0;
unsigned char ledCntTime;
unsigned int count5s = 0;
unsigned char overWorkTime;
unsigned char preLedStep;
unsigned int count8s;
unsigned int count900s;
unsigned char lowBatFlag = 0;
unsigned char sleepTime;
unsigned char startChrgTime = 0;


unsigned char ADC_Sample(unsigned char adch, unsigned char adldo);
void DelayXms(unsigned char x);
unsigned char ADC_Result(unsigned char adch);
void Init_System();
void AD_Init();
void Sleep_Mode();
void pwmInit();
void pwmStop();
void chrgPwmInit();
void chrgPwmStop();
void chrgCtr();
void checkOutA();
void checkBatAD();
void ledShow();
void keyCtr();
void workCtr();
void ledCtr();
char keyRead(char keyStatus);

# 100
void interrupt Isr_Timer()
{
if(TMR2IF)
{
TMR2IF = 0;
if(++intCount >= 160)
{
intCount = 0;
IntFlag = 1;
if(++count1s >= 100)
{
count1s = 0;
}
}
ledShow();
intCount10++;
}

}

# 124
void main()
{
Init_System();
AD_Init();
firstTime = 100;
while (1)
{
asm("clrwdt");
if(intCount10 > 10)
{
intCount10 = 0;
checkOutA();
}
if(!IntFlag)
continue;
IntFlag = 0;
chrgCtr();
checkBatAD();
if(chrgFlag == 0 && lowBatFlag == 0)
{
keyCtr();
}
workCtr();
ledCtr();
if(chrgFlag == 0 && workStep == 0 && keyCount == 0 && firstTime == 0 && showBatTime == 0)
{
if(++sleepTime >= 200)
{
sleepTime = 0;
Sleep_Mode();
}
}
else
{
sleepTime = 0;
}
}
}

void ledShow()
{
if(++ledCntTime > 30)
{
ledCntTime = 0;
if(++ledCnt > 5)
{
ledCnt = 0;
}
PORTA &= 0xDF;
PORTB &= 0xC7;
TRISA |= 0x20;
TRISB |= 0x38;
switch(ledCnt)
{
case 1:
if(ledStep > 0)
{
TRISB &= 0xE7;
PORTB |= 0x10;
}
break;
case 2:
if(ledStep > 1)
{
TRISB &= 0xCF;
PORTB |= 0x20;
}
break;
case 3:
if(ledStep > 2)
{
TRISB &= 0xE7;
PORTB |= 0x08;
}
break;
case 4:
if(ledStep > 3)
{
TRISB &= 0xCF;
PORTB |= 0x10;
}
break;
case 5:
if(ledStep > 4)
{
TRISA &= 0xDF;
TRISB &= 0xDF;
PORTB |= 0x20;
}
break;
case 0:
if(ledStep > 5)
{
TRISA &= 0xDF;
TRISB &= 0xDF;
PORTA |= 0x20;
}
break;
default:
break;
}
}


}


void ledCtr()
{
if(firstTime > 0)
{
firstTime--;
ledStep = 6;
if(prePwStep < pwStep)
{
prePwStep = pwStep;
}
}
else if(overWorkTime > 0)
{
overWorkTime--;
if(overWorkTime % 60 < 30)
{
ledStep = preLedStep;
}
else
{
ledStep = 0;
}
}
else if(showBatTime > 0)
{
showBatTime--;
if(prePwStep >= 14)
{
ledStep = prePwStep/14;
}
else if(prePwStep > 5)
{
ledStep = 1;
}
else
{
if(count1s < 50)
{
ledStep = 1;
}
else
{
ledStep = 0;
}
}
}
else if(workStep > 0)
{
ledStep = workStep;
}
else if(chrgFlag)
{
if(count1s % 50 == 0)
{
if(++ledStep > 6)
{
ledStep = lockLedStep;
}
}
}
else
{
ledStep = 0;
}
}



void chrgCtr()
{
if(PORTA & 0x02)
{
if(chrgFlag == 0)
{
chrgFlag = 1;
ledStep = 0;
chrgMaxDuty = 0;
chrgPwmStop();
}
workStep = 0;
lowBatFlag = 0;
if(prePwStep < pwStep)
{
if(++count50s > 2000)
{
count50s = 0;
prePwStep++;
}
}
else
{
count50s = 0;
}
if(protectFlag)
{
chrgPwmStop();
ledStep = 6;
if(prePwStep < 99 && protectFlag == 1)
{
if(++reChrgCount > 250)
{
reChrgCount = 0;
chrgFullFlag = 0;
protectFlag = 0;
if(prePwStep > 14)
{
lockLedStep = (prePwStep/14) - 1;
}
else
{
lockLedStep = 0;
}
}
}
else
{
reChrgCount = 0;
}
return;
}
if(batADValue < 1118)
{
chrgMode = 0;
chrgMaxAD = 15;
}
else if(batADValue < 1530)
{
chrgMode = 1;
chrgMaxAD = 40;
lockCount = 0;
}
else if(count1s == 0)
{
if(++lockCount > 200)
{
lockCount = 0;
chrgMode = 2;
}

chrgMaxAD = 40;
}
if(chrgMode == 2 && outADValue < 5)
{
if(++fullCount >= 200)
{
fullCount = 0;
chrgFullFlag = 1;
}
}
else
{
fullCount = 0;
}
if(chrgFullFlag)
{
lockLedStep = 6;
chrgPwmStop();
}
else
{
if(prePwStep < 15)
{
lockLedStep = 0;
}
else
{
lockLedStep = (prePwStep/14) - 1;
}
if(batADValue > 1545 || outADValue > (chrgMaxAD + 2))
{
if(++subTime > chrgWaitTime)
{
if(chrgMaxDuty > 1)
{
chrgMaxDuty--;
}
subTime = 0;
chrgWaitTime = 50;
}
addTime = 0;
}
else if(batADValue < 1545 && outADValue < (chrgMaxAD - 4))
{
if(++addTime > chrgWaitTime)
{
addTime = 0;
if(chrgMaxDuty < 75)
{
chrgMaxDuty++;
}
}
subTime = 0;
}


if((PWMCON0 & 0x01) == 0)
{
chrgPwmInit();
}
PWMD01H = 0X00;
PWMD0L = chrgMaxDuty;
}
}
else
{
startChrgTime = 0;
chrgFlag = 0;
chrgFullFlag = 0;
protectFlag = 0;
chrgMode = 0;
chrgMaxAD = 0;
chrgMaxDuty = 0;
lockCount = 0;
lockLedStep = 0;
chrgWaitTime = 20;
chrgPwmStop();
if(prePwStep > 0 && prePwStep > pwStep)
{
if(++count50s > 2000)
{
count50s = 0;
prePwStep--;
}
}
else
{
count50s = 0;
}
}
}



char keyRead(char keyStatus)
{
if(keyStatus)
{
keyCount++;
if(keyCount >= 100)
{
keyCount = 100;
if(!longPressFlag)
{
longPressFlag = 1;
return 2;
}
}
}
else
{
if(keyCount >= 100)
{
keyCount = 0;
longPressFlag = 0;
return 0;
}
else if(keyCount >= 6)
{
keyCount = 0;
return 1;
}
keyCount = 0;
}
return 0;
}

void keyCtr()
{
char kclick = keyRead(0x04 & (~PORTB));
if(kclick == 1)
{
if(workStep > 0)
{
if(++workStep > 6)
{
workStep = 1;
}
}
else if(showBatTime > 0)
{
showBatTime = 0;
}
else
{
showBatTime = 200;
count1s = 0;
}
}
else if(kclick == 2)
{
if(workStep > 0)
{
workStep = 0;
}
else
{
workStep = 1;
startTime = 30;
showBatTime = 0;
}
}
}

void workCtr()
{

if(startTime > 0)
{
startTime--;
}
if(workStep > 0)
{
if((PWMCON0 & 0x02) == 0)
{
pwmInit();
}
maxDuty = 33 + (workStep*11);
if(overCount >= 5)
{
if(++count5s > 500)
{
count5s = 0;
overWorkTime = 180;
preLedStep = workStep;
workStep = 0;

}
}
else
{
count5s = 0;
}
if(count1s == 0 && ++count900s >= 900)
{
workStep = 0;
}
}
else
{
pwmStop();
count900s = 0;
}
}

void checkOutA()
{
if(chrgFlag)
{
test_adc = ADC_Sample(4, 5);
}
else
{
test_adc = ADC_Sample(0, 5);
}
if (0xA5 == test_adc)
{
if(chrgFlag && adresult > 210)
{
if(++overChrgTime > 10)
{
overChrgTime = 0;
protectFlag = 2;
}

}
else
{
overChrgTime = 0;
}
outADValue = adresult;

if(workStep && (outADValue > 220))
{
if(++workOverOutTime > 50)
{
workOverOutTime = 0;
workStep = 0;
}
}
else
{
workOverOutTime = 0;
}
unsigned char maxtempV = 40;
if(workStep < 6 && outADValue > maxtempV)
{
if(++overCount > 5)
{
overCount = 5;
}
}
else if(outADValue > (maxtempV+3))
{
if(++overCount > 5)
{
overCount = 5;
}
}
else
{
unsigned char maxAout = 11;
if(workStep == 1)
{
maxAout = maxAout + 5;
}
else if(workStep == 2)
{
maxAout = maxAout + 6;
}
else if(workStep == 3)
{
maxAout = maxAout + 7;
}
else if(workStep == 4)
{
maxAout = maxAout + 8;
}
else if(workStep == 5)
{
maxAout = maxAout + 9;
}
else if(workStep == 6)
{
maxAout = maxAout + 10;
}
if(overCount > 0)
{
overCount--;
}
if(outADValue > maxAout)
{
if(++addPowerCount > 3)
{
addPowerCount = 3;
if(startTime == 0)
{
tempDuty = 72 + (workStep*4);

}
else
{
tempDuty = maxDuty;
}
}

}
else
{
addPowerCount = 0;
if(tempDuty > maxDuty)
{
tempDuty--;
}
else
{
tempDuty = maxDuty;
}

}

}
PWMD01H = 0X00;
PWMD1L = maxDuty;
}
else
{
ADCON0 = 0;
ADCON1 = 0;
_delay((unsigned long)((100)*(16000000/4000000.0)));
}
}

void checkBatAD()
{
test_adc = ADC_Sample(2, 5);
if (0xA5 == test_adc)
{
batADValue = adresult;
if(batADValue < 1117)
{
pwStep = 0;
if(++count8s > 800)
{
count8s = 0;
lowBatFlag = 1;
if(workStep > 0)
{
overWorkTime = 180;
preLedStep = workStep;
}
prePwStep = 0;
workStep = 0;
}
}
else
{
count8s = 0;
if(batADValue >= 1340)
{
pwStep = ((batADValue - 1340) /2) + 13;
}
else
{
pwStep = (batADValue - 1117) / 16;
}
if(pwStep > 99)
{
pwStep = 99;
}
}
if(chrgFlag && batADValue > 1861)
{
protectFlag = 1;
}
}
else
{
ADCON0 = 0;
ADCON1 = 0;
_delay((unsigned long)((100)*(16000000/4000000.0)));
}
test_adc = ADC_Sample(3, 5);
if (0xA5 == test_adc)
{
if(chrgFlag && adresult > 100)
{

if(adresult > 810 || (batADValue - adresult) > 810)
{

if(++countHalfFull > 250)
{
countHalfFull = 0;
protectFlag = 2;
}
}
else
{
countHalfFull = 0;
}
}
}
else
{
ADCON0 = 0;
ADCON1 = 0;
_delay((unsigned long)((100)*(16000000/4000000.0)));
}
}

# 790
void Init_System()
{
asm("nop");
asm("clrwdt");
OPTION_REG = 0;
asm("clrwdt");
OSCCON = 0X72;

WPUA = 0B00000000;
WPDA = 0x02;
WPUB = 0B00000100;

TRISA = 0x1F;
TRISB = 0B00000100;

PORTA = 0X00;
PORTB = 0X00;



PR2 = 249;
TMR2IF = 0;
TMR2IE = 1;

T2CON = 0B00000100;
INTCON = 0XC0;
}

# 827
void AD_Init()
{

# 860
ADCON0 = 0X41;

# 877
ADCON1 = 0;
ANSEL0 = 0X1D;
}


void chrgPwmInit()
{
PWMCON1 = 0B00000000;

PWMTH = 0X00;
PWMTL = 100;



PWMD01H = 0;
PWMD0L = 1;
PWM01DT = 0X00;

PWMCON0 = 0X01;
PWMCON2 =0X00;
}

void chrgPwmStop()
{
PWMCON0 &= 0xFE;
RB0 = 0;
}

void pwmInit()
{
PWMCON1 = 0B00000000;
PWMTH = 0X00;
PWMTL = 100;


PWMD01H = 0;
PWMD1L = 50;
PWM01DT = 0X00;

PWMCON0 = 0X62;
PWMCON2 =0X00;
}

void pwmStop()
{
PWMCON0 &= 0XFD;
RB1 = 0;
}

# 934
void Sleep_Mode()
{
INTCON = 0;

OPTION_REG = 0;

TRISA = 0x1F;
WPUA = 0B00000000;
PORTA = 0x00;
TRISB = 0B00000100;
PORTB = 0B00000000;
WPUB = 0B00000100;

ADCON0 = 0;
ADCON1 = 0;

PWMCON0 = 0;

OSCCON = 0X70;

IOCA = 0B00000010;
IOCB = 0B00000100;

RAIE = 1;
PEIE = 1;
RBIE = 1;
GIE = 0;

PIE1 &= 0X08;
PIR1 = 0;
INTCON &= 0XC8;

PORTA;
RAIF = 0;
PORTB;
RBIF = 0;
asm("clrwdt");

asm("sleep");

asm("nop");
asm("clrwdt");
asm("nop");
asm("nop");
asm("nop");
asm("nop");
asm("nop");
if(RAIF) RAIF = 0;
if(RBIF) RBIF = 0;
if(TMR2IF) TMR2IF = 0;
IOCA = 0B00000000;
IOCB = 0B00000000;
Init_System();
AD_Init();
}

# 1010
unsigned char ADC_Sample(unsigned char adch, unsigned char adldo)
{
volatile unsigned long adsum = 0;
volatile unsigned int admin = 0, admax = 0;
volatile unsigned int ad_temp = 0;

if ((!LDO_EN) && (adldo & 0x04) )
{

ADCON1 = adldo;
_delay((unsigned long)((100)*(16000000/4000000.0)));
}
else
ADCON1 = adldo;

if(adch & 0x10)
{
CHS4 = 1;
adch &= 0x0f;
}
unsigned char i = 0;
for (i = 0; i < 10; i++)
{
ADCON0 = (unsigned char)(0X41 | (adch << 2));
asm("nop");
asm("nop");
asm("nop");
asm("nop");
GODONE = 1;

unsigned char j = 0;
while (GODONE)
{
_delay((unsigned long)((2)*(16000000/4000000.0)));

if (0 == (--j))
return 0;
}

ad_temp = (unsigned int)((ADRESH << 4) + (ADRESL >> 4));

if (0 == admax)
{
admax = ad_temp;
admin = ad_temp;
}
else if (ad_temp > admax)
admax = ad_temp;
else if (ad_temp < admin)
admin = ad_temp;

adsum += ad_temp;
}
adsum -= admax;
if (adsum >= admin)
adsum -= admin;
else
adsum = 0;

adresult = adsum >> 3;

adsum = 0;
admin = 0;
admax = 0;
return 0xA5;

}

