---- C:\mcuproject\scm\zdt\D205_062B_SOP14\main.c ----------------------------------------------------------------------
1:                /**********************************************************
2:                AD检测范例程序
3:                **********************************************************/
4:                #pragma warning disable 752
5:                #pragma warning disable 373			//屏蔽掉编译的1个警告
6:                #include <sc.h>
7:                
8:                #ifndef _XTAL_FREQ
9:                #define _XTAL_FREQ 16000000			//16MHz,使用内置延时函数必须定义主频，
10:               									//如用FCPU_DIV选择2T，则定时赋值减半
11:               #endif
12:               #define		u8t		unsigned char
13:               #define		u16t	unsigned int
14:               #define     POWER_RATIO  	(4096UL*1.2*1000)
15:               
16:               
17:               #define		A_LED5						 RB0
18:               #define		A_LED4						 RB1
19:               #define		A_LED3						 RB5
20:               #define		A_LED2						 RA4
21:               #define		A_LED1						 RA5
22:               
23:               
24:               #define		A_LED5_OUT					 TRISB	&= 0xFE
25:               #define		A_LED4_OUT					 TRISB	&= 0xFD
26:               #define		A_LED3_OUT					 TRISB	&= 0xDF
27:               #define		A_LED2_OUT					 TRISA	&= 0xEF
28:               #define		A_LED1_OUT					 TRISA	&= 0xDF
29:               
30:               const static unsigned char numArray[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x71,0x79,0x50,0x76};
31:               
32:               volatile unsigned int adresult;
33:               volatile unsigned int result;
34:               volatile unsigned char test_adc;
35:               volatile unsigned int power_ad;
36:               u8t	intCount;
37:               u8t	count1s;
38:               u8t	IntFlag;
39:               u8t	chrgFlag;
40:               u8t	chrgFullFlag;
41:               u8t	intCount10;
42:               u16t	outADValue;
43:               u16t	batADValue;
44:               u8t		countHalfFull;
45:               u8t		protectFlag;
46:               u8t		workOverOutTime;
47:               u8t		workStep = 0;
48:               u8t		ledCnt;
49:               u8t		ledStep;
50:               u8t		keyCount;
51:               u8t		keyCount2;
52:               u8t		longPressFlag;
53:               u8t		longPressFlag2;
54:               u8t		maxDuty;
55:               u8t		overCount;
56:               u8t		addPowerCount;
57:               u8t		tempDuty;
58:               u8t		startTime;
59:               u8t		firstTime;
60:               u8t		overChrgTime;
61:               u8t		pwStep;
62:               u8t		prePwStep;
63:               u16t	count50s;
64:               u8t		reChrgCount;
65:               u8t		lockLedStep;
66:               u8t		showBatTime;
67:               u8t		chrgMode = 0;
68:               u8t		chrgMaxAD = 0;
69:               u8t		lockCount = 0;
70:               u16t	fullCount = 0;
71:               u8t addTime;
72:               u8t subTime;
73:               u8t chrgWaitTime;
74:               u8t	chrgMaxDuty = 0;
75:               u8t	ledCntTime;
76:               u16t	count5s = 0;
77:               u16t		overWorkTime;
78:               u8t		preLedStep;
79:               u16t	count8s;
80:               u16t	count900s;
81:               u8t		lowBatFlag = 0;
82:               u8t		sleepTime;
83:               u8t		startChrgTime = 0;
84:               u8t shiweiNum = 0;	//十位
85:               u8t	geweiNum = 0;	//个位
86:               u8t	jrStep = 0;
87:               u8t	preWorkStep = 0;
88:               u8t	prejrStep = 0;
89:               u8t	chrgPwmFlag = 0;
90:               u8t	motorPwmFlag = 0;
91:               u16t	jrStartTime = 0;
92:               u8t		jrShowTime = 0;
93:               u8t		jrPwmTime = 0;
94:               u8t		jrDuty = 0;
95:               u8t		jrDutyFX = 0;
96:               u8t		jrWaitTime = 0;
97:               
98:               unsigned char ADC_Sample(unsigned char adch, unsigned char adldo);
99:               void DelayXms(unsigned char x);
100:              unsigned char ADC_Result(unsigned char adch);
101:              void Init_System();
102:              void AD_Init();
103:              void Sleep_Mode();
104:              void pwmInit();
105:              void pwmStop();
106:              void chrgPwmInit();
107:              void chrgPwmStop();
108:              void chrgCtr();
109:              void checkOutA();
110:              void checkBatAD();
111:              void ledShow();
112:              void keyCtr();
113:              void workCtr();
114:              void ledCtr();
115:              char keyRead(char keyStatus);
116:              
117:              
118:              
119:              //#define _DEBUG			//调试程序用
120:              
121:              
122:              /***********************************************************
123:              中断服务函数
124:              函数名称：Isr_Timer()
125:              函数功能：中断处理函数
126:              入口参数：
127:              出口参数：
128:              备    注：125US定时2中断
129:              			所有中断都是在这个函数里面处理
130:              ***********************************************************/
131:              void interrupt Isr_Timer() 
132:              {
133:              	if(TMR2IF) 
  056C    1283    CLRB	0x3,5
  056D    1C8D    SNZB	0xD,1
  056E    2D80    JP	0x580
134:              	{			//若只使能了一个中断源,可以略去判断
135:              		TMR2IF = 0;
  056F    108D    CLRB	0xD,1
136:              		if(++intCount >= 160)
  0570    30A0    LDIA	0xA0
  0571    0AD4    INCR	0x54
  0572    0254    SUBA	0x54
  0573    1C03    SNZB	0x3,0
  0574    2D7D    JP	0x57D
  0575    3064    LDIA	0x64
137:              		{
138:              			intCount = 0;
  0576    01D4    CLR	0x54
139:              			IntFlag = 1;
  0577    01D2    CLR	0x52
  0578    0AD2    INCR	0x52
140:              			if(++count1s >= 100)
  0579    0AD3    INCR	0x53
  057A    0253    SUBA	0x53
  057B    1803    SZB	0x3,0
141:              			{
142:              				count1s = 0;
  057C    01D3    CLR	0x53
143:              			}
144:              		}
145:              		ledShow();
  057D    21EC    CALL	0x1EC
146:              		intCount10++;
  057E    1283    CLRB	0x3,5
  057F    0ACF    INCR	0x4F
  0580    0872    LD	A,0x72
  0581    008A    LD	0xA,A
  0582    0871    LD	A,0x71
  0583    0084    LD	0x4,A
  0584    0E70    SWAPA	0x70
  0585    0083    LD	0x3,A
  0586    0EFE    SWAPR	0x7E
  0587    0E7E    SWAPA	0x7E
  0588    0009    RETI
147:              	}
148:              
149:              }
150:              
151:              
152:              /***********************************************************
153:              main主函数
154:              ***********************************************************/
155:              void main() 
156:              {
157:              	Init_System();
  0462    25C0    CALL	0x5C0
158:              	AD_Init();
  0463    2633    CALL	0x633
159:              	shiweiNum = geweiNum = numArray[8];
  0464    3009    LDIA	0x9
  0465    0084    LD	0x4,A
  0466    25DA    CALL	0x5DA
  0467    1283    CLRB	0x3,5
  0468    00EB    LD	0x6B,A
  0469    00EC    LD	0x6C,A
160:              	firstTime = 200;
  046A    30C8    LDIA	0xC8
  046B    00ED    LD	0x6D,A
161:              	while (1) 
  046C    0064    CLRWDT
162:              	{
163:              		asm("clrwdt");
164:              		if(intCount10 > 10)
  046D    300B    LDIA	0xB
  046E    1283    CLRB	0x3,5
  046F    024F    SUBA	0x4F
  0470    1C03    SNZB	0x3,0
  0471    2C74    JP	0x474
165:              		{
166:              			intCount10 = 0;
  0472    01CF    CLR	0x4F
167:              			checkOutA();
  0473    22A9    CALL	0x2A9
168:              		}
169:              		if(!IntFlag)
  0474    1283    CLRB	0x3,5
  0475    0852    LD	A,0x52
  0476    1903    SZB	0x3,2
  0477    2C6C    JP	0x46C
170:                  		continue;			//10ms执行一次
171:                  	IntFlag = 0;
  0478    01D2    CLR	0x52
172:              		chrgCtr();
  0479    2018    CALL	0x18
173:              		checkBatAD();
  047A    2361    CALL	0x361
174:              		if(chrgFlag == 0 && lowBatFlag == 0 && firstTime == 0)
  047B    1283    CLRB	0x3,5
  047C    0851    LD	A,0x51
  047D    1D03    SNZB	0x3,2
  047E    2C86    JP	0x486
  047F    0838    LD	A,0x38
  0480    1D03    SNZB	0x3,2
  0481    2C86    JP	0x486
  0482    086D    LD	A,0x6D
  0483    1D03    SNZB	0x3,2
  0484    2C86    JP	0x486
175:              		{
176:              			keyCtr();
  0485    2523    CALL	0x523
177:              		}
178:              		workCtr();
  0486    24E9    CALL	0x4E9
179:              		ledCtr();
  0487    2405    CALL	0x405
180:              		if(chrgFlag == 0 && workStep == 0 && keyCount == 0 && firstTime == 0 && showBatTime == 0 && overWorkTime == 0)
  0488    0851    LD	A,0x51
  0489    1D03    SNZB	0x3,2
  048A    2CA5    JP	0x4A5
  048B    087A    LD	A,0x7A
  048C    1D03    SNZB	0x3,2
  048D    2CA5    JP	0x4A5
  048E    084A    LD	A,0x4A
  048F    1D03    SNZB	0x3,2
  0490    2CA5    JP	0x4A5
  0491    086D    LD	A,0x6D
  0492    1D03    SNZB	0x3,2
  0493    2CA5    JP	0x4A5
  0494    0841    LD	A,0x41
  0495    1D03    SNZB	0x3,2
  0496    2CA5    JP	0x4A5
  0497    0824    LD	A,0x24
  0498    0425    ORA	0x25
  0499    1D03    SNZB	0x3,2
  049A    2CA5    JP	0x4A5
  049B    30C8    LDIA	0xC8
181:              		{
182:              			shiweiNum = geweiNum = 0;
  049C    01EB    CLR	0x6B
  049D    01EC    CLR	0x6C
183:              			if(++sleepTime >= 200)
  049E    0AB7    INCR	0x37
  049F    0237    SUBA	0x37
  04A0    1C03    SNZB	0x3,0
  04A1    2C6C    JP	0x46C
184:              			{
185:              				sleepTime = 0;
  04A2    01B7    CLR	0x37
186:              				Sleep_Mode();
  04A3    24A7    CALL	0x4A7
  04A4    2C6C    JP	0x46C
187:              			}
188:              		}
189:              		else
190:              		{
191:              			sleepTime = 0;
  04A5    01B7    CLR	0x37
  04A6    2C6C    JP	0x46C
192:              		}
193:              	}
194:              }
195:              
196:              void ledShow()
197:              {
198:              	if(++ledCntTime > 5)
  01EC    3006    LDIA	0x6
  01ED    0AB9    INCR	0x39
  01EE    0239    SUBA	0x39
  01EF    1C03    SNZB	0x3,0
  01F0    0008    RET
  01F1    300F    LDIA	0xF
199:              	{
200:              		ledCntTime = 0;
  01F2    01B9    CLR	0x39
201:              		if(++ledCnt > 14)
  01F3    0ACB    INCR	0x4B
  01F4    024B    SUBA	0x4B
  01F5    1803    SZB	0x3,0
202:              		{
203:              			ledCnt = 0;
  01F6    01CB    CLR	0x4B
204:              		}
205:              		PORTA &= 0x3F;
  01F7    303F    LDIA	0x3F
  01F8    1683    SETB	0x3,5
  01F9    0586    ANDR	0x6
206:              		PORTB &= 0xDC;
  01FA    30DC    LDIA	0xDC
  01FB    1283    CLRB	0x3,5
  01FC    0586    ANDR	0x6
207:              		TRISA |= 0x30;
  01FD    3030    LDIA	0x30
  01FE    1683    SETB	0x3,5
  01FF    0485    ORR	0x5
208:              		TRISB |= 0x23;
  0200    3023    LDIA	0x23
  0201    1283    CLRB	0x3,5
  0202    0485    ORR	0x5
209:              		switch(ledCnt)
  0203    2A9D    JP	0x29D
210:              		{
211:              			case 1:
212:              			if(shiweiNum & 0x01)
  0204    1C6C    SNZB	0x6C,0
  0205    0008    RET
213:              			{
214:              				A_LED3_OUT;
  0206    1285    CLRB	0x5,5
215:              				A_LED2_OUT;
  0207    1683    SETB	0x3,5
  0208    1205    CLRB	0x5,4
216:              				A_LED3 = 1;
  0209    1283    CLRB	0x3,5
  020A    1686    SETB	0x6,5
217:              				A_LED2 = 0;
  020B    1683    SETB	0x3,5
  020C    1206    CLRB	0x6,4
  020D    0008    RET
218:              			}
219:              			break;
220:              			case 2:
221:              			if(shiweiNum & 0x02)
  020E    1CEC    SNZB	0x6C,1
  020F    0008    RET
222:              			{
223:              				A_LED3_OUT;
  0210    1285    CLRB	0x5,5
224:              				A_LED2_OUT;
  0211    1683    SETB	0x3,5
  0212    1205    CLRB	0x5,4
225:              				A_LED2 = 1;
  0213    1606    SETB	0x6,4
226:              				A_LED3 = 0;
  0214    1283    CLRB	0x3,5
  0215    1286    CLRB	0x6,5
  0216    0008    RET
227:              			}
228:              			break;
229:              			case 3:
230:              			if(shiweiNum & 0x04)
  0217    1D6C    SNZB	0x6C,2
  0218    0008    RET
231:              			{
232:              				A_LED3_OUT;
  0219    1285    CLRB	0x5,5
233:              				A_LED4_OUT;
  021A    1085    CLRB	0x5,1
234:              				A_LED3 = 1;
  021B    1686    SETB	0x6,5
235:              				A_LED4 = 0;
  021C    1086    CLRB	0x6,1
  021D    0008    RET
236:              			}
237:              			break;
238:              			case 4:
239:              			if(shiweiNum & 0x08)
  021E    1DEC    SNZB	0x6C,3
  021F    0008    RET
240:              			{
241:              				A_LED2_OUT;
  0220    1683    SETB	0x3,5
  0221    1205    CLRB	0x5,4
242:              				A_LED4_OUT;
  0222    1283    CLRB	0x3,5
  0223    1085    CLRB	0x5,1
243:              				A_LED2 = 1;
  0224    1683    SETB	0x3,5
  0225    1606    SETB	0x6,4
244:              				A_LED4 = 0;
  0226    1283    CLRB	0x3,5
  0227    1086    CLRB	0x6,1
  0228    0008    RET
245:              			}
246:              			break;
247:              			case 5:
248:              			if(shiweiNum & 0x10)
  0229    1E6C    SNZB	0x6C,4
  022A    0008    RET
249:              			{
250:              				A_LED2_OUT;
  022B    1683    SETB	0x3,5
  022C    1205    CLRB	0x5,4
251:              				A_LED5_OUT;
  022D    1283    CLRB	0x3,5
  022E    1005    CLRB	0x5,0
252:              				A_LED2 = 1;
  022F    1683    SETB	0x3,5
  0230    1606    SETB	0x6,4
253:              				A_LED5 = 0;
  0231    1283    CLRB	0x3,5
  0232    1006    CLRB	0x6,0
  0233    0008    RET
254:              			}
255:              			break;
256:              			case 6:
257:              			if(shiweiNum & 0x20)
  0234    1EEC    SNZB	0x6C,5
  0235    0008    RET
258:              			{
259:              				A_LED3_OUT;
  0236    1285    CLRB	0x5,5
260:              				A_LED5_OUT;
  0237    1005    CLRB	0x5,0
261:              				A_LED3 = 1;
  0238    1686    SETB	0x6,5
262:              				A_LED5 = 0;
  0239    1006    CLRB	0x6,0
  023A    0008    RET
263:              			}
264:              			break;
265:              			case 7:
266:              			if(shiweiNum & 0x40)
  023B    1F6C    SNZB	0x6C,6
  023C    0008    RET
267:              			{
268:              				A_LED4_OUT;
  023D    1085    CLRB	0x5,1
269:              				A_LED5_OUT;
  023E    1005    CLRB	0x5,0
270:              				A_LED4 = 1;
  023F    1486    SETB	0x6,1
271:              				A_LED5 = 0;
  0240    1006    CLRB	0x6,0
  0241    0008    RET
272:              			}
273:              			break;
274:              			case 8:
275:              			if(geweiNum & 0x01)
  0242    1C6B    SNZB	0x6B,0
  0243    0008    RET
276:              			{
277:              				A_LED1_OUT;
  0244    1683    SETB	0x3,5
  0245    1285    CLRB	0x5,5
278:              				A_LED2_OUT;
  0246    1205    CLRB	0x5,4
279:              				A_LED2 = 1;
  0247    1606    SETB	0x6,4
280:              				A_LED1 = 0;
  0248    1286    CLRB	0x6,5
  0249    0008    RET
281:              			}
282:              			break;
283:              			case 9:
284:              			if(geweiNum & 0x02)
  024A    1CEB    SNZB	0x6B,1
  024B    0008    RET
285:              			{
286:              				A_LED1_OUT;
  024C    1683    SETB	0x3,5
  024D    1285    CLRB	0x5,5
287:              				A_LED2_OUT;
  024E    1205    CLRB	0x5,4
288:              				A_LED1 = 1;
  024F    1686    SETB	0x6,5
289:              				A_LED2 = 0;
  0250    1206    CLRB	0x6,4
  0251    0008    RET
290:              			}
291:              			break;
292:              			case 10:
293:              			if(geweiNum & 0x04)
  0252    1D6B    SNZB	0x6B,2
  0253    0008    RET
294:              			{
295:              				A_LED1_OUT;
  0254    1683    SETB	0x3,5
  0255    1285    CLRB	0x5,5
296:              				A_LED3_OUT;
  0256    1283    CLRB	0x3,5
  0257    1285    CLRB	0x5,5
297:              				A_LED3 = 1;
  0258    1686    SETB	0x6,5
298:              				A_LED1 = 0;
  0259    1683    SETB	0x3,5
  025A    1286    CLRB	0x6,5
  025B    0008    RET
299:              			}
300:              			break;
301:              			case 11:
302:              			if(geweiNum & 0x08)
  025C    1DEB    SNZB	0x6B,3
  025D    0008    RET
303:              			{
304:              				A_LED1_OUT;
  025E    1683    SETB	0x3,5
  025F    1285    CLRB	0x5,5
305:              				A_LED3_OUT;
  0260    1283    CLRB	0x3,5
  0261    1285    CLRB	0x5,5
306:              				A_LED1 = 1;
  0262    1683    SETB	0x3,5
  0263    1686    SETB	0x6,5
307:              				A_LED3 = 0;
  0264    1283    CLRB	0x3,5
  0265    1286    CLRB	0x6,5
  0266    0008    RET
308:              			}
309:              			break;
310:              			case 12:
311:              			if(geweiNum & 0x10)
  0267    1E6B    SNZB	0x6B,4
  0268    0008    RET
312:              			{
313:              				A_LED1_OUT;
  0269    1683    SETB	0x3,5
  026A    1285    CLRB	0x5,5
314:              				A_LED4_OUT;
  026B    1283    CLRB	0x3,5
  026C    1085    CLRB	0x5,1
315:              				A_LED4 = 1;
  026D    1486    SETB	0x6,1
316:              				A_LED1 = 0;
  026E    1683    SETB	0x3,5
  026F    1286    CLRB	0x6,5
  0270    0008    RET
317:              			}
318:              			break;
319:              			case 13:
320:              			if(geweiNum & 0x20)
  0271    1EEB    SNZB	0x6B,5
  0272    0008    RET
321:              			{
322:              				A_LED1_OUT;
  0273    1683    SETB	0x3,5
  0274    1285    CLRB	0x5,5
323:              				A_LED4_OUT;
  0275    1283    CLRB	0x3,5
  0276    1085    CLRB	0x5,1
324:              				A_LED1 = 1;
  0277    1683    SETB	0x3,5
  0278    1686    SETB	0x6,5
325:              				A_LED4 = 0;
  0279    1283    CLRB	0x3,5
  027A    1086    CLRB	0x6,1
  027B    0008    RET
326:              			}
327:              			break;
328:              			case 14:
329:              			if(geweiNum & 0x40)
  027C    1F6B    SNZB	0x6B,6
  027D    0008    RET
330:              			{
331:              				A_LED1_OUT;
  027E    1683    SETB	0x3,5
  027F    1285    CLRB	0x5,5
332:              				A_LED5_OUT;
  0280    1283    CLRB	0x3,5
  0281    1005    CLRB	0x5,0
333:              				A_LED1 = 1;
  0282    1683    SETB	0x3,5
  0283    1686    SETB	0x6,5
334:              				A_LED5 = 0;
  0284    1283    CLRB	0x3,5
  0285    1006    CLRB	0x6,0
  0286    0008    RET
335:              			}
336:              			break;
337:              			case 15:
338:              			if(workStep > 0)
  0287    087A    LD	A,0x7A
  0288    1903    SZB	0x3,2
  0289    0008    RET
339:              			{
340:              				A_LED2_OUT;
  028A    1683    SETB	0x3,5
  028B    1205    CLRB	0x5,4
341:              				A_LED5_OUT;
  028C    1283    CLRB	0x3,5
  028D    1005    CLRB	0x5,0
342:              				A_LED5 = 1;
  028E    1406    SETB	0x6,0
343:              				A_LED2 = 0;
  028F    1683    SETB	0x3,5
  0290    1206    CLRB	0x6,4
  0291    0008    RET
344:              			}
345:              			break;
346:              			case 0:
347:              			if(workStep > 0)
  0292    087A    LD	A,0x7A
  0293    1903    SZB	0x3,2
  0294    0008    RET
348:              			{
349:              				A_LED1_OUT;
  0295    1683    SETB	0x3,5
  0296    1285    CLRB	0x5,5
350:              				A_LED5_OUT;
  0297    1283    CLRB	0x3,5
  0298    1005    CLRB	0x5,0
351:              				A_LED5 = 1;
  0299    1406    SETB	0x6,0
352:              				A_LED1 = 0;
  029A    1683    SETB	0x3,5
  029B    1286    CLRB	0x6,5
  029C    0008    RET
  029D    084B    LD	A,0x4B
  029E    0084    LD	0x4,A
  029F    3010    LDIA	0x10
  02A0    0204    SUBA	0x4
  02A1    1803    SZB	0x3,0
  02A2    0008    RET
  02A3    3006    LDIA	0x6
  02A4    008A    LD	0xA,A
  02A5    3000    LDIA	0x0
  02A6    0704    ADDA	0x4
  02A7    0082    LD	0x2,A
  02A8    0008    RET
353:              			}
354:              			break;
355:              			default:
356:              			break;
357:              		}
358:              	}
359:              	
360:              	
361:              }
362:              
363:              
364:              void ledCtr()
365:              {
366:              	if(firstTime > 0)
  0405    086D    LD	A,0x6D
  0406    1903    SZB	0x3,2
  0407    2C10    JP	0x410
367:              	{
368:              		firstTime--;
  0408    03ED    DECR	0x6D
369:              		if(prePwStep < pwStep)
  0409    0843    LD	A,0x43
  040A    0279    SUBA	0x79
  040B    1803    SZB	0x3,0
  040C    0008    RET
370:              		{
371:              			prePwStep = pwStep;
  040D    0843    LD	A,0x43
  040E    00F9    LD	0x79,A
  040F    0008    RET
372:              		}
373:              	}
374:              	else if(overWorkTime > 0)
  0410    0824    LD	A,0x24
  0411    0425    ORA	0x25
  0412    1903    SZB	0x3,2
  0413    2C23    JP	0x423
375:              	{
376:              		overWorkTime--;
  0414    3001    LDIA	0x1
  0415    02A4    SUBR	0x24
  0416    3000    LDIA	0x0
  0417    1C03    SNZB	0x3,0
  0418    03A5    DECR	0x25
  0419    02A5    SUBR	0x25
377:              		shiweiNum = numArray[11];
  041A    300C    LDIA	0xC
  041B    0084    LD	0x4,A
  041C    25DA    CALL	0x5DA
  041D    00EC    LD	0x6C,A
378:              		geweiNum = numArray[12];
  041E    300D    LDIA	0xD
  041F    0084    LD	0x4,A
  0420    25DA    CALL	0x5DA
  0421    00EB    LD	0x6B,A
379:              	}
  0422    0008    RET
380:              	else if(showBatTime > 0)
  0423    0841    LD	A,0x41
  0424    1903    SZB	0x3,2
  0425    2C35    JP	0x435
  0426    300A    LDIA	0xA
381:              	{
382:              		showBatTime--;
  0427    03C1    DECR	0x41
383:              		shiweiNum = numArray[prePwStep/10];
  0428    00F3    LD	0x73,A
  0429    0879    LD	A,0x79
  042A    25A5    CALL	0x5A5
  042B    3E01    ADDIA	0x1
  042C    0084    LD	0x4,A
  042D    25DA    CALL	0x5DA
384:              		geweiNum = numArray[prePwStep%10];
  042E    245D    CALL	0x45D
  042F    2589    CALL	0x589
  0430    3E01    ADDIA	0x1
  0431    0084    LD	0x4,A
  0432    25DA    CALL	0x5DA
  0433    00EB    LD	0x6B,A
385:              	}
  0434    0008    RET
386:              	else if(workStep > 0)
  0435    087A    LD	A,0x7A
  0436    1903    SZB	0x3,2
  0437    2C49    JP	0x449
387:              	{
388:              		
389:              
390:              		shiweiNum = numArray[workStep/10];
  0438    300A    LDIA	0xA
  0439    00F3    LD	0x73,A
  043A    087A    LD	A,0x7A
  043B    25A5    CALL	0x5A5
  043C    3E01    ADDIA	0x1
  043D    0084    LD	0x4,A
  043E    25DA    CALL	0x5DA
  043F    00EC    LD	0x6C,A
391:              		geweiNum = numArray[workStep%10];
  0440    300A    LDIA	0xA
  0441    00F3    LD	0x73,A
  0442    087A    LD	A,0x7A
  0443    2589    CALL	0x589
  0444    3E01    ADDIA	0x1
  0445    0084    LD	0x4,A
  0446    25DA    CALL	0x5DA
  0447    00EB    LD	0x6B,A
392:              
393:              	}
  0448    0008    RET
394:              	else if(chrgFlag)
  0449    0851    LD	A,0x51
  044A    1903    SZB	0x3,2
  044B    2C5A    JP	0x45A
395:              	{
396:              		shiweiNum = numArray[prePwStep/10];
  044C    300A    LDIA	0xA
  044D    00F3    LD	0x73,A
  044E    0879    LD	A,0x79
  044F    25A5    CALL	0x5A5
  0450    3E01    ADDIA	0x1
  0451    0084    LD	0x4,A
  0452    25DA    CALL	0x5DA
397:              		geweiNum = numArray[prePwStep%10];
  0453    245D    CALL	0x45D
  0454    2589    CALL	0x589
  0455    3E01    ADDIA	0x1
  0456    0084    LD	0x4,A
  0457    25DA    CALL	0x5DA
  0458    00EB    LD	0x6B,A
398:              	}
  0459    0008    RET
399:              	else
400:              	{
401:              		shiweiNum = 0;
  045A    01EC    CLR	0x6C
402:              		geweiNum = 0;
  045B    01EB    CLR	0x6B
  045C    0008    RET
403:              	}
404:              }
405:              
406:              
407:              
408:              void chrgCtr()
409:              {
410:              	if(PORTA & 0x02)
  0018    1683    SETB	0x3,5
  0019    1C86    SNZB	0x6,1
  001A    28DF    JP	0xDF
411:              	{
412:              		if(chrgFlag == 0)
  001B    1283    CLRB	0x3,5
  001C    0851    LD	A,0x51
  001D    1D03    SNZB	0x3,2
  001E    2823    JP	0x23
413:              		{
414:              			chrgFlag = 1;
  001F    01D1    CLR	0x51
  0020    0AD1    INCR	0x51
415:              			chrgMaxDuty = 0;
  0021    01BA    CLR	0x3A
416:              			chrgPwmStop();
  0022    2642    CALL	0x642
417:              		}
418:              		jrStep = 0;
  0023    01B6    CLR	0x36
419:              		workStep = 0;
  0024    01FA    CLR	0x7A
420:              		pwmStop();
  0025    263B    CALL	0x63B
421:              		lowBatFlag = 0;
  0026    01B8    CLR	0x38
422:              		if(prePwStep < pwStep)
  0027    0843    LD	A,0x43
  0028    0279    SUBA	0x79
  0029    1803    SZB	0x3,0
  002A    2834    JP	0x34
423:              		{
424:              			if(++count50s > 3000)
  002B    20FD    CALL	0xFD
  002C    1903    SZB	0x3,2
  002D    022A    SUBA	0x2A
  002E    1C03    SNZB	0x3,0
  002F    2836    JP	0x36
425:              			{
426:              				count50s = 0;
  0030    01AA    CLR	0x2A
  0031    01AB    CLR	0x2B
427:              				prePwStep++;
  0032    0AF9    INCR	0x79
  0033    2836    JP	0x36
428:              			}
429:              		}
430:              		else
431:              		{
432:              			count50s = 0;
  0034    01AA    CLR	0x2A
  0035    01AB    CLR	0x2B
433:              		}
434:              		if(protectFlag)
  0036    084D    LD	A,0x4D
  0037    1903    SZB	0x3,2
  0038    284B    JP	0x4B
435:              		{
436:              			chrgPwmStop();
  0039    2642    CALL	0x642
437:              			if(prePwStep < 99 && protectFlag == 1)
  003A    3063    LDIA	0x63
  003B    0279    SUBA	0x79
  003C    1803    SZB	0x3,0
  003D    2849    JP	0x49
  003E    0B4D    SZDECA	0x4D
  003F    2849    JP	0x49
438:              			{
439:              				if(++reChrgCount > 250)
  0040    30FB    LDIA	0xFB
  0041    0AC2    INCR	0x42
  0042    0242    SUBA	0x42
  0043    1C03    SNZB	0x3,0
  0044    0008    RET
440:              				{
441:              					reChrgCount = 0;
  0045    01C2    CLR	0x42
442:              					chrgFullFlag = 0;
  0046    01D0    CLR	0x50
443:              					protectFlag = 0;
  0047    01CD    CLR	0x4D
  0048    0008    RET
444:              				}
445:              			}
446:              			else
447:              			{
448:              				reChrgCount = 0;
  0049    01C2    CLR	0x42
  004A    0008    RET
449:              			}
450:              			return;
451:              		}
452:              		if(batADValue < 1118)
  004B    3004    LDIA	0x4
  004C    0278    SUBA	0x78
  004D    305E    LDIA	0x5E
  004E    1903    SZB	0x3,2
  004F    0277    SUBA	0x77
  0050    1803    SZB	0x3,0
  0051    2855    JP	0x55
  0052    300F    LDIA	0xF
453:              		{
454:              			chrgMode = 0;
  0053    01C0    CLR	0x40
455:              			chrgMaxAD = 15;
  0054    286E    JP	0x6E
456:              		}
457:              		else if(batADValue < 1530)
  0055    3005    LDIA	0x5
  0056    0278    SUBA	0x78
  0057    30FA    LDIA	0xFA
  0058    1903    SZB	0x3,2
  0059    0277    SUBA	0x77
  005A    1803    SZB	0x3,0
  005B    2862    JP	0x62
  005C    303C    LDIA	0x3C
458:              		{
459:              			chrgMode = 1;
  005D    01C0    CLR	0x40
  005E    0AC0    INCR	0x40
460:              			chrgMaxAD = 60;
  005F    00BF    LD	0x3F,A
461:              			lockCount = 0;
  0060    01BE    CLR	0x3E
462:              		}
  0061    286F    JP	0x6F
463:              		else if(count1s == 0)
  0062    0853    LD	A,0x53
  0063    1D03    SNZB	0x3,2
  0064    286F    JP	0x6F
464:              		{
465:              			if(++lockCount > 200)
  0065    30C9    LDIA	0xC9
  0066    0ABE    INCR	0x3E
  0067    023E    SUBA	0x3E
  0068    1C03    SNZB	0x3,0
  0069    286D    JP	0x6D
  006A    3002    LDIA	0x2
466:              			{
467:              				lockCount = 0;
  006B    01BE    CLR	0x3E
468:              				chrgMode = 2;
  006C    00C0    LD	0x40,A
469:              			}
470:              			
471:              			chrgMaxAD = 60;
  006D    303C    LDIA	0x3C
  006E    00BF    LD	0x3F,A
472:              		}
473:              		if(chrgMode == 2 && outADValue < 8)
  006F    3002    LDIA	0x2
  0070    0640    XORA	0x40
  0071    1D03    SNZB	0x3,2
  0072    2889    JP	0x89
  0073    3000    LDIA	0x0
  0074    022D    SUBA	0x2D
  0075    3008    LDIA	0x8
  0076    1903    SZB	0x3,2
  0077    022C    SUBA	0x2C
  0078    1803    SZB	0x3,0
  0079    2889    JP	0x89
474:              		{
475:              			if(++fullCount >= 200)
  007A    0AA8    INCR	0x28
  007B    1903    SZB	0x3,2
  007C    0AA9    INCR	0x29
  007D    3000    LDIA	0x0
  007E    0229    SUBA	0x29
  007F    30C8    LDIA	0xC8
  0080    1903    SZB	0x3,2
  0081    0228    SUBA	0x28
  0082    1C03    SNZB	0x3,0
  0083    288B    JP	0x8B
476:              			{
477:              				fullCount = 0;
  0084    01A8    CLR	0x28
  0085    01A9    CLR	0x29
478:              				chrgFullFlag = 1;
  0086    01D0    CLR	0x50
  0087    0AD0    INCR	0x50
  0088    288B    JP	0x8B
479:              			}
480:              		}
481:              		else
482:              		{
483:              			fullCount = 0;
  0089    01A8    CLR	0x28
  008A    01A9    CLR	0x29
484:              		}
485:              		if(chrgFullFlag)
  008B    0850    LD	A,0x50
  008C    1903    SZB	0x3,2
  008D    288F    JP	0x8F
486:              		{
487:              			chrgPwmStop();
  008E    2E42    JP	0x642
488:              		}
489:              		else
490:              		{
491:              				if(batADValue > 1550 || outADValue > (chrgMaxAD + 2))
  008F    3006    LDIA	0x6
  0090    0278    SUBA	0x78
  0091    300F    LDIA	0xF
  0092    1903    SZB	0x3,2
  0093    0277    SUBA	0x77
  0094    1803    SZB	0x3,0
  0095    28A5    JP	0xA5
  0096    083F    LD	A,0x3F
  0097    3E02    ADDIA	0x2
  0098    00F3    LD	0x73,A
  0099    3000    LDIA	0x0
  009A    1803    SZB	0x3,0
  009B    3001    LDIA	0x1
  009C    00F4    LD	0x74,A
  009D    082D    LD	A,0x2D
  009E    0274    SUBA	0x74
  009F    1D03    SNZB	0x3,2
  00A0    28A3    JP	0xA3
  00A1    082C    LD	A,0x2C
  00A2    0273    SUBA	0x73
  00A3    1803    SZB	0x3,0
  00A4    28B4    JP	0xB4
492:              				{
493:              					if(++subTime > chrgWaitTime)
  00A5    0ABC    INCR	0x3C
  00A6    083C    LD	A,0x3C
  00A7    023B    SUBA	0x3B
  00A8    1803    SZB	0x3,0
  00A9    28B2    JP	0xB2
494:              					{
495:              						if(chrgMaxDuty > 1)
  00AA    3002    LDIA	0x2
  00AB    023A    SUBA	0x3A
  00AC    1C03    SNZB	0x3,0
  00AD    28AF    JP	0xAF
496:              						{
497:              							chrgMaxDuty--;
  00AE    03BA    DECR	0x3A
  00AF    3032    LDIA	0x32
498:              						}
499:              						subTime = 0;
  00B0    01BC    CLR	0x3C
500:              						chrgWaitTime = 50;
  00B1    00BB    LD	0x3B,A
501:              					}
502:              					addTime = 0;
  00B2    01BD    CLR	0x3D
503:              				}
  00B3    28D4    JP	0xD4
504:              				else if(batADValue < 1550 && outADValue < (chrgMaxAD - 4))
  00B4    3006    LDIA	0x6
  00B5    0278    SUBA	0x78
  00B6    300E    LDIA	0xE
  00B7    1903    SZB	0x3,2
  00B8    0277    SUBA	0x77
  00B9    1803    SZB	0x3,0
  00BA    28D4    JP	0xD4
  00BB    083F    LD	A,0x3F
  00BC    3EFC    ADDIA	0xFC
  00BD    00F3    LD	0x73,A
  00BE    30FF    LDIA	0xFF
  00BF    1803    SZB	0x3,0
  00C0    3000    LDIA	0x0
  00C1    00F4    LD	0x74,A
  00C2    022D    SUBA	0x2D
  00C3    1D03    SNZB	0x3,2
  00C4    28C7    JP	0xC7
  00C5    0873    LD	A,0x73
  00C6    022C    SUBA	0x2C
  00C7    1803    SZB	0x3,0
  00C8    28D4    JP	0xD4
505:              				{
506:              					if(++addTime > chrgWaitTime)
  00C9    0ABD    INCR	0x3D
  00CA    083D    LD	A,0x3D
  00CB    023B    SUBA	0x3B
  00CC    1803    SZB	0x3,0
  00CD    28D3    JP	0xD3
  00CE    304B    LDIA	0x4B
507:              					{
508:              						addTime = 0;
  00CF    01BD    CLR	0x3D
509:              						if(chrgMaxDuty < 75)
  00D0    023A    SUBA	0x3A
  00D1    1C03    SNZB	0x3,0
510:              						{
511:              							chrgMaxDuty++;
  00D2    0ABA    INCR	0x3A
512:              						}
513:              					}
514:              					subTime = 0;
  00D3    01BC    CLR	0x3C
515:              				}
516:              				
517:              	
518:              				if(chrgPwmFlag == 0)
  00D4    0835    LD	A,0x35
  00D5    1D03    SNZB	0x3,2
  00D6    28D8    JP	0xD8
519:              				{
520:              					chrgPwmInit();
  00D7    25EE    CALL	0x5EE
521:              				}
522:              				PWMD23H = 0X00;
  00D8    1683    SETB	0x3,5
  00D9    019E    CLR	0x1E
523:              				PWMD2L = chrgMaxDuty;
  00DA    1283    CLRB	0x3,5
  00DB    083A    LD	A,0x3A
  00DC    1683    SETB	0x3,5
  00DD    009B    LD	0x1B,A
  00DE    0008    RET
  00DF    3014    LDIA	0x14
524:              		}
525:              	}
526:              	else
527:              	{
528:              		startChrgTime = 0;
529:              		chrgFlag = 0;
  00E0    1283    CLRB	0x3,5
  00E1    01D1    CLR	0x51
530:              		chrgFullFlag = 0;
  00E2    01D0    CLR	0x50
531:              		protectFlag = 0;
  00E3    01CD    CLR	0x4D
532:              		chrgMode = 0;
  00E4    01C0    CLR	0x40
533:              		chrgMaxAD = 0;
  00E5    01BF    CLR	0x3F
534:              		chrgMaxDuty = 0;
  00E6    01BA    CLR	0x3A
535:              		lockCount = 0;
536:              		lockLedStep = 0;
  00E7    01BE    CLR	0x3E
537:              		chrgWaitTime = 20;
  00E8    00BB    LD	0x3B,A
538:              		chrgPwmStop();
  00E9    2642    CALL	0x642
539:              		if(prePwStep > 0 && prePwStep > pwStep)
  00EA    0879    LD	A,0x79
  00EB    1903    SZB	0x3,2
  00EC    28FA    JP	0xFA
  00ED    0879    LD	A,0x79
  00EE    0243    SUBA	0x43
  00EF    1803    SZB	0x3,0
  00F0    28FA    JP	0xFA
540:              		{
541:              			if(++count50s > 3000)
  00F1    20FD    CALL	0xFD
  00F2    1903    SZB	0x3,2
  00F3    022A    SUBA	0x2A
  00F4    1C03    SNZB	0x3,0
  00F5    0008    RET
542:              			{
543:              				count50s = 0;
  00F6    01AA    CLR	0x2A
  00F7    01AB    CLR	0x2B
544:              				prePwStep--;
  00F8    03F9    DECR	0x79
  00F9    0008    RET
545:              			}
546:              		}
547:              		else
548:              		{
549:              			count50s = 0;
  00FA    01AA    CLR	0x2A
  00FB    01AB    CLR	0x2B
  00FC    0008    RET
550:              		}
551:              	}
552:              }
553:              
554:              
555:              
556:              char keyRead(char keyStatus)	
  054E    00F3    LD	0x73,A
557:              { 
558:              	if(keyStatus)
  054F    0873    LD	A,0x73
  0550    3064    LDIA	0x64
  0551    1903    SZB	0x3,2
  0552    2D60    JP	0x560
559:              	{
560:              		keyCount++;
  0553    0ACA    INCR	0x4A
561:              		if(keyCount >= 100)
  0554    024A    SUBA	0x4A
  0555    1C03    SNZB	0x3,0
  0556    3400    RET	0x0
562:              		{
563:              			keyCount = 100;
  0557    3064    LDIA	0x64
  0558    00CA    LD	0x4A,A
564:              			if(!longPressFlag)
  0559    0849    LD	A,0x49
  055A    1D03    SNZB	0x3,2
  055B    3400    RET	0x0
  055C    3002    LDIA	0x2
565:              			{
566:              				longPressFlag = 1;
  055D    01C9    CLR	0x49
  055E    0AC9    INCR	0x49
567:              				return 2;
  055F    0008    RET
568:              			}
569:              		}
570:              	}
571:              	else
572:              	{
573:              		if(keyCount >= 100)
  0560    024A    SUBA	0x4A
  0561    1C03    SNZB	0x3,0
  0562    2D66    JP	0x566
574:              		{
575:              			keyCount = 0;
  0563    01CA    CLR	0x4A
576:              			longPressFlag = 0;
  0564    01C9    CLR	0x49
577:              			return	0;
  0565    3400    RET	0x0
578:              		}
579:              		else if(keyCount >= 6)
  0566    3006    LDIA	0x6
  0567    024A    SUBA	0x4A
580:              		{
581:              			keyCount = 0;
  0568    01CA    CLR	0x4A
  0569    1803    SZB	0x3,0
582:              			return	1;
  056A    3401    RET	0x1
  056B    3400    RET	0x0
583:              		}
584:              		keyCount = 0;
585:              	}
586:              	return 0;
587:              }
588:              
589:              
590:              char keyRead2(char keyStatus)	
591:              { 
592:              	if(keyStatus)
593:              	{
594:              		keyCount2++;
595:              		if(keyCount2 >= 100)
596:              		{
597:              			keyCount2 = 100;
598:              			if(!longPressFlag2)
599:              			{
600:              				longPressFlag2 = 1;
601:              				return 2;
602:              			}
603:              		}
604:              	}
605:              	else
606:              	{
607:              		if(keyCount2 >= 100)
608:              		{
609:              			keyCount2 = 0;
610:              			longPressFlag2 = 0;
611:              			return	0;
612:              		}
613:              		else if(keyCount2 >= 5)
614:              		{
615:              			keyCount2 = 0;
616:              			return	1;
617:              		}
618:              		keyCount2 = 0;
619:              	}
620:              	return 0;
621:              }
622:              
623:              
624:              void keyCtr()
625:              {
626:              	char kclick = keyRead(0x04 & (~PORTB));
  0523    0906    COMA	0x6
  0524    3904    ANDIA	0x4
  0525    254E    CALL	0x54E
  0526    00F4    LD	0x74,A
627:              	if(kclick == 1)
  0527    0B74    SZDECA	0x74
  0528    2D3D    JP	0x53D
628:              	{
629:              		if(workStep > 0)
  0529    087A    LD	A,0x7A
  052A    1903    SZB	0x3,2
  052B    2D34    JP	0x534
630:              		{
631:              			if(++workStep > 32)
  052C    3021    LDIA	0x21
  052D    0AFA    INCR	0x7A
  052E    027A    SUBA	0x7A
  052F    1C03    SNZB	0x3,0
  0530    0008    RET
632:              			{
633:              				workStep = 1;
  0531    01FA    CLR	0x7A
  0532    0AFA    INCR	0x7A
  0533    0008    RET
634:              			}
635:              		}
636:              		else if(showBatTime > 0)
  0534    0841    LD	A,0x41
  0535    1903    SZB	0x3,2
  0536    2D39    JP	0x539
637:              		{
638:              			showBatTime = 0;
  0537    01C1    CLR	0x41
639:              		}
  0538    0008    RET
640:              		else
641:              		{
642:              			showBatTime = 200;
  0539    30C8    LDIA	0xC8
  053A    00C1    LD	0x41,A
643:              			count1s = 0;
  053B    01D3    CLR	0x53
  053C    0008    RET
644:              		}
645:              	}
646:              	else if(kclick == 2)
  053D    3002    LDIA	0x2
  053E    0674    XORA	0x74
  053F    1D03    SNZB	0x3,2
  0540    0008    RET
647:              	{
648:              		if(workStep > 0)
  0541    087A    LD	A,0x7A
  0542    1903    SZB	0x3,2
  0543    2D46    JP	0x546
649:              		{
650:              			workStep = 0;
  0544    01FA    CLR	0x7A
651:              		}
  0545    0008    RET
  0546    301E    LDIA	0x1E
652:              		else
653:              		{
654:              			workStep = 1;
  0547    01FA    CLR	0x7A
  0548    0AFA    INCR	0x7A
655:              			startTime = 30;
  0549    00C5    LD	0x45,A
656:              			showBatTime = 0;
  054A    01C1    CLR	0x41
657:              			overWorkTime = 0;
  054B    01A4    CLR	0x24
  054C    01A5    CLR	0x25
  054D    0008    RET
658:              		}
659:              	}
660:              }
661:              
662:              void workCtr()
663:              {
664:              
665:              	if(startTime > 0)
  04E9    0845    LD	A,0x45
  04EA    1D03    SNZB	0x3,2
666:              	{
667:              		startTime--;
  04EB    03C5    DECR	0x45
668:              	}
669:              	if(workStep > 0)
  04EC    087A    LD	A,0x7A
  04ED    1903    SZB	0x3,2
  04EE    2D1F    JP	0x51F
670:              	{
671:              		if(motorPwmFlag == 0)
  04EF    0834    LD	A,0x34
  04F0    1D03    SNZB	0x3,2
  04F1    2CF3    JP	0x4F3
672:              		{
673:              			pwmInit();
  04F2    261E    CALL	0x61E
674:              			
675:              		}
676:              		maxDuty = 99 + workStep;
  04F3    087A    LD	A,0x7A
  04F4    3E63    ADDIA	0x63
  04F5    00C8    LD	0x48,A
677:              		if(overCount >= 5)
  04F6    3005    LDIA	0x5
  04F7    0247    SUBA	0x47
  04F8    1C03    SNZB	0x3,0
  04F9    2D0D    JP	0x50D
678:              		{
679:              			if(++count5s > 300)
  04FA    0AA6    INCR	0x26
  04FB    1903    SZB	0x3,2
  04FC    0AA7    INCR	0x27
  04FD    3001    LDIA	0x1
  04FE    0227    SUBA	0x27
  04FF    302D    LDIA	0x2D
  0500    1903    SZB	0x3,2
  0501    0226    SUBA	0x26
  0502    1C03    SNZB	0x3,0
  0503    2D0F    JP	0x50F
  0504    30E8    LDIA	0xE8
680:              			{
681:              				count5s = 0;
  0505    01A6    CLR	0x26
  0506    01A7    CLR	0x27
682:              				overWorkTime = 1000;
683:              				preWorkStep = workStep;
684:                  			prejrStep = jrStep;
  0507    00A4    LD	0x24,A
  0508    3003    LDIA	0x3
  0509    00A5    LD	0x25,A
685:              				workStep = 0;
  050A    01FA    CLR	0x7A
686:              				jrStep = 0;
  050B    01B6    CLR	0x36
  050C    2D0F    JP	0x50F
687:              			}
688:              		}
689:              		else
690:              		{
691:              			count5s = 0;
  050D    01A6    CLR	0x26
  050E    01A7    CLR	0x27
692:              		}
693:              		if(count1s == 0 && ++count900s >= 900)
  050F    0853    LD	A,0x53
  0510    1D03    SNZB	0x3,2
  0511    0008    RET
  0512    0AA0    INCR	0x20
  0513    1903    SZB	0x3,2
  0514    0AA1    INCR	0x21
  0515    3003    LDIA	0x3
  0516    0221    SUBA	0x21
  0517    3084    LDIA	0x84
  0518    1903    SZB	0x3,2
  0519    0220    SUBA	0x20
  051A    1C03    SNZB	0x3,0
  051B    0008    RET
694:              		{
695:              			workStep = 0;
  051C    01FA    CLR	0x7A
696:              			jrStep = 0;
  051D    01B6    CLR	0x36
  051E    0008    RET
697:              		}
698:              	}
699:              	else
700:              	{
701:              		pwmStop();
  051F    263B    CALL	0x63B
702:              		count900s = 0;
  0520    01A0    CLR	0x20
  0521    01A1    CLR	0x21
  0522    0008    RET
703:              	}
704:              	
705:              }
706:              
707:              void checkOutA()
708:              {
709:              	test_adc = ADC_Sample(0, 5);		//测试AN0口的AD值，参考电压2V
  02A9    3005    LDIA	0x5
  02AA    00F3    LD	0x73,A
  02AB    3000    LDIA	0x0
  02AC    2103    CALL	0x103
  02AD    00D5    LD	0x55,A
710:              	if (0xA5 == test_adc)				//测试完成，如因其他原因导致AD转换没有完成，则不处理
  02AE    30A5    LDIA	0xA5
  02AF    0655    XORA	0x55
  02B0    1D03    SNZB	0x3,2
  02B1    2B57    JP	0x357
711:              	{
712:              		if(chrgFlag && adresult > 210)
  02B2    0851    LD	A,0x51
  02B3    1903    SZB	0x3,2
  02B4    2AC5    JP	0x2C5
  02B5    3000    LDIA	0x0
  02B6    0233    SUBA	0x33
  02B7    30D3    LDIA	0xD3
  02B8    1903    SZB	0x3,2
  02B9    0232    SUBA	0x32
  02BA    1C03    SNZB	0x3,0
  02BB    2AC5    JP	0x2C5
713:              		{
714:              			if(++overChrgTime > 10)
  02BC    300B    LDIA	0xB
  02BD    0AC4    INCR	0x44
  02BE    0244    SUBA	0x44
  02BF    1C03    SNZB	0x3,0
  02C0    2AC6    JP	0x2C6
  02C1    3002    LDIA	0x2
715:              			{
716:              				overChrgTime = 0;
  02C2    01C4    CLR	0x44
717:              				protectFlag = 2;
  02C3    00CD    LD	0x4D,A
  02C4    2AC6    JP	0x2C6
718:              			}
719:              			
720:              		}
721:              		else
722:              		{
723:              			overChrgTime = 0;
  02C5    01C4    CLR	0x44
724:              		}
725:              		outADValue = adresult;
  02C6    0833    LD	A,0x33
  02C7    00AD    LD	0x2D,A
  02C8    0832    LD	A,0x32
  02C9    00AC    LD	0x2C,A
726:              		//电机坏了过载保护
727:                      if(workStep && (outADValue > 600))
  02CA    087A    LD	A,0x7A
  02CB    1903    SZB	0x3,2
  02CC    2ADC    JP	0x2DC
  02CD    3002    LDIA	0x2
  02CE    022D    SUBA	0x2D
  02CF    3059    LDIA	0x59
  02D0    1903    SZB	0x3,2
  02D1    022C    SUBA	0x2C
  02D2    1C03    SNZB	0x3,0
  02D3    2ADC    JP	0x2DC
728:                      {
729:                      	if(++workOverOutTime > 50)
  02D4    3033    LDIA	0x33
  02D5    0ACC    INCR	0x4C
  02D6    024C    SUBA	0x4C
  02D7    1C03    SNZB	0x3,0
  02D8    2ADD    JP	0x2DD
730:                      	{
731:                      		workOverOutTime = 0;
  02D9    01CC    CLR	0x4C
732:                      		workStep = 0;
  02DA    01FA    CLR	0x7A
  02DB    2ADD    JP	0x2DD
733:                      	}
734:                      }
735:              		else
736:              		{
737:              			workOverOutTime = 0;
  02DC    01CC    CLR	0x4C
738:              		}
739:              		u8t maxtempV = 130 + (workStep * 10);
  02DD    300A    LDIA	0xA
  02DE    00F3    LD	0x73,A
  02DF    087A    LD	A,0x7A
  02E0    2610    CALL	0x610
  02E1    3E82    ADDIA	0x82
  02E2    00E9    LD	0x69,A
740:              		if(jrStep > 0)
  02E3    0836    LD	A,0x36
  02E4    1903    SZB	0x3,2
  02E5    2AEE    JP	0x2EE
741:              		{
742:              			maxtempV = maxtempV - 40;
  02E6    30D8    LDIA	0xD8
  02E7    07E9    ADDR	0x69
743:              			if(workStep < 5)
  02E8    3005    LDIA	0x5
  02E9    027A    SUBA	0x7A
  02EA    1803    SZB	0x3,0
  02EB    2AEE    JP	0x2EE
744:                      	{
745:                      		maxtempV = maxtempV - 30;
  02EC    30E2    LDIA	0xE2
  02ED    07E9    ADDR	0x69
746:                      	}
747:              		}
748:              		if(outADValue > maxtempV)
  02EE    0869    LD	A,0x69
  02EF    00E7    LD	0x67,A
  02F0    01E8    CLR	0x68
  02F1    082D    LD	A,0x2D
  02F2    0268    SUBA	0x68
  02F3    1D03    SNZB	0x3,2
  02F4    2AF7    JP	0x2F7
  02F5    082C    LD	A,0x2C
  02F6    0267    SUBA	0x67
  02F7    1803    SZB	0x3,0
  02F8    2B01    JP	0x301
749:                      {
750:                      	if(++overCount > 5)
  02F9    3006    LDIA	0x6
  02FA    0AC7    INCR	0x47
  02FB    0247    SUBA	0x47
  02FC    1C03    SNZB	0x3,0
  02FD    2B50    JP	0x350
751:                      	{
752:                      		overCount = 5;
  02FE    3005    LDIA	0x5
  02FF    00C7    LD	0x47,A
  0300    2B50    JP	0x350
753:                      	}
754:                      }
755:                      else
756:                      {
757:                      	
758:                      	if(overCount > 0)
  0301    0847    LD	A,0x47
  0302    1903    SZB	0x3,2
  0303    2B05    JP	0x305
759:                      	{
760:                      		overCount--;
  0304    03C7    DECR	0x47
761:                      	}
762:              			u8t maxAout = 20;
  0305    3014    LDIA	0x14
  0306    00EA    LD	0x6A,A
763:                      	if(pwStep > 3)
  0307    3004    LDIA	0x4
  0308    0243    SUBA	0x43
  0309    1C03    SNZB	0x3,0
  030A    2B0D    JP	0x30D
764:                      		maxAout = 22;
  030B    3016    LDIA	0x16
  030C    00EA    LD	0x6A,A
765:                      	if(workStep < 5)
  030D    3005    LDIA	0x5
  030E    027A    SUBA	0x7A
  030F    1803    SZB	0x3,0
  0310    2B13    JP	0x313
766:                  		{
767:                  			maxAout = maxAout - 1;
  0311    30FF    LDIA	0xFF
  0312    2B3C    JP	0x33C
768:                  		}
769:                  		else if(workStep < 9)
  0313    3009    LDIA	0x9
  0314    027A    SUBA	0x7A
  0315    1803    SZB	0x3,0
  0316    2B19    JP	0x319
770:                  		{
771:                  			maxAout = maxAout + 3;
  0317    3003    LDIA	0x3
  0318    2B3C    JP	0x33C
772:                  		}
773:                  		else if(workStep < 13)
  0319    300D    LDIA	0xD
  031A    027A    SUBA	0x7A
  031B    1803    SZB	0x3,0
  031C    2B1F    JP	0x31F
774:                  		{
775:                  			maxAout = maxAout + 6;
  031D    3006    LDIA	0x6
  031E    2B3C    JP	0x33C
776:                  		}
777:                  		else if(workStep < 17)
  031F    3011    LDIA	0x11
  0320    027A    SUBA	0x7A
  0321    1803    SZB	0x3,0
  0322    2B25    JP	0x325
778:                  		{
779:                  			maxAout = maxAout + 8;
  0323    3008    LDIA	0x8
  0324    2B3C    JP	0x33C
780:                  		}
781:                  		else if(workStep < 21)
  0325    3015    LDIA	0x15
  0326    027A    SUBA	0x7A
  0327    1803    SZB	0x3,0
  0328    2B2B    JP	0x32B
782:                  		{
783:                  			maxAout = maxAout + 9;
  0329    3009    LDIA	0x9
  032A    2B3C    JP	0x33C
784:                  		}
785:                  		else if(workStep < 25)
  032B    3019    LDIA	0x19
  032C    027A    SUBA	0x7A
  032D    1803    SZB	0x3,0
  032E    2B31    JP	0x331
786:                  		{
787:                  			maxAout = maxAout + 10;
  032F    300A    LDIA	0xA
  0330    2B3C    JP	0x33C
788:                  		}
789:                  		else if(workStep < 29)
  0331    301D    LDIA	0x1D
  0332    027A    SUBA	0x7A
  0333    1803    SZB	0x3,0
  0334    2B37    JP	0x337
790:                  		{
791:                  			maxAout = maxAout + 11;
  0335    300B    LDIA	0xB
  0336    2B3C    JP	0x33C
792:                  		}
793:                  		else if(workStep < 33)
  0337    3021    LDIA	0x21
  0338    027A    SUBA	0x7A
  0339    1803    SZB	0x3,0
  033A    2B3D    JP	0x33D
794:                  		{
795:                  			maxAout = maxAout + 12;
  033B    300C    LDIA	0xC
  033C    07EA    ADDR	0x6A
796:                  		}
797:              			if(outADValue > maxAout)
  033D    086A    LD	A,0x6A
  033E    00E7    LD	0x67,A
  033F    01E8    CLR	0x68
  0340    082D    LD	A,0x2D
  0341    0268    SUBA	0x68
  0342    1D03    SNZB	0x3,2
  0343    2B46    JP	0x346
  0344    082C    LD	A,0x2C
  0345    0267    SUBA	0x67
  0346    1803    SZB	0x3,0
  0347    2B4E    JP	0x34E
798:                      	{
799:              				if(startTime == 0)
  0348    0845    LD	A,0x45
  0349    1D03    SNZB	0x3,2
  034A    2B4E    JP	0x34E
800:              				{
801:              					tempDuty = 167 + workStep;
  034B    087A    LD	A,0x7A
  034C    3EA7    ADDIA	0xA7
  034D    2B4F    JP	0x34F
802:              				}
803:              				else
804:              				{
805:              					tempDuty = maxDuty;
  034E    0848    LD	A,0x48
  034F    00C6    LD	0x46,A
806:              				}
807:                      	}
808:                      	else 
809:                      	{
810:                      		tempDuty = maxDuty;
811:                      	}
812:                 
813:                      }
814:              		PWMD23H = 0X00;
  0350    1683    SETB	0x3,5
  0351    019E    CLR	0x1E
815:              		PWMD3L = tempDuty;
  0352    1283    CLRB	0x3,5
  0353    0846    LD	A,0x46
  0354    1683    SETB	0x3,5
  0355    009C    LD	0x1C,A
816:              	}
  0356    0008    RET
817:              	else
818:              	{
819:              		ADCON0 = 0;						//如果转换没有完成，需初始化ADCON0,1
  0357    1683    SETB	0x3,5
  0358    0195    CLR	0x15
820:              		ADCON1 = 0;				
  0359    0196    CLR	0x16
821:              		__delay_us(100);				//延时100us(编译器内置函数)
  035A    3084    LDIA	0x84
  035B    1283    CLRB	0x3,5
  035C    00E7    LD	0x67,A
  035D    0BE7    SZDECR	0x67
  035E    2B5D    JP	0x35D
  035F    2B60    JP	0x360
  0360    0008    RET
822:              	}
823:              }
824:              
825:              void checkBatAD()
826:              {
827:              	test_adc = ADC_Sample(2, 5);		//测试AN2口的AD值，参考电压2V
  0361    3005    LDIA	0x5
  0362    00F3    LD	0x73,A
  0363    3002    LDIA	0x2
  0364    2103    CALL	0x103
  0365    00D5    LD	0x55,A
828:              	if (0xA5 == test_adc)				//测试完成，如因其他原因导致AD转换没有完成，则不处理
  0366    30A5    LDIA	0xA5
  0367    0655    XORA	0x55
  0368    1D03    SNZB	0x3,2
  0369    2BC2    JP	0x3C2
829:              	{
830:              		batADValue = adresult;
  036A    0833    LD	A,0x33
  036B    00F8    LD	0x78,A
  036C    0832    LD	A,0x32
  036D    00F7    LD	0x77,A
831:              		if(batADValue < 1117)
  036E    3004    LDIA	0x4
  036F    0278    SUBA	0x78
  0370    305D    LDIA	0x5D
  0371    1903    SZB	0x3,2
  0372    0277    SUBA	0x77
  0373    1803    SZB	0x3,0
  0374    2B88    JP	0x388
832:                      {
833:                      	pwStep = 0;
  0375    01C3    CLR	0x43
834:              			if(++count8s > 800)
  0376    0AA2    INCR	0x22
  0377    1903    SZB	0x3,2
  0378    0AA3    INCR	0x23
  0379    3003    LDIA	0x3
  037A    0223    SUBA	0x23
  037B    3021    LDIA	0x21
  037C    1903    SZB	0x3,2
  037D    0222    SUBA	0x22
  037E    1C03    SNZB	0x3,0
  037F    2BB5    JP	0x3B5
835:              			{
836:              				count8s = 0;
  0380    01A2    CLR	0x22
  0381    01A3    CLR	0x23
837:              				lowBatFlag = 1;
  0382    01B8    CLR	0x38
  0383    0AB8    INCR	0x38
838:              				prePwStep = 0;
  0384    01F9    CLR	0x79
839:              				workStep = 0;
  0385    01FA    CLR	0x7A
840:              				jrStep = 0;
  0386    01B6    CLR	0x36
  0387    2BB5    JP	0x3B5
  0388    3005    LDIA	0x5
841:              			}
842:                      }
843:                      else
844:                      {
845:              	        count8s = 0;
  0389    01A2    CLR	0x22
  038A    01A3    CLR	0x23
846:              			if(batADValue >= 1340)
  038B    0278    SUBA	0x78
  038C    303C    LDIA	0x3C
  038D    1903    SZB	0x3,2
  038E    0277    SUBA	0x77
847:              	    	{
848:              	    		pwStep = ((batADValue - 1340) /2) + 13;
  038F    0877    LD	A,0x77
  0390    1C03    SNZB	0x3,0
  0391    2B9F    JP	0x39F
  0392    3EC4    ADDIA	0xC4
  0393    00F4    LD	0x74,A
  0394    0878    LD	A,0x78
  0395    1803    SZB	0x3,0
  0396    3E01    ADDIA	0x1
  0397    3EFA    ADDIA	0xFA
  0398    00F5    LD	0x75,A
  0399    1003    CLRB	0x3,0
  039A    0CF5    RRCR	0x75
  039B    0CF4    RRCR	0x74
  039C    0874    LD	A,0x74
  039D    3E0D    ADDIA	0xD
  039E    2BAE    JP	0x3AE
849:              	    	}
  039F    3EA3    ADDIA	0xA3
  03A0    00F4    LD	0x74,A
  03A1    0878    LD	A,0x78
  03A2    1803    SZB	0x3,0
  03A3    3E01    ADDIA	0x1
  03A4    3EFB    ADDIA	0xFB
  03A5    00F5    LD	0x75,A
  03A6    3004    LDIA	0x4
  03A7    1003    CLRB	0x3,0
  03A8    0CF5    RRCR	0x75
  03A9    0CF4    RRCR	0x74
  03AA    3EFF    ADDIA	0xFF
  03AB    1D03    SNZB	0x3,2
  03AC    2BA7    JP	0x3A7
  03AD    0874    LD	A,0x74
  03AE    00C3    LD	0x43,A
850:              	    	else
851:              	    	{
852:              	    		pwStep = (batADValue - 1117) / 16;
853:              	    	}
854:              	    	if(pwStep > 99)
  03AF    3064    LDIA	0x64
  03B0    0243    SUBA	0x43
  03B1    1C03    SNZB	0x3,0
  03B2    2BB5    JP	0x3B5
855:              	    	{
856:              	    		pwStep = 99;
  03B3    3063    LDIA	0x63
  03B4    00C3    LD	0x43,A
857:              	    	}
858:                  	}
859:              		if(chrgFlag && batADValue > 1861)
  03B5    0851    LD	A,0x51
  03B6    1903    SZB	0x3,2
  03B7    2BC9    JP	0x3C9
  03B8    3007    LDIA	0x7
  03B9    0278    SUBA	0x78
  03BA    3046    LDIA	0x46
  03BB    1903    SZB	0x3,2
  03BC    0277    SUBA	0x77
  03BD    1C03    SNZB	0x3,0
  03BE    2BC9    JP	0x3C9
860:                      {
861:              	        protectFlag = 1;
  03BF    01CD    CLR	0x4D
  03C0    0ACD    INCR	0x4D
  03C1    2BC9    JP	0x3C9
862:                      }
863:              	}
864:              	else
865:              	{
866:              		ADCON0 = 0;						//如果转换没有完成，需初始化ADCON0,1
  03C2    1683    SETB	0x3,5
  03C3    0195    CLR	0x15
867:              		ADCON1 = 0;				
  03C4    0196    CLR	0x16
868:              		__delay_us(100);				//延时100us(编译器内置函数)
  03C5    3085    LDIA	0x85
  03C6    00F4    LD	0x74,A
  03C7    0BF4    SZDECR	0x74
  03C8    2BC7    JP	0x3C7
869:              	}
870:              
871:              	test_adc = ADC_Sample(3, 5);		//测试AN2口的AD值，参考电压2V
  03C9    3005    LDIA	0x5
  03CA    00F3    LD	0x73,A
  03CB    3003    LDIA	0x3
  03CC    2103    CALL	0x103
  03CD    00D5    LD	0x55,A
872:              	if (0xA5 == test_adc)				//测试完成，如因其他原因导致AD转换没有完成，则不处理
  03CE    30A5    LDIA	0xA5
  03CF    0655    XORA	0x55
  03D0    1D03    SNZB	0x3,2
  03D1    2BFD    JP	0x3FD
873:              	{
874:              		if(chrgFlag && adresult > 100)
  03D2    0851    LD	A,0x51
  03D3    1903    SZB	0x3,2
  03D4    0008    RET
  03D5    3000    LDIA	0x0
  03D6    0233    SUBA	0x33
  03D7    3065    LDIA	0x65
  03D8    1903    SZB	0x3,2
  03D9    0232    SUBA	0x32
  03DA    1C03    SNZB	0x3,0
  03DB    0008    RET
875:              	    {
876:              	    	//有电池
877:              	    	if(adresult > 810 || (batADValue - adresult) > 810)
  03DC    3003    LDIA	0x3
  03DD    0233    SUBA	0x33
  03DE    302B    LDIA	0x2B
  03DF    1903    SZB	0x3,2
  03E0    0232    SUBA	0x32
  03E1    1803    SZB	0x3,0
  03E2    2BF2    JP	0x3F2
  03E3    0832    LD	A,0x32
  03E4    0277    SUBA	0x77
  03E5    00F4    LD	0x74,A
  03E6    0833    LD	A,0x33
  03E7    1C03    SNZB	0x3,0
  03E8    0A33    INCA	0x33
  03E9    0278    SUBA	0x78
  03EA    00F5    LD	0x75,A
  03EB    3003    LDIA	0x3
  03EC    0275    SUBA	0x75
  03ED    302B    LDIA	0x2B
  03EE    1903    SZB	0x3,2
  03EF    0274    SUBA	0x74
  03F0    1C03    SNZB	0x3,0
  03F1    2BFB    JP	0x3FB
878:              	    	{
879:              	    		//有一节电池已经满了
880:              	    		if(++countHalfFull > 250)
  03F2    30FB    LDIA	0xFB
  03F3    0ACE    INCR	0x4E
  03F4    024E    SUBA	0x4E
  03F5    1C03    SNZB	0x3,0
  03F6    0008    RET
  03F7    3002    LDIA	0x2
881:              	    		{
882:              	    			countHalfFull = 0;
  03F8    01CE    CLR	0x4E
883:              					protectFlag = 2;
  03F9    00CD    LD	0x4D,A
  03FA    0008    RET
884:              	    		}
885:              	    	}
886:              	    	else
887:              	    	{
888:              	    		countHalfFull = 0;
  03FB    01CE    CLR	0x4E
889:              	    	}
890:              	    }
891:              	}
  03FC    0008    RET
892:              	else
893:              	{
894:              		ADCON0 = 0;						//如果转换没有完成，需初始化ADCON0,1
  03FD    1683    SETB	0x3,5
  03FE    0195    CLR	0x15
895:              		ADCON1 = 0;				
  03FF    0196    CLR	0x16
896:              		__delay_us(100);				//延时100us(编译器内置函数)
  0400    3085    LDIA	0x85
  0401    00F4    LD	0x74,A
  0402    0BF4    SZDECR	0x74
  0403    2C02    JP	0x402
  0404    0008    RET
897:              	}
898:              	
899:              }
900:              
901:              
902:              
903:              /**********************************************************
904:              函数名称：Init_System
905:              函数功能：系统初始化
906:              入口参数：无
907:              出口参数：无
908:              备    注：
909:              **********************************************************/
910:              void Init_System() 
  05C0    0000    NOP
  05C1    0064    CLRWDT
911:              {
912:              	asm("nop");
913:              	asm("clrwdt");
914:              	OPTION_REG = 0;					//预分频给TMR0 ，Timer0使用内部时钟Focs/4，预分频比为1:2
  05C2    1283    CLRB	0x3,5
  05C3    0181    CLR	0x1
  05C4    0064    CLRWDT
915:              	asm("clrwdt");
916:              	OSCCON = 0X72;					//内部振荡器8M
  05C5    3072    LDIA	0x72
  05C6    1283    CLRB	0x3,5
  05C7    0094    LD	0x14,A
917:              
918:              	WPUA = 0B00000000;				//配置上拉，1为使能上拉
  05C8    1683    SETB	0x3,5
  05C9    0188    CLR	0x8
919:              	WPDA = 0x00;					//RA1开下拉
  05CA    0187    CLR	0x7
920:              	WPUB = 0x04;
  05CB    3004    LDIA	0x4
  05CC    1283    CLRB	0x3,5
  05CD    0088    LD	0x8,A
921:              
922:              	TRISA = 0x0F;				//配置IO状态，0为输出，1为输入
  05CE    300F    LDIA	0xF
  05CF    1683    SETB	0x3,5
923:              	TRISB = 0x04;
924:              
925:              	PORTA = 0X00;
926:              	PORTB = 0X00;
  05D0    24E0    CALL	0x4E0
927:              
928:              //---------------------------------------
929:              //125us中断初始化
930:              	PR2 = 249;					//设定Timer初始值，定时周期是250*2/8M=62.5uS
  05D1    30F9    LDIA	0xF9
  05D2    0091    LD	0x11,A
931:              	TMR2IF = 0;
  05D3    108D    CLRB	0xD,1
932:              	TMR2IE = 1;					//使能Timer2溢出中断
  05D4    148E    SETB	0xE,1
933:              
934:              	T2CON = 0B00000100;			//开启Timer2,设置TMR2的分频比为1:1
  05D5    3004    LDIA	0x4
  05D6    0093    LD	0x13,A
935:              	INTCON = 0XC0;				//开启总中断
  05D7    30C0    LDIA	0xC0
  05D8    008B    LD	0xB,A
  05D9    0008    RET
936:              }
937:              
938:              /***********************************************************
939:              中断服务函数
940:              函数名称：AD_Init()
941:              函数功能：AD初始化处理函数
942:              入口参数：
943:              出口参数：
944:              备    注：第一次打开AD允许位ADON，需延时20uS以上才能进入AD采样
945:              			如后继程序不关闭ADON，则不需要延时
946:              ***********************************************************/
947:              void AD_Init() 
948:              {
949:              	/*********** ADCON0 ****************************
950:              		Bit7~Bit6  ADCS<1:0>:  AD转换时钟选择位。
951:              			00=  F HSI /16
952:              			01=  F HSI /32
953:              			10=  F HSI /64
954:              			11=  F HSI /128
955:              		Bit5~Bit2  CHS<3:0>:  模拟通道选择位。与ADCON1寄存器CHS4组合CHS<3:0>
956:              			CHS<4:0>: 
957:              			00000=  AN0
958:              			00001=  AN1
959:              			00010=  AN2
960:              			00011=  AN3
961:              			00100=  AN4
962:              			00101=  AN5
963:              			00110=  保留
964:              			00111=  保留
965:              			01000=  AN8
966:              			… 
967:              			01101=  AN13
968:              			01110=  AN14
969:              			01111=  AN15
970:              			11111=  1.2V（固定参考电压）
971:              			其他=  保留
972:              		Bit1  GO/DONE: AD转换状态位。
973:              			1=  AD转换正在进行。将该位置1启动AD转换。当AD转换完成以后，该位由硬件自动清零。
974:              				当GO/DONE位从1变0或ADIF从0变1时，需至少等待两个TAD时间，才能再次启动AD转换。
975:              			0=  AD转换完成/或不在进行中。
976:              		Bit0  ADON:  ADC使能位。
977:              			1=  使能ADC；
978:              			0=  禁止ADC，不消耗工作电流。
979:              	*********************************************/
980:              	ADCON0 = 0X41;		//ADON开启，AD采样时间选为FSYS/16
  0633    3041    LDIA	0x41
  0634    1683    SETB	0x3,5
  0635    0095    LD	0x15,A
981:              	
982:              	/*********** ADCON1 ****************************
983:              		Bit7  ADFM:  AD转换结果格式选择位；
984:              			1=  右对齐；
985:              			0=  左对齐。
986:              		Bit6  CHS4:  通道选择位
987:              		Bit5~Bit3  未用 
988:              		Bit2  LDO_EN:  内部参考电压使能位。
989:              			1=  使能ADC内部LDO参考电压；
990:              				当选择内部LDO作参考电压时，ADC最大有效精度为8位。
991:              			0=  VDD作为ADC参考电压。
992:              		Bit1~Bit0  LDO_SEL<1:0>:  参考电压选择位
993:              			0X=  2.0V
994:              			10=  2.4V
995:              			11=  3.0V
996:              	*********************************************/
997:              	ADCON1 = 0;
  0636    0196    CLR	0x16
998:              	ANSEL0 = 0X0D;
  0637    300D    LDIA	0xD
  0638    0093    LD	0x13,A
999:              	ANSEL1 = 0x00;	
  0639    0194    CLR	0x14
  063A    0008    RET
1000:             }
1001:             
1002:             
1003:             void chrgPwmInit()
1004:             {
1005:             		chrgPwmFlag = 1;
  05EE    01B5    CLR	0x35
  05EF    0AB5    INCR	0x35
1006:             		PWMCON1 = 0B00000000;	//PWM选择D组，死区2禁止，死区1使能，死区时钟源为Fosc/4
  05F0    0196    CLR	0x16
1007:             		
1008:             		PWMTH = 0X00;			//周期选择为0FF，则周期为（255+1）*1/8M，周期的时钟分频在PWMCON0选择
  05F1    0198    CLR	0x18
1009:             		PWMTL = 100;			//PWM 周期=[PWMT+1]*Tosc*(CLKDIV 分频值)
  05F2    3064    LDIA	0x64
  05F3    0097    LD	0x17,A
1010:             		
1011:             	
1012:             		
1013:             		PWMD23H = 0;			//配置PWM1,PWM2的占空比，该值不能超过周期，否者为100%输出
  05F4    1683    SETB	0x3,5
  05F5    019E    CLR	0x1E
1014:             		PWMD2L = 10;			//互补模式，PWM1的占空比与PWM0互补，和设置值无关
  05F6    300A    LDIA	0xA
  05F7    009B    LD	0x1B,A
1015:             		PWM23DT = 0X00;			//死区设为2uS，计算为（3+1）*1/8M*4
  05F8    019D    CLR	0x1D
1016:             		
1017:             		PWMCON0 = 0X04;			//打开PWM2 分频比为1
  05F9    3004    LDIA	0x4
1018:             		PWMCON2 =0X00;			//PWM4输出反向
  05FA    2DFB    JP	0x5FB
1019:             }
1020:             
1021:             void chrgPwmStop()
1022:             {
1023:             	if(chrgPwmFlag)
  0642    0835    LD	A,0x35
  0643    1903    SZB	0x3,2
  0644    0008    RET
1024:             	{
1025:             		chrgPwmFlag = 0;
  0645    01B5    CLR	0x35
1026:             		PWMCON0 &= 0xFB;	//关闭PWM2
  0646    1115    CLRB	0x15,2
1027:             		RB3 = 0;
  0647    1186    CLRB	0x6,3
  0648    0008    RET
1028:             	}
1029:             }
1030:             
1031:             void pwmInit()
1032:             {
1033:             		motorPwmFlag = 1;
  061E    01B4    CLR	0x34
  061F    0AB4    INCR	0x34
1034:             		PWMCON1 = 0B00000000;	//PWM选择A组，死区2禁止，死区1使能，死区时钟源为Fosc/4
  0620    0196    CLR	0x16
1035:             		PWMTH = 0X00;			//周期选择为0FF，则周期为（255+1）*1/8M，周期的时钟分频在PWMCON0选择
  0621    0198    CLR	0x18
1036:             		PWMTL = 200;			//PWM 周期=[PWMT+1]*Tosc*(CLKDIV 分频值)
  0622    30C8    LDIA	0xC8
  0623    0097    LD	0x17,A
1037:             		
1038:             		
1039:             		PWMD23H = 0;			//配置PWM1,PWM2的占空比，该值不能超过周期，否者为100%输出
  0624    1683    SETB	0x3,5
  0625    019E    CLR	0x1E
1040:             		PWMD3L = 80;			//互补模式，PWM1的占空比与PWM0互补，和设置值无关
  0626    3050    LDIA	0x50
  0627    009C    LD	0x1C,A
1041:             		PWM23DT = 0X00;			//死区设为2uS，计算为（3+1）*1/8M*4
  0628    019D    CLR	0x1D
1042:             
1043:             		PWMCON0 = 0X48;			//打开PWM1 分频比为8
  0629    3048    LDIA	0x48
1044:             		PWMCON2 =0X00;			//PWM4输出反向
  062A    2DFB    JP	0x5FB
1045:             }
1046:             
1047:             void pwmStop()
1048:             {
1049:             	if(motorPwmFlag)
  063B    0834    LD	A,0x34
  063C    1903    SZB	0x3,2
  063D    0008    RET
1050:             	{
1051:             		motorPwmFlag = 0;
  063E    01B4    CLR	0x34
1052:             		PWMCON0 &= 0XF7;
  063F    1195    CLRB	0x15,3
1053:             		RB4 = 0;
  0640    1206    CLRB	0x6,4
  0641    0008    RET
1054:             	}
1055:             }
1056:             
1057:             
1058:             /***********************************************
1059:             函数名称：Sleep_Mode
1060:             函数功能：进入休眠模式
1061:             入口参数：无
1062:             出口参数：无
1063:             备注：
1064:             ************************************************/
1065:             void Sleep_Mode()
1066:             {
1067:             	INTCON = 0;		
  04A7    018B    CLR	0xB
1068:             	
1069:             	OPTION_REG = 0;
  04A8    0181    CLR	0x1
1070:             
1071:             	WPUA  = 0B00000000;			//RA0 开上拉电阻
  04A9    1683    SETB	0x3,5
  04AA    0188    CLR	0x8
1072:             	TRISA = 0x0F;				//配置IO状态，0为输出，1为输入
  04AB    300F    LDIA	0xF
1073:             	TRISB = 0x04;
1074:             
1075:             	PORTA = 0X00;
1076:             	PORTB = 0X00;
  04AC    24E0    CALL	0x4E0
1077:             	WPUB  = 0x04;			//RB2 开上拉电阻
  04AD    0088    LD	0x8,A
1078:                			
1079:                	ADCON0 = 0;					//关闭所有模块
  04AE    1683    SETB	0x3,5
  04AF    0195    CLR	0x15
1080:             	ADCON1 = 0;
  04B0    0196    CLR	0x16
1081:             	
1082:             	PWMCON0 = 0;
  04B1    1283    CLRB	0x3,5
  04B2    0195    CLR	0x15
1083:             		
1084:             	OSCCON = 0X70;				//配置振荡为8M,关闭WDT，需注意芯片工程选项里WDT必须选为DISABLE,否则无法软件关掉WDT
  04B3    3070    LDIA	0x70
  04B4    0094    LD	0x14,A
1085:             	
1086:             	IOCA = 0x02;			//允许RA1的IO电平变化中断
  04B5    3002    LDIA	0x2
  04B6    1683    SETB	0x3,5
  04B7    0089    LD	0x9,A
1087:             	IOCB = 0x04;			//允许RB3的IO口电平变化中断
  04B8    3004    LDIA	0x4
  04B9    1283    CLRB	0x3,5
  04BA    0089    LD	0x9,A
1088:             	
1089:             	RAIE = 1;					//允许PORTA的IO电平变化中断
  04BB    158E    SETB	0xE,3
1090:             	PEIE = 1;					//要用RORTA中断唤醒，则PEIE必须设为1
  04BC    170B    SETB	0xB,6
1091:             	RBIE = 1;					//允许PORTB电平变化中断
  04BD    158B    SETB	0xB,3
1092:             	GIE = 0;					//唤醒后执行SLEEP后程序;
  04BE    138B    CLRB	0xB,7
1093:             	
1094:             	PIE1 &= 0X08;				//关闭不需要的中断
  04BF    3008    LDIA	0x8
  04C0    058E    ANDR	0xE
1095:             	PIR1 = 0;					//必须清不需要的中断标志位
  04C1    018D    CLR	0xD
1096:             	INTCON &= 0XC8;				//必须清不需要的中断标志位
  04C2    30C8    LDIA	0xC8
  04C3    058B    ANDR	0xB
1097:             
1098:             	PORTA;						//读PORTA值并锁存,用电平变化中断必须执行这一步
  04C4    1683    SETB	0x3,5
  04C5    0806    LD	A,0x6
1099:             	RAIF = 0;					//清PORTA中断标志位
  04C6    1283    CLRB	0x3,5
  04C7    118D    CLRB	0xD,3
1100:             	PORTB;						//读PORTB值并锁存	
  04C8    0806    LD	A,0x6
1101:             	RBIF = 0;					//清PORTB中断标志位		
  04C9    100B    CLRB	0xB,0
  04CA    0064    CLRWDT
  04CB    0063    STOP
  04CC    0000    NOP
  04CD    0064    CLRWDT
  04CE    0000    NOP
  04CF    0000    NOP
  04D0    0000    NOP
  04D1    0000    NOP
  04D2    0000    NOP
1102:             	asm("clrwdt");
1103:             
1104:             	asm("sleep");				//进入休眠模式
1105:             	
1106:             	asm("nop");
1107:             	asm("clrwdt");
1108:             	asm("nop");
1109:             	asm("nop");
1110:             	asm("nop");
1111:             	asm("nop");
1112:             	asm("nop");
1113:             	if(RAIF)  RAIF = 0;			//清中断标志
  04D3    1283    CLRB	0x3,5
  04D4    198D    SZB	0xD,3
  04D5    118D    CLRB	0xD,3
1114:             	if(RBIF)  RBIF = 0;			//清中断标志
  04D6    180B    SZB	0xB,0
  04D7    100B    CLRB	0xB,0
1115:             	if(TMR2IF) TMR2IF = 0;
  04D8    188D    SZB	0xD,1
  04D9    108D    CLRB	0xD,1
1116:             	IOCA = 0B00000000;			//允许RA1的IO电平变化中断
  04DA    1683    SETB	0x3,5
  04DB    0189    CLR	0x9
1117:             	IOCB = 0B00000000;			//允许RB3的IO口电平变化中断
  04DC    1283    CLRB	0x3,5
  04DD    0189    CLR	0x9
1118:             	Init_System();
  04DE    25C0    CALL	0x5C0
1119:             	AD_Init();
  04DF    2E33    JP	0x633
1120:             }
1121:             
1122:             
1123:             
1124:             /**********************************************************
1125:             函数名称：AD_Sample
1126:             函数功能：AD检测
1127:             入口参数：adch - 检测通道
1128:             出口参数：无
1129:             备    注：采样通道需自行设置为输入口
1130:             	      采样10次,取中间八次的平均值为采样结果存于adresult中
1131:             
1132:             	      adch 为输入AD通道 0-15，31
1133:                          31  检测内部1.2V
1134:             	
1135:              		  adldo =5,开启内部LDO 2V 作为ADC 参考
1136:              		  adldo =6,开启内部LDO 2.4V 作为ADC 参考
1137:             		  adldo =7,开启内部LDO 3V 作为ADC 参考
1138:              		  adldo =0,VDD 作为ADC 参考
1139:              		  AD转换结果左对齐
1140:              		  ADC参考电压从VDD切换到LDO时需要延时100us以上，才能进行AD转换
1141:             **********************************************************/
1142:             unsigned char ADC_Sample(unsigned char adch, unsigned char adldo) 
  0103    1283    CLRB	0x3,5
  0104    00DB    LD	0x5B,A
1143:             {
1144:             	volatile unsigned long adsum = 0;
1145:             	volatile unsigned int admin = 0, admax = 0;
  0105    21DE    CALL	0x1DE
1146:             	volatile unsigned int ad_temp = 0;
  0106    01E5    CLR	0x65
  0107    01E6    CLR	0x66
1147:             
1148:             	if ((!LDO_EN) && (adldo & 0x04) ) 
  0108    1683    SETB	0x3,5
  0109    1D16    SNZB	0x16,2
  010A    1D73    SNZB	0x73,2
  010B    2915    JP	0x115
1149:             	{
1150:             								//如果AD参考从VDD换到内部LDO，需要延时100US以上
1151:             		ADCON1 = adldo;			//左对齐,AD值取12位
  010C    0873    LD	A,0x73
  010D    0096    LD	0x16,A
1152:             		__delay_us(100);		//IDE内置延时函数，延时100us
  010E    3084    LDIA	0x84
  010F    1283    CLRB	0x3,5
  0110    00D6    LD	0x56,A
  0111    0BD6    SZDECR	0x56
  0112    2911    JP	0x111
  0113    2914    JP	0x114
1153:             	} 
  0114    2917    JP	0x117
1154:             	else
1155:             		ADCON1 = adldo;			//如果ADCON1.7(ADFM)=1为右对齐，,AD值取10位
  0115    0873    LD	A,0x73
  0116    0096    LD	0x16,A
1156:             
1157:             	if(adch & 0x10) 
  0117    1283    CLRB	0x3,5
  0118    1E5B    SNZB	0x5B,4
  0119    291F    JP	0x11F
1158:             	{
1159:             		CHS4 = 1;
  011A    1683    SETB	0x3,5
  011B    1716    SETB	0x16,6
1160:             		adch &= 0x0f;
  011C    300F    LDIA	0xF
  011D    1283    CLRB	0x3,5
  011E    05DB    ANDR	0x5B
1161:             	}
1162:             	unsigned char i = 0;
1163:             	for (i = 0; i < 10; i++) 
  011F    01DC    CLR	0x5C
1164:             	{
1165:             		ADCON0 = (unsigned char)(0X41 | (adch << 2));	//16分频，如果主频为16M，则必须选16分频或以上
  0120    085B    LD	A,0x5B
  0121    00D6    LD	0x56,A
  0122    3001    LDIA	0x1
  0123    1003    CLRB	0x3,0
  0124    0DD6    RLCR	0x56
  0125    3EFF    ADDIA	0xFF
  0126    1003    CLRB	0x3,0
  0127    1D03    SNZB	0x3,2
  0128    2924    JP	0x124
  0129    0D56    RLCA	0x56
  012A    3841    ORIA	0x41
  012B    1683    SETB	0x3,5
  012C    0095    LD	0x15,A
  012D    0000    NOP
  012E    0000    NOP
  012F    0000    NOP
  0130    0000    NOP
1166:             		asm("nop");
1167:             		asm("nop");
1168:             		asm("nop");
1169:             		asm("nop");				//选择通道后需延时1uS以上
1170:             		GODONE = 1;				//开始转换
  0131    1683    SETB	0x3,5
  0132    1495    SETB	0x15,1
1171:             
1172:             		unsigned char j = 0;
  0133    1283    CLRB	0x3,5
  0134    01DA    CLR	0x5A
1173:             		while (GODONE) 
  0135    1683    SETB	0x3,5
  0136    1C95    SNZB	0x15,1
  0137    2940    JP	0x140
1174:             		{
1175:             			__delay_us(2);		//延时2us(编译器内置函数)
  0138    2939    JP	0x139
  0139    293A    JP	0x13A
  013A    293B    JP	0x13B
  013B    293C    JP	0x13C
1176:             
1177:             			if (0 == (--j))		//延时0.5ms仍没有AD转换结束，跳出程序
  013C    1283    CLRB	0x3,5
  013D    0BDA    SZDECR	0x5A
  013E    2935    JP	0x135
1178:             			return 0;
  013F    3400    RET	0x0
1179:             		}
1180:             
1181:             		ad_temp = (unsigned int)((ADRESH << 4) + (ADRESL >> 4));	//计算12位AD值
  0140    0819    LD	A,0x19
  0141    1283    CLRB	0x3,5
  0142    00E5    LD	0x65,A
  0143    01E6    CLR	0x66
  0144    0EE5    SWAPR	0x65
  0145    0EE6    SWAPR	0x66
  0146    30F0    LDIA	0xF0
  0147    05E6    ANDR	0x66
  0148    0865    LD	A,0x65
  0149    390F    ANDIA	0xF
  014A    04E6    ORR	0x66
  014B    30F0    LDIA	0xF0
  014C    05E5    ANDR	0x65
  014D    1683    SETB	0x3,5
  014E    0E18    SWAPA	0x18
  014F    390F    ANDIA	0xF
  0150    1283    CLRB	0x3,5
  0151    07E5    ADDR	0x65
  0152    1803    SZB	0x3,0
  0153    0AE6    INCR	0x66
1182:             
1183:             		if (0 == admax) 
  0154    0863    LD	A,0x63
  0155    0464    ORA	0x64
  0156    1D03    SNZB	0x3,2
  0157    295A    JP	0x15A
1184:             		{
1185:             			admax = ad_temp;
  0158    21E7    CALL	0x1E7
  0159    296C    JP	0x16C
1186:             			admin = ad_temp;
1187:             		} 
1188:             		else if (ad_temp > admax)
  015A    0866    LD	A,0x66
  015B    0264    SUBA	0x64
  015C    1D03    SNZB	0x3,2
  015D    2960    JP	0x160
  015E    0865    LD	A,0x65
  015F    0263    SUBA	0x63
  0160    1803    SZB	0x3,0
  0161    2964    JP	0x164
1189:             			admax = ad_temp;				//AD采样最大值
  0162    21E7    CALL	0x1E7
  0163    2970    JP	0x170
1190:             		else if (ad_temp < admin)
  0164    0862    LD	A,0x62
  0165    0266    SUBA	0x66
  0166    1D03    SNZB	0x3,2
  0167    296A    JP	0x16A
  0168    0861    LD	A,0x61
  0169    0265    SUBA	0x65
  016A    1803    SZB	0x3,0
  016B    2970    JP	0x170
1191:             			admin = ad_temp;				//AD采样最小值
  016C    0866    LD	A,0x66
  016D    00E2    LD	0x62,A
  016E    0865    LD	A,0x65
  016F    00E1    LD	0x61,A
1192:             
1193:             		adsum += ad_temp;
  0170    0865    LD	A,0x65
  0171    00D6    LD	0x56,A
  0172    0866    LD	A,0x66
  0173    00D7    LD	0x57,A
  0174    01D8    CLR	0x58
  0175    01D9    CLR	0x59
  0176    0856    LD	A,0x56
  0177    07DD    ADDR	0x5D
  0178    0857    LD	A,0x57
  0179    1103    CLRB	0x3,2
  017A    1803    SZB	0x3,0
  017B    3E01    ADDIA	0x1
  017C    1D03    SNZB	0x3,2
  017D    07DE    ADDR	0x5E
  017E    0858    LD	A,0x58
  017F    1103    CLRB	0x3,2
  0180    1803    SZB	0x3,0
  0181    3E01    ADDIA	0x1
  0182    1D03    SNZB	0x3,2
  0183    07DF    ADDR	0x5F
  0184    0859    LD	A,0x59
  0185    1103    CLRB	0x3,2
  0186    1803    SZB	0x3,0
  0187    3E01    ADDIA	0x1
  0188    1D03    SNZB	0x3,2
  0189    07E0    ADDR	0x60
  018A    300A    LDIA	0xA
  018B    0ADC    INCR	0x5C
  018C    025C    SUBA	0x5C
  018D    1C03    SNZB	0x3,0
  018E    2920    JP	0x120
1194:             	}
1195:             		adsum -= admax;
  018F    0863    LD	A,0x63
  0190    00D6    LD	0x56,A
  0191    0864    LD	A,0x64
  0192    21CF    CALL	0x1CF
  0193    1C03    SNZB	0x3,0
  0194    0F59    SZINCA	0x59
  0195    02E0    SUBR	0x60
1196:             		if (adsum >= admin)
  0196    0861    LD	A,0x61
  0197    00D6    LD	0x56,A
  0198    0862    LD	A,0x62
  0199    00D7    LD	0x57,A
  019A    01D8    CLR	0x58
  019B    01D9    CLR	0x59
  019C    0859    LD	A,0x59
  019D    0260    SUBA	0x60
  019E    1D03    SNZB	0x3,2
  019F    29AA    JP	0x1AA
  01A0    0858    LD	A,0x58
  01A1    025F    SUBA	0x5F
  01A2    1D03    SNZB	0x3,2
  01A3    29AA    JP	0x1AA
  01A4    0857    LD	A,0x57
  01A5    025E    SUBA	0x5E
  01A6    1D03    SNZB	0x3,2
  01A7    29AA    JP	0x1AA
  01A8    0856    LD	A,0x56
  01A9    025D    SUBA	0x5D
  01AA    1C03    SNZB	0x3,0
  01AB    29B4    JP	0x1B4
1197:             			adsum -= admin;
  01AC    0861    LD	A,0x61
  01AD    00D6    LD	0x56,A
  01AE    0862    LD	A,0x62
  01AF    21CF    CALL	0x1CF
  01B0    1C03    SNZB	0x3,0
  01B1    0F59    SZINCA	0x59
  01B2    02E0    SUBR	0x60
  01B3    29B8    JP	0x1B8
1198:             		else
1199:             			adsum = 0;
  01B4    01DD    CLR	0x5D
  01B5    01DE    CLR	0x5E
  01B6    01DF    CLR	0x5F
  01B7    01E0    CLR	0x60
1200:             
1201:             		adresult = adsum >> 3;		//8次平均值作为最终结果
  01B8    085D    LD	A,0x5D
  01B9    00D6    LD	0x56,A
  01BA    085E    LD	A,0x5E
  01BB    00D7    LD	0x57,A
  01BC    085F    LD	A,0x5F
  01BD    00D8    LD	0x58,A
  01BE    0860    LD	A,0x60
  01BF    00D9    LD	0x59,A
  01C0    3003    LDIA	0x3
  01C1    1003    CLRB	0x3,0
  01C2    0CD9    RRCR	0x59
  01C3    0CD8    RRCR	0x58
  01C4    0CD7    RRCR	0x57
  01C5    0CD6    RRCR	0x56
  01C6    3EFF    ADDIA	0xFF
  01C7    1D03    SNZB	0x3,2
  01C8    29C1    JP	0x1C1
  01C9    0857    LD	A,0x57
  01CA    00B3    LD	0x33,A
  01CB    0856    LD	A,0x56
  01CC    00B2    LD	0x32,A
1202:             
1203:             		adsum = 0;
1204:             		admin = 0;
1205:             		admax = 0;
  01CD    21DE    CALL	0x1DE
1206:             		return 0xA5;
  01CE    34A5    RET	0xA5
1207:             		
1208:             }
1209:             
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\lbmod.c ----------------------------------------------------------------------
1:                // byte unsigned modulus
2:                
3:                unsigned char
4:                __lbmod(unsigned char dividend, unsigned char divisor)
  0589    00D6    LD	0x56,A
  058A    3008    LDIA	0x8
  058B    00D7    LD	0x57,A
  058C    01D8    CLR	0x58
  058D    0856    LD	A,0x56
  058E    00F4    LD	0x74,A
  058F    3007    LDIA	0x7
  0590    1003    CLRB	0x3,0
  0591    0CF4    RRCR	0x74
  0592    3EFF    ADDIA	0xFF
  0593    1003    CLRB	0x3,0
  0594    1D03    SNZB	0x3,2
  0595    2D91    JP	0x591
  0596    0D58    RLCA	0x58
  0597    0474    ORA	0x74
  0598    00D8    LD	0x58,A
  0599    1003    CLRB	0x3,0
  059A    0DD6    RLCR	0x56
  059B    0873    LD	A,0x73
  059C    0258    SUBA	0x58
  059D    1C03    SNZB	0x3,0
  059E    2DA1    JP	0x5A1
  059F    0873    LD	A,0x73
  05A0    02D8    SUBR	0x58
  05A1    0BD7    SZDECR	0x57
  05A2    2D8D    JP	0x58D
  05A3    0858    LD	A,0x58
  05A4    0008    RET
5:                {
6:                	unsigned char	rem;
7:                	unsigned char	counter;
8:                
9:                	counter = 8;
10:               	rem = 0;
11:               	do {
12:               		rem = (rem << 1) | (dividend >> 7);
13:               		dividend <<= 1;
14:               		if(divisor <= rem)
15:               			rem -= divisor;
16:               	} while(--counter != 0);
17:               	return rem;
18:               }
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\lbdiv.c ----------------------------------------------------------------------
1:                // byte unsigned division
2:                
3:                unsigned char
4:                __lbdiv(unsigned char dividend, unsigned char divisor)
  05A5    00F4    LD	0x74,A
  05A6    01F6    CLR	0x76
  05A7    0873    LD	A,0x73
  05A8    1903    SZB	0x3,2
  05A9    2DBE    JP	0x5BE
  05AA    01F5    CLR	0x75
  05AB    0AF5    INCR	0x75
  05AC    1BF3    SZB	0x73,7
  05AD    2DB1    JP	0x5B1
  05AE    1003    CLRB	0x3,0
  05AF    0DF3    RLCR	0x73
  05B0    2DAB    JP	0x5AB
  05B1    1003    CLRB	0x3,0
  05B2    0DF6    RLCR	0x76
  05B3    0873    LD	A,0x73
  05B4    0274    SUBA	0x74
  05B5    1C03    SNZB	0x3,0
  05B6    2DBB    JP	0x5BB
  05B7    0873    LD	A,0x73
  05B8    02F4    SUBR	0x74
  05B9    1476    SETB	0x76,0
  05BA    1003    CLRB	0x3,0
  05BB    0CF3    RRCR	0x73
  05BC    0BF5    SZDECR	0x75
  05BD    2DB1    JP	0x5B1
  05BE    0876    LD	A,0x76
  05BF    0008    RET
5:                {
6:                	unsigned char	quotient;
7:                	unsigned char	counter;
8:                
9:                	quotient = 0;
10:               	if(divisor != 0) {
11:               		counter = 1;
12:               		while((divisor & 0x80) == 0) {
13:               			divisor <<= 1;
14:               			counter++;
15:               		}
16:               		do {
17:               			quotient <<= 1;
18:               			if(divisor <= dividend) {
19:               				dividend -= divisor;
20:               				quotient |= 1;
21:               			}
22:               			divisor >>= 1;
23:               		} while(--counter != 0);
24:               	}
25:               	return quotient;
26:               }
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\Umul8.c ----------------------------------------------------------------------
1:                // 8 x 8 bit multiplication with 8 bit result
2:                
3:                unsigned char
4:                __bmul(unsigned char multiplier, unsigned char multiplicand)
  0610    00F5    LD	0x75,A
  0611    01F4    CLR	0x74
  0612    0873    LD	A,0x73
  0613    1875    SZB	0x75,0
  0614    07F4    ADDR	0x74
  0615    1003    CLRB	0x3,0
  0616    0DF3    RLCR	0x73
  0617    1003    CLRB	0x3,0
  0618    0CF5    RRCR	0x75
  0619    0875    LD	A,0x75
  061A    1D03    SNZB	0x3,2
  061B    2E12    JP	0x612
  061C    0874    LD	A,0x74
  061D    0008    RET
5:                {
6:                	unsigned char product = 0;
7:                
8:                #if defined(__OPTIMIZE_SPEED__)
9:                
10:               	if(multiplier & 0x01)
11:               		product = (product + multiplicand) & 0xff;
12:               	multiplicand <<= 1;
13:               
14:               	if(multiplier & 0x02)
15:               		product = (product + multiplicand) & 0xff;
16:               	multiplicand <<= 1;
17:               
18:               	if(multiplier & 0x04)
19:               		product = (product + multiplicand) & 0xff;
20:               	multiplicand <<= 1;
21:               
22:               	if(multiplier & 0x08)
23:               		product = (product + multiplicand) & 0xff;
24:               	multiplicand <<= 1;
25:               
26:               	if(multiplier & 0x10)
27:               		product = (product + multiplicand) & 0xff;
28:               	multiplicand <<= 1;
29:               
30:               	if(multiplier & 0x20)
31:               		product = (product + multiplicand) & 0xff;
32:               	multiplicand <<= 1;
33:               
34:               	if(multiplier & 0x40)
35:               		product = (product + multiplicand) & 0xff;
36:               	multiplicand <<= 1;
37:               
38:               	if(multiplier & 0x80)
39:               		product = (product + multiplicand) & 0xff;
40:               
41:               #else
42:               	do {
43:               		if(multiplier & 1)
44:               			product += multiplicand;
45:               		multiplicand <<= 1;
46:               		multiplier >>= 1;
47:               	} while(multiplier != 0);
48:               
49:               #endif
50:               	return product;
51:               }
---- stringtab ------------------------------------------------------------------
  05DA    3005    LDIA	0x5
  05DB    008A    LD	0xA,A
  05DC    0804    LD	A,0x4
  05DD    0A84    INCR	0x4
  05DE    0782    ADDR	0x2
  05DF    3400    RET	0x0
---- reset_enter ------------------------------------------------------------------
  0000    280C    JP	0xC
  000C    280D    JP	0xD
---- start_initialization ------------------------------------------------------------------
  000D    3077    LDIA	0x77
  000E    0084    LD	0x4,A
  000F    307B    LDIA	0x7B
  0010    262B    CALL	0x62B
  0011    3020    LDIA	0x20
  0012    1383    CLRB	0x3,7
  0013    0084    LD	0x4,A
  0014    3056    LDIA	0x56
  0015    262B    CALL	0x62B
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F0    LD	0x70,A
  0007    0804    LD	A,0x4
  0008    00F1    LD	0x71,A
  0009    080A    LD	A,0xA
  000A    00F2    LD	0x72,A
  000B    2D6C    JP	0x56C
---- common_function ------------------------------------------------------------------
  0016    0183    CLR	0x3
  0017    2C62    JP	0x462
  00FD    0AAA    INCR	0x2A
  00FE    1903    SZB	0x3,2
  00FF    0AAB    INCR	0x2B
  0100    300B    LDIA	0xB
  0101    022B    SUBA	0x2B
  0102    34B9    RET	0xB9
  01CF    00D7    LD	0x57,A
  01D0    01D8    CLR	0x58
  01D1    01D9    CLR	0x59
  01D2    0856    LD	A,0x56
  01D3    02DD    SUBR	0x5D
  01D4    0857    LD	A,0x57
  01D5    1C03    SNZB	0x3,0
  01D6    0F57    SZINCA	0x57
  01D7    02DE    SUBR	0x5E
  01D8    0858    LD	A,0x58
  01D9    1C03    SNZB	0x3,0
  01DA    0F58    SZINCA	0x58
  01DB    02DF    SUBR	0x5F
  01DC    0859    LD	A,0x59
  01DD    0008    RET
  01DE    01DD    CLR	0x5D
  01DF    01DE    CLR	0x5E
  01E0    01DF    CLR	0x5F
  01E1    01E0    CLR	0x60
  01E2    01E1    CLR	0x61
  01E3    01E2    CLR	0x62
  01E4    01E3    CLR	0x63
  01E5    01E4    CLR	0x64
  01E6    0008    RET
  01E7    0866    LD	A,0x66
  01E8    00E4    LD	0x64,A
  01E9    0865    LD	A,0x65
  01EA    00E3    LD	0x63,A
  01EB    0008    RET
  045D    00EC    LD	0x6C,A
  045E    300A    LDIA	0xA
  045F    00F3    LD	0x73,A
  0460    0879    LD	A,0x79
  0461    0008    RET
  04E0    0085    LD	0x5,A
  04E1    3004    LDIA	0x4
  04E2    1283    CLRB	0x3,5
  04E3    0085    LD	0x5,A
  04E4    1683    SETB	0x3,5
  04E5    0186    CLR	0x6
  04E6    1283    CLRB	0x3,5
  04E7    0186    CLR	0x6
  04E8    0008    RET
  05E0    343F    RET	0x3F
  05E1    3406    RET	0x6
  05E2    345B    RET	0x5B
  05E3    344F    RET	0x4F
  05E4    3466    RET	0x66
  05E5    346D    RET	0x6D
  05E6    347D    RET	0x7D
  05E7    3407    RET	0x7
  05E8    347F    RET	0x7F
  05E9    346F    RET	0x6F
  05EA    3471    RET	0x71
  05EB    3479    RET	0x79
  05EC    3450    RET	0x50
  05ED    3476    RET	0x76
  05FB    1283    CLRB	0x3,5
  05FC    0095    LD	0x15,A
  05FD    019D    CLR	0x1D
  05FE    0008    RET
  0600    2A92    JP	0x292
  0601    2A04    JP	0x204
  0602    2A0E    JP	0x20E
  0603    2A17    JP	0x217
  0604    2A1E    JP	0x21E
  0605    2A29    JP	0x229
  0606    2A34    JP	0x234
  0607    2A3B    JP	0x23B
  0608    2A42    JP	0x242
  0609    2A4A    JP	0x24A
  060A    2A52    JP	0x252
  060B    2A5C    JP	0x25C
  060C    2A67    JP	0x267
  060D    2A71    JP	0x271
  060E    2A7C    JP	0x27C
  060F    2A87    JP	0x287
  062B    0064    CLRWDT
  062C    0180    CLR	0x0
  062D    0A84    INCR	0x4
  062E    0604    XORA	0x4
  062F    1903    SZB	0x3,2
  0630    3400    RET	0x0
  0631    0604    XORA	0x4
  0632    2E2C    JP	0x62C
