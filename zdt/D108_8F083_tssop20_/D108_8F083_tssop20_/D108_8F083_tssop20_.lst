---- C:\mcuproject\scm\zdt\D108_8F083_tssop20_\D108_8F083_tssop20_\main.c ----------------------------------------------------------------------
1:                #include <sc.h>
2:                #include "Touch_Kscan_Library.h"
3:                
4:                #ifndef _XTAL_FREQ
5:                #define _XTAL_FREQ 8000000			//8MHz,使用内置延时函数必须定义主频，
6:                									//如用16M需改此参数为16000000
7:                #endif
8:                #define     POWER_RATIO  	(4096UL*1.2*1000)
9:                
10:               #define		uchar		unsigned char
11:               #define		u8t		unsigned char
12:               #define		uint			unsigned int
13:               #define		u16t			unsigned int
14:               #define		ulong		unsigned long
15:               #define		MOT1		RA5
16:               #define		MOT2		RA6
17:               #define		MOT3		RA7
18:               #define		MOT4		RB7
19:               
20:               volatile unsigned char MainTime;
21:               volatile bit	B_MainLoop,B_OnOff;
22:               u8t	count1s = 0;
23:               u8t	workStep = 0;
24:               u8t	wuhuaFlag = 0;
25:               u16t		shanshuoTime = 0;
26:               u16t		shanshuoTime2 = 0;
27:               u16t		shanshuoTime3 = 0;
28:               u16t		fanValue = 0;
29:               u16t		wuhuaValue = 0;
30:               u8t	fanDuty = 0;
31:               u8t	count10s = 0;
32:               u8t	fanOverTime = 0;
33:               u8t	firstTime = 0;
34:               u16t	checkTime = 0;
35:               u16t	lowWaterTime = 0;
36:               u8t		chrgFlag = 0;
37:               u8t		chrgFullFlag = 0;
38:               u8t		chrgFullTime = 0;
39:               u8t		firstLock = 0;
40:               u8t		lowBatLock = 0;
41:               u16t		lowBatTime = 0;	
42:               u16t		lowFanTime = 0;//风扇降低为1档的时间
43:               u8t		bujinFlag = 0;	
44:               u16t	motorStep = 0;
45:               u16t	maxMotorStep = 512;
46:               u8t		powerFlag = 0;
47:               u16t		keyCount = 0;
48:               u8t		longKeyFlag = 0;
49:               u8t		closeTime = 0;
50:               u8t		motorStopFlag = 0;
51:               u8t		zeroFlag = 1;	//默认在原点
52:               u8t		bujinStartFlag = 0;
53:               
54:               volatile unsigned int adresult;
55:               volatile unsigned int result;
56:               volatile unsigned char test_adc;
57:               volatile unsigned int power_ad;
58:               
59:               void chrgCtr();
60:               unsigned char ADC_Sample(unsigned char adch, unsigned char adldo);
61:               
62:               //系统初始化
63:               void Init_System()
  0407    0000    NOP
  0408    0064    CLRWDT
64:               {
65:               	asm("nop");
66:               	asm("clrwdt");
67:               	INTCON = 0;				//禁止中断
  0409    018B    CLR	0xB
68:               	OSCCON = 0X72;			//配置振荡为8M
  040A    3072    LDIA	0x72
  040B    1283    CLRB	0x3,5
  040C    1303    CLRB	0x3,6
  040D    0094    LD	0x14,A
69:               	OPTION_REG = 0;
  040E    0181    CLR	0x1
70:               	
71:               	
72:               	//延时等待电源电压稳定
73:               	//DelayXms(200);
74:               	TRISA = 0x04;
  040F    3004    LDIA	0x4
  0410    1683    SETB	0x3,5
  0411    0085    LD	0x5,A
75:               	PORTA = 0;
  0412    0186    CLR	0x6
76:               	TRISB = 0x20;
  0413    3020    LDIA	0x20
  0414    1283    CLRB	0x3,5
  0415    0085    LD	0x5,A
77:               	PORTB = 0;
  0416    0186    CLR	0x6
78:               	WPUB = 0x00;
  0417    0188    CLR	0x8
79:               	TRISC = 0;
  0418    1703    SETB	0x3,6
  0419    0185    CLR	0x5
80:               	PORTC = 0;
  041A    0186    CLR	0x6
81:               
82:               	PIE1 = 2;
  041B    3002    LDIA	0x2
  041C    1303    CLRB	0x3,6
  041D    008E    LD	0xE,A
83:               	PR2 = 250;				//8M下将TMR2设置为125us中断
  041E    30FA    LDIA	0xFA
  041F    0091    LD	0x11,A
84:               	T2CON = 4;				//使能定时器2
  0420    3004    LDIA	0x4
  0421    0093    LD	0x13,A
85:               
86:               	INTCON = 0XC0;			//使能中断
  0422    30C0    LDIA	0xC0
  0423    008B    LD	0xB,A
87:               	ADCON0 = 0X41;
88:               	ADON = 1;
89:               	ADCON1 = 0x00;
  0424    2FCB    JP	0x7CB
90:               }
91:               
92:               
93:               /**********************************************************
94:               函数名称：Refurbish_Sfr
95:               函数功能：刷新一些特殊功能寄存器
96:               入口参数：无
97:               出口参数：无
98:               备    注：每隔一定时间刷新一次SFR可增强抗干扰能力
99:               **********************************************************/
100:              void Refurbish_Sfr() 
101:              {
102:              	//刷新中断相关控制寄存器
103:              	PIE1 = 2;
  076B    3002    LDIA	0x2
  076C    1283    CLRB	0x3,5
  076D    008E    LD	0xE,A
104:              	PR2 = 250;
  076E    30FA    LDIA	0xFA
  076F    0091    LD	0x11,A
105:              	INTCON = 0XC0;
  0770    30C0    LDIA	0xC0
  0771    008B    LD	0xB,A
106:              	if (4 != T2CON)
  0772    3004    LDIA	0x4
  0773    0613    XORA	0x13
  0774    1903    SZB	0x3,2
  0775    0008    RET
107:              		T2CON = 4;
  0776    3004    LDIA	0x4
  0777    0093    LD	0x13,A
  0778    0008    RET
108:              }
109:              
110:              
111:              /***********************************************************
112:              键处理函数
113:              ***********************************************************/
114:              void KeyServer() 
115:              {
116:              	static unsigned char KeyOldFlag = 0;
117:              	if (KeyFlag[0]) 
  0E97    0879    LD	A,0x79
  0E98    1903    SZB	0x3,2
  0E99    2F33    JP	0x733
118:              	{
119:              		if (KeyFlag[0] != KeyOldFlag) 
  0E9A    0879    LD	A,0x79
  0E9B    0636    XORA	0x36
  0E9C    1903    SZB	0x3,2
  0E9D    2F08    JP	0x708
120:              		{
121:              			//确定状态改变的按键
122:              			KeyOldFlag ^= KeyFlag[0];
  0E9E    0879    LD	A,0x79
  0E9F    06B6    XORR	0x36
123:              			if ((KeyOldFlag & 0x1) && (KeyFlag[0] & 0x1) && firstLock == 0 && powerFlag > 0) 
  0EA0    1836    SZB	0x36,0
  0EA1    1C79    SNZB	0x79,0
  0EA2    2EC3    JP	0x6C3
  0EA3    1683    SETB	0x3,5
  0EA4    084F    LD	A,0x4F
  0EA5    1D03    SNZB	0x3,2
  0EA6    2EC3    JP	0x6C3
  0EA7    1283    CLRB	0x3,5
  0EA8    083C    LD	A,0x3C
  0EA9    1903    SZB	0x3,2
  0EAA    2EC3    JP	0x6C3
124:              			{
125:              				//KEY1被按下
126:              				if(lowBatLock == 1)
  0EAB    0B3E    SZDECA	0x3E
  0EAC    2EB2    JP	0x6B2
127:              				{
128:              					shanshuoTime2 = 450;
  0EAD    30C2    LDIA	0xC2
  0EAE    00AC    LD	0x2C,A
  0EAF    3001    LDIA	0x1
  0EB0    00AD    LD	0x2D,A
129:              				}
  0EB1    2EB7    JP	0x6B7
130:              				else if(++wuhuaFlag > 2)
  0EB2    3003    LDIA	0x3
  0EB3    0AC5    INCR	0x45
  0EB4    0245    SUBA	0x45
  0EB5    1803    SZB	0x3,0
131:              				{
132:              					wuhuaFlag = 0;
  0EB6    01C5    CLR	0x45
133:              				}
134:              				if(wuhuaFlag >= 2)
  0EB7    3002    LDIA	0x2
  0EB8    0245    SUBA	0x45
  0EB9    1C03    SNZB	0x3,0
  0EBA    2EC1    JP	0x6C1
135:              				{
136:              					shanshuoTime2 = 450;
  0EBB    30C2    LDIA	0xC2
  0EBC    00AC    LD	0x2C,A
  0EBD    3001    LDIA	0x1
  0EBE    00AD    LD	0x2D,A
137:              					count10s = 0;
  0EBF    01C3    CLR	0x43
138:              				}
  0EC0    2EC3    JP	0x6C3
139:              				else
140:              				{
141:              					shanshuoTime2 = 0;
  0EC1    01AC    CLR	0x2C
  0EC2    01AD    CLR	0x2D
142:              				}
143:              			}
144:              			if ((KeyOldFlag & 0x2) && (KeyFlag[0] & 0x2) && firstLock == 0 && powerFlag > 0) 
  0EC3    1283    CLRB	0x3,5
  0EC4    18B6    SZB	0x36,1
  0EC5    1CF9    SNZB	0x79,1
  0EC6    2EE4    JP	0x6E4
  0EC7    1683    SETB	0x3,5
  0EC8    084F    LD	A,0x4F
  0EC9    1D03    SNZB	0x3,2
  0ECA    2EE4    JP	0x6E4
  0ECB    1283    CLRB	0x3,5
  0ECC    083C    LD	A,0x3C
  0ECD    1903    SZB	0x3,2
  0ECE    2EE4    JP	0x6E4
145:              			{
146:              				//KEY2被按下
147:              				if(lowBatLock == 1)
  0ECF    0B3E    SZDECA	0x3E
  0ED0    2ED4    JP	0x6D4
148:              				{
149:              					shanshuoTime = 450;
  0ED1    2738    CALL	0x738
  0ED2    158A    SETB	0xA,3
150:              				}
  0ED3    2EDB    JP	0x6DB
151:              				else if(++workStep > 3)
  0ED4    3004    LDIA	0x4
  0ED5    0AFB    INCR	0x7B
  0ED6    027B    SUBA	0x7B
  0ED7    1C03    SNZB	0x3,0
  0ED8    2EDB    JP	0x6DB
152:              				{
153:              					workStep = 0;
  0ED9    01FB    CLR	0x7B
154:              					bujinFlag = 0;
  0EDA    01BD    CLR	0x3D
155:              				}
156:              				if(workStep >= 2)
  0EDB    3002    LDIA	0x2
  0EDC    027B    SUBA	0x7B
  0EDD    1C03    SNZB	0x3,0
  0EDE    2EE2    JP	0x6E2
157:              				{
158:              					shanshuoTime = 450;
  0EDF    2738    CALL	0x738
  0EE0    158A    SETB	0xA,3
159:              				}
  0EE1    2EE4    JP	0x6E4
160:              				else
161:              				{
162:              					shanshuoTime = 0;
  0EE2    01AE    CLR	0x2E
  0EE3    01AF    CLR	0x2F
163:              				}
164:              				
165:              			}
166:              			if ((KeyOldFlag & 0x4) && (KeyFlag[0] & 0x4) && firstLock == 0 && workStep > 0 && powerFlag > 0) 
  0EE4    1283    CLRB	0x3,5
  0EE5    1936    SZB	0x36,2
  0EE6    1D79    SNZB	0x79,2
  0EE7    2F05    JP	0x705
  0EE8    1683    SETB	0x3,5
  0EE9    084F    LD	A,0x4F
  0EEA    1D03    SNZB	0x3,2
  0EEB    2F05    JP	0x705
  0EEC    087B    LD	A,0x7B
  0EED    1903    SZB	0x3,2
  0EEE    2F05    JP	0x705
  0EEF    1283    CLRB	0x3,5
  0EF0    083C    LD	A,0x3C
  0EF1    1903    SZB	0x3,2
  0EF2    2F05    JP	0x705
167:              			{
168:              				//KEY3被按下
169:              				if(++bujinFlag > 3)
  0EF3    3004    LDIA	0x4
  0EF4    0ABD    INCR	0x3D
  0EF5    023D    SUBA	0x3D
  0EF6    1803    SZB	0x3,0
170:              				{
171:              					bujinFlag = 0;
  0EF7    01BD    CLR	0x3D
  0EF8    3002    LDIA	0x2
172:              				}
173:              				bujinStartFlag = 1;
  0EF9    01B8    CLR	0x38
  0EFA    0AB8    INCR	0x38
174:              				if(bujinFlag >= 2)
  0EFB    023D    SUBA	0x3D
  0EFC    1C03    SNZB	0x3,0
  0EFD    2F03    JP	0x703
175:              				{
176:              					shanshuoTime3 = 450;
  0EFE    30C2    LDIA	0xC2
  0EFF    00AA    LD	0x2A,A
  0F00    3001    LDIA	0x1
  0F01    00AB    LD	0x2B,A
177:              				}
  0F02    2F05    JP	0x705
178:              				else
179:              				{
180:              					shanshuoTime3 = 0;
  0F03    01AA    CLR	0x2A
  0F04    01AB    CLR	0x2B
181:              				}
182:              			}
183:              
184:              			KeyOldFlag = KeyFlag[0];
  0F05    0879    LD	A,0x79
  0F06    1283    CLRB	0x3,5
  0F07    00B6    LD	0x36,A
185:              		}
186:              		if(firstLock == 0 && KeyOldFlag & 0x4)
  0F08    1683    SETB	0x3,5
  0F09    084F    LD	A,0x4F
  0F0A    1D03    SNZB	0x3,2
  0F0B    0008    RET
  0F0C    1283    CLRB	0x3,5
  0F0D    1D36    SNZB	0x36,2
  0F0E    0008    RET
187:              		{
188:              			if(++keyCount >= 400)
  0F0F    0AA6    INCR	0x26
  0F10    1903    SZB	0x3,2
  0F11    0AA7    INCR	0x27
  0F12    3001    LDIA	0x1
  0F13    0227    SUBA	0x27
  0F14    3090    LDIA	0x90
  0F15    1903    SZB	0x3,2
  0F16    0226    SUBA	0x26
  0F17    1C03    SNZB	0x3,0
  0F18    0008    RET
189:              			{
190:              				keyCount = 0;
  0F19    01A6    CLR	0x26
  0F1A    01A7    CLR	0x27
191:              				if(longKeyFlag == 0)
  0F1B    083B    LD	A,0x3B
  0F1C    1D03    SNZB	0x3,2
  0F1D    0008    RET
192:              				{
193:              					longKeyFlag = 1;
  0F1E    01BB    CLR	0x3B
  0F1F    0ABB    INCR	0x3B
194:              					if(powerFlag > 0)
  0F20    083C    LD	A,0x3C
  0F21    1903    SZB	0x3,2
  0F22    2F2A    JP	0x72A
195:              					{
196:              						powerFlag = 0;
  0F23    01BC    CLR	0x3C
197:              						workStep = 0;
  0F24    01FB    CLR	0x7B
198:              						wuhuaFlag = 0;
  0F25    01C5    CLR	0x45
199:              						bujinFlag = 0;
  0F26    01BD    CLR	0x3D
200:              						shanshuoTime3 = 0;
  0F27    01AA    CLR	0x2A
  0F28    01AB    CLR	0x2B
201:              					}
  0F29    0008    RET
  0F2A    30D0    LDIA	0xD0
202:              					else
203:              					{
204:              						powerFlag = 1;
  0F2B    01BC    CLR	0x3C
  0F2C    0ABC    INCR	0x3C
205:              						workStep = 1;
  0F2D    01FB    CLR	0x7B
  0F2E    0AFB    INCR	0x7B
206:              						shanshuoTime3 = 2000;
  0F2F    00AA    LD	0x2A,A
  0F30    3007    LDIA	0x7
  0F31    00AB    LD	0x2B,A
  0F32    0008    RET
207:              					}
208:              				}
209:              			}
210:              		}
211:              	} 
212:              	else 
213:              	{
214:              		KeyOldFlag = 0;
  0F33    01B6    CLR	0x36
215:              		longKeyFlag = 0;
  0F34    01BB    CLR	0x3B
216:              		keyCount = 0;
  0F35    01A6    CLR	0x26
  0F36    01A7    CLR	0x27
  0F37    0008    RET
217:              	}
218:              }
219:              
220:              
221:              /***********************************************************
222:              中断服务函数
223:              ***********************************************************/
224:              void interrupt Isr_Timer()
225:              {
226:              	if(TMR2IF)				//若只使能了一个中断源,可以略去判断
  07E1    1283    CLRB	0x3,5
  07E2    1303    CLRB	0x3,6
  07E3    1C8D    SNZB	0xD,1
  07E4    2FF4    JP	0x7F4
227:              	{
228:              		TMR2IF = 0;
  07E5    108D    CLRB	0xD,1
229:              		if(++MainTime >= 32)	//需根据你选择的触摸路数和触摸电容选择扫描一次按键的时间
  07E6    3020    LDIA	0x20
  07E7    0AC7    INCR	0x47
  07E8    0247    SUBA	0x47
  07E9    1C03    SNZB	0x3,0
  07EA    2FF5    JP	0x7F5
230:              		{						//一般103电容，8路触摸，8M主频检测时间约4ms，故扫描一次的时间可选5ms
231:              			MainTime = 0;
  07EB    01C7    CLR	0x47
232:              			B_MainLoop = 1;
  07EC    1778    SETB	0x78,6
233:              			if(++count1s >= 250)
  07ED    30FA    LDIA	0xFA
  07EE    0AC6    INCR	0x46
  07EF    0246    SUBA	0x46
  07F0    1C03    SNZB	0x3,0
  07F1    2FF5    JP	0x7F5
234:              			{
235:              				count1s = 0;
  07F2    01C6    CLR	0x46
  07F3    2FF5    JP	0x7F5
236:              			}
237:              		}
238:              	}
239:              	else
240:              	{
241:              		PIR1 = 0;
  07F4    018D    CLR	0xD
  07F5    0871    LD	A,0x71
  07F6    008A    LD	0xA,A
  07F7    0E70    SWAPA	0x70
  07F8    0083    LD	0x3,A
  07F9    0EFE    SWAPR	0x7E
  07FA    0E7E    SWAPA	0x7E
  07FB    0009    RETI
242:              	}
243:              	
244:              }
245:              
246:              void WorkSleep()
247:              {
248:              #if (0 != C_KEY_WAKEUP)
249:              	static unsigned char time;
250:              	
251:              	if(B_OnOff)time = 0;
  0425    1AF8    SZB	0x78,5
  0426    01B5    CLR	0x35
252:              	
253:              	if(++time >= 125)
  0427    307D    LDIA	0x7D
  0428    0AB5    INCR	0x35
  0429    0235    SUBA	0x35
  042A    1C03    SNZB	0x3,0
  042B    0008    RET
254:              	{
255:              		time = 0;
  042C    01B5    CLR	0x35
256:              		INTCON = 0;			//;关断ADC模块及中断使能；
  042D    018B    CLR	0xB
257:              		PIE1 = 0;
  042E    018E    CLR	0xE
258:              		PIE2 = 0;
  042F    1703    SETB	0x3,6
  0430    0190    CLR	0x10
259:              		PIR1 = 0;
  0431    1303    CLRB	0x3,6
  0432    018D    CLR	0xD
260:              		PIR2 = 0;
  0433    1703    SETB	0x3,6
  0434    018F    CLR	0xF
261:              		T2CON = 0;
  0435    1303    CLRB	0x3,6
  0436    0193    CLR	0x13
262:              		ADCON1 = 0;
  0437    1683    SETB	0x3,5
  0438    0196    CLR	0x16
263:              
264:              		//进入休眠前关掉所有功能模块,以降低休眠电流
265:              		ADCON0 = 0;
  0439    0195    CLR	0x15
266:              	
267:              		//进入休眠前,必须固定口线电平,这儿全部输出低电平,并关闭所有上拉电阻
268:              		PORTA = 0x01;
  043A    3001    LDIA	0x1
  043B    0086    LD	0x6,A
269:              		PORTB = 0x00;
  043C    1283    CLRB	0x3,5
  043D    0186    CLR	0x6
270:              		TRISC = 0;
  043E    1703    SETB	0x3,6
  043F    0185    CLR	0x5
271:              		PORTC = 0x03;
  0440    3003    LDIA	0x3
  0441    0086    LD	0x6,A
272:              
273:              		TRISB5 =1;//输入
  0442    1303    CLRB	0x3,6
  0443    1685    SETB	0x5,5
274:              		//WPUB7 = 1;//上拉			
275:              		RBIF = 0;//清标志
  0444    100B    CLRB	0xB,0
276:              		RBIE = 1; //允许PB口电平变化中断
  0445    158B    SETB	0xB,3
277:              		IOCB5= 1;//允许PB1电平变化中断
  0446    1689    SETB	0x9,5
278:              		PORTB;//读一次PB口	
  0447    0806    LD	A,0x6
279:              /****如需要PA口中断唤醒，使能下列程序并按需修改****
280:              			TRISA0 =1;	//输入
281:              			WPUA0 = 1;	//上拉			
282:              			RAIF = 0;	//清标志
283:              			RAIE = 1;	//允许PA口电平变化中断
284:              			IOCA0 = 1;	//允许PA0电平变化中断
285:              			PEIE = 1;	//允许外设中断
286:              			PORTA;		//读一次PA口			
287:              ************************************/	
288:              
289:              		//进入休眠模式,触摸允许唤醒的按键后恢复正常工作
290:              		SystemEnterSleep();
  0448    2480    CALL	0x480
  0449    118A    CLRB	0xA,3
291:              		if(RAIF) 
  044A    1D8D    SNZB	0xD,3
  044B    2C4F    JP	0x44F
292:              		{
293:              			RAIF = 0;
  044C    118D    CLRB	0xD,3
294:              			PORTA;
  044D    1683    SETB	0x3,5
  044E    0806    LD	A,0x6
295:              		}
296:              		//休眠被唤醒,重新配置中断等SFR,使系统进入正常工作
297:              		Refurbish_Sfr();
  044F    276B    CALL	0x76B
  0450    118A    CLRB	0xA,3
298:              		PORTB &= 0xFD;
  0451    1086    CLRB	0x6,1
299:              		ADCON0 = 0X41;
300:              		ADON = 1;
301:              		ADCON1 = 0x00;
  0452    2FCB    JP	0x7CB
302:              	}
303:              #endif
304:              }
305:              
306:              
307:              /**********************************************************
308:              函数名称：AD_Sample
309:              函数功能：AD检测
310:              入口参数：adch - 检测通道
311:              出口参数：无
312:              备    注：采样通道需自行设置为输入口
313:              	      采样10次,取中间八次的平均值为采样结果存于adresult中
314:              
315:              	      adch 为输入AD通道 0-15，31
316:                           31  检测内部1.2V
317:              	
318:               		  adldo =5,开启内部LDO 2V 作为ADC 参考
319:               		  adldo =6,开启内部LDO 2.4V 作为ADC 参考
320:              		  adldo =7,开启内部LDO 3V 作为ADC 参考
321:               		  adldo =0,VDD 作为ADC 参考
322:               		  AD转换结果左对齐
323:               		  ADC参考电压从VDD切换到LDO时需要延时100us以上，才能进行AD转换
324:              **********************************************************/
325:              unsigned char ADC_Sample(unsigned char adch, unsigned char adldo) 
  01B7    1283    CLRB	0x3,5
  01B8    00CB    LD	0x4B,A
326:              {
327:              	volatile unsigned long adsum = 0;
328:              	volatile unsigned int admin = 0, admax = 0;
  01B9    23E9    CALL	0x3E9
  01BA    118A    CLRB	0xA,3
329:              	volatile unsigned int ad_temp = 0;
  01BB    01D5    CLR	0x55
  01BC    01D6    CLR	0x56
330:              
331:              	if ((!LDO_EN) && (adldo & 0x04) ) 
  01BD    1683    SETB	0x3,5
  01BE    1D16    SNZB	0x16,2
  01BF    1D72    SNZB	0x72,2
  01C0    29C9    JP	0x1C9
332:              	{
333:              								//如果AD参考从VDD换到内部LDO，需要延时100US以上
334:              		ADCON1 = adldo;			//左对齐,AD值取12位
  01C1    0872    LD	A,0x72
  01C2    0096    LD	0x16,A
335:              		__delay_us(100);		//IDE内置延时函数，延时100us
  01C3    3042    LDIA	0x42
  01C4    00F3    LD	0x73,A
  01C5    0BF3    SZDECR	0x73
  01C6    29C5    JP	0x1C5
  01C7    0000    NOP
336:              	} 
  01C8    29CB    JP	0x1CB
337:              	else
338:              		ADCON1 = adldo;			//如果ADCON1.7(ADFM)=1为右对齐，,AD值取10位
  01C9    0872    LD	A,0x72
  01CA    0096    LD	0x16,A
339:              
340:              	if(adch & 0x10) 
  01CB    1283    CLRB	0x3,5
  01CC    1303    CLRB	0x3,6
  01CD    1E4B    SNZB	0x4B,4
  01CE    29D4    JP	0x1D4
341:              	{
342:              		CHS4 = 1;
  01CF    1683    SETB	0x3,5
  01D0    1716    SETB	0x16,6
343:              		adch &= 0x0f;
  01D1    300F    LDIA	0xF
  01D2    1283    CLRB	0x3,5
  01D3    05CB    ANDR	0x4B
344:              	}
345:              	unsigned char i = 0;
346:              	for (i = 0; i < 10; i++) 
  01D4    01CC    CLR	0x4C
347:              	{
348:              		ADCON0 = (unsigned char)(0X41 | (adch << 2));	//16分频，如果主频为16M，则必须选16分频或以上
  01D5    084B    LD	A,0x4B
  01D6    00F3    LD	0x73,A
  01D7    3001    LDIA	0x1
  01D8    1003    CLRB	0x3,0
  01D9    0DF3    RLCR	0x73
  01DA    3EFF    ADDIA	0xFF
  01DB    1003    CLRB	0x3,0
  01DC    1D03    SNZB	0x3,2
  01DD    29D9    JP	0x1D9
  01DE    0D73    RLCA	0x73
  01DF    3841    ORIA	0x41
  01E0    1683    SETB	0x3,5
  01E1    0095    LD	0x15,A
  01E2    0000    NOP
  01E3    0000    NOP
  01E4    0000    NOP
  01E5    0000    NOP
349:              		asm("nop");
350:              		asm("nop");
351:              		asm("nop");
352:              		asm("nop");				//选择通道后需延时1uS以上
353:              		GODONE = 1;				//开始转换
  01E6    1683    SETB	0x3,5
  01E7    1303    CLRB	0x3,6
  01E8    1495    SETB	0x15,1
354:              
355:              		unsigned char j = 0;
  01E9    1283    CLRB	0x3,5
  01EA    01CA    CLR	0x4A
356:              		while (GODONE) 
  01EB    1683    SETB	0x3,5
  01EC    1C95    SNZB	0x15,1
  01ED    29F5    JP	0x1F5
357:              		{
358:              			__delay_us(2);		//延时2us(编译器内置函数)
  01EE    29EF    JP	0x1EF
  01EF    29F0    JP	0x1F0
359:              
360:              			if (0 == (--j))		//延时0.5ms仍没有AD转换结束，跳出程序
  01F0    1283    CLRB	0x3,5
  01F1    1303    CLRB	0x3,6
  01F2    0BCA    SZDECR	0x4A
  01F3    29EB    JP	0x1EB
361:              			return 0;
  01F4    3400    RET	0x0
362:              		}
363:              
364:              		ad_temp = (unsigned int)((ADRESH << 4) + (ADRESL >> 4));	//计算12位AD值
  01F5    0819    LD	A,0x19
  01F6    1283    CLRB	0x3,5
  01F7    00D5    LD	0x55,A
  01F8    01D6    CLR	0x56
  01F9    0ED5    SWAPR	0x55
  01FA    0ED6    SWAPR	0x56
  01FB    30F0    LDIA	0xF0
  01FC    05D6    ANDR	0x56
  01FD    0855    LD	A,0x55
  01FE    390F    ANDIA	0xF
  01FF    04D6    ORR	0x56
  0200    30F0    LDIA	0xF0
  0201    05D5    ANDR	0x55
  0202    1683    SETB	0x3,5
  0203    0E18    SWAPA	0x18
  0204    390F    ANDIA	0xF
  0205    1283    CLRB	0x3,5
  0206    07D5    ADDR	0x55
  0207    1803    SZB	0x3,0
  0208    0AD6    INCR	0x56
365:              
366:              		if (0 == admax) 
  0209    0853    LD	A,0x53
  020A    0454    ORA	0x54
  020B    1D03    SNZB	0x3,2
  020C    2A10    JP	0x210
367:              		{
368:              			admax = ad_temp;
  020D    23FE    CALL	0x3FE
  020E    118A    CLRB	0xA,3
  020F    2A23    JP	0x223
369:              			admin = ad_temp;
370:              		} 
371:              		else if (ad_temp > admax)
  0210    0856    LD	A,0x56
  0211    0254    SUBA	0x54
  0212    1D03    SNZB	0x3,2
  0213    2A16    JP	0x216
  0214    0855    LD	A,0x55
  0215    0253    SUBA	0x53
  0216    1803    SZB	0x3,0
  0217    2A1B    JP	0x21B
372:              			admax = ad_temp;				//AD采样最大值
  0218    23FE    CALL	0x3FE
  0219    118A    CLRB	0xA,3
  021A    2A27    JP	0x227
373:              		else if (ad_temp < admin)
  021B    0852    LD	A,0x52
  021C    0256    SUBA	0x56
  021D    1D03    SNZB	0x3,2
  021E    2A21    JP	0x221
  021F    0851    LD	A,0x51
  0220    0255    SUBA	0x55
  0221    1803    SZB	0x3,0
  0222    2A27    JP	0x227
374:              			admin = ad_temp;				//AD采样最小值
  0223    0856    LD	A,0x56
  0224    00D2    LD	0x52,A
  0225    0855    LD	A,0x55
  0226    00D1    LD	0x51,A
375:              
376:              		adsum += ad_temp;
  0227    0855    LD	A,0x55
  0228    00F3    LD	0x73,A
  0229    0856    LD	A,0x56
  022A    00F4    LD	0x74,A
  022B    01F5    CLR	0x75
  022C    01F6    CLR	0x76
  022D    0873    LD	A,0x73
  022E    07CD    ADDR	0x4D
  022F    0874    LD	A,0x74
  0230    1103    CLRB	0x3,2
  0231    1803    SZB	0x3,0
  0232    3E01    ADDIA	0x1
  0233    1D03    SNZB	0x3,2
  0234    07CE    ADDR	0x4E
  0235    0875    LD	A,0x75
  0236    1103    CLRB	0x3,2
  0237    1803    SZB	0x3,0
  0238    3E01    ADDIA	0x1
  0239    1D03    SNZB	0x3,2
  023A    07CF    ADDR	0x4F
  023B    0876    LD	A,0x76
  023C    1103    CLRB	0x3,2
  023D    1803    SZB	0x3,0
  023E    3E01    ADDIA	0x1
  023F    1D03    SNZB	0x3,2
  0240    07D0    ADDR	0x50
  0241    300A    LDIA	0xA
  0242    0ACC    INCR	0x4C
  0243    024C    SUBA	0x4C
  0244    1C03    SNZB	0x3,0
  0245    29D5    JP	0x1D5
377:              	}
378:              		adsum -= admax;
  0246    0853    LD	A,0x53
  0247    00F3    LD	0x73,A
  0248    0854    LD	A,0x54
  0249    23DA    CALL	0x3DA
  024A    118A    CLRB	0xA,3
  024B    1C03    SNZB	0x3,0
  024C    0F76    SZINCA	0x76
  024D    02D0    SUBR	0x50
379:              		if (adsum >= admin)
  024E    0851    LD	A,0x51
  024F    00F3    LD	0x73,A
  0250    0852    LD	A,0x52
  0251    00F4    LD	0x74,A
  0252    01F5    CLR	0x75
  0253    01F6    CLR	0x76
  0254    0876    LD	A,0x76
  0255    0250    SUBA	0x50
  0256    1D03    SNZB	0x3,2
  0257    2A62    JP	0x262
  0258    0875    LD	A,0x75
  0259    024F    SUBA	0x4F
  025A    1D03    SNZB	0x3,2
  025B    2A62    JP	0x262
  025C    0874    LD	A,0x74
  025D    024E    SUBA	0x4E
  025E    1D03    SNZB	0x3,2
  025F    2A62    JP	0x262
  0260    0873    LD	A,0x73
  0261    024D    SUBA	0x4D
  0262    1C03    SNZB	0x3,0
  0263    2A6D    JP	0x26D
380:              			adsum -= admin;
  0264    0851    LD	A,0x51
  0265    00F3    LD	0x73,A
  0266    0852    LD	A,0x52
  0267    23DA    CALL	0x3DA
  0268    118A    CLRB	0xA,3
  0269    1C03    SNZB	0x3,0
  026A    0F76    SZINCA	0x76
  026B    02D0    SUBR	0x50
  026C    2A71    JP	0x271
381:              		else
382:              			adsum = 0;
  026D    01CD    CLR	0x4D
  026E    01CE    CLR	0x4E
  026F    01CF    CLR	0x4F
  0270    01D0    CLR	0x50
383:              
384:              		adresult = adsum >> 3;		//8次平均值作为最终结果
  0271    084D    LD	A,0x4D
  0272    00F3    LD	0x73,A
  0273    084E    LD	A,0x4E
  0274    00F4    LD	0x74,A
  0275    084F    LD	A,0x4F
  0276    00F5    LD	0x75,A
  0277    0850    LD	A,0x50
  0278    00F6    LD	0x76,A
  0279    3003    LDIA	0x3
  027A    1003    CLRB	0x3,0
  027B    0CF6    RRCR	0x76
  027C    0CF5    RRCR	0x75
  027D    0CF4    RRCR	0x74
  027E    0CF3    RRCR	0x73
  027F    3EFF    ADDIA	0xFF
  0280    1D03    SNZB	0x3,2
  0281    2A7A    JP	0x27A
  0282    0874    LD	A,0x74
  0283    00C9    LD	0x49,A
  0284    0873    LD	A,0x73
  0285    00C8    LD	0x48,A
385:              
386:              		adsum = 0;
387:              		admin = 0;
388:              		admax = 0;
  0286    23E9    CALL	0x3E9
389:              		return 0xA5;
  0287    34A5    RET	0xA5
390:              		
391:              }
392:              
393:              
394:              void chrgCtr()
395:              {
396:              	if(PORTB & 0x20)
  0DFC    1283    CLRB	0x3,5
  0DFD    1303    CLRB	0x3,6
  0DFE    1E86    SNZB	0x6,5
  0DFF    2E18    JP	0x618
397:              	{
398:              		chrgFlag = 1;
  0E00    01C1    CLR	0x41
  0E01    0AC1    INCR	0x41
399:              		firstLock = 0;
  0E02    1683    SETB	0x3,5
  0E03    01CF    CLR	0x4F
400:              		lowBatLock = 0;
  0E04    1283    CLRB	0x3,5
  0E05    3010    LDIA	0x10
  0E06    01BE    CLR	0x3E
401:              		if(power_ad > 4140)
  0E07    0225    SUBA	0x25
  0E08    302D    LDIA	0x2D
  0E09    1903    SZB	0x3,2
  0E0A    0224    SUBA	0x24
  0E0B    1C03    SNZB	0x3,0
  0E0C    2E16    JP	0x616
402:              		{
403:              			if(++chrgFullTime > 200)
  0E0D    30C9    LDIA	0xC9
  0E0E    0ABF    INCR	0x3F
  0E0F    023F    SUBA	0x3F
  0E10    1C03    SNZB	0x3,0
  0E11    0008    RET
404:              			{
405:              				chrgFullTime = 0;
  0E12    01BF    CLR	0x3F
406:              				chrgFullFlag = 1;
  0E13    01C0    CLR	0x40
  0E14    0AC0    INCR	0x40
  0E15    0008    RET
407:              			}
408:              		}
409:              		else
410:              		{
411:              			chrgFullTime = 0;
  0E16    01BF    CLR	0x3F
  0E17    0008    RET
412:              		}
413:              
414:              	}
415:              	else
416:              	{
417:              		chrgFlag = 0;
  0E18    01C1    CLR	0x41
418:              		chrgFullTime = 0;
  0E19    01BF    CLR	0x3F
419:              		chrgFullFlag = 0;
  0E1A    01C0    CLR	0x40
  0E1B    0008    RET
420:              		
421:              	}
422:              }
423:              
424:              void keyLedCtr()
425:              {
426:              	if(shanshuoTime > 0)
  0330    1283    CLRB	0x3,5
  0331    082E    LD	A,0x2E
  0332    042F    ORA	0x2F
  0333    1903    SZB	0x3,2
  0334    2B4E    JP	0x34E
427:              	{
428:              		shanshuoTime--;
  0335    3001    LDIA	0x1
  0336    02AE    SUBR	0x2E
  0337    3000    LDIA	0x0
  0338    1C03    SNZB	0x3,0
  0339    03AF    DECR	0x2F
  033A    02AF    SUBR	0x2F
429:              		if((shanshuoTime % 150) < 75)
  033B    3096    LDIA	0x96
  033C    00F2    LD	0x72,A
  033D    01F3    CLR	0x73
  033E    082F    LD	A,0x2F
  033F    00F5    LD	0x75,A
  0340    082E    LD	A,0x2E
  0341    00F4    LD	0x74,A
  0342    23A5    CALL	0x3A5
  0343    118A    CLRB	0xA,3
  0344    3000    LDIA	0x0
  0345    0273    SUBA	0x73
  0346    304B    LDIA	0x4B
  0347    1903    SZB	0x3,2
  0348    0272    SUBA	0x72
  0349    1803    SZB	0x3,0
  034A    2B51    JP	0x351
430:              		{
431:              			PORTC |= 0x01;
  034B    1703    SETB	0x3,6
  034C    1406    SETB	0x6,0
432:              		}
  034D    2B53    JP	0x353
433:              		else
434:              		{
435:              			PORTC &= 0xFE;
  0351    1703    SETB	0x3,6
  0352    1006    CLRB	0x6,0
436:              		}
437:              	}
438:              	else if(workStep > 0)
  034E    087B    LD	A,0x7B
  034F    1903    SZB	0x3,2
  0350    2B4B    JP	0x34B
439:              	{
440:              		PORTC &= 0xFE;
441:              	}
442:              	else
443:              	{
444:              		PORTC |= 0x01;
445:              	}
446:              	
447:              	if(shanshuoTime2 > 0)
  0353    1303    CLRB	0x3,6
  0354    082C    LD	A,0x2C
  0355    042D    ORA	0x2D
  0356    1903    SZB	0x3,2
  0357    2B71    JP	0x371
448:              	{
449:              		shanshuoTime2--;
  0358    3001    LDIA	0x1
  0359    02AC    SUBR	0x2C
  035A    3000    LDIA	0x0
  035B    1C03    SNZB	0x3,0
  035C    03AD    DECR	0x2D
  035D    02AD    SUBR	0x2D
450:              		if((shanshuoTime2 % 150) < 75)
  035E    3096    LDIA	0x96
  035F    00F2    LD	0x72,A
  0360    01F3    CLR	0x73
  0361    082D    LD	A,0x2D
  0362    00F5    LD	0x75,A
  0363    082C    LD	A,0x2C
  0364    00F4    LD	0x74,A
  0365    23A5    CALL	0x3A5
  0366    118A    CLRB	0xA,3
  0367    3000    LDIA	0x0
  0368    0273    SUBA	0x73
  0369    304B    LDIA	0x4B
  036A    1903    SZB	0x3,2
  036B    0272    SUBA	0x72
  036C    1803    SZB	0x3,0
  036D    2B74    JP	0x374
451:              		{
452:              			PORTC |= 0x02;
  036E    1703    SETB	0x3,6
  036F    1486    SETB	0x6,1
453:              		}
  0370    2B76    JP	0x376
454:              		else
455:              		{
456:              			PORTC &= 0xFD;
  0374    1703    SETB	0x3,6
  0375    1086    CLRB	0x6,1
457:              		}
458:              	}
459:              	else if(wuhuaFlag > 0)
  0371    0845    LD	A,0x45
  0372    1903    SZB	0x3,2
  0373    2B6E    JP	0x36E
460:              	{
461:              		PORTC &= 0xFD;
462:              	}
463:              	else
464:              	{
465:              		PORTC |= 0x02;
466:              	}
467:              	if(shanshuoTime3 > 0)
  0376    1303    CLRB	0x3,6
  0377    082A    LD	A,0x2A
  0378    042B    ORA	0x2B
  0379    1903    SZB	0x3,2
  037A    2B97    JP	0x397
468:              	{
469:              		shanshuoTime3--;
  037B    3001    LDIA	0x1
  037C    02AA    SUBR	0x2A
  037D    3000    LDIA	0x0
  037E    1C03    SNZB	0x3,0
  037F    03AB    DECR	0x2B
  0380    02AB    SUBR	0x2B
470:              		if((shanshuoTime3 % 150) < 75)
  0381    3096    LDIA	0x96
  0382    00F2    LD	0x72,A
  0383    01F3    CLR	0x73
  0384    082B    LD	A,0x2B
  0385    00F5    LD	0x75,A
  0386    082A    LD	A,0x2A
  0387    00F4    LD	0x74,A
  0388    23A5    CALL	0x3A5
  0389    118A    CLRB	0xA,3
  038A    3000    LDIA	0x0
  038B    0273    SUBA	0x73
  038C    304B    LDIA	0x4B
  038D    1903    SZB	0x3,2
  038E    0272    SUBA	0x72
  038F    1803    SZB	0x3,0
  0390    2B94    JP	0x394
471:              		{
472:              			PORTA |= 0x01;
  0391    1683    SETB	0x3,5
  0392    1406    SETB	0x6,0
473:              		}
  0393    0008    RET
474:              		else
475:              		{
476:              			PORTA &= 0xFE;
  0394    1683    SETB	0x3,5
  0395    1006    CLRB	0x6,0
  0396    0008    RET
477:              		}
478:              	}
479:              	else if(bujinFlag)
  0397    083D    LD	A,0x3D
  0398    1D03    SNZB	0x3,2
  0399    2B94    JP	0x394
480:              	{
481:              		PORTA &= 0xFE;
482:              	}
483:              	else if(chrgFlag)
  039A    0841    LD	A,0x41
  039B    1903    SZB	0x3,2
  039C    2B91    JP	0x391
484:              	{
485:              		if(chrgFullFlag || count1s < 50)
  039D    0840    LD	A,0x40
  039E    1D03    SNZB	0x3,2
  039F    2B94    JP	0x394
  03A0    3032    LDIA	0x32
  03A1    0246    SUBA	0x46
  03A2    1C03    SNZB	0x3,0
  03A3    2B94    JP	0x394
  03A4    2B91    JP	0x391
486:              		{
487:              			PORTA &= 0xFE;
488:              		}
489:              		else
490:              		{
491:              			PORTA |= 0x01;
492:              		}
493:              	}
494:              	else
495:              	{
496:              		PORTA |= 0x01;
497:              	}
498:              	
499:              }
500:              
501:              void pwmInit()
502:              {
503:              
504:              	PWMTH = 0x00;
  0E44    0198    CLR	0x18
505:              	PWMTL = 73;
  0E45    3049    LDIA	0x49
  0E46    0097    LD	0x17,A
506:              	PWMD23H = 0x00;
  0E47    1683    SETB	0x3,5
  0E48    019E    CLR	0x1E
507:              	PWMD3L = 32;
  0E49    3020    LDIA	0x20
  0E4A    009C    LD	0x1C,A
508:              	PWMCON1 = 0xC0;
  0E4B    30C0    LDIA	0xC0
  0E4C    1283    CLRB	0x3,5
  0E4D    0096    LD	0x16,A
509:              	PWMCON2 = 0x00;
  0E4E    019D    CLR	0x1D
510:              	PWMCON0 |= 0x28;
  0E4F    3028    LDIA	0x28
  0E50    0495    ORR	0x15
  0E51    0008    RET
511:              }
512:              
513:              void pwmStop()
514:              {
515:              	PWMD3L = 0;
  0E52    1683    SETB	0x3,5
  0E53    019C    CLR	0x1C
516:              	PWMCON0 &= 0xF7;
  0E54    1283    CLRB	0x3,5
  0E55    1195    CLRB	0x15,3
517:              	PORTA &= 0xF7;
  0E56    1683    SETB	0x3,5
  0E57    1186    CLRB	0x6,3
  0E58    0008    RET
518:              }
519:              
520:              void fanInit()
521:              {
522:              
523:              	PWMTH = 0x00;
  03C9    0198    CLR	0x18
524:              	PWMT4L = 73;
  03CA    3049    LDIA	0x49
  03CB    009C    LD	0x1C,A
525:              	PWMD4L = fanDuty;
  03CC    0844    LD	A,0x44
  03CD    009B    LD	0x1B,A
526:              	PWMCON1 = 0xC0;
  03CE    30C0    LDIA	0xC0
  03CF    0096    LD	0x16,A
527:              	PWMCON2 = 0x00;
  03D0    019D    CLR	0x1D
528:              	PWMCON0 |= 0x30;
  03D1    3030    LDIA	0x30
  03D2    0495    ORR	0x15
  03D3    0008    RET
529:              }
530:              
531:              void fanStop()
532:              {
533:              	PWMD4L = 0;
  03D4    1283    CLRB	0x3,5
  03D5    019B    CLR	0x1B
534:              	PWMCON0 &= 0xEF;
  03D6    1215    CLRB	0x15,4
535:              	PORTA &= 0xEF;
  03D7    1683    SETB	0x3,5
  03D8    1206    CLRB	0x6,4
  03D9    0008    RET
536:              }
537:              
538:              void fanCtr()
539:              {
540:              	if(workStep > 0)
  0288    087B    LD	A,0x7B
  0289    1903    SZB	0x3,2
  028A    2AF7    JP	0x2F7
541:              	{
542:              		PORTA |= 0x02;
  028B    1486    SETB	0x6,1
543:              		u8t maxFanValue = 52;
  028C    3034    LDIA	0x34
  028D    1283    CLRB	0x3,5
  028E    00D7    LD	0x57,A
544:              		if(workStep == 1)
  028F    0B7B    SZDECA	0x7B
  0290    2A93    JP	0x293
545:              		{	
546:              			maxFanValue = 40;
  0291    3028    LDIA	0x28
  0292    00D7    LD	0x57,A
547:              		}
548:              		if(power_ad < 3150)
  0293    300C    LDIA	0xC
  0294    0225    SUBA	0x25
  0295    304E    LDIA	0x4E
  0296    1903    SZB	0x3,2
  0297    0224    SUBA	0x24
  0298    1803    SZB	0x3,0
  0299    2A9C    JP	0x29C
549:              		{
550:              			maxFanValue = 32;
  029A    3020    LDIA	0x20
  029B    00D7    LD	0x57,A
551:              		}
552:              		if(workStep == 3)
  029C    3003    LDIA	0x3
  029D    067B    XORA	0x7B
  029E    1D03    SNZB	0x3,2
  029F    2AA2    JP	0x2A2
553:              		{
554:              			maxFanValue = 10;
  02A0    300A    LDIA	0xA
  02A1    00D7    LD	0x57,A
  02A2    3002    LDIA	0x2
555:              		}
556:              		test_adc = ADC_Sample(2, 0);
  02A3    01F2    CLR	0x72
  02A4    21B7    CALL	0x1B7
  02A5    118A    CLRB	0xA,3
  02A6    00B7    LD	0x37,A
557:              		if (0xA5 == test_adc)
  02A7    30A5    LDIA	0xA5
  02A8    0637    XORA	0x37
  02A9    1D03    SNZB	0x3,2
  02AA    2AD5    JP	0x2D5
558:              		{
559:              			volatile unsigned long fan_temp;
560:              			if(power_ad > 0)
  02AB    0824    LD	A,0x24
  02AC    0425    ORA	0x25
  02AD    1903    SZB	0x3,2
  02AE    2AD5    JP	0x2D5
561:              			{
562:              				fan_temp = ((unsigned long)1UL*adresult * power_ad)/4096;
  02AF    0848    LD	A,0x48
  02B0    00CA    LD	0x4A,A
  02B1    0849    LD	A,0x49
  02B2    00CB    LD	0x4B,A
  02B3    01CC    CLR	0x4C
  02B4    01CD    CLR	0x4D
  02B5    0824    LD	A,0x24
  02B6    00CE    LD	0x4E,A
  02B7    0825    LD	A,0x25
  02B8    00CF    LD	0x4F,A
  02B9    01D0    CLR	0x50
  02BA    01D1    CLR	0x51
  02BB    22FD    CALL	0x2FD
  02BC    118A    CLRB	0xA,3
  02BD    084D    LD	A,0x4D
  02BE    00DB    LD	0x5B,A
  02BF    084C    LD	A,0x4C
  02C0    00DA    LD	0x5A,A
  02C1    084B    LD	A,0x4B
  02C2    00D9    LD	0x59,A
  02C3    084A    LD	A,0x4A
  02C4    00D8    LD	0x58,A
  02C5    300C    LDIA	0xC
  02C6    1003    CLRB	0x3,0
  02C7    0CDB    RRCR	0x5B
  02C8    0CDA    RRCR	0x5A
  02C9    0CD9    RRCR	0x59
  02CA    0CD8    RRCR	0x58
  02CB    3EFF    ADDIA	0xFF
  02CC    1D03    SNZB	0x3,2
  02CD    2AC6    JP	0x2C6
563:              				fanValue = (unsigned int)(fan_temp);
  02CE    0859    LD	A,0x59
  02CF    1683    SETB	0x3,5
  02D0    00CA    LD	0x4A,A
  02D1    1283    CLRB	0x3,5
  02D2    0858    LD	A,0x58
  02D3    1683    SETB	0x3,5
  02D4    00C9    LD	0x49,A
564:              			}
565:              		}
566:              		if(fanValue > 1300)
  02D5    3005    LDIA	0x5
  02D6    1683    SETB	0x3,5
  02D7    024A    SUBA	0x4A
  02D8    3015    LDIA	0x15
  02D9    1903    SZB	0x3,2
  02DA    0249    SUBA	0x49
  02DB    1C03    SNZB	0x3,0
  02DC    2AEA    JP	0x2EA
567:              		{
568:              			if(++fanOverTime > 50)
  02DD    3033    LDIA	0x33
  02DE    1283    CLRB	0x3,5
  02DF    0AC2    INCR	0x42
  02E0    0242    SUBA	0x42
  02E1    1C03    SNZB	0x3,0
  02E2    2AEC    JP	0x2EC
  02E3    30C2    LDIA	0xC2
569:              			{
570:              				fanOverTime = 0;
  02E4    01C2    CLR	0x42
571:              				workStep = 0;
  02E5    01FB    CLR	0x7B
572:              				shanshuoTime = 450;
  02E6    00AE    LD	0x2E,A
  02E7    3001    LDIA	0x1
  02E8    00AF    LD	0x2F,A
  02E9    2AEC    JP	0x2EC
573:              			}
574:              		}
575:              		else
576:              		{
577:              			fanOverTime = 0;
  02EA    1283    CLRB	0x3,5
  02EB    01C2    CLR	0x42
578:              		}
579:              		if(fanDuty < maxFanValue)
  02EC    0857    LD	A,0x57
  02ED    0244    SUBA	0x44
  02EE    1803    SZB	0x3,0
  02EF    2AF2    JP	0x2F2
580:              		{
581:              			fanDuty++;
  02F0    0AC4    INCR	0x44
582:              		}
  02F1    2AF6    JP	0x2F6
583:              		else if(fanDuty > maxFanValue)
  02F2    0844    LD	A,0x44
  02F3    0257    SUBA	0x57
  02F4    1C03    SNZB	0x3,0
584:              		{
585:              			fanDuty--;
  02F5    03C4    DECR	0x44
586:              		}
587:              		fanInit();
  02F6    2BC9    JP	0x3C9
588:              	}
589:              	else
590:              	{
591:              		fanStop();
  02F7    23D4    CALL	0x3D4
592:              		fanDuty = 0;
  02F8    1283    CLRB	0x3,5
  02F9    01C4    CLR	0x44
593:              		PORTA &= 0xFD;
  02FA    1683    SETB	0x3,5
  02FB    1086    CLRB	0x6,1
  02FC    0008    RET
594:              	}
595:              }
596:              
597:              void wuhuaCtr()
598:              {
599:              	if(count1s == 0)
  0E1C    1283    CLRB	0x3,5
  0E1D    0846    LD	A,0x46
  0E1E    1D03    SNZB	0x3,2
  0E1F    2E37    JP	0x637
600:              	{
601:              		if(++count10s >= 20)
  0E20    3014    LDIA	0x14
  0E21    0AC3    INCR	0x43
  0E22    0243    SUBA	0x43
  0E23    1803    SZB	0x3,0
602:              		{
603:              			count10s = 0;
  0E24    01C3    CLR	0x43
604:              		}
605:              		if(workStep == 0 && wuhuaFlag == 0 && powerFlag > 0)
  0E25    087B    LD	A,0x7B
  0E26    1D03    SNZB	0x3,2
  0E27    2E36    JP	0x636
  0E28    0845    LD	A,0x45
  0E29    1D03    SNZB	0x3,2
  0E2A    2E36    JP	0x636
  0E2B    083C    LD	A,0x3C
  0E2C    1903    SZB	0x3,2
  0E2D    2E36    JP	0x636
606:              		{
607:              			if(++closeTime > 200)
  0E2E    30C9    LDIA	0xC9
  0E2F    0ABA    INCR	0x3A
  0E30    023A    SUBA	0x3A
  0E31    1C03    SNZB	0x3,0
  0E32    2E37    JP	0x637
608:              			{
609:              				closeTime = 0;
  0E33    01BA    CLR	0x3A
610:              				powerFlag = 0;
  0E34    01BC    CLR	0x3C
  0E35    2E37    JP	0x637
611:              			}
612:              		}
613:              		else
614:              		{
615:              			closeTime = 0;
  0E36    01BA    CLR	0x3A
616:              		}
617:              	}
618:              	if(wuhuaFlag == 1 || (wuhuaFlag == 2 && count10s < 10))
  0E37    0345    DECA	0x45
  0E38    1903    SZB	0x3,2
  0E39    2E42    JP	0x642
  0E3A    3002    LDIA	0x2
  0E3B    0645    XORA	0x45
  0E3C    1D03    SNZB	0x3,2
  0E3D    2E43    JP	0x643
  0E3E    300A    LDIA	0xA
  0E3F    0243    SUBA	0x43
  0E40    1803    SZB	0x3,0
  0E41    2E43    JP	0x643
619:              	{
620:              		pwmInit();
  0E42    2E44    JP	0x644
621:              		/*
622:              		if(++checkTime > 200)
623:              		{
624:              			if(lowWaterTime > 110)
625:              			{
626:              				//干烧状态
627:              				wuhuaFlag = 0;
628:              				shanshuoTime2 = 450;
629:              			}
630:              			checkTime = 0;
631:              			lowWaterTime = 0;
632:              		}
633:              		
634:              		test_adc = ADC_Sample(2, 0);
635:              		if (0xA5 == test_adc)
636:              		{
637:              			volatile unsigned long wuhua_temp;
638:              			if(power_ad > 0)
639:              			{
640:              				wuhua_temp = (unsigned long)(1UL*adresult * power_ad)/4096;
641:              				wuhuaValue = (unsigned int)(wuhua_temp);
642:              			}
643:              		}
644:              		if(wuhuaValue < 7)
645:              		{
646:              			lowWaterTime++;
647:              		}
648:              		*/
649:              	}
650:              	else
651:              	{
652:              		pwmStop();
  0E43    2E52    JP	0x652
653:              	}
654:              }
655:              
656:              void bujinCtr()
657:              {
658:              	if(bujinFlag || motorStopFlag)
  0F3D    1283    CLRB	0x3,5
  0F3E    083D    LD	A,0x3D
  0F3F    1903    SZB	0x3,2
  0F40    0839    LD	A,0x39
  0F41    1903    SZB	0x3,2
  0F42    2FE3    JP	0x7E3
659:              	{
660:              		//马达启动或者切换原点定位
661:              		if(bujinStartFlag && zeroFlag)
  0F43    0838    LD	A,0x38
  0F44    1903    SZB	0x3,2
  0F45    2F66    JP	0x766
  0F46    086E    LD	A,0x6E
  0F47    1903    SZB	0x3,2
  0F48    2F66    JP	0x766
662:              		{
663:              			bujinStartFlag = 0;
  0F49    01B8    CLR	0x38
664:              			if(bujinFlag == 1)
  0F4A    0B3D    SZDECA	0x3D
  0F4B    2F4F    JP	0x74F
665:              			{
666:              				maxMotorStep = 512;
  0F4C    3002    LDIA	0x2
  0F4D    01EC    CLR	0x6C
  0F4E    2F5C    JP	0x75C
667:              				motorStopFlag = 1;
  0F5D    01B9    CLR	0x39
  0F5E    0AB9    INCR	0x39
668:              			}
669:              			else if(bujinFlag == 2)
  0F4F    3002    LDIA	0x2
  0F50    063D    XORA	0x3D
  0F51    1D03    SNZB	0x3,2
  0F52    2F55    JP	0x755
670:              			{
671:              				maxMotorStep = 1024;
  0F53    3004    LDIA	0x4
  0F54    2F4D    JP	0x74D
672:              				motorStopFlag = 1;
673:              			}
674:              			else if(bujinFlag == 3)
  0F55    3003    LDIA	0x3
  0F56    063D    XORA	0x3D
  0F57    1D03    SNZB	0x3,2
  0F58    2F5F    JP	0x75F
675:              			{
676:              				maxMotorStep = 1696;		//1360 120度
  0F59    30A0    LDIA	0xA0
  0F5A    00EC    LD	0x6C,A
  0F5B    3006    LDIA	0x6
  0F5C    00ED    LD	0x6D,A
677:              				motorStopFlag = 1;
678:              			}
679:              			motorStep = maxMotorStep/2;
  0F5F    086D    LD	A,0x6D
  0F60    00A9    LD	0x29,A
  0F61    086C    LD	A,0x6C
  0F62    00A8    LD	0x28,A
  0F63    1003    CLRB	0x3,0
  0F64    0CA9    RRCR	0x29
  0F65    0CA8    RRCR	0x28
680:              		}
681:              		if(motorStep == maxMotorStep/2 || motorStep == ((maxMotorStep/2) + maxMotorStep))
  0F66    27E9    CALL	0x7E9
  0F67    158A    SETB	0xA,3
  0F68    0CF3    RRCR	0x73
  0F69    0CF2    RRCR	0x72
  0F6A    0829    LD	A,0x29
  0F6B    0673    XORA	0x73
  0F6C    1D03    SNZB	0x3,2
  0F6D    2F70    JP	0x770
  0F6E    0828    LD	A,0x28
  0F6F    0672    XORA	0x72
  0F70    1903    SZB	0x3,2
  0F71    2F85    JP	0x785
  0F72    27E9    CALL	0x7E9
  0F73    158A    SETB	0xA,3
  0F74    0CF3    RRCR	0x73
  0F75    0CF2    RRCR	0x72
  0F76    086C    LD	A,0x6C
  0F77    0772    ADDA	0x72
  0F78    00F4    LD	0x74,A
  0F79    086D    LD	A,0x6D
  0F7A    1803    SZB	0x3,0
  0F7B    0A6D    INCA	0x6D
  0F7C    0773    ADDA	0x73
  0F7D    00F5    LD	0x75,A
  0F7E    0629    XORA	0x29
  0F7F    1D03    SNZB	0x3,2
  0F80    2F83    JP	0x783
  0F81    0828    LD	A,0x28
  0F82    0674    XORA	0x74
  0F83    1D03    SNZB	0x3,2
  0F84    2F8C    JP	0x78C
682:              		{
683:              			zeroFlag = 1;
  0F85    01EE    CLR	0x6E
  0F86    0AEE    INCR	0x6E
684:              			if(bujinFlag == 0)
  0F87    083D    LD	A,0x3D
  0F88    1D03    SNZB	0x3,2
  0F89    2F8D    JP	0x78D
685:              			{
686:              				motorStopFlag = 0;
  0F8A    01B9    CLR	0x39
  0F8B    2F8D    JP	0x78D
687:              			}
688:              		}
689:              		else
690:              		{
691:              			zeroFlag = 0;
  0F8C    01EE    CLR	0x6E
692:              		}
693:              		
694:              		
695:              		if(++motorStep >= (maxMotorStep*2))
  0F8D    27E9    CALL	0x7E9
  0F8E    158A    SETB	0xA,3
  0F8F    0DF2    RLCR	0x72
  0F90    0DF3    RLCR	0x73
  0F91    0AA8    INCR	0x28
  0F92    1903    SZB	0x3,2
  0F93    0AA9    INCR	0x29
  0F94    0873    LD	A,0x73
  0F95    0229    SUBA	0x29
  0F96    1D03    SNZB	0x3,2
  0F97    2F9A    JP	0x79A
  0F98    0872    LD	A,0x72
  0F99    0228    SUBA	0x28
  0F9A    1C03    SNZB	0x3,0
  0F9B    2F9E    JP	0x79E
696:              		{
697:              			motorStep = 0;
  0F9C    01A8    CLR	0x28
  0F9D    01A9    CLR	0x29
698:              		}
699:              		u8t	tempStep = motorStep % 8;
  0F9E    0828    LD	A,0x28
  0F9F    00F6    LD	0x76,A
  0FA0    3007    LDIA	0x7
  0FA1    05F6    ANDR	0x76
700:              		if(motorStep < maxMotorStep)
  0FA2    086D    LD	A,0x6D
  0FA3    0229    SUBA	0x29
  0FA4    1D03    SNZB	0x3,2
  0FA5    2FA8    JP	0x7A8
  0FA6    086C    LD	A,0x6C
  0FA7    0228    SUBA	0x28
  0FA8    1C03    SNZB	0x3,0
  0FA9    2FCB    JP	0x7CB
  0FAA    2FD7    JP	0x7D7
701:              		{
702:              			//正转
703:              			switch(tempStep)
704:              			{
705:              				case 0:
706:              				MOT1 = 1;MOT2 = 0;MOT3 = 0;MOT4 = 0;
  0FAB    27F5    CALL	0x7F5
  0FAC    1386    CLRB	0x6,7
707:              				break;
  0FAD    0008    RET
708:              				case 1:
709:              				MOT1 = 1;MOT2 = 1;MOT3 = 0;MOT4 = 0;
  0FAE    1683    SETB	0x3,5
  0FAF    1686    SETB	0x6,5
710:              				break;
  0FB0    2FFB    JP	0x7FB
711:              				case 2:
712:              				MOT1 = 0;MOT2 = 1;MOT3 = 0;MOT4 = 0;
  0FB1    1683    SETB	0x3,5
  0FB2    1286    CLRB	0x6,5
713:              				break;
  0FB3    2FFB    JP	0x7FB
714:              				case 3:
715:              				MOT1 = 0;MOT2 = 1;MOT3 = 1;MOT4 = 0;
  0FB4    1683    SETB	0x3,5
  0FB5    1286    CLRB	0x6,5
  0FB6    1706    SETB	0x6,6
  0FB7    1786    SETB	0x6,7
  0FB8    1283    CLRB	0x3,5
  0FB9    1386    CLRB	0x6,7
716:              				break;
  0FBA    0008    RET
717:              				case 4:
718:              				MOT1 = 0;MOT2 = 0;MOT3 = 1;MOT4 = 0;
  0FBB    27EF    CALL	0x7EF
  0FBC    1386    CLRB	0x6,7
719:              				break;
  0FBD    0008    RET
720:              				case 5:
721:              				MOT1 = 0;MOT2 = 0;MOT3 = 1;MOT4 = 1;
  0FBE    27EF    CALL	0x7EF
  0FBF    1786    SETB	0x6,7
722:              				break;
  0FC0    0008    RET
723:              				case 6:
724:              				MOT1 = 0;MOT2 = 0;MOT3 = 0;MOT4 = 1;
  0FC1    1683    SETB	0x3,5
  0FC2    1286    CLRB	0x6,5
  0FC3    1306    CLRB	0x6,6
  0FC4    1386    CLRB	0x6,7
  0FC5    1283    CLRB	0x3,5
  0FC6    1786    SETB	0x6,7
725:              				break;
  0FC7    0008    RET
726:              				case 7:
727:              				MOT1 = 1;MOT2 = 0;MOT3 = 0;MOT4 = 1;
  0FC8    27F5    CALL	0x7F5
  0FC9    1786    SETB	0x6,7
728:              				break;
  0FCA    0008    RET
  0FCB    0876    LD	A,0x76
  0FCC    0084    LD	0x4,A
  0FCD    3008    LDIA	0x8
  0FCE    0204    SUBA	0x4
  0FCF    1803    SZB	0x3,0
  0FD0    0008    RET
  0FD1    3008    LDIA	0x8
  0FD2    008A    LD	0xA,A
  0FD3    1003    CLRB	0x3,0
  0FD4    0D04    RLCA	0x4
  0FD5    3E17    ADDIA	0x17
  0FD6    0082    LD	0x2,A
  0FD7    0876    LD	A,0x76
  0FD8    0084    LD	0x4,A
  0FD9    3008    LDIA	0x8
  0FDA    0204    SUBA	0x4
  0FDB    1803    SZB	0x3,0
  0FDC    0008    RET
  0FDD    3008    LDIA	0x8
  0FDE    008A    LD	0xA,A
  0FDF    1003    CLRB	0x3,0
  0FE0    0D04    RLCA	0x4
  0FE1    3E27    ADDIA	0x27
  0FE2    0082    LD	0x2,A
729:              			}
730:              		}
731:              		else
732:              		{
733:              			//反转
734:              			switch(tempStep)
735:              			{
736:              				case 7:
737:              				MOT1 = 1;MOT2 = 0;MOT3 = 0;MOT4 = 0;
738:              				break;
739:              				case 6:
740:              				MOT1 = 1;MOT2 = 1;MOT3 = 0;MOT4 = 0;
741:              				break;
742:              				case 5:
743:              				MOT1 = 0;MOT2 = 1;MOT3 = 0;MOT4 = 0;
744:              				break;
745:              				case 4:
746:              				MOT1 = 0;MOT2 = 1;MOT3 = 1;MOT4 = 0;
747:              				break;
748:              				case 3:
749:              				MOT1 = 0;MOT2 = 0;MOT3 = 1;MOT4 = 0;
750:              				break;
751:              				case 2:
752:              				MOT1 = 0;MOT2 = 0;MOT3 = 1;MOT4 = 1;
753:              				break;
754:              				case 1:
755:              				MOT1 = 0;MOT2 = 0;MOT3 = 0;MOT4 = 1;
756:              				break;
757:              				case 0:
758:              				MOT1 = 1;MOT2 = 0;MOT3 = 0;MOT4 = 1;
759:              				break;
760:              			}
761:              		}
762:              	}
763:              	else
764:              	{
765:              		PORTA &= 0x1F;
  0FE3    301F    LDIA	0x1F
  0FE4    1683    SETB	0x3,5
  0FE5    0586    ANDR	0x6
766:              		PORTB &= 0x7F;
  0FE6    1283    CLRB	0x3,5
  0FE7    1386    CLRB	0x6,7
  0FE8    0008    RET
767:              	}
768:              }
769:              
770:              
771:              void workCtr()
  0025    301F    LDIA	0x1F
772:              {
773:              	test_adc = ADC_Sample(31, 0);		//测试内部基准1.2V相对电源的AD值
  0026    01F2    CLR	0x72
  0027    21B7    CALL	0x1B7
  0028    118A    CLRB	0xA,3
  0029    00B7    LD	0x37,A
774:              	if (0xA5 == test_adc)
  002A    30A5    LDIA	0xA5
  002B    0637    XORA	0x37
  002C    1D03    SNZB	0x3,2
  002D    285F    JP	0x5F
775:              	{
776:              		volatile unsigned long power_temp;
777:              			
778:              		power_temp = (unsigned long)((POWER_RATIO)/adresult);		//1.2*4096/AD=VDD，参数放大1000倍 
  002E    3096    LDIA	0x96
  002F    01D3    CLR	0x53
  0030    00D4    LD	0x54,A
  0031    304A    LDIA	0x4A
  0032    00D5    LD	0x55,A
  0033    0849    LD	A,0x49
  0034    00CE    LD	0x4E,A
  0035    0848    LD	A,0x48
  0036    00CD    LD	0x4D,A
  0037    2169    CALL	0x169
  0038    118A    CLRB	0xA,3
  0039    084D    LD	A,0x4D
  003A    00D0    LD	0x50,A
  003B    084E    LD	A,0x4E
  003C    00D1    LD	0x51,A
  003D    084F    LD	A,0x4F
  003E    00D2    LD	0x52,A
  003F    20AE    CALL	0xAE
  0040    118A    CLRB	0xA,3
  0041    0850    LD	A,0x50
  0042    00DF    LD	0x5F,A
  0043    0851    LD	A,0x51
  0044    00E0    LD	0x60,A
  0045    0852    LD	A,0x52
  0046    00E1    LD	0x61,A
  0047    2110    CALL	0x110
  0048    118A    CLRB	0xA,3
  0049    0862    LD	A,0x62
  004A    1683    SETB	0x3,5
  004B    00CE    LD	0x4E,A
  004C    1283    CLRB	0x3,5
  004D    0861    LD	A,0x61
  004E    1683    SETB	0x3,5
  004F    00CD    LD	0x4D,A
  0050    1283    CLRB	0x3,5
  0051    0860    LD	A,0x60
  0052    1683    SETB	0x3,5
  0053    00CC    LD	0x4C,A
  0054    1283    CLRB	0x3,5
  0055    085F    LD	A,0x5F
  0056    1683    SETB	0x3,5
  0057    00CB    LD	0x4B,A
779:              		power_ad = (unsigned int)(power_temp);		//通过内部基准电压推出芯片VDD电压
  0058    084C    LD	A,0x4C
  0059    1283    CLRB	0x3,5
  005A    00A5    LD	0x25,A
  005B    1683    SETB	0x3,5
  005C    084B    LD	A,0x4B
  005D    1283    CLRB	0x3,5
  005E    00A4    LD	0x24,A
780:              	}
781:              	if(workStep == 2 && power_ad < 3300)
  005F    3002    LDIA	0x2
  0060    067B    XORA	0x7B
  0061    1D03    SNZB	0x3,2
  0062    287A    JP	0x7A
  0063    300C    LDIA	0xC
  0064    0225    SUBA	0x25
  0065    30E4    LDIA	0xE4
  0066    1903    SZB	0x3,2
  0067    0224    SUBA	0x24
  0068    1803    SZB	0x3,0
  0069    287A    JP	0x7A
782:              	{
783:              		if(++lowFanTime > 2000)
  006A    1683    SETB	0x3,5
  006B    0AC5    INCR	0x45
  006C    1903    SZB	0x3,2
  006D    0AC6    INCR	0x46
  006E    3007    LDIA	0x7
  006F    0246    SUBA	0x46
  0070    30D1    LDIA	0xD1
  0071    1903    SZB	0x3,2
  0072    0245    SUBA	0x45
  0073    1C03    SNZB	0x3,0
  0074    287D    JP	0x7D
784:              		{
785:              			lowFanTime = 0;
  0075    01C5    CLR	0x45
  0076    01C6    CLR	0x46
786:              			workStep = 1;
  0077    01FB    CLR	0x7B
  0078    0AFB    INCR	0x7B
  0079    287D    JP	0x7D
787:              		}
788:              	}
789:              	else
790:              	{
791:              		lowFanTime = 0;
  007A    1683    SETB	0x3,5
  007B    01C5    CLR	0x45
  007C    01C6    CLR	0x46
792:              	}	
793:              	if(power_ad < 2900)
  007D    300B    LDIA	0xB
  007E    1283    CLRB	0x3,5
  007F    0225    SUBA	0x25
  0080    3054    LDIA	0x54
  0081    1903    SZB	0x3,2
  0082    0224    SUBA	0x24
  0083    1803    SZB	0x3,0
  0084    2899    JP	0x99
794:              	{
795:              		if(++lowBatTime > 1000)
  0085    1683    SETB	0x3,5
  0086    0AC7    INCR	0x47
  0087    1903    SZB	0x3,2
  0088    0AC8    INCR	0x48
  0089    3003    LDIA	0x3
  008A    0248    SUBA	0x48
  008B    30E9    LDIA	0xE9
  008C    1903    SZB	0x3,2
  008D    0247    SUBA	0x47
  008E    1C03    SNZB	0x3,0
  008F    289C    JP	0x9C
796:              		{
797:              			lowBatTime = 0;
  0090    01C7    CLR	0x47
  0091    01C8    CLR	0x48
798:              			lowBatLock = 1;
  0092    1283    CLRB	0x3,5
  0093    01BE    CLR	0x3E
  0094    0ABE    INCR	0x3E
799:              			workStep = 0;
  0095    01FB    CLR	0x7B
800:              			wuhuaFlag = 0;
  0096    01C5    CLR	0x45
801:              			bujinFlag = 0;
  0097    01BD    CLR	0x3D
  0098    289C    JP	0x9C
802:              		}
803:              	}
804:              	else
805:              	{
806:              		lowBatTime = 0;
  0099    1683    SETB	0x3,5
  009A    01C7    CLR	0x47
  009B    01C8    CLR	0x48
807:              	}
808:              	if(firstTime > 0)
  009C    1683    SETB	0x3,5
  009D    0850    LD	A,0x50
  009E    1903    SZB	0x3,2
  009F    28A6    JP	0xA6
809:              	{
810:              		firstTime--;
  00A0    03D0    DECR	0x50
811:              		PORTB = 0x00;
  00A1    1283    CLRB	0x3,5
  00A2    0186    CLR	0x6
812:              		PORTA = 0x00;
  00A3    1683    SETB	0x3,5
  00A4    0186    CLR	0x6
813:              	}
  00A5    0008    RET
814:              	else
815:              	{
816:              		keyLedCtr();
  00A6    2330    CALL	0x330
  00A7    118A    CLRB	0xA,3
817:              		fanCtr();
  00A8    2288    CALL	0x288
818:              		wuhuaCtr();
  00A9    158A    SETB	0xA,3
  00AA    261C    CALL	0x61C
  00AB    118A    CLRB	0xA,3
819:              		bujinCtr();
  00AC    158A    SETB	0xA,3
  00AD    2F3D    JP	0x73D
820:              		
821:              	}
822:              	
823:              }
824:              
825:              /***********************************************************
826:              主循环
827:              ***********************************************************/
828:              void main()
829:              {
830:              	Init_System();
  0E59    118A    CLRB	0xA,3
  0E5A    2407    CALL	0x407
  0E5B    158A    SETB	0xA,3
  0E5C    30C8    LDIA	0xC8
831:              	firstLock = 1;
  0E5D    01CF    CLR	0x4F
  0E5E    0ACF    INCR	0x4F
832:              	firstTime = 200;
  0E5F    00D0    LD	0x50,A
833:              	while(1)
834:              	{
835:              		if(B_MainLoop)
  0E60    1F78    SNZB	0x78,6
  0E61    2E60    JP	0x660
836:              		{
837:              			B_MainLoop = 0;
  0E62    1378    CLRB	0x78,6
  0E63    0064    CLRWDT
838:              			CLRWDT();
839:              			
840:              			CheckTouchKey();
  0E64    118A    CLRB	0xA,3
  0E65    2453    CALL	0x453
  0E66    158A    SETB	0xA,3
841:              			chrgCtr();
  0E67    158A    SETB	0xA,3
  0E68    25FC    CALL	0x5FC
  0E69    158A    SETB	0xA,3
842:              			Refurbish_Sfr();
  0E6A    118A    CLRB	0xA,3
  0E6B    276B    CALL	0x76B
  0E6C    158A    SETB	0xA,3
843:              			KeyServer();
  0E6D    158A    SETB	0xA,3
  0E6E    2697    CALL	0x697
  0E6F    158A    SETB	0xA,3
844:              			workCtr();
  0E70    118A    CLRB	0xA,3
  0E71    2025    CALL	0x25
  0E72    158A    SETB	0xA,3
845:              			if(firstTime == 0 && chrgFlag == 0 && workStep == 0 && wuhuaFlag == 0 && powerFlag == 0 && keyCount == 0 && bujinFlag == 0 && shanshuoTime == 0 && shanshuoTime2 == 0)
  0E73    1683    SETB	0x3,5
  0E74    0850    LD	A,0x50
  0E75    1D03    SNZB	0x3,2
  0E76    2E60    JP	0x660
  0E77    1283    CLRB	0x3,5
  0E78    0841    LD	A,0x41
  0E79    1D03    SNZB	0x3,2
  0E7A    2E60    JP	0x660
  0E7B    087B    LD	A,0x7B
  0E7C    1D03    SNZB	0x3,2
  0E7D    2E60    JP	0x660
  0E7E    0845    LD	A,0x45
  0E7F    1D03    SNZB	0x3,2
  0E80    2E60    JP	0x660
  0E81    083C    LD	A,0x3C
  0E82    1D03    SNZB	0x3,2
  0E83    2E60    JP	0x660
  0E84    0826    LD	A,0x26
  0E85    0427    ORA	0x27
  0E86    1D03    SNZB	0x3,2
  0E87    2E60    JP	0x660
  0E88    083D    LD	A,0x3D
  0E89    1D03    SNZB	0x3,2
  0E8A    2E60    JP	0x660
  0E8B    082E    LD	A,0x2E
  0E8C    042F    ORA	0x2F
  0E8D    1D03    SNZB	0x3,2
  0E8E    2E60    JP	0x660
  0E8F    082C    LD	A,0x2C
  0E90    042D    ORA	0x2D
  0E91    1D03    SNZB	0x3,2
  0E92    2E60    JP	0x660
846:              			{
847:              				WorkSleep();
  0E93    118A    CLRB	0xA,3
  0E94    2425    CALL	0x425
  0E95    158A    SETB	0xA,3
  0E96    2E60    JP	0x660
848:              			}
849:              		}
850:              	}
851:              }
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\ftdiv.c ----------------------------------------------------------------------
1:                /*	Floating point routines.
2:                
3:                	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:                */
5:                
6:                // this is bigendian code right now. Need to parameterise it.
7:                
8:                #include	"ftarith.h"
9:                
10:               #define	f1_as_dividend	(*(unsigned short long *)&f1)
11:               #define	f2_as_divisor	(*(unsigned short long *)&f2)
12:               #define	f3_as_quot	(*(unsigned short long *)&f3)
13:               
14:               // floating addition
15:               #ifdef _OLDLIB
16:               #define	cntr		sign2
17:               float
18:               #ifdef _PIC18
19:               __ftdiv(float f1, float f2)
20:               #else
21:               __ftdiv(float f2, float f1)
22:               #endif
23:               {
24:               	unsigned char	exp1, exp2, sign1, sign2;
25:               	float	f3;
26:               	
27:               	f3_as_quot = 0;
28:               	sign1 = __ftunpack(&f1_as_dividend, &exp1);
29:               	if(exp1 == 0)
30:               		return f3;
31:               	sign2 = __ftunpack(&f2_as_divisor, &exp2);
32:               	if(exp2 == 0)
33:               		return f3;
34:               	exp1 -= exp2-127+8;	// compute new exponent
35:               	sign1 ^= sign2;
36:               	cntr = 16+8;
37:               	do {
38:               		f3_as_quot <<= 1;
39:               		if(f1_as_dividend >= f2_as_divisor) {
40:               			f1_as_dividend -= f2_as_divisor;
41:               			f3_as_quot |= 1;
42:               		}
43:               		f1_as_dividend <<= 1;
44:               	} while(--cntr != 0);
45:               	__ftpack(&f3_as_quot, exp1);
46:               	if(sign1)
47:               		f3_as_quot |= 0x800000;
48:               	return f3;
49:               }
50:               #else
51:               #define	exp2	sign
52:               float
53:               #ifdef _PIC18
54:               __ftdiv(float f1, float f2)
55:               #else
56:               __ftdiv(float f2, float f1)
  00AE    0853    LD	A,0x53
  00AF    00D6    LD	0x56,A
  00B0    0854    LD	A,0x54
  00B1    00D7    LD	0x57,A
  00B2    0855    LD	A,0x55
  00B3    00D8    LD	0x58,A
  00B4    1003    CLRB	0x3,0
  00B5    0D57    RLCA	0x57
  00B6    0D58    RLCA	0x58
  00B7    00DD    LD	0x5D,A
  00B8    085D    LD	A,0x5D
  00B9    1D03    SNZB	0x3,2
  00BA    28BC    JP	0xBC
  00BB    2C03    JP	0x403
  00BC    0850    LD	A,0x50
  00BD    00D6    LD	0x56,A
  00BE    0851    LD	A,0x51
  00BF    00D7    LD	0x57,A
  00C0    0852    LD	A,0x52
  00C1    00D8    LD	0x58,A
  00C2    1003    CLRB	0x3,0
  00C3    0D57    RLCA	0x57
  00C4    0D58    RLCA	0x58
  00C5    00DE    LD	0x5E,A
  00C6    085E    LD	A,0x5E
  00C7    1D03    SNZB	0x3,2
  00C8    28CA    JP	0xCA
  00C9    2C03    JP	0x403
  00CA    3089    LDIA	0x89
  00CB    01DA    CLR	0x5A
  00CC    01DB    CLR	0x5B
  00CD    01DC    CLR	0x5C
  00CE    075E    ADDA	0x5E
  00CF    00D6    LD	0x56,A
  00D0    02DD    SUBR	0x5D
  00D1    0855    LD	A,0x55
  00D2    00DE    LD	0x5E,A
  00D3    0852    LD	A,0x52
  00D4    06DE    XORR	0x5E
  00D5    3080    LDIA	0x80
  00D6    05DE    ANDR	0x5E
  00D7    3018    LDIA	0x18
  00D8    17D4    SETB	0x54,7
  00D9    01D5    CLR	0x55
  00DA    17D1    SETB	0x51,7
  00DB    01D2    CLR	0x52
  00DC    00D9    LD	0x59,A
  00DD    1003    CLRB	0x3,0
  00DE    0DDA    RLCR	0x5A
  00DF    0DDB    RLCR	0x5B
  00E0    0DDC    RLCR	0x5C
  00E1    0852    LD	A,0x52
  00E2    0255    SUBA	0x55
  00E3    1D03    SNZB	0x3,2
  00E4    28EB    JP	0xEB
  00E5    0851    LD	A,0x51
  00E6    0254    SUBA	0x54
  00E7    1D03    SNZB	0x3,2
  00E8    28EB    JP	0xEB
  00E9    0850    LD	A,0x50
  00EA    0253    SUBA	0x53
  00EB    1C03    SNZB	0x3,0
  00EC    28F9    JP	0xF9
  00ED    0850    LD	A,0x50
  00EE    02D3    SUBR	0x53
  00EF    0851    LD	A,0x51
  00F0    1C03    SNZB	0x3,0
  00F1    0F51    SZINCA	0x51
  00F2    02D4    SUBR	0x54
  00F3    0852    LD	A,0x52
  00F4    1C03    SNZB	0x3,0
  00F5    0A52    INCA	0x52
  00F6    02D5    SUBR	0x55
  00F7    145A    SETB	0x5A,0
  00F8    1003    CLRB	0x3,0
  00F9    0DD3    RLCR	0x53
  00FA    0DD4    RLCR	0x54
  00FB    0DD5    RLCR	0x55
  00FC    0BD9    SZDECR	0x59
  00FD    28DD    JP	0xDD
  00FE    085A    LD	A,0x5A
  00FF    00F2    LD	0x72,A
  0100    085B    LD	A,0x5B
  0101    00F3    LD	0x73,A
  0102    085C    LD	A,0x5C
  0103    00F4    LD	0x74,A
  0104    085D    LD	A,0x5D
  0105    00F5    LD	0x75,A
  0106    085E    LD	A,0x5E
  0107    00F6    LD	0x76,A
  0108    2179    CALL	0x179
  0109    0872    LD	A,0x72
  010A    00D0    LD	0x50,A
  010B    0873    LD	A,0x73
  010C    00D1    LD	0x51,A
  010D    0874    LD	A,0x74
  010E    00D2    LD	0x52,A
  010F    0008    RET
57:               #endif
58:               {
59:               	unsigned char	exp, sign, cntr;
60:               	float	f3;
61:               	
62:               	// unpack the operands
63:               	if((exp = f1_as_dividend >> 15) == 0)
64:               		return 0.0;
65:               	if((exp2 = f2_as_divisor >> 15) == 0)
66:               		return 0.0;
67:               	f3_as_quot = 0;
68:               	exp -= exp2-127+8;	// compute new exponent
69:               	sign = f1_as_dividend >> 16;
70:               	sign ^= (unsigned char)(f2_as_divisor >> 16);
71:               	sign &= 0x80;
72:               	f1_as_dividend |= 0x8000UL;
73:               	f1_as_dividend &= 0xFFFFUL;
74:               	f2_as_divisor |= 0x8000UL;
75:               	f2_as_divisor &= 0xFFFFUL;
76:               	cntr = 16+8;
77:               	do {
78:               		f3_as_quot <<= 1;
79:               		if(f1_as_dividend >= f2_as_divisor) {
80:               			f1_as_dividend -= f2_as_divisor;
81:               			f3_as_quot |= 1;
82:               		}
83:               		f1_as_dividend <<= 1;
84:               	} while(--cntr != 0);
85:               	return __ftpack(f3_as_quot, exp, sign);
86:               }
87:               #endif	
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\fttol.c ----------------------------------------------------------------------
1:                /*	Floating point routines.
2:                
3:                	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:                */
5:                
6:                // this is bigendian code right now. Need to parameterise it.
7:                
8:                #include	"ftarith.h"
9:                
10:               #define	f1_as_mant1	(*(unsigned short long *)&f1)
11:               
12:               // Convert float to long
13:               
14:               #ifdef _OLDLIB
15:               long
16:               __fttol(float f1)
17:               {
18:               	unsigned char	sign1, exp1;
19:               	unsigned long	lval;
20:               
21:               	sign1 = __ftunpack(&f1_as_mant1, &exp1);
22:               	lval = f1_as_mant1;
23:               	exp1 -= 127+15;
24:               	if((signed char)exp1 < 0) {
25:               		if((signed char)exp1 < -15)
26:               			return 0;
27:               		do
28:               			lval >>= 1;
29:               		while(++exp1 != 0);
30:               	} else {
31:               		if(exp1 >= 32)
32:               			return 00;
33:               		while(exp1 != 0) {
34:               			lval <<= 1;
35:               			exp1--;
36:               		}
37:               	}
38:               	if(sign1)
39:               		lval = -lval;
40:               	return lval;
41:               }
42:               #else
43:               long
44:               __fttol(float f1)
  0110    23F2    CALL	0x3F2
  0111    118A    CLRB	0xA,3
  0112    1003    CLRB	0x3,0
  0113    0D64    RLCA	0x64
  0114    0D65    RLCA	0x65
  0115    00EB    LD	0x6B,A
  0116    086B    LD	A,0x6B
  0117    1D03    SNZB	0x3,2
  0118    291E    JP	0x11E
  0119    01DF    CLR	0x5F
  011A    01E0    CLR	0x60
  011B    01E1    CLR	0x61
  011C    01E2    CLR	0x62
  011D    0008    RET
  011E    23F2    CALL	0x3F2
  011F    118A    CLRB	0xA,3
  0120    3017    LDIA	0x17
  0121    1003    CLRB	0x3,0
  0122    0CE5    RRCR	0x65
  0123    0CE4    RRCR	0x64
  0124    0CE3    RRCR	0x63
  0125    3EFF    ADDIA	0xFF
  0126    1D03    SNZB	0x3,2
  0127    2921    JP	0x121
  0128    0863    LD	A,0x63
  0129    00E6    LD	0x66,A
  012A    17E0    SETB	0x60,7
  012B    01E1    CLR	0x61
  012C    085F    LD	A,0x5F
  012D    00E7    LD	0x67,A
  012E    0860    LD	A,0x60
  012F    00E8    LD	0x68,A
  0130    0861    LD	A,0x61
  0131    00E9    LD	0x69,A
  0132    308E    LDIA	0x8E
  0133    01EA    CLR	0x6A
  0134    02EB    SUBR	0x6B
  0135    1FEB    SNZB	0x6B,7
  0136    2944    JP	0x144
  0137    086B    LD	A,0x6B
  0138    3A80    XORIA	0x80
  0139    3E8F    ADDIA	0x8F
  013A    1C03    SNZB	0x3,0
  013B    2919    JP	0x119
  013C    1003    CLRB	0x3,0
  013D    0CEA    RRCR	0x6A
  013E    0CE9    RRCR	0x69
  013F    0CE8    RRCR	0x68
  0140    0CE7    RRCR	0x67
  0141    0FEB    SZINCR	0x6B
  0142    293C    JP	0x13C
  0143    2952    JP	0x152
  0144    3018    LDIA	0x18
  0145    026B    SUBA	0x6B
  0146    1803    SZB	0x3,0
  0147    2919    JP	0x119
  0148    086B    LD	A,0x6B
  0149    1903    SZB	0x3,2
  014A    2952    JP	0x152
  014B    1003    CLRB	0x3,0
  014C    0DE7    RLCR	0x67
  014D    0DE8    RLCR	0x68
  014E    0DE9    RLCR	0x69
  014F    0DEA    RLCR	0x6A
  0150    03EB    DECR	0x6B
  0151    2948    JP	0x148
  0152    0866    LD	A,0x66
  0153    1903    SZB	0x3,2
  0154    2960    JP	0x160
  0155    09E7    COMR	0x67
  0156    09E8    COMR	0x68
  0157    09E9    COMR	0x69
  0158    09EA    COMR	0x6A
  0159    0AE7    INCR	0x67
  015A    1903    SZB	0x3,2
  015B    0AE8    INCR	0x68
  015C    1903    SZB	0x3,2
  015D    0AE9    INCR	0x69
  015E    1903    SZB	0x3,2
  015F    0AEA    INCR	0x6A
  0160    086A    LD	A,0x6A
  0161    00E2    LD	0x62,A
  0162    0869    LD	A,0x69
  0163    00E1    LD	0x61,A
  0164    0868    LD	A,0x68
  0165    00E0    LD	0x60,A
  0166    0867    LD	A,0x67
  0167    00DF    LD	0x5F,A
  0168    0008    RET
45:               {
46:               	unsigned char	sign1, exp1;
47:               	unsigned long	lval;
48:               
49:               	if((exp1 = f1_as_mant1 >> 15) == 0)
50:               		return 0;
51:               	sign1 = f1_as_mant1 >> 23;
52:               	f1_as_mant1 |= 0x8000UL;
53:               	f1_as_mant1 &= 0xFFFFUL;
54:               	lval = f1_as_mant1;
55:               	exp1 -= 127+15;
56:               	if((signed char)exp1 < 0) {
57:               		if((signed char)exp1 < -15)
58:               			return 0;
59:               		do
60:               			lval >>= 1;
61:               		while(++exp1 != 0);
62:               	} else {
63:               		if(exp1 >= 24)
64:               			return 0;
65:               		while(exp1 != 0) {
66:               			lval <<= 1;
67:               			exp1--;
68:               		}
69:               	}
70:               	if(sign1)
71:               		lval = -lval;
72:               	return lval;
73:               }
74:               #endif
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\lwtoft.c ----------------------------------------------------------------------
1:                /*	Floating point routines.
2:                
3:                	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:                */
5:                
6:                // this is bigendian code right now. Need to parameterise it.
7:                
8:                #include	"ftarith.h"
9:                
10:               
11:               // Convert unsigned int to float
12:               
13:               #ifdef _OLDLIB
14:               #define	f1_as_mant1	(*(unsigned short long *)&f1)
15:               float
16:               __lwtoft(unsigned int c)
17:               {
18:               	float	f1;
19:               	
20:               	if(c == 0)
21:               		return 0.0;
22:               	f1_as_mant1 = c;
23:               	__ftpack(&f1_as_mant1, 127+15);
24:               	return f1;
25:               }
26:               #else
27:               float
28:               __lwtoft(unsigned int c)
  0169    084D    LD	A,0x4D
  016A    00F2    LD	0x72,A
  016B    084E    LD	A,0x4E
  016C    00F3    LD	0x73,A
  016D    308E    LDIA	0x8E
  016E    01F4    CLR	0x74
  016F    00F5    LD	0x75,A
  0170    01F6    CLR	0x76
  0171    2179    CALL	0x179
  0172    0872    LD	A,0x72
  0173    00CD    LD	0x4D,A
  0174    0873    LD	A,0x73
  0175    00CE    LD	0x4E,A
  0176    0874    LD	A,0x74
  0177    00CF    LD	0x4F,A
  0178    0008    RET
29:               {
30:               	return __ftpack(c, 127+15, 0);
31:               }
32:               #endif
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\float.c ----------------------------------------------------------------------
1:                /*	Floating point routines.
2:                
3:                	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:                */
5:                
6:                #include	"ftarith.h"
7:                
8:                
9:                //	unpack the operand pointed to. Store the exponent into the location pointed to by exp,
10:               //	and return the sign (zero is positive)
11:               
12:               #ifdef _OLDLIB
13:               
14:               unsigned char
15:               __ftunpack(unsigned short long * arg, unsigned char * exp)
16:               {
17:               	unsigned char	sign;
18:               
19:               	*exp = sign = *arg >> 15;
20:               	if(sign == 0) {
21:               		*arg = 0;
22:               		return 0;
23:               	}
24:               	sign = 0;
25:               	*arg |= 0x8000;
26:               	if(*arg & 0x800000)
27:               		sign++;
28:               	*arg &= 0xFFFF;
29:               	return sign;
30:               }
31:               
32:               // normalize and pack the supplied argument into floating point format
33:               
34:               void
35:               __ftpack(unsigned short long * arg, unsigned char exp)
36:               {
37:               	if(exp == 0 || *arg == 0) {
38:               		*arg = 0;
39:               		return;
40:               	}
41:               	while(*arg & 0xFE0000UL) {
42:               		exp++;
43:               		*arg >>= 1;
44:               	}
45:               	while(*arg & 0xFF0000UL) {
46:               		exp++;
47:               		(*arg)++;
48:               		*arg >>= 1;
49:               	}
50:               	while(!(*arg & 0x8000UL)) {
51:               		exp--;
52:               		*arg <<= 1;
53:               	}
54:               	if(!(exp & 1))
55:               		*arg &= ~0x8000L;
56:               	exp >>= 1;
57:               	*arg |= (unsigned short long)exp << 16;
58:               }
59:               
60:               #else
61:               float
62:               __ftpack(unsigned short long arg, unsigned char exp, unsigned char sign)
  0179    0875    LD	A,0x75
  017A    1903    SZB	0x3,2
  017B    2981    JP	0x181
  017C    0874    LD	A,0x74
  017D    0473    ORA	0x73
  017E    0472    ORA	0x72
  017F    1D03    SNZB	0x3,2
  0180    2988    JP	0x188
  0181    01F2    CLR	0x72
  0182    01F3    CLR	0x73
  0183    01F4    CLR	0x74
  0184    0008    RET
  0185    0AF5    INCR	0x75
  0186    23F9    CALL	0x3F9
  0187    118A    CLRB	0xA,3
  0188    30FE    LDIA	0xFE
  0189    0574    ANDA	0x74
  018A    1903    SZB	0x3,2
  018B    2995    JP	0x195
  018C    2985    JP	0x185
  018D    0AF5    INCR	0x75
  018E    0AF2    INCR	0x72
  018F    1903    SZB	0x3,2
  0190    0AF3    INCR	0x73
  0191    1903    SZB	0x3,2
  0192    0AF4    INCR	0x74
  0193    23F9    CALL	0x3F9
  0194    118A    CLRB	0xA,3
  0195    30FF    LDIA	0xFF
  0196    0574    ANDA	0x74
  0197    1903    SZB	0x3,2
  0198    29A3    JP	0x1A3
  0199    298D    JP	0x18D
  019A    3002    LDIA	0x2
  019B    0275    SUBA	0x75
  019C    1C03    SNZB	0x3,0
  019D    29A5    JP	0x1A5
  019E    03F5    DECR	0x75
  019F    1003    CLRB	0x3,0
  01A0    0DF2    RLCR	0x72
  01A1    0DF3    RLCR	0x73
  01A2    0DF4    RLCR	0x74
  01A3    1FF3    SNZB	0x73,7
  01A4    299A    JP	0x19A
  01A5    1C75    SNZB	0x75,0
  01A6    13F3    CLRB	0x73,7
  01A7    1003    CLRB	0x3,0
  01A8    0CF5    RRCR	0x75
  01A9    0875    LD	A,0x75
  01AA    00CC    LD	0x4C,A
  01AB    01CB    CLR	0x4B
  01AC    01CA    CLR	0x4A
  01AD    084A    LD	A,0x4A
  01AE    04F2    ORR	0x72
  01AF    084B    LD	A,0x4B
  01B0    04F3    ORR	0x73
  01B1    084C    LD	A,0x4C
  01B2    04F4    ORR	0x74
  01B3    0876    LD	A,0x76
  01B4    1D03    SNZB	0x3,2
  01B5    17F4    SETB	0x74,7
  01B6    0008    RET
63:               {
64:               	if(exp == 0 || arg == 0)
65:               		return 0.0;
66:               	while(arg & 0xFE0000UL) {
67:               		exp++;
68:               		arg >>= 1;
69:               	}
70:               	while(arg & 0xFF0000UL) {
71:               		exp++;
72:               		(arg)++;
73:               		arg >>= 1;
74:               	}
75:               	while(!(arg & 0x8000UL) && exp > 1) {
76:               		exp--;
77:               		arg <<= 1;
78:               	}
79:               	if(!(exp & 1))
80:               		arg &= ~0x8000L;
81:               	exp >>= 1;
82:               	arg |= (unsigned short long)exp << 16;
83:               	if (sign)
84:               		arg |= 0x800000UL;
85:                  return *(float*)&arg;	
86:               }
87:               
88:               #endif
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\Umul32.c ----------------------------------------------------------------------
1:                // 32 x 32 bit multiplication with 32 bit result
2:                #ifdef _PIC18
3:                #define _Has_hardware_multiply 1
4:                #else
5:                #define _Has_hardware_multiply 0
6:                #endif
7:                
8:                #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:                #define _Has_large_call_stack 1
10:               #else
11:               #define _Has_large_call_stack 0
12:               #endif
13:               
14:               unsigned long
15:               __lmul(unsigned long multiplier, unsigned long multiplicand)
  02FD    01F2    CLR	0x72
  02FE    01F3    CLR	0x73
  02FF    01F4    CLR	0x74
  0300    01F5    CLR	0x75
  0301    1C4A    SNZB	0x4A,0
  0302    2B17    JP	0x317
  0303    084E    LD	A,0x4E
  0304    07F2    ADDR	0x72
  0305    084F    LD	A,0x4F
  0306    1103    CLRB	0x3,2
  0307    1803    SZB	0x3,0
  0308    3E01    ADDIA	0x1
  0309    1D03    SNZB	0x3,2
  030A    07F3    ADDR	0x73
  030B    0850    LD	A,0x50
  030C    1103    CLRB	0x3,2
  030D    1803    SZB	0x3,0
  030E    3E01    ADDIA	0x1
  030F    1D03    SNZB	0x3,2
  0310    07F4    ADDR	0x74
  0311    0851    LD	A,0x51
  0312    1103    CLRB	0x3,2
  0313    1803    SZB	0x3,0
  0314    3E01    ADDIA	0x1
  0315    1D03    SNZB	0x3,2
  0316    07F5    ADDR	0x75
  0317    1003    CLRB	0x3,0
  0318    0DCE    RLCR	0x4E
  0319    0DCF    RLCR	0x4F
  031A    0DD0    RLCR	0x50
  031B    0DD1    RLCR	0x51
  031C    1003    CLRB	0x3,0
  031D    0CCD    RRCR	0x4D
  031E    0CCC    RRCR	0x4C
  031F    0CCB    RRCR	0x4B
  0320    0CCA    RRCR	0x4A
  0321    084D    LD	A,0x4D
  0322    044C    ORA	0x4C
  0323    044B    ORA	0x4B
  0324    044A    ORA	0x4A
  0325    1D03    SNZB	0x3,2
  0326    2B01    JP	0x301
  0327    0875    LD	A,0x75
  0328    00CD    LD	0x4D,A
  0329    0874    LD	A,0x74
  032A    00CC    LD	0x4C,A
  032B    0873    LD	A,0x73
  032C    00CB    LD	0x4B,A
  032D    0872    LD	A,0x72
  032E    00CA    LD	0x4A,A
  032F    0008    RET
16:               {
17:               	unsigned long product;
18:               
19:               #define LOWBYTE(x)  (*(unsigned char *)(&x))
20:               #define LMIDBYTE(x) (*(((unsigned char *)(&x))+1))
21:               #define HMIDBYTE(x) (*(((unsigned char *)(&x))+2))
22:               #define HIGHBYTE(x) (*(((unsigned char *)(&x))+3))
23:               
24:               #if (_Has_hardware_multiply || _Has_large_call_stack) && defined(__OPTIMIZE_SPEED__)
25:               	{
26:               
27:               #define USE_SHRINK
28:               
29:               /*
30:               a 32-bit multiply can be decomposed into the sum of ten 8-bit multiplies
31:                            a  b  c  d
32:               *            e  f  g  h
33:               -----------------------
34:                          |         dh
35:                          |      ch  0
36:                          |   bh  0  0
37:                          |ah  0  0  0
38:                          |      dg  0
39:                          |   cg  0  0
40:                          |bg  0  0  0
41:                        ag| 0  0  0  0 (we ignore this intermediate product
42:                                        because it does not affect the low 32 bits of the result)
43:                          |   df  0  0
44:                          |cf  0  0  0
45:                        bf| 0  0  0  0 (ignore)
46:                     af  0| 0  0  0  0 (ignore)
47:                          |de  0  0  0
48:                        ce| 0  0  0  0 (ignore)
49:                     be  0| 0  0  0  0 (ignore)
50:               +  ae  0  0| 0  0  0  0 (ignore)
51:               =======================
52:                */
53:               		product =  (unsigned int)LOWBYTE(multiplier) * LOWBYTE(multiplicand);
54:               
55:               #if defined(USE_MASKS)
56:               		product += ((unsigned long)
57:               			     ((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand))
58:               			     +
59:               			     ((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
60:               			<< 8;
61:               
62:               		product += ((unsigned long)
63:               			    ((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand))
64:               			    +
65:               			    ((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
66:               			    +
67:               			    ((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
68:               			<< 16;
69:               
70:               		/* cast to smaller type to avoid adding high bits just to discard */
71:               		product += ((unsigned long)
72:               			    (unsigned char)
73:               			    ((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand))
74:               			    +
75:               			    (unsigned char)
76:               			    ((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand))
77:               			    +
78:               			    (unsigned char)
79:               			    ((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
80:               			    +
81:               			    (unsigned char)
82:               			    ((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand)))
83:               			<< 24;
84:               
85:               #elif defined(USE_SHRINK)
86:               		/* add direct to upper bytes, rather than shift and add all bytes */
87:               		*((unsigned short long*)(((unsigned char*)&product)+1)) +=
88:               			((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand));
89:               		*((unsigned short long*)(((unsigned char*)&product)+1)) +=
90:               			((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand));
91:               
92:               
93:               		*((unsigned int*)(((unsigned char*)&product)+2)) +=
94:               			((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand));
95:               		*((unsigned int*)(((unsigned char*)&product)+2)) +=
96:               			((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
97:               		*((unsigned int*)(((unsigned char*)&product)+2)) +=
98:               			((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand));
99:               
100:              		*(((unsigned char*)&product)+3) +=
101:              			(unsigned char)
102:              			((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand));
103:              		*(((unsigned char*)&product)+3) +=
104:              			(unsigned char)
105:              			((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand));
106:              		*(((unsigned char*)&product)+3) +=
107:              			(unsigned char)
108:              			((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
109:              		*(((unsigned char*)&product)+3) +=
110:              			(unsigned char)
111:              			((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand));
112:              
113:              #else
114:              #error No method chosen
115:              #endif
116:              	}
117:              #else
118:              
119:              	product = 0;
120:              	do {
121:              		if(multiplier & 1)
122:              			product += multiplicand;
123:              		multiplicand <<= 1;
124:              		multiplier >>= 1;
125:              	} while(multiplier != 0);
126:              
127:              #endif
128:              	return product;
129:              }
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\lwmod.c ----------------------------------------------------------------------
1:                // word unsigned modulus
2:                
3:                unsigned int
4:                #ifdef __PICC__
5:                #warning TODO: update cgpic and this file to use the other prototype
6:                __lwmod(unsigned int divisor, unsigned int dividend)
  03A5    0872    LD	A,0x72
  03A6    0473    ORA	0x73
  03A7    1903    SZB	0x3,2
  03A8    2BC4    JP	0x3C4
  03A9    01F6    CLR	0x76
  03AA    0AF6    INCR	0x76
  03AB    1BF3    SZB	0x73,7
  03AC    2BB1    JP	0x3B1
  03AD    1003    CLRB	0x3,0
  03AE    0DF2    RLCR	0x72
  03AF    0DF3    RLCR	0x73
  03B0    2BAA    JP	0x3AA
  03B1    0873    LD	A,0x73
  03B2    0275    SUBA	0x75
  03B3    1D03    SNZB	0x3,2
  03B4    2BB7    JP	0x3B7
  03B5    0872    LD	A,0x72
  03B6    0274    SUBA	0x74
  03B7    1C03    SNZB	0x3,0
  03B8    2BC0    JP	0x3C0
  03B9    0872    LD	A,0x72
  03BA    02F4    SUBR	0x74
  03BB    0873    LD	A,0x73
  03BC    1C03    SNZB	0x3,0
  03BD    03F5    DECR	0x75
  03BE    02F5    SUBR	0x75
  03BF    1003    CLRB	0x3,0
  03C0    0CF3    RRCR	0x73
  03C1    0CF2    RRCR	0x72
  03C2    0BF6    SZDECR	0x76
  03C3    2BB1    JP	0x3B1
  03C4    0875    LD	A,0x75
  03C5    00F3    LD	0x73,A
  03C6    0874    LD	A,0x74
  03C7    00F2    LD	0x72,A
  03C8    0008    RET
7:                #else
8:                __lwmod(unsigned int dividend, unsigned int divisor)
9:                #endif
10:               {
11:               	unsigned char	counter;
12:               
13:               	if(divisor != 0) {
14:               		counter = 1;
15:               		while((divisor & 0x8000) == 0) {
16:               			divisor <<= 1;
17:               			counter++;
18:               		}
19:               		do {
20:               			if(divisor <= dividend)
21:               				dividend -= divisor;
22:               			divisor >>= 1;
23:               		} while(--counter != 0);
24:               	}
25:               	return dividend;
26:               }
---- library_code ------------------------------------------------------------------
  0453    1A78    SZB	0x78,4
  0454    2C61    JP	0x461
  0455    2510    CALL	0x510
  0456    118A    CLRB	0xA,3
  0457    3008    LDIA	0x8
  0458    1283    CLRB	0x3,5
  0459    1303    CLRB	0x3,6
  045A    0AB4    INCR	0x34
  045B    0234    SUBA	0x34
  045C    1C03    SNZB	0x3,0
  045D    2C7F    JP	0x47F
  045E    01B4    CLR	0x34
  045F    1678    SETB	0x78,4
  0460    2C7F    JP	0x47F
  0461    19F8    SZB	0x78,3
  0462    2C79    JP	0x479
  0463    257F    CALL	0x57F
  0464    118A    CLRB	0xA,3
  0465    2714    CALL	0x714
  0466    118A    CLRB	0xA,3
  0467    15F8    SETB	0x78,3
  0468    18F8    SZB	0x78,1
  0469    2C70    JP	0x470
  046A    3002    LDIA	0x2
  046B    1283    CLRB	0x3,5
  046C    1303    CLRB	0x3,6
  046D    0234    SUBA	0x34
  046E    1C03    SNZB	0x3,0
  046F    2C75    JP	0x475
  0470    2700    CALL	0x700
  0471    118A    CLRB	0xA,3
  0472    10F8    CLRB	0x78,1
  0473    1278    CLRB	0x78,4
  0474    11F8    CLRB	0x78,3
  0475    1283    CLRB	0x3,5
  0476    1303    CLRB	0x3,6
  0477    01B4    CLR	0x34
  0478    2C7F    JP	0x47F
  0479    2698    CALL	0x698
  047A    118A    CLRB	0xA,3
  047B    2570    CALL	0x570
  047C    118A    CLRB	0xA,3
  047D    1278    CLRB	0x78,4
  047E    11F8    CLRB	0x78,3
  047F    2F45    JP	0x745
  0480    0064    CLRWDT
  0481    1683    SETB	0x3,5
  0482    1303    CLRB	0x3,6
  0483    0181    CLR	0x1
  0484    3007    LDIA	0x7
  0485    1283    CLRB	0x3,5
  0486    0481    ORR	0x1
  0487    1581    SETB	0x1,3
  0488    0064    CLRWDT
  0489    300A    LDIA	0xA
  048A    1283    CLRB	0x3,5
  048B    1303    CLRB	0x3,6
  048C    0081    LD	0x1,A
  048D    0064    CLRWDT
  048E    1283    CLRB	0x3,5
  048F    1703    SETB	0x3,6
  0490    0191    CLR	0x11
  0491    0193    CLR	0x13
  0492    3002    LDIA	0x2
  0493    1303    CLRB	0x3,6
  0494    0094    LD	0x14,A
  0495    0063    STOP
  0496    0000    NOP
  0497    0064    CLRWDT
  0498    3072    LDIA	0x72
  0499    1283    CLRB	0x3,5
  049A    1303    CLRB	0x3,6
  049B    0094    LD	0x14,A
  049C    3079    LDIA	0x79
  049D    1703    SETB	0x3,6
  049E    0093    LD	0x13,A
  049F    2570    CALL	0x570
  04A0    118A    CLRB	0xA,3
  04A1    1478    SETB	0x78,0
  04A2    2510    CALL	0x510
  04A3    118A    CLRB	0xA,3
  04A4    1283    CLRB	0x3,5
  04A5    1303    CLRB	0x3,6
  04A6    27D7    CALL	0x7D7
  04A7    118A    CLRB	0xA,3
  04A8    1C0B    SNZB	0xB,0
  04A9    188B    SZB	0xB,1
  04AA    2CAD    JP	0x4AD
  04AB    1D8D    SNZB	0xD,3
  04AC    2CB4    JP	0x4B4
  04AD    2570    CALL	0x570
  04AE    1283    CLRB	0x3,5
  04AF    1303    CLRB	0x3,6
  04B0    01B4    CLR	0x34
  04B1    1278    CLRB	0x78,4
  04B2    11F8    CLRB	0x78,3
  04B3    0008    RET
  04B4    0850    LD	A,0x50
  04B5    3907    ANDIA	0x7
  04B6    1003    CLRB	0x3,0
  04B7    1903    SZB	0x3,2
  04B8    2D0A    JP	0x50A
  04B9    0D52    RLCA	0x52
  04BA    3EB8    ADDIA	0xB8
  04BB    0084    LD	0x4,A
  04BC    1383    CLRB	0x3,7
  04BD    0800    LD	A,0x0
  04BE    00CE    LD	0x4E,A
  04BF    0A84    INCR	0x4
  04C0    0800    LD	A,0x0
  04C1    00CF    LD	0x4F,A
  04C2    00CD    LD	0x4D,A
  04C3    084E    LD	A,0x4E
  04C4    00CC    LD	0x4C,A
  04C5    084E    LD	A,0x4E
  04C6    044F    ORA	0x4F
  04C7    1903    SZB	0x3,2
  04C8    2D09    JP	0x509
  04C9    0852    LD	A,0x52
  04CA    3E09    ADDIA	0x9
  04CB    0084    LD	0x4,A
  04CC    158A    SETB	0xA,3
  04CD    2000    CALL	0x0
  04CE    118A    CLRB	0xA,3
  04CF    07CC    ADDR	0x4C
  04D0    1803    SZB	0x3,0
  04D1    0ACD    INCR	0x4D
  04D2    1003    CLRB	0x3,0
  04D3    0D52    RLCA	0x52
  04D4    3EA6    ADDIA	0xA6
  04D5    27B6    CALL	0x7B6
  04D6    118A    CLRB	0xA,3
  04D7    084D    LD	A,0x4D
  04D8    024B    SUBA	0x4B
  04D9    1D03    SNZB	0x3,2
  04DA    2CDD    JP	0x4DD
  04DB    084C    LD	A,0x4C
  04DC    024A    SUBA	0x4A
  04DD    1C03    SNZB	0x3,0
  04DE    2CF1    JP	0x4F1
  04DF    27D7    CALL	0x7D7
  04E0    118A    CLRB	0xA,3
  04E1    0850    LD	A,0x50
  04E2    3907    ANDIA	0x7
  04E3    1D03    SNZB	0x3,2
  04E4    2CE8    JP	0x4E8
  04E5    0852    LD	A,0x52
  04E6    2675    CALL	0x675
  04E7    118A    CLRB	0xA,3
  04E8    1283    CLRB	0x3,5
  04E9    3003    LDIA	0x3
  04EA    1303    CLRB	0x3,6
  04EB    1003    CLRB	0x3,0
  04EC    27DC    CALL	0x7DC
  04ED    118A    CLRB	0xA,3
  04EE    1803    SZB	0x3,0
  04EF    2CAD    JP	0x4AD
  04F0    2CE1    JP	0x4E1
  04F1    0D52    RLCA	0x52
  04F2    3EAC    ADDIA	0xAC
  04F3    27B6    CALL	0x7B6
  04F4    118A    CLRB	0xA,3
  04F5    1003    CLRB	0x3,0
  04F6    0D52    RLCA	0x52
  04F7    3EA6    ADDIA	0xA6
  04F8    27A0    CALL	0x7A0
  04F9    118A    CLRB	0xA,3
  04FA    0800    LD	A,0x0
  04FB    00CA    LD	0x4A,A
  04FC    0A84    INCR	0x4
  04FD    0800    LD	A,0x0
  04FE    00CB    LD	0x4B,A
  04FF    1003    CLRB	0x3,0
  0500    0D52    RLCA	0x52
  0501    3EAC    ADDIA	0xAC
  0502    27A0    CALL	0x7A0
  0503    118A    CLRB	0xA,3
  0504    084E    LD	A,0x4E
  0505    0080    LD	0x0,A
  0506    0A84    INCR	0x4
  0507    084F    LD	A,0x4F
  0508    0080    LD	0x0,A
  0509    1003    CLRB	0x3,0
  050A    3003    LDIA	0x3
  050B    27DC    CALL	0x7DC
  050C    118A    CLRB	0xA,3
  050D    1803    SZB	0x3,0
  050E    2C80    JP	0x480
  050F    2CB4    JP	0x4B4
  0510    01F7    CLR	0x77
  0511    01F5    CLR	0x75
  0512    0AF5    INCR	0x75
  0513    01F6    CLR	0x76
  0514    1C78    SNZB	0x78,0
  0515    2D1A    JP	0x51A
  0516    0875    LD	A,0x75
  0517    3907    ANDIA	0x7
  0518    1903    SZB	0x3,2
  0519    2D66    JP	0x566
  051A    1283    CLRB	0x3,5
  051B    1703    SETB	0x3,6
  051C    0191    CLR	0x11
  051D    0192    CLR	0x12
  051E    3079    LDIA	0x79
  051F    0093    LD	0x13,A
  0520    1303    CLRB	0x3,6
  0521    1305    CLRB	0x5,6
  0522    1306    CLRB	0x6,6
  0523    0000    NOP
  0524    0000    NOP
  0525    0000    NOP
  0526    0000    NOP
  0527    0000    NOP
  0528    0000    NOP
  0529    0000    NOP
  052A    0000    NOP
  052B    1283    CLRB	0x3,5
  052C    1303    CLRB	0x3,6
  052D    1705    SETB	0x5,6
  052E    0877    LD	A,0x77
  052F    3E0C    ADDIA	0xC
  0530    0084    LD	0x4,A
  0531    158A    SETB	0xA,3
  0532    2000    CALL	0x0
  0533    118A    CLRB	0xA,3
  0534    1703    SETB	0x3,6
  0535    0091    LD	0x11,A
  0536    0877    LD	A,0x77
  0537    3E0F    ADDIA	0xF
  0538    0084    LD	0x4,A
  0539    158A    SETB	0xA,3
  053A    2000    CALL	0x0
  053B    118A    CLRB	0xA,3
  053C    0092    LD	0x12,A
  053D    0000    NOP
  053E    0000    NOP
  053F    0000    NOP
  0540    0000    NOP
  0541    1283    CLRB	0x3,5
  0542    1703    SETB	0x3,6
  0543    1411    SETB	0x11,0
  0544    30D0    LDIA	0xD0
  0545    00F3    LD	0x73,A
  0546    3007    LDIA	0x7
  0547    00F4    LD	0x74,A
  0548    1B91    SZB	0x11,7
  0549    2D56    JP	0x556
  054A    3001    LDIA	0x1
  054B    02F3    SUBR	0x73
  054C    1C03    SNZB	0x3,0
  054D    03F4    DECR	0x74
  054E    0873    LD	A,0x73
  054F    0474    ORA	0x74
  0550    1D03    SNZB	0x3,2
  0551    2D48    JP	0x548
  0552    30FF    LDIA	0xFF
  0553    1303    CLRB	0x3,6
  0554    00B4    LD	0x34,A
  0555    2D70    JP	0x570
  0556    1003    CLRB	0x3,0
  0557    0D77    RLCA	0x77
  0558    3EB8    ADDIA	0xB8
  0559    0084    LD	0x4,A
  055A    0816    LD	A,0x16
  055B    1383    CLRB	0x3,7
  055C    0780    ADDR	0x0
  055D    0F84    SZINCR	0x4
  055E    0800    LD	A,0x0
  055F    1803    SZB	0x3,0
  0560    0A00    INCA	0x0
  0561    00FF    LD	0x7F,A
  0562    0817    LD	A,0x17
  0563    077F    ADDA	0x7F
  0564    0080    LD	0x0,A
  0565    0384    DECR	0x4
  0566    3003    LDIA	0x3
  0567    1003    CLRB	0x3,0
  0568    0DF5    RLCR	0x75
  0569    0DF6    RLCR	0x76
  056A    0AF7    INCR	0x77
  056B    0277    SUBA	0x77
  056C    1C03    SNZB	0x3,0
  056D    2D14    JP	0x514
  056E    1078    CLRB	0x78,0
  056F    0008    RET
  0570    01F2    CLR	0x72
  0571    1003    CLRB	0x3,0
  0572    0D72    RLCA	0x72
  0573    3EB8    ADDIA	0xB8
  0574    0084    LD	0x4,A
  0575    3003    LDIA	0x3
  0576    1383    CLRB	0x3,7
  0577    0180    CLR	0x0
  0578    0A84    INCR	0x4
  0579    0180    CLR	0x0
  057A    0AF2    INCR	0x72
  057B    0272    SUBA	0x72
  057C    1803    SZB	0x3,0
  057D    0008    RET
  057E    2D71    JP	0x571
  057F    1283    CLRB	0x3,5
  0580    1303    CLRB	0x3,6
  0581    01D6    CLR	0x56
  0582    01A0    CLR	0x20
  0583    01A1    CLR	0x21
  0584    01B3    CLR	0x33
  0585    0856    LD	A,0x56
  0586    3907    ANDIA	0x7
  0587    3E01    ADDIA	0x1
  0588    0084    LD	0x4,A
  0589    158A    SETB	0xA,3
  058A    2000    CALL	0x0
  058B    118A    CLRB	0xA,3
  058C    00D0    LD	0x50,A
  058D    1003    CLRB	0x3,0
  058E    0D56    RLCA	0x56
  058F    3EB8    ADDIA	0xB8
  0590    0084    LD	0x4,A
  0591    3003    LDIA	0x3
  0592    0A84    INCR	0x4
  0593    1003    CLRB	0x3,0
  0594    1383    CLRB	0x3,7
  0595    0C80    RRCR	0x0
  0596    0384    DECR	0x4
  0597    0C80    RRCR	0x0
  0598    3EFF    ADDIA	0xFF
  0599    1D03    SNZB	0x3,2
  059A    2D92    JP	0x592
  059B    1003    CLRB	0x3,0
  059C    0D56    RLCA	0x56
  059D    3EB8    ADDIA	0xB8
  059E    0084    LD	0x4,A
  059F    0800    LD	A,0x0
  05A0    00D4    LD	0x54,A
  05A1    0A84    INCR	0x4
  05A2    0800    LD	A,0x0
  05A3    00D5    LD	0x55,A
  05A4    0856    LD	A,0x56
  05A5    3E09    ADDIA	0x9
  05A6    0084    LD	0x4,A
  05A7    158A    SETB	0xA,3
  05A8    2000    CALL	0x0
  05A9    118A    CLRB	0xA,3
  05AA    00D3    LD	0x53,A
  05AB    00D1    LD	0x51,A
  05AC    01D2    CLR	0x52
  05AD    0854    LD	A,0x54
  05AE    07D1    ADDR	0x51
  05AF    1803    SZB	0x3,0
  05B0    0AD2    INCR	0x52
  05B1    0855    LD	A,0x55
  05B2    07D2    ADDR	0x52
  05B3    0856    LD	A,0x56
  05B4    2665    CALL	0x665
  05B5    118A    CLRB	0xA,3
  05B6    3A00    XORIA	0x0
  05B7    1D03    SNZB	0x3,2
  05B8    2E16    JP	0x616
  05B9    1283    CLRB	0x3,5
  05BA    1303    CLRB	0x3,6
  05BB    1003    CLRB	0x3,0
  05BC    0D56    RLCA	0x56
  05BD    3EA6    ADDIA	0xA6
  05BE    0084    LD	0x4,A
  05BF    1383    CLRB	0x3,7
  05C0    0800    LD	A,0x0
  05C1    00CE    LD	0x4E,A
  05C2    0A84    INCR	0x4
  05C3    0800    LD	A,0x0
  05C4    00CF    LD	0x4F,A
  05C5    1003    CLRB	0x3,0
  05C6    0D56    RLCA	0x56
  05C7    3EA0    ADDIA	0xA0
  05C8    2799    CALL	0x799
  05C9    118A    CLRB	0xA,3
  05CA    0252    SUBA	0x52
  05CB    1D03    SNZB	0x3,2
  05CC    2DCF    JP	0x5CF
  05CD    084A    LD	A,0x4A
  05CE    0251    SUBA	0x51
  05CF    1803    SZB	0x3,0
  05D0    2DDE    JP	0x5DE
  05D1    1003    CLRB	0x3,0
  05D2    0D56    RLCA	0x56
  05D3    3EA0    ADDIA	0xA0
  05D4    2799    CALL	0x799
  05D5    118A    CLRB	0xA,3
  05D6    0854    LD	A,0x54
  05D7    024A    SUBA	0x4A
  05D8    00D4    LD	0x54,A
  05D9    0855    LD	A,0x55
  05DA    1C03    SNZB	0x3,0
  05DB    0A55    INCA	0x55
  05DC    024B    SUBA	0x4B
  05DD    2E02    JP	0x602
  05DE    084F    LD	A,0x4F
  05DF    0252    SUBA	0x52
  05E0    1D03    SNZB	0x3,2
  05E1    2DE4    JP	0x5E4
  05E2    084E    LD	A,0x4E
  05E3    0251    SUBA	0x51
  05E4    1803    SZB	0x3,0
  05E5    2E5D    JP	0x65D
  05E6    1003    CLRB	0x3,0
  05E7    0D56    RLCA	0x56
  05E8    3EAC    ADDIA	0xAC
  05E9    2799    CALL	0x799
  05EA    118A    CLRB	0xA,3
  05EB    0252    SUBA	0x52
  05EC    1D03    SNZB	0x3,2
  05ED    2DF0    JP	0x5F0
  05EE    084A    LD	A,0x4A
  05EF    0251    SUBA	0x51
  05F0    1803    SZB	0x3,0
  05F1    2E5D    JP	0x65D
  05F2    1003    CLRB	0x3,0
  05F3    0D56    RLCA	0x56
  05F4    3EA0    ADDIA	0xA0
  05F5    0084    LD	0x4,A
  05F6    084E    LD	A,0x4E
  05F7    0080    LD	0x0,A
  05F8    0A84    INCR	0x4
  05F9    084F    LD	A,0x4F
  05FA    0080    LD	0x0,A
  05FB    0854    LD	A,0x54
  05FC    024E    SUBA	0x4E
  05FD    00D4    LD	0x54,A
  05FE    0855    LD	A,0x55
  05FF    1C03    SNZB	0x3,0
  0600    0A55    INCA	0x55
  0601    024F    SUBA	0x4F
  0602    00D5    LD	0x55,A
  0603    0856    LD	A,0x56
  0604    3EBE    ADDIA	0xBE
  0605    0084    LD	0x4,A
  0606    0180    CLR	0x0
  0607    0855    LD	A,0x55
  0608    1903    SZB	0x3,2
  0609    2E0C    JP	0x60C
  060A    30FF    LDIA	0xFF
  060B    2E0D    JP	0x60D
  060C    0854    LD	A,0x54
  060D    00D3    LD	0x53,A
  060E    0233    SUBA	0x33
  060F    1803    SZB	0x3,0
  0610    2E14    JP	0x614
  0611    0853    LD	A,0x53
  0612    00B3    LD	0x33,A
  0613    2E57    JP	0x657
  0614    0AB4    INCR	0x34
  0615    2E5D    JP	0x65D
  0616    1283    CLRB	0x3,5
  0617    1303    CLRB	0x3,6
  0618    1003    CLRB	0x3,0
  0619    0D56    RLCA	0x56
  061A    3EA0    ADDIA	0xA0
  061B    0084    LD	0x4,A
  061C    1383    CLRB	0x3,7
  061D    0800    LD	A,0x0
  061E    00CA    LD	0x4A,A
  061F    0A84    INCR	0x4
  0620    0800    LD	A,0x0
  0621    00CB    LD	0x4B,A
  0622    084A    LD	A,0x4A
  0623    3E01    ADDIA	0x1
  0624    00CC    LD	0x4C,A
  0625    084B    LD	A,0x4B
  0626    1803    SZB	0x3,0
  0627    3E01    ADDIA	0x1
  0628    00CD    LD	0x4D,A
  0629    0852    LD	A,0x52
  062A    024D    SUBA	0x4D
  062B    1D03    SNZB	0x3,2
  062C    2E2F    JP	0x62F
  062D    0851    LD	A,0x51
  062E    024C    SUBA	0x4C
  062F    1C03    SNZB	0x3,0
  0630    2E5D    JP	0x65D
  0631    1003    CLRB	0x3,0
  0632    0D56    RLCA	0x56
  0633    3EA6    ADDIA	0xA6
  0634    0084    LD	0x4,A
  0635    0800    LD	A,0x0
  0636    2787    CALL	0x787
  0637    118A    CLRB	0xA,3
  0638    1C03    SNZB	0x3,0
  0639    2E43    JP	0x643
  063A    1003    CLRB	0x3,0
  063B    0D56    RLCA	0x56
  063C    3EAC    ADDIA	0xAC
  063D    0084    LD	0x4,A
  063E    0800    LD	A,0x0
  063F    2787    CALL	0x787
  0640    118A    CLRB	0xA,3
  0641    1803    SZB	0x3,0
  0642    2E4F    JP	0x64F
  0643    0856    LD	A,0x56
  0644    3EBE    ADDIA	0xBE
  0645    0084    LD	0x4,A
  0646    3009    LDIA	0x9
  0647    0A80    INCR	0x0
  0648    0200    SUBA	0x0
  0649    1C03    SNZB	0x3,0
  064A    2E53    JP	0x653
  064B    0856    LD	A,0x56
  064C    2675    CALL	0x675
  064D    118A    CLRB	0xA,3
  064E    2E5D    JP	0x65D
  064F    0856    LD	A,0x56
  0650    3EBE    ADDIA	0xBE
  0651    0084    LD	0x4,A
  0652    0180    CLR	0x0
  0653    0821    LD	A,0x21
  0654    0420    ORA	0x20
  0655    1D03    SNZB	0x3,2
  0656    2E5D    JP	0x65D
  0657    0850    LD	A,0x50
  0658    00F2    LD	0x72,A
  0659    01F3    CLR	0x73
  065A    0856    LD	A,0x56
  065B    268A    CALL	0x68A
  065C    118A    CLRB	0xA,3
  065D    3003    LDIA	0x3
  065E    1283    CLRB	0x3,5
  065F    1303    CLRB	0x3,6
  0660    0AD6    INCR	0x56
  0661    0256    SUBA	0x56
  0662    1803    SZB	0x3,0
  0663    0008    RET
  0664    2D85    JP	0x585
  0665    00F3    LD	0x73,A
  0666    3907    ANDIA	0x7
  0667    3E01    ADDIA	0x1
  0668    0084    LD	0x4,A
  0669    158A    SETB	0xA,3
  066A    2000    CALL	0x0
  066B    118A    CLRB	0xA,3
  066C    00F2    LD	0x72,A
  066D    1DF3    SNZB	0x73,3
  066E    2E71    JP	0x671
  066F    087A    LD	A,0x7A
  0670    2E72    JP	0x672
  0671    0879    LD	A,0x79
  0672    05F2    ANDR	0x72
  0673    0872    LD	A,0x72
  0674    0008    RET
  0675    00F2    LD	0x72,A
  0676    1003    CLRB	0x3,0
  0677    0D72    RLCA	0x72
  0678    3EB2    ADDIA	0xB2
  0679    0084    LD	0x4,A
  067A    1383    CLRB	0x3,7
  067B    27C5    CALL	0x7C5
  067C    118A    CLRB	0xA,3
  067D    3EAC    ADDIA	0xAC
  067E    0084    LD	0x4,A
  067F    27C5    CALL	0x7C5
  0680    118A    CLRB	0xA,3
  0681    3EA6    ADDIA	0xA6
  0682    0084    LD	0x4,A
  0683    27C5    CALL	0x7C5
  0684    3EA0    ADDIA	0xA0
  0685    0084    LD	0x4,A
  0686    0180    CLR	0x0
  0687    0A84    INCR	0x4
  0688    0180    CLR	0x0
  0689    0008    RET
  068A    00F4    LD	0x74,A
  068B    1283    CLRB	0x3,5
  068C    1303    CLRB	0x3,6
  068D    0AB4    INCR	0x34
  068E    01A0    CLR	0x20
  068F    01A1    CLR	0x21
  0690    1DF4    SNZB	0x74,3
  0691    2E95    JP	0x695
  0692    0872    LD	A,0x72
  0693    00A1    LD	0x21,A
  0694    0008    RET
  0695    0872    LD	A,0x72
  0696    00A0    LD	0x20,A
  0697    0008    RET
  0698    1283    CLRB	0x3,5
  0699    3004    LDIA	0x4
  069A    1303    CLRB	0x3,6
  069B    01CE    CLR	0x4E
  069C    0AB2    INCR	0x32
  069D    0232    SUBA	0x32
  069E    1C03    SNZB	0x3,0
  069F    0008    RET
  06A0    01B2    CLR	0x32
  06A1    1003    CLRB	0x3,0
  06A2    0D4E    RLCA	0x4E
  06A3    3EB8    ADDIA	0xB8
  06A4    0084    LD	0x4,A
  06A5    1383    CLRB	0x3,7
  06A6    0800    LD	A,0x0
  06A7    00CA    LD	0x4A,A
  06A8    0A84    INCR	0x4
  06A9    0800    LD	A,0x0
  06AA    00CB    LD	0x4B,A
  06AB    084E    LD	A,0x4E
  06AC    2665    CALL	0x665
  06AD    118A    CLRB	0xA,3
  06AE    3A00    XORIA	0x0
  06AF    1D03    SNZB	0x3,2
  06B0    2EE7    JP	0x6E7
  06B1    1283    CLRB	0x3,5
  06B2    1303    CLRB	0x3,6
  06B3    1003    CLRB	0x3,0
  06B4    0D4E    RLCA	0x4E
  06B5    3EB2    ADDIA	0xB2
  06B6    0084    LD	0x4,A
  06B7    1383    CLRB	0x3,7
  06B8    2779    CALL	0x779
  06B9    118A    CLRB	0xA,3
  06BA    1903    SZB	0x3,2
  06BB    024C    SUBA	0x4C
  06BC    1C03    SNZB	0x3,0
  06BD    2EC4    JP	0x6C4
  06BE    0F4C    SZINCA	0x4C
  06BF    2EE7    JP	0x6E7
  06C0    0A4D    INCA	0x4D
  06C1    1D03    SNZB	0x3,2
  06C2    2EE7    JP	0x6E7
  06C3    1003    CLRB	0x3,0
  06C4    0D4E    RLCA	0x4E
  06C5    3EAC    ADDIA	0xAC
  06C6    0084    LD	0x4,A
  06C7    2779    CALL	0x779
  06C8    118A    CLRB	0xA,3
  06C9    1903    SZB	0x3,2
  06CA    024C    SUBA	0x4C
  06CB    1C03    SNZB	0x3,0
  06CC    2ED3    JP	0x6D3
  06CD    0F4C    SZINCA	0x4C
  06CE    2EE7    JP	0x6E7
  06CF    0A4D    INCA	0x4D
  06D0    1D03    SNZB	0x3,2
  06D1    2EE7    JP	0x6E7
  06D2    1003    CLRB	0x3,0
  06D3    0D4E    RLCA	0x4E
  06D4    3EA6    ADDIA	0xA6
  06D5    0084    LD	0x4,A
  06D6    2779    CALL	0x779
  06D7    118A    CLRB	0xA,3
  06D8    1903    SZB	0x3,2
  06D9    024C    SUBA	0x4C
  06DA    1C03    SNZB	0x3,0
  06DB    2EE2    JP	0x6E2
  06DC    0F4C    SZINCA	0x4C
  06DD    2EE7    JP	0x6E7
  06DE    0A4D    INCA	0x4D
  06DF    1D03    SNZB	0x3,2
  06E0    2EE7    JP	0x6E7
  06E1    1003    CLRB	0x3,0
  06E2    0D4E    RLCA	0x4E
  06E3    3EA0    ADDIA	0xA0
  06E4    0084    LD	0x4,A
  06E5    27D1    CALL	0x7D1
  06E6    118A    CLRB	0xA,3
  06E7    1283    CLRB	0x3,5
  06E8    1303    CLRB	0x3,6
  06E9    1003    CLRB	0x3,0
  06EA    0D4E    RLCA	0x4E
  06EB    3EAC    ADDIA	0xAC
  06EC    0084    LD	0x4,A
  06ED    1383    CLRB	0x3,7
  06EE    27BD    CALL	0x7BD
  06EF    118A    CLRB	0xA,3
  06F0    3EA6    ADDIA	0xA6
  06F1    27AB    CALL	0x7AB
  06F2    118A    CLRB	0xA,3
  06F3    27BD    CALL	0x7BD
  06F4    118A    CLRB	0xA,3
  06F5    3EAC    ADDIA	0xAC
  06F6    27AB    CALL	0x7AB
  06F7    118A    CLRB	0xA,3
  06F8    27D1    CALL	0x7D1
  06F9    118A    CLRB	0xA,3
  06FA    3003    LDIA	0x3
  06FB    0ACE    INCR	0x4E
  06FC    024E    SUBA	0x4E
  06FD    1803    SZB	0x3,0
  06FE    0008    RET
  06FF    2EA1    JP	0x6A1
  0700    01F9    CLR	0x79
  0701    01FA    CLR	0x7A
  0702    01F3    CLR	0x73
  0703    1003    CLRB	0x3,0
  0704    0D73    RLCA	0x73
  0705    3EB8    ADDIA	0xB8
  0706    0084    LD	0x4,A
  0707    1383    CLRB	0x3,7
  0708    0180    CLR	0x0
  0709    0A84    INCR	0x4
  070A    0180    CLR	0x0
  070B    0873    LD	A,0x73
  070C    2675    CALL	0x675
  070D    118A    CLRB	0xA,3
  070E    3003    LDIA	0x3
  070F    0AF3    INCR	0x73
  0710    0273    SUBA	0x73
  0711    1803    SZB	0x3,0
  0712    0008    RET
  0713    2F03    JP	0x703
  0714    1283    CLRB	0x3,5
  0715    1303    CLRB	0x3,6
  0716    0821    LD	A,0x21
  0717    0420    ORA	0x20
  0718    1903    SZB	0x3,2
  0719    2F38    JP	0x738
  071A    01B0    CLR	0x30
  071B    0820    LD	A,0x20
  071C    0622    XORA	0x22
  071D    1D03    SNZB	0x3,2
  071E    2F31    JP	0x731
  071F    0821    LD	A,0x21
  0720    0623    XORA	0x23
  0721    1D03    SNZB	0x3,2
  0722    2F31    JP	0x731
  0723    3002    LDIA	0x2
  0724    0AB1    INCR	0x31
  0725    0231    SUBA	0x31
  0726    1C03    SNZB	0x3,0
  0727    0008    RET
  0728    01B1    CLR	0x31
  0729    0820    LD	A,0x20
  072A    00F9    LD	0x79,A
  072B    0821    LD	A,0x21
  072C    00FA    LD	0x7A,A
  072D    1978    SZB	0x78,2
  072E    0008    RET
  072F    1578    SETB	0x78,2
  0730    2F5B    JP	0x75B
  0731    1178    CLRB	0x78,2
  0732    0820    LD	A,0x20
  0733    00A2    LD	0x22,A
  0734    0821    LD	A,0x21
  0735    00A3    LD	0x23,A
  0736    01B1    CLR	0x31
  0737    0008    RET
  0738    01B1    CLR	0x31
  0739    01A2    CLR	0x22
  073A    01A3    CLR	0x23
  073B    3002    LDIA	0x2
  073C    0AB0    INCR	0x30
  073D    0230    SUBA	0x30
  073E    1C03    SNZB	0x3,0
  073F    0008    RET
  0740    01B0    CLR	0x30
  0741    01F9    CLR	0x79
  0742    01FA    CLR	0x7A
  0743    1178    CLRB	0x78,2
  0744    0008    RET
  0745    087A    LD	A,0x7A
  0746    0479    ORA	0x79
  0747    1903    SZB	0x3,2
  0748    2F56    JP	0x756
  0749    1683    SETB	0x3,5
  074A    1303    CLRB	0x3,6
  074B    0AC1    INCR	0x41
  074C    1903    SZB	0x3,2
  074D    0AC2    INCR	0x42
  074E    303A    LDIA	0x3A
  074F    0242    SUBA	0x42
  0750    3098    LDIA	0x98
  0751    1903    SZB	0x3,2
  0752    0241    SUBA	0x41
  0753    1C03    SNZB	0x3,0
  0754    0008    RET
  0755    14F8    SETB	0x78,1
  0756    1683    SETB	0x3,5
  0757    1303    CLRB	0x3,6
  0758    01C1    CLR	0x41
  0759    01C2    CLR	0x42
  075A    0008    RET
  075B    01F4    CLR	0x74
  075C    0874    LD	A,0x74
  075D    2665    CALL	0x665
  075E    118A    CLRB	0xA,3
  075F    3A00    XORIA	0x0
  0760    1D03    SNZB	0x3,2
  0761    2F65    JP	0x765
  0762    0874    LD	A,0x74
  0763    2675    CALL	0x675
  0764    118A    CLRB	0xA,3
  0765    3003    LDIA	0x3
  0766    0AF4    INCR	0x74
  0767    0274    SUBA	0x74
  0768    1803    SZB	0x3,0
  0769    0008    RET
  076A    2F5C    JP	0x75C
---- stringtab ------------------------------------------------------------------
  0800    3008    LDIA	0x8
  0801    008A    LD	0xA,A
  0802    0804    LD	A,0x4
  0803    0A84    INCR	0x4
  0804    0782    ADDR	0x2
  0805    3400    RET	0x0
---- reset_enter ------------------------------------------------------------------
  0000    118A    CLRB	0xA,3
  0001    280B    JP	0xB
  000B    118A    CLRB	0xA,3
  000C    280D    JP	0xD
---- start_initialization ------------------------------------------------------------------
  000D    3002    LDIA	0x2
  000E    01EC    CLR	0x6C
  000F    00ED    LD	0x6D,A
  0010    3001    LDIA	0x1
  0011    00EE    LD	0x6E,A
  0012    30A0    LDIA	0xA0
  0013    1383    CLRB	0x3,7
  0014    0084    LD	0x4,A
  0015    30CB    LDIA	0xCB
  0016    158A    SETB	0xA,3
  0017    25F4    CALL	0x5F4
  0018    118A    CLRB	0xA,3
  0019    3020    LDIA	0x20
  001A    0084    LD	0x4,A
  001B    304A    LDIA	0x4A
  001C    158A    SETB	0xA,3
  001D    25F4    CALL	0x5F4
  001E    01F9    CLR	0x79
  001F    01FA    CLR	0x7A
  0020    01FB    CLR	0x7B
  0021    01F8    CLR	0x78
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F0    LD	0x70,A
  0007    080A    LD	A,0xA
  0008    00F1    LD	0x71,A
  0009    118A    CLRB	0xA,3
  000A    2FE1    JP	0x7E1
---- common_function ------------------------------------------------------------------
  0022    0183    CLR	0x3
  0023    158A    SETB	0xA,3
  0024    2E59    JP	0x659
  03DA    00F4    LD	0x74,A
  03DB    01F5    CLR	0x75
  03DC    01F6    CLR	0x76
  03DD    0873    LD	A,0x73
  03DE    02CD    SUBR	0x4D
  03DF    0874    LD	A,0x74
  03E0    1C03    SNZB	0x3,0
  03E1    0F74    SZINCA	0x74
  03E2    02CE    SUBR	0x4E
  03E3    0875    LD	A,0x75
  03E4    1C03    SNZB	0x3,0
  03E5    0F75    SZINCA	0x75
  03E6    02CF    SUBR	0x4F
  03E7    0876    LD	A,0x76
  03E8    0008    RET
  03E9    01CD    CLR	0x4D
  03EA    01CE    CLR	0x4E
  03EB    01CF    CLR	0x4F
  03EC    01D0    CLR	0x50
  03ED    01D1    CLR	0x51
  03EE    01D2    CLR	0x52
  03EF    01D3    CLR	0x53
  03F0    01D4    CLR	0x54
  03F1    0008    RET
  03F2    085F    LD	A,0x5F
  03F3    00E3    LD	0x63,A
  03F4    0860    LD	A,0x60
  03F5    00E4    LD	0x64,A
  03F6    0861    LD	A,0x61
  03F7    00E5    LD	0x65,A
  03F8    0008    RET
  03F9    1003    CLRB	0x3,0
  03FA    0CF4    RRCR	0x74
  03FB    0CF3    RRCR	0x73
  03FC    0CF2    RRCR	0x72
  03FD    0008    RET
  03FE    0856    LD	A,0x56
  03FF    00D4    LD	0x54,A
  0400    0855    LD	A,0x55
  0401    00D3    LD	0x53,A
  0402    0008    RET
  0403    01D0    CLR	0x50
  0404    01D1    CLR	0x51
  0405    01D2    CLR	0x52
  0406    0008    RET
  0779    0800    LD	A,0x0
  077A    00CC    LD	0x4C,A
  077B    0A84    INCR	0x4
  077C    0800    LD	A,0x0
  077D    00CD    LD	0x4D,A
  077E    084A    LD	A,0x4A
  077F    02CC    SUBR	0x4C
  0780    084B    LD	A,0x4B
  0781    1C03    SNZB	0x3,0
  0782    03CD    DECR	0x4D
  0783    02CD    SUBR	0x4D
  0784    3000    LDIA	0x0
  0785    024D    SUBA	0x4D
  0786    3402    RET	0x2
  0787    00CA    LD	0x4A,A
  0788    0A84    INCR	0x4
  0789    0800    LD	A,0x0
  078A    00CB    LD	0x4B,A
  078B    0853    LD	A,0x53
  078C    074A    ADDA	0x4A
  078D    00CC    LD	0x4C,A
  078E    084B    LD	A,0x4B
  078F    1803    SZB	0x3,0
  0790    0A4B    INCA	0x4B
  0791    00CD    LD	0x4D,A
  0792    0855    LD	A,0x55
  0793    024D    SUBA	0x4D
  0794    1D03    SNZB	0x3,2
  0795    0008    RET
  0796    0854    LD	A,0x54
  0797    024C    SUBA	0x4C
  0798    0008    RET
  0799    0084    LD	0x4,A
  079A    0800    LD	A,0x0
  079B    00CA    LD	0x4A,A
  079C    0A84    INCR	0x4
  079D    0800    LD	A,0x0
  079E    00CB    LD	0x4B,A
  079F    0008    RET
  07A0    0084    LD	0x4,A
  07A1    084A    LD	A,0x4A
  07A2    0080    LD	0x0,A
  07A3    0A84    INCR	0x4
  07A4    084B    LD	A,0x4B
  07A5    0080    LD	0x0,A
  07A6    1003    CLRB	0x3,0
  07A7    0D52    RLCA	0x52
  07A8    3EB2    ADDIA	0xB2
  07A9    0084    LD	0x4,A
  07AA    0008    RET
  07AB    0084    LD	0x4,A
  07AC    0874    LD	A,0x74
  07AD    0080    LD	0x0,A
  07AE    0A84    INCR	0x4
  07AF    0875    LD	A,0x75
  07B0    0080    LD	0x0,A
  07B1    1003    CLRB	0x3,0
  07B2    0D4E    RLCA	0x4E
  07B3    3EB2    ADDIA	0xB2
  07B4    0084    LD	0x4,A
  07B5    0008    RET
  07B6    0084    LD	0x4,A
  07B7    0800    LD	A,0x0
  07B8    00CA    LD	0x4A,A
  07B9    0A84    INCR	0x4
  07BA    0800    LD	A,0x0
  07BB    00CB    LD	0x4B,A
  07BC    0008    RET
  07BD    0800    LD	A,0x0
  07BE    00F4    LD	0x74,A
  07BF    0A84    INCR	0x4
  07C0    0800    LD	A,0x0
  07C1    00F5    LD	0x75,A
  07C2    1003    CLRB	0x3,0
  07C3    0D4E    RLCA	0x4E
  07C4    0008    RET
  07C5    0180    CLR	0x0
  07C6    0A84    INCR	0x4
  07C7    0180    CLR	0x0
  07C8    1003    CLRB	0x3,0
  07C9    0D72    RLCA	0x72
  07CA    0008    RET
  07CB    3041    LDIA	0x41
  07CC    1683    SETB	0x3,5
  07CD    0095    LD	0x15,A
  07CE    1415    SETB	0x15,0
  07CF    0196    CLR	0x16
  07D0    0008    RET
  07D1    084A    LD	A,0x4A
  07D2    0080    LD	0x0,A
  07D3    0A84    INCR	0x4
  07D4    084B    LD	A,0x4B
  07D5    0080    LD	0x0,A
  07D6    0008    RET
  07D7    01D2    CLR	0x52
  07D8    01D0    CLR	0x50
  07D9    0AD0    INCR	0x50
  07DA    01D1    CLR	0x51
  07DB    0008    RET
  07DC    0DD0    RLCR	0x50
  07DD    0DD1    RLCR	0x51
  07DE    0AD2    INCR	0x52
  07DF    0252    SUBA	0x52
  07E0    0008    RET
  0806    3401    RET	0x1
  0807    3402    RET	0x2
  0808    3404    RET	0x4
  0809    3408    RET	0x8
  080A    3410    RET	0x10
  080B    3420    RET	0x20
  080C    3440    RET	0x40
  080D    3480    RET	0x80
  080E    340A    RET	0xA
  080F    340A    RET	0xA
  0810    340A    RET	0xA
  0811    3402    RET	0x2
  0812    3402    RET	0x2
  0813    3402    RET	0x2
  0814    3444    RET	0x44
  0815    3443    RET	0x43
  0816    3442    RET	0x42
  0817    158A    SETB	0xA,3
  0818    2FAB    JP	0x7AB
  0819    158A    SETB	0xA,3
  081A    2FAE    JP	0x7AE
  081B    158A    SETB	0xA,3
  081C    2FB1    JP	0x7B1
  081D    158A    SETB	0xA,3
  081E    2FB4    JP	0x7B4
  081F    158A    SETB	0xA,3
  0820    2FBB    JP	0x7BB
  0821    158A    SETB	0xA,3
  0822    2FBE    JP	0x7BE
  0823    158A    SETB	0xA,3
  0824    2FC1    JP	0x7C1
  0825    158A    SETB	0xA,3
  0826    2FC8    JP	0x7C8
  0827    158A    SETB	0xA,3
  0828    2FC8    JP	0x7C8
  0829    158A    SETB	0xA,3
  082A    2FC1    JP	0x7C1
  082B    158A    SETB	0xA,3
  082C    2FBE    JP	0x7BE
  082D    158A    SETB	0xA,3
  082E    2FBB    JP	0x7BB
  082F    158A    SETB	0xA,3
  0830    2FB4    JP	0x7B4
  0831    158A    SETB	0xA,3
  0832    2FB1    JP	0x7B1
  0833    158A    SETB	0xA,3
  0834    2FAE    JP	0x7AE
  0835    158A    SETB	0xA,3
  0836    2FAB    JP	0x7AB
  0DF4    0064    CLRWDT
  0DF5    0180    CLR	0x0
  0DF6    0A84    INCR	0x4
  0DF7    0604    XORA	0x4
  0DF8    1903    SZB	0x3,2
  0DF9    3400    RET	0x0
  0DFA    0604    XORA	0x4
  0DFB    2DF5    JP	0x5F5
  0F38    30C2    LDIA	0xC2
  0F39    00AE    LD	0x2E,A
  0F3A    3001    LDIA	0x1
  0F3B    00AF    LD	0x2F,A
  0F3C    0008    RET
  0FE9    086D    LD	A,0x6D
  0FEA    00F3    LD	0x73,A
  0FEB    086C    LD	A,0x6C
  0FEC    00F2    LD	0x72,A
  0FED    1003    CLRB	0x3,0
  0FEE    0008    RET
  0FEF    1683    SETB	0x3,5
  0FF0    1286    CLRB	0x6,5
  0FF1    1306    CLRB	0x6,6
  0FF2    1786    SETB	0x6,7
  0FF3    1283    CLRB	0x3,5
  0FF4    0008    RET
  0FF5    1683    SETB	0x3,5
  0FF6    1686    SETB	0x6,5
  0FF7    1306    CLRB	0x6,6
  0FF8    1386    CLRB	0x6,7
  0FF9    1283    CLRB	0x3,5
  0FFA    0008    RET
  0FFB    1706    SETB	0x6,6
  0FFC    1386    CLRB	0x6,7
  0FFD    1283    CLRB	0x3,5
  0FFE    1386    CLRB	0x6,7
