---- C:\mcuproject\scm\zdt\D108_8F083_tssop20_\D108_8F083_tssop20_\main.c ----------------------------------------------------------------------
1:                #include <sc.h>
2:                #include "Touch_Kscan_Library.h"
3:                
4:                #ifndef _XTAL_FREQ
5:                #define _XTAL_FREQ 8000000			//8MHz,使用内置延时函数必须定义主频，
6:                									//如用16M需改此参数为16000000
7:                #endif
8:                #define     POWER_RATIO  	(4096UL*1.2*1000)
9:                
10:               #define		uchar		unsigned char
11:               #define		u8t		unsigned char
12:               #define		uint			unsigned int
13:               #define		u16t			unsigned int
14:               #define		ulong		unsigned long
15:               #define		MOT1		RA5
16:               #define		MOT2		RA6
17:               #define		MOT3		RA7
18:               #define		MOT4		RB7
19:               
20:               volatile unsigned char MainTime;
21:               volatile bit	B_MainLoop,B_OnOff;
22:               u8t	count1s = 0;
23:               u8t	workStep = 0;
24:               u8t	wuhuaFlag = 0;
25:               u16t		shanshuoTime = 0;
26:               u16t		shanshuoTime2 = 0;
27:               u16t		shanshuoTime3 = 0;
28:               u16t		fanValue = 0;
29:               u16t		wuhuaValue = 0;
30:               u8t	fanDuty = 0;
31:               u8t	count10s = 0;
32:               u8t	fanOverTime = 0;
33:               u8t	firstTime = 0;
34:               u16t	checkTime = 0;
35:               u16t	lowWaterTime = 0;
36:               u8t		chrgFlag = 0;
37:               u8t		chrgFullFlag = 0;
38:               u8t		chrgFullTime = 0;
39:               u8t		firstLock = 0;
40:               u8t		lowBatLock = 0;
41:               u8t		lowBatTime = 0;	
42:               u8t		lowFanTime = 0;//风扇降低为1档的时间
43:               u8t		bujinFlag = 0;	
44:               u16t	motorStep = 0;
45:               u16t	maxMotorStep = 512;
46:               u8t		powerFlag = 0;
47:               u16t		keyCount = 0;
48:               u8t		longKeyFlag = 0;
49:               u8t		closeTime = 0;
50:               u8t		motorStopFlag = 0;
51:               u8t		zeroFlag = 1;	//默认在原点
52:               u8t		bujinStartFlag = 0;
53:               
54:               volatile unsigned int adresult;
55:               volatile unsigned int result;
56:               volatile unsigned char test_adc;
57:               volatile unsigned int power_ad;
58:               
59:               void chrgCtr();
60:               unsigned char ADC_Sample(unsigned char adch, unsigned char adldo);
61:               
62:               //系统初始化
63:               void Init_System()
  0420    0000    NOP
  0421    0064    CLRWDT
64:               {
65:               	asm("nop");
66:               	asm("clrwdt");
67:               	INTCON = 0;				//禁止中断
  0422    018B    CLR	0xB
68:               	OSCCON = 0X72;			//配置振荡为8M
  0423    3072    LDIA	0x72
  0424    1283    CLRB	0x3,5
  0425    1303    CLRB	0x3,6
  0426    0094    LD	0x14,A
69:               	OPTION_REG = 0;
  0427    0181    CLR	0x1
70:               	
71:               	
72:               	//延时等待电源电压稳定
73:               	//DelayXms(200);
74:               	TRISA = 0x04;
  0428    3004    LDIA	0x4
  0429    1683    SETB	0x3,5
  042A    0085    LD	0x5,A
75:               	PORTA = 0;
  042B    0186    CLR	0x6
76:               	TRISB = 0x20;
  042C    3020    LDIA	0x20
  042D    1283    CLRB	0x3,5
  042E    0085    LD	0x5,A
77:               	PORTB = 0;
  042F    0186    CLR	0x6
78:               	WPUB = 0x00;
  0430    0188    CLR	0x8
79:               	TRISC = 0;
  0431    1703    SETB	0x3,6
  0432    0185    CLR	0x5
80:               	PORTC = 0;
  0433    0186    CLR	0x6
81:               
82:               	PIE1 = 2;
  0434    3002    LDIA	0x2
  0435    1303    CLRB	0x3,6
  0436    008E    LD	0xE,A
83:               	PR2 = 250;				//8M下将TMR2设置为125us中断
  0437    30FA    LDIA	0xFA
  0438    0091    LD	0x11,A
84:               	T2CON = 4;				//使能定时器2
  0439    3004    LDIA	0x4
  043A    0093    LD	0x13,A
85:               
86:               	INTCON = 0XC0;			//使能中断
  043B    30C0    LDIA	0xC0
  043C    008B    LD	0xB,A
87:               	ADCON0 = 0X41;
88:               	ADON = 1;
89:               	ADCON1 = 0x00;
  043D    2FE4    JP	0x7E4
90:               }
91:               
92:               
93:               /**********************************************************
94:               函数名称：Refurbish_Sfr
95:               函数功能：刷新一些特殊功能寄存器
96:               入口参数：无
97:               出口参数：无
98:               备    注：每隔一定时间刷新一次SFR可增强抗干扰能力
99:               **********************************************************/
100:              void Refurbish_Sfr() 
101:              {
102:              	//刷新中断相关控制寄存器
103:              	PIE1 = 2;
  0784    3002    LDIA	0x2
  0785    1283    CLRB	0x3,5
  0786    008E    LD	0xE,A
104:              	PR2 = 250;
  0787    30FA    LDIA	0xFA
  0788    0091    LD	0x11,A
105:              	INTCON = 0XC0;
  0789    30C0    LDIA	0xC0
  078A    008B    LD	0xB,A
106:              	if (4 != T2CON)
  078B    3004    LDIA	0x4
  078C    0613    XORA	0x13
  078D    1903    SZB	0x3,2
  078E    0008    RET
107:              		T2CON = 4;
  078F    3004    LDIA	0x4
  0790    0093    LD	0x13,A
  0791    0008    RET
108:              }
109:              
110:              
111:              /***********************************************************
112:              键处理函数
113:              ***********************************************************/
114:              void KeyServer() 
115:              {
116:              	static unsigned char KeyOldFlag = 0;
117:              	if (KeyFlag[0]) 
  0E99    0879    LD	A,0x79
  0E9A    1903    SZB	0x3,2
  0E9B    2F33    JP	0x733
118:              	{
119:              		if (KeyFlag[0] != KeyOldFlag) 
  0E9C    0879    LD	A,0x79
  0E9D    0634    XORA	0x34
  0E9E    1903    SZB	0x3,2
  0E9F    2F0A    JP	0x70A
120:              		{
121:              			//确定状态改变的按键
122:              			KeyOldFlag ^= KeyFlag[0];
  0EA0    0879    LD	A,0x79
  0EA1    06B4    XORR	0x34
123:              			if ((KeyOldFlag & 0x1) && (KeyFlag[0] & 0x1) && firstLock == 0 && powerFlag > 0) 
  0EA2    1834    SZB	0x34,0
  0EA3    1C79    SNZB	0x79,0
  0EA4    2EC5    JP	0x6C5
  0EA5    1683    SETB	0x3,5
  0EA6    084D    LD	A,0x4D
  0EA7    1D03    SNZB	0x3,2
  0EA8    2EC5    JP	0x6C5
  0EA9    1283    CLRB	0x3,5
  0EAA    083A    LD	A,0x3A
  0EAB    1903    SZB	0x3,2
  0EAC    2EC5    JP	0x6C5
124:              			{
125:              				//KEY1被按下
126:              				if(lowBatLock == 1)
  0EAD    0B3E    SZDECA	0x3E
  0EAE    2EB4    JP	0x6B4
127:              				{
128:              					shanshuoTime2 = 450;
  0EAF    30C2    LDIA	0xC2
  0EB0    00AA    LD	0x2A,A
  0EB1    3001    LDIA	0x1
  0EB2    00AB    LD	0x2B,A
129:              				}
  0EB3    2EB9    JP	0x6B9
130:              				else if(++wuhuaFlag > 2)
  0EB4    3003    LDIA	0x3
  0EB5    0AC5    INCR	0x45
  0EB6    0245    SUBA	0x45
  0EB7    1803    SZB	0x3,0
131:              				{
132:              					wuhuaFlag = 0;
  0EB8    01C5    CLR	0x45
133:              				}
134:              				if(wuhuaFlag >= 2)
  0EB9    3002    LDIA	0x2
  0EBA    0245    SUBA	0x45
  0EBB    1C03    SNZB	0x3,0
  0EBC    2EC3    JP	0x6C3
135:              				{
136:              					shanshuoTime2 = 450;
  0EBD    30C2    LDIA	0xC2
  0EBE    00AA    LD	0x2A,A
  0EBF    3001    LDIA	0x1
  0EC0    00AB    LD	0x2B,A
137:              					count10s = 0;
  0EC1    01C3    CLR	0x43
138:              				}
  0EC2    2EC5    JP	0x6C5
139:              				else
140:              				{
141:              					shanshuoTime2 = 0;
  0EC3    01AA    CLR	0x2A
  0EC4    01AB    CLR	0x2B
142:              				}
143:              			}
144:              			if ((KeyOldFlag & 0x2) && (KeyFlag[0] & 0x2) && firstLock == 0 && powerFlag > 0) 
  0EC5    1283    CLRB	0x3,5
  0EC6    18B4    SZB	0x34,1
  0EC7    1CF9    SNZB	0x79,1
  0EC8    2EE6    JP	0x6E6
  0EC9    1683    SETB	0x3,5
  0ECA    084D    LD	A,0x4D
  0ECB    1D03    SNZB	0x3,2
  0ECC    2EE6    JP	0x6E6
  0ECD    1283    CLRB	0x3,5
  0ECE    083A    LD	A,0x3A
  0ECF    1903    SZB	0x3,2
  0ED0    2EE6    JP	0x6E6
145:              			{
146:              				//KEY2被按下
147:              				if(lowBatLock == 1)
  0ED1    0B3E    SZDECA	0x3E
  0ED2    2ED6    JP	0x6D6
148:              				{
149:              					shanshuoTime = 450;
  0ED3    2739    CALL	0x739
  0ED4    158A    SETB	0xA,3
150:              				}
  0ED5    2EDD    JP	0x6DD
151:              				else if(++workStep > 3)
  0ED6    3004    LDIA	0x4
  0ED7    0AFB    INCR	0x7B
  0ED8    027B    SUBA	0x7B
  0ED9    1C03    SNZB	0x3,0
  0EDA    2EDD    JP	0x6DD
152:              				{
153:              					workStep = 0;
  0EDB    01FB    CLR	0x7B
154:              					bujinFlag = 0;
  0EDC    01BB    CLR	0x3B
155:              				}
156:              				if(workStep >= 2)
  0EDD    3002    LDIA	0x2
  0EDE    027B    SUBA	0x7B
  0EDF    1C03    SNZB	0x3,0
  0EE0    2EE4    JP	0x6E4
157:              				{
158:              					shanshuoTime = 450;
  0EE1    2739    CALL	0x739
  0EE2    158A    SETB	0xA,3
159:              				}
  0EE3    2EE6    JP	0x6E6
160:              				else
161:              				{
162:              					shanshuoTime = 0;
  0EE4    01AC    CLR	0x2C
  0EE5    01AD    CLR	0x2D
163:              				}
164:              				
165:              			}
166:              			if ((KeyOldFlag & 0x4) && (KeyFlag[0] & 0x4) && firstLock == 0 && workStep > 0 && powerFlag > 0) 
  0EE6    1283    CLRB	0x3,5
  0EE7    1934    SZB	0x34,2
  0EE8    1D79    SNZB	0x79,2
  0EE9    2F07    JP	0x707
  0EEA    1683    SETB	0x3,5
  0EEB    084D    LD	A,0x4D
  0EEC    1D03    SNZB	0x3,2
  0EED    2F07    JP	0x707
  0EEE    087B    LD	A,0x7B
  0EEF    1903    SZB	0x3,2
  0EF0    2F07    JP	0x707
  0EF1    1283    CLRB	0x3,5
  0EF2    083A    LD	A,0x3A
  0EF3    1903    SZB	0x3,2
  0EF4    2F07    JP	0x707
167:              			{
168:              				//KEY3被按下
169:              				if(++bujinFlag > 3)
  0EF5    3004    LDIA	0x4
  0EF6    0ABB    INCR	0x3B
  0EF7    023B    SUBA	0x3B
  0EF8    1803    SZB	0x3,0
170:              				{
171:              					bujinFlag = 0;
  0EF9    01BB    CLR	0x3B
  0EFA    3002    LDIA	0x2
172:              				}
173:              				bujinStartFlag = 1;
  0EFB    01B6    CLR	0x36
  0EFC    0AB6    INCR	0x36
174:              				if(bujinFlag >= 2)
  0EFD    023B    SUBA	0x3B
  0EFE    1C03    SNZB	0x3,0
  0EFF    2F05    JP	0x705
175:              				{
176:              					shanshuoTime3 = 450;
  0F00    30C2    LDIA	0xC2
  0F01    00A8    LD	0x28,A
  0F02    3001    LDIA	0x1
  0F03    00A9    LD	0x29,A
177:              				}
  0F04    2F07    JP	0x707
178:              				else
179:              				{
180:              					shanshuoTime3 = 0;
  0F05    01A8    CLR	0x28
  0F06    01A9    CLR	0x29
181:              				}
182:              			}
183:              
184:              			KeyOldFlag = KeyFlag[0];
  0F07    0879    LD	A,0x79
  0F08    1283    CLRB	0x3,5
  0F09    00B4    LD	0x34,A
185:              		}
186:              		if(firstLock == 0 && KeyOldFlag & 0x4)
  0F0A    1683    SETB	0x3,5
  0F0B    084D    LD	A,0x4D
  0F0C    1D03    SNZB	0x3,2
  0F0D    0008    RET
  0F0E    1283    CLRB	0x3,5
  0F0F    1D34    SNZB	0x34,2
  0F10    0008    RET
187:              		{
188:              			if(++keyCount >= 400)
  0F11    1683    SETB	0x3,5
  0F12    0AC5    INCR	0x45
  0F13    1903    SZB	0x3,2
  0F14    0AC6    INCR	0x46
  0F15    3001    LDIA	0x1
  0F16    0246    SUBA	0x46
  0F17    3090    LDIA	0x90
  0F18    1903    SZB	0x3,2
  0F19    0245    SUBA	0x45
  0F1A    1C03    SNZB	0x3,0
  0F1B    0008    RET
189:              			{
190:              				keyCount = 0;
  0F1C    01C5    CLR	0x45
  0F1D    01C6    CLR	0x46
191:              				if(longKeyFlag == 0)
  0F1E    1283    CLRB	0x3,5
  0F1F    0839    LD	A,0x39
  0F20    1D03    SNZB	0x3,2
  0F21    0008    RET
192:              				{
193:              					longKeyFlag = 1;
  0F22    01B9    CLR	0x39
  0F23    0AB9    INCR	0x39
194:              					if(powerFlag > 0)
  0F24    083A    LD	A,0x3A
  0F25    1903    SZB	0x3,2
  0F26    2F2C    JP	0x72C
195:              					{
196:              						powerFlag = 0;
  0F27    01BA    CLR	0x3A
197:              						workStep = 0;
  0F28    01FB    CLR	0x7B
198:              						wuhuaFlag = 0;
  0F29    01C5    CLR	0x45
199:              						bujinFlag = 0;
  0F2A    01BB    CLR	0x3B
200:              					}
  0F2B    0008    RET
  0F2C    3084    LDIA	0x84
201:              					else
202:              					{
203:              						powerFlag = 1;
  0F2D    01BA    CLR	0x3A
  0F2E    0ABA    INCR	0x3A
204:              						shanshuoTime3 = 900;
  0F2F    00A8    LD	0x28,A
  0F30    3003    LDIA	0x3
  0F31    00A9    LD	0x29,A
  0F32    0008    RET
205:              					}
206:              				}
207:              			}
208:              		}
209:              	} 
210:              	else 
211:              	{
212:              		KeyOldFlag = 0;
  0F33    01B4    CLR	0x34
213:              		longKeyFlag = 0;
  0F34    01B9    CLR	0x39
214:              		keyCount = 0;
  0F35    1683    SETB	0x3,5
  0F36    01C5    CLR	0x45
  0F37    01C6    CLR	0x46
  0F38    0008    RET
215:              	}
216:              }
217:              
218:              
219:              /***********************************************************
220:              中断服务函数
221:              ***********************************************************/
222:              void interrupt Isr_Timer()
223:              {
224:              	if(TMR2IF)				//若只使能了一个中断源,可以略去判断
  0E1E    1283    CLRB	0x3,5
  0E1F    1303    CLRB	0x3,6
  0E20    1C8D    SNZB	0xD,1
  0E21    2E31    JP	0x631
225:              	{
226:              		TMR2IF = 0;
  0E22    108D    CLRB	0xD,1
227:              		if(++MainTime >= 32)	//需根据你选择的触摸路数和触摸电容选择扫描一次按键的时间
  0E23    3020    LDIA	0x20
  0E24    0AC7    INCR	0x47
  0E25    0247    SUBA	0x47
  0E26    1C03    SNZB	0x3,0
  0E27    2E32    JP	0x632
228:              		{						//一般103电容，8路触摸，8M主频检测时间约4ms，故扫描一次的时间可选5ms
229:              			MainTime = 0;
  0E28    01C7    CLR	0x47
230:              			B_MainLoop = 1;
  0E29    1778    SETB	0x78,6
231:              			if(++count1s >= 250)
  0E2A    30FA    LDIA	0xFA
  0E2B    0AC6    INCR	0x46
  0E2C    0246    SUBA	0x46
  0E2D    1C03    SNZB	0x3,0
  0E2E    2E32    JP	0x632
232:              			{
233:              				count1s = 0;
  0E2F    01C6    CLR	0x46
  0E30    2E32    JP	0x632
234:              			}
235:              		}
236:              	}
237:              	else
238:              	{
239:              		PIR1 = 0;
  0E31    018D    CLR	0xD
  0E32    0871    LD	A,0x71
  0E33    008A    LD	0xA,A
  0E34    0E70    SWAPA	0x70
  0E35    0083    LD	0x3,A
  0E36    0EFE    SWAPR	0x7E
  0E37    0E7E    SWAPA	0x7E
  0E38    0009    RETI
240:              	}
241:              	
242:              }
243:              
244:              void WorkSleep()
245:              {
246:              #if (0 != C_KEY_WAKEUP)
247:              	static unsigned char time;
248:              	
249:              	if(B_OnOff)time = 0;
  043E    1AF8    SZB	0x78,5
  043F    01B3    CLR	0x33
250:              	
251:              	if(++time >= 125)
  0440    307D    LDIA	0x7D
  0441    0AB3    INCR	0x33
  0442    0233    SUBA	0x33
  0443    1C03    SNZB	0x3,0
  0444    0008    RET
252:              	{
253:              		time = 0;
  0445    01B3    CLR	0x33
254:              		INTCON = 0;			//;关断ADC模块及中断使能；
  0446    018B    CLR	0xB
255:              		PIE1 = 0;
  0447    018E    CLR	0xE
256:              		PIE2 = 0;
  0448    1703    SETB	0x3,6
  0449    0190    CLR	0x10
257:              		PIR1 = 0;
  044A    1303    CLRB	0x3,6
  044B    018D    CLR	0xD
258:              		PIR2 = 0;
  044C    1703    SETB	0x3,6
  044D    018F    CLR	0xF
259:              		T2CON = 0;
  044E    1303    CLRB	0x3,6
  044F    0193    CLR	0x13
260:              		ADCON1 = 0;
  0450    1683    SETB	0x3,5
  0451    0196    CLR	0x16
261:              
262:              		//进入休眠前关掉所有功能模块,以降低休眠电流
263:              		ADCON0 = 0;
  0452    0195    CLR	0x15
264:              	
265:              		//进入休眠前,必须固定口线电平,这儿全部输出低电平,并关闭所有上拉电阻
266:              		PORTA = 0x01;
  0453    3001    LDIA	0x1
  0454    0086    LD	0x6,A
267:              		PORTB = 0x00;
  0455    1283    CLRB	0x3,5
  0456    0186    CLR	0x6
268:              		TRISC = 0;
  0457    1703    SETB	0x3,6
  0458    0185    CLR	0x5
269:              		PORTC = 0x03;
  0459    3003    LDIA	0x3
  045A    0086    LD	0x6,A
270:              
271:              		TRISB5 =1;//输入
  045B    1303    CLRB	0x3,6
  045C    1685    SETB	0x5,5
272:              		//WPUB7 = 1;//上拉			
273:              		RBIF = 0;//清标志
  045D    100B    CLRB	0xB,0
274:              		RBIE = 1; //允许PB口电平变化中断
  045E    158B    SETB	0xB,3
275:              		IOCB5= 1;//允许PB1电平变化中断
  045F    1689    SETB	0x9,5
276:              		PORTB;//读一次PB口	
  0460    0806    LD	A,0x6
277:              /****如需要PA口中断唤醒，使能下列程序并按需修改****
278:              			TRISA0 =1;	//输入
279:              			WPUA0 = 1;	//上拉			
280:              			RAIF = 0;	//清标志
281:              			RAIE = 1;	//允许PA口电平变化中断
282:              			IOCA0 = 1;	//允许PA0电平变化中断
283:              			PEIE = 1;	//允许外设中断
284:              			PORTA;		//读一次PA口			
285:              ************************************/	
286:              
287:              		//进入休眠模式,触摸允许唤醒的按键后恢复正常工作
288:              		SystemEnterSleep();
  0461    2499    CALL	0x499
  0462    118A    CLRB	0xA,3
289:              		if(RAIF) 
  0463    1D8D    SNZB	0xD,3
  0464    2C68    JP	0x468
290:              		{
291:              			RAIF = 0;
  0465    118D    CLRB	0xD,3
292:              			PORTA;
  0466    1683    SETB	0x3,5
  0467    0806    LD	A,0x6
293:              		}
294:              		//休眠被唤醒,重新配置中断等SFR,使系统进入正常工作
295:              		Refurbish_Sfr();
  0468    2784    CALL	0x784
  0469    118A    CLRB	0xA,3
296:              		PORTB &= 0xFD;
  046A    1086    CLRB	0x6,1
297:              		ADCON0 = 0X41;
298:              		ADON = 1;
299:              		ADCON1 = 0x00;
  046B    2FE4    JP	0x7E4
300:              	}
301:              #endif
302:              }
303:              
304:              
305:              /**********************************************************
306:              函数名称：AD_Sample
307:              函数功能：AD检测
308:              入口参数：adch - 检测通道
309:              出口参数：无
310:              备    注：采样通道需自行设置为输入口
311:              	      采样10次,取中间八次的平均值为采样结果存于adresult中
312:              
313:              	      adch 为输入AD通道 0-15，31
314:                           31  检测内部1.2V
315:              	
316:               		  adldo =5,开启内部LDO 2V 作为ADC 参考
317:               		  adldo =6,开启内部LDO 2.4V 作为ADC 参考
318:              		  adldo =7,开启内部LDO 3V 作为ADC 参考
319:               		  adldo =0,VDD 作为ADC 参考
320:               		  AD转换结果左对齐
321:               		  ADC参考电压从VDD切换到LDO时需要延时100us以上，才能进行AD转换
322:              **********************************************************/
323:              unsigned char ADC_Sample(unsigned char adch, unsigned char adldo) 
  01A2    1283    CLRB	0x3,5
  01A3    00CB    LD	0x4B,A
324:              {
325:              	volatile unsigned long adsum = 0;
326:              	volatile unsigned int admin = 0, admax = 0;
  01A4    23F4    CALL	0x3F4
  01A5    118A    CLRB	0xA,3
327:              	volatile unsigned int ad_temp = 0;
  01A6    01D5    CLR	0x55
  01A7    01D6    CLR	0x56
328:              
329:              	if ((!LDO_EN) && (adldo & 0x04) ) 
  01A8    1683    SETB	0x3,5
  01A9    1D16    SNZB	0x16,2
  01AA    1D72    SNZB	0x72,2
  01AB    29B4    JP	0x1B4
330:              	{
331:              								//如果AD参考从VDD换到内部LDO，需要延时100US以上
332:              		ADCON1 = adldo;			//左对齐,AD值取12位
  01AC    0872    LD	A,0x72
  01AD    0096    LD	0x16,A
333:              		__delay_us(100);		//IDE内置延时函数，延时100us
  01AE    3042    LDIA	0x42
  01AF    00F3    LD	0x73,A
  01B0    0BF3    SZDECR	0x73
  01B1    29B0    JP	0x1B0
  01B2    0000    NOP
334:              	} 
  01B3    29B6    JP	0x1B6
335:              	else
336:              		ADCON1 = adldo;			//如果ADCON1.7(ADFM)=1为右对齐，,AD值取10位
  01B4    0872    LD	A,0x72
  01B5    0096    LD	0x16,A
337:              
338:              	if(adch & 0x10) 
  01B6    1283    CLRB	0x3,5
  01B7    1303    CLRB	0x3,6
  01B8    1E4B    SNZB	0x4B,4
  01B9    29BF    JP	0x1BF
339:              	{
340:              		CHS4 = 1;
  01BA    1683    SETB	0x3,5
  01BB    1716    SETB	0x16,6
341:              		adch &= 0x0f;
  01BC    300F    LDIA	0xF
  01BD    1283    CLRB	0x3,5
  01BE    05CB    ANDR	0x4B
342:              	}
343:              	unsigned char i = 0;
344:              	for (i = 0; i < 10; i++) 
  01BF    01CC    CLR	0x4C
345:              	{
346:              		ADCON0 = (unsigned char)(0X41 | (adch << 2));	//16分频，如果主频为16M，则必须选16分频或以上
  01C0    084B    LD	A,0x4B
  01C1    00F3    LD	0x73,A
  01C2    3001    LDIA	0x1
  01C3    1003    CLRB	0x3,0
  01C4    0DF3    RLCR	0x73
  01C5    3EFF    ADDIA	0xFF
  01C6    1003    CLRB	0x3,0
  01C7    1D03    SNZB	0x3,2
  01C8    29C4    JP	0x1C4
  01C9    0D73    RLCA	0x73
  01CA    3841    ORIA	0x41
  01CB    1683    SETB	0x3,5
  01CC    0095    LD	0x15,A
  01CD    0000    NOP
  01CE    0000    NOP
  01CF    0000    NOP
  01D0    0000    NOP
347:              		asm("nop");
348:              		asm("nop");
349:              		asm("nop");
350:              		asm("nop");				//选择通道后需延时1uS以上
351:              		GODONE = 1;				//开始转换
  01D1    1683    SETB	0x3,5
  01D2    1303    CLRB	0x3,6
  01D3    1495    SETB	0x15,1
352:              
353:              		unsigned char j = 0;
  01D4    1283    CLRB	0x3,5
  01D5    01CA    CLR	0x4A
354:              		while (GODONE) 
  01D6    1683    SETB	0x3,5
  01D7    1C95    SNZB	0x15,1
  01D8    29E0    JP	0x1E0
355:              		{
356:              			__delay_us(2);		//延时2us(编译器内置函数)
  01D9    29DA    JP	0x1DA
  01DA    29DB    JP	0x1DB
357:              
358:              			if (0 == (--j))		//延时0.5ms仍没有AD转换结束，跳出程序
  01DB    1283    CLRB	0x3,5
  01DC    1303    CLRB	0x3,6
  01DD    0BCA    SZDECR	0x4A
  01DE    29D6    JP	0x1D6
359:              			return 0;
  01DF    3400    RET	0x0
360:              		}
361:              
362:              		ad_temp = (unsigned int)((ADRESH << 4) + (ADRESL >> 4));	//计算12位AD值
  01E0    0819    LD	A,0x19
  01E1    1283    CLRB	0x3,5
  01E2    00D5    LD	0x55,A
  01E3    01D6    CLR	0x56
  01E4    0ED5    SWAPR	0x55
  01E5    0ED6    SWAPR	0x56
  01E6    30F0    LDIA	0xF0
  01E7    05D6    ANDR	0x56
  01E8    0855    LD	A,0x55
  01E9    390F    ANDIA	0xF
  01EA    04D6    ORR	0x56
  01EB    30F0    LDIA	0xF0
  01EC    05D5    ANDR	0x55
  01ED    1683    SETB	0x3,5
  01EE    0E18    SWAPA	0x18
  01EF    390F    ANDIA	0xF
  01F0    1283    CLRB	0x3,5
  01F1    07D5    ADDR	0x55
  01F2    1803    SZB	0x3,0
  01F3    0AD6    INCR	0x56
363:              
364:              		if (0 == admax) 
  01F4    0853    LD	A,0x53
  01F5    0454    ORA	0x54
  01F6    1D03    SNZB	0x3,2
  01F7    29FB    JP	0x1FB
365:              		{
366:              			admax = ad_temp;
  01F8    2409    CALL	0x409
  01F9    118A    CLRB	0xA,3
  01FA    2A0E    JP	0x20E
367:              			admin = ad_temp;
368:              		} 
369:              		else if (ad_temp > admax)
  01FB    0856    LD	A,0x56
  01FC    0254    SUBA	0x54
  01FD    1D03    SNZB	0x3,2
  01FE    2A01    JP	0x201
  01FF    0855    LD	A,0x55
  0200    0253    SUBA	0x53
  0201    1803    SZB	0x3,0
  0202    2A06    JP	0x206
370:              			admax = ad_temp;				//AD采样最大值
  0203    2409    CALL	0x409
  0204    118A    CLRB	0xA,3
  0205    2A12    JP	0x212
371:              		else if (ad_temp < admin)
  0206    0852    LD	A,0x52
  0207    0256    SUBA	0x56
  0208    1D03    SNZB	0x3,2
  0209    2A0C    JP	0x20C
  020A    0851    LD	A,0x51
  020B    0255    SUBA	0x55
  020C    1803    SZB	0x3,0
  020D    2A12    JP	0x212
372:              			admin = ad_temp;				//AD采样最小值
  020E    0856    LD	A,0x56
  020F    00D2    LD	0x52,A
  0210    0855    LD	A,0x55
  0211    00D1    LD	0x51,A
373:              
374:              		adsum += ad_temp;
  0212    0855    LD	A,0x55
  0213    00F3    LD	0x73,A
  0214    0856    LD	A,0x56
  0215    00F4    LD	0x74,A
  0216    01F5    CLR	0x75
  0217    01F6    CLR	0x76
  0218    0873    LD	A,0x73
  0219    07CD    ADDR	0x4D
  021A    0874    LD	A,0x74
  021B    1103    CLRB	0x3,2
  021C    1803    SZB	0x3,0
  021D    3E01    ADDIA	0x1
  021E    1D03    SNZB	0x3,2
  021F    07CE    ADDR	0x4E
  0220    0875    LD	A,0x75
  0221    1103    CLRB	0x3,2
  0222    1803    SZB	0x3,0
  0223    3E01    ADDIA	0x1
  0224    1D03    SNZB	0x3,2
  0225    07CF    ADDR	0x4F
  0226    0876    LD	A,0x76
  0227    1103    CLRB	0x3,2
  0228    1803    SZB	0x3,0
  0229    3E01    ADDIA	0x1
  022A    1D03    SNZB	0x3,2
  022B    07D0    ADDR	0x50
  022C    300A    LDIA	0xA
  022D    0ACC    INCR	0x4C
  022E    024C    SUBA	0x4C
  022F    1C03    SNZB	0x3,0
  0230    29C0    JP	0x1C0
375:              	}
376:              		adsum -= admax;
  0231    0853    LD	A,0x53
  0232    00F3    LD	0x73,A
  0233    0854    LD	A,0x54
  0234    23E5    CALL	0x3E5
  0235    118A    CLRB	0xA,3
  0236    1C03    SNZB	0x3,0
  0237    0F76    SZINCA	0x76
  0238    02D0    SUBR	0x50
377:              		if (adsum >= admin)
  0239    0851    LD	A,0x51
  023A    00F3    LD	0x73,A
  023B    0852    LD	A,0x52
  023C    00F4    LD	0x74,A
  023D    01F5    CLR	0x75
  023E    01F6    CLR	0x76
  023F    0876    LD	A,0x76
  0240    0250    SUBA	0x50
  0241    1D03    SNZB	0x3,2
  0242    2A4D    JP	0x24D
  0243    0875    LD	A,0x75
  0244    024F    SUBA	0x4F
  0245    1D03    SNZB	0x3,2
  0246    2A4D    JP	0x24D
  0247    0874    LD	A,0x74
  0248    024E    SUBA	0x4E
  0249    1D03    SNZB	0x3,2
  024A    2A4D    JP	0x24D
  024B    0873    LD	A,0x73
  024C    024D    SUBA	0x4D
  024D    1C03    SNZB	0x3,0
  024E    2A58    JP	0x258
378:              			adsum -= admin;
  024F    0851    LD	A,0x51
  0250    00F3    LD	0x73,A
  0251    0852    LD	A,0x52
  0252    23E5    CALL	0x3E5
  0253    118A    CLRB	0xA,3
  0254    1C03    SNZB	0x3,0
  0255    0F76    SZINCA	0x76
  0256    02D0    SUBR	0x50
  0257    2A5C    JP	0x25C
379:              		else
380:              			adsum = 0;
  0258    01CD    CLR	0x4D
  0259    01CE    CLR	0x4E
  025A    01CF    CLR	0x4F
  025B    01D0    CLR	0x50
381:              
382:              		adresult = adsum >> 3;		//8次平均值作为最终结果
  025C    084D    LD	A,0x4D
  025D    00F3    LD	0x73,A
  025E    084E    LD	A,0x4E
  025F    00F4    LD	0x74,A
  0260    084F    LD	A,0x4F
  0261    00F5    LD	0x75,A
  0262    0850    LD	A,0x50
  0263    00F6    LD	0x76,A
  0264    3003    LDIA	0x3
  0265    1003    CLRB	0x3,0
  0266    0CF6    RRCR	0x76
  0267    0CF5    RRCR	0x75
  0268    0CF4    RRCR	0x74
  0269    0CF3    RRCR	0x73
  026A    3EFF    ADDIA	0xFF
  026B    1D03    SNZB	0x3,2
  026C    2A65    JP	0x265
  026D    0874    LD	A,0x74
  026E    00C9    LD	0x49,A
  026F    0873    LD	A,0x73
  0270    00C8    LD	0x48,A
383:              
384:              		adsum = 0;
385:              		admin = 0;
386:              		admax = 0;
  0271    23F4    CALL	0x3F4
387:              		return 0xA5;
  0272    34A5    RET	0xA5
388:              		
389:              }
390:              
391:              
392:              void chrgCtr()
393:              {
394:              	if(PORTB & 0x20)
  0E39    1283    CLRB	0x3,5
  0E3A    1303    CLRB	0x3,6
  0E3B    1E86    SNZB	0x6,5
  0E3C    2E55    JP	0x655
395:              	{
396:              		chrgFlag = 1;
  0E3D    01C1    CLR	0x41
  0E3E    0AC1    INCR	0x41
397:              		firstLock = 0;
  0E3F    1683    SETB	0x3,5
  0E40    01CD    CLR	0x4D
398:              		lowBatLock = 0;
  0E41    1283    CLRB	0x3,5
  0E42    3010    LDIA	0x10
  0E43    01BE    CLR	0x3E
399:              		if(power_ad > 4140)
  0E44    0225    SUBA	0x25
  0E45    302D    LDIA	0x2D
  0E46    1903    SZB	0x3,2
  0E47    0224    SUBA	0x24
  0E48    1C03    SNZB	0x3,0
  0E49    2E53    JP	0x653
400:              		{
401:              			if(++chrgFullTime > 200)
  0E4A    30C9    LDIA	0xC9
  0E4B    0ABF    INCR	0x3F
  0E4C    023F    SUBA	0x3F
  0E4D    1C03    SNZB	0x3,0
  0E4E    0008    RET
402:              			{
403:              				chrgFullTime = 0;
  0E4F    01BF    CLR	0x3F
404:              				chrgFullFlag = 1;
  0E50    01C0    CLR	0x40
  0E51    0AC0    INCR	0x40
  0E52    0008    RET
405:              			}
406:              		}
407:              		else
408:              		{
409:              			chrgFullTime = 0;
  0E53    01BF    CLR	0x3F
  0E54    0008    RET
410:              		}
411:              
412:              	}
413:              	else
414:              	{
415:              		chrgFlag = 0;
  0E55    01C1    CLR	0x41
416:              		chrgFullTime = 0;
  0E56    01BF    CLR	0x3F
417:              		chrgFullFlag = 0;
  0E57    01C0    CLR	0x40
  0E58    0008    RET
418:              		
419:              	}
420:              }
421:              
422:              void keyLedCtr()
423:              {
424:              	if(shanshuoTime > 0)
  0312    1283    CLRB	0x3,5
  0313    082C    LD	A,0x2C
  0314    042D    ORA	0x2D
  0315    1903    SZB	0x3,2
  0316    2B30    JP	0x330
425:              	{
426:              		shanshuoTime--;
  0317    3001    LDIA	0x1
  0318    02AC    SUBR	0x2C
  0319    3000    LDIA	0x0
  031A    1C03    SNZB	0x3,0
  031B    03AD    DECR	0x2D
  031C    02AD    SUBR	0x2D
427:              		if((shanshuoTime % 150) < 75)
  031D    3096    LDIA	0x96
  031E    00F2    LD	0x72,A
  031F    01F3    CLR	0x73
  0320    082D    LD	A,0x2D
  0321    00F5    LD	0x75,A
  0322    082C    LD	A,0x2C
  0323    00F4    LD	0x74,A
  0324    2387    CALL	0x387
  0325    118A    CLRB	0xA,3
  0326    3000    LDIA	0x0
  0327    0273    SUBA	0x73
  0328    304B    LDIA	0x4B
  0329    1903    SZB	0x3,2
  032A    0272    SUBA	0x72
  032B    1803    SZB	0x3,0
  032C    2B33    JP	0x333
428:              		{
429:              			PORTC |= 0x01;
  032D    1703    SETB	0x3,6
  032E    1406    SETB	0x6,0
430:              		}
  032F    2B35    JP	0x335
431:              		else
432:              		{
433:              			PORTC &= 0xFE;
  0333    1703    SETB	0x3,6
  0334    1006    CLRB	0x6,0
434:              		}
435:              	}
436:              	else if(workStep > 0)
  0330    087B    LD	A,0x7B
  0331    1903    SZB	0x3,2
  0332    2B2D    JP	0x32D
437:              	{
438:              		PORTC &= 0xFE;
439:              	}
440:              	else
441:              	{
442:              		PORTC |= 0x01;
443:              	}
444:              	
445:              	if(shanshuoTime2 > 0)
  0335    1303    CLRB	0x3,6
  0336    082A    LD	A,0x2A
  0337    042B    ORA	0x2B
  0338    1903    SZB	0x3,2
  0339    2B53    JP	0x353
446:              	{
447:              		shanshuoTime2--;
  033A    3001    LDIA	0x1
  033B    02AA    SUBR	0x2A
  033C    3000    LDIA	0x0
  033D    1C03    SNZB	0x3,0
  033E    03AB    DECR	0x2B
  033F    02AB    SUBR	0x2B
448:              		if((shanshuoTime2 % 150) < 75)
  0340    3096    LDIA	0x96
  0341    00F2    LD	0x72,A
  0342    01F3    CLR	0x73
  0343    082B    LD	A,0x2B
  0344    00F5    LD	0x75,A
  0345    082A    LD	A,0x2A
  0346    00F4    LD	0x74,A
  0347    2387    CALL	0x387
  0348    118A    CLRB	0xA,3
  0349    3000    LDIA	0x0
  034A    0273    SUBA	0x73
  034B    304B    LDIA	0x4B
  034C    1903    SZB	0x3,2
  034D    0272    SUBA	0x72
  034E    1803    SZB	0x3,0
  034F    2B56    JP	0x356
449:              		{
450:              			PORTC |= 0x02;
  0350    1703    SETB	0x3,6
  0351    1486    SETB	0x6,1
451:              		}
  0352    2B58    JP	0x358
452:              		else
453:              		{
454:              			PORTC &= 0xFD;
  0356    1703    SETB	0x3,6
  0357    1086    CLRB	0x6,1
455:              		}
456:              	}
457:              	else if(wuhuaFlag > 0)
  0353    0845    LD	A,0x45
  0354    1903    SZB	0x3,2
  0355    2B50    JP	0x350
458:              	{
459:              		PORTC &= 0xFD;
460:              	}
461:              	else
462:              	{
463:              		PORTC |= 0x02;
464:              	}
465:              	if(shanshuoTime3 > 0)
  0358    1303    CLRB	0x3,6
  0359    0828    LD	A,0x28
  035A    0429    ORA	0x29
  035B    1903    SZB	0x3,2
  035C    2B79    JP	0x379
466:              	{
467:              		shanshuoTime3--;
  035D    3001    LDIA	0x1
  035E    02A8    SUBR	0x28
  035F    3000    LDIA	0x0
  0360    1C03    SNZB	0x3,0
  0361    03A9    DECR	0x29
  0362    02A9    SUBR	0x29
468:              		if((shanshuoTime3 % 150) < 75)
  0363    3096    LDIA	0x96
  0364    00F2    LD	0x72,A
  0365    01F3    CLR	0x73
  0366    0829    LD	A,0x29
  0367    00F5    LD	0x75,A
  0368    0828    LD	A,0x28
  0369    00F4    LD	0x74,A
  036A    2387    CALL	0x387
  036B    118A    CLRB	0xA,3
  036C    3000    LDIA	0x0
  036D    0273    SUBA	0x73
  036E    304B    LDIA	0x4B
  036F    1903    SZB	0x3,2
  0370    0272    SUBA	0x72
  0371    1803    SZB	0x3,0
  0372    2B76    JP	0x376
469:              		{
470:              			PORTA |= 0x01;
  0373    1683    SETB	0x3,5
  0374    1406    SETB	0x6,0
471:              		}
  0375    0008    RET
472:              		else
473:              		{
474:              			PORTA &= 0xFE;
  0376    1683    SETB	0x3,5
  0377    1006    CLRB	0x6,0
  0378    0008    RET
475:              		}
476:              	}
477:              	else if(bujinFlag)
  0379    083B    LD	A,0x3B
  037A    1D03    SNZB	0x3,2
  037B    2B76    JP	0x376
478:              	{
479:              		PORTA &= 0xFE;
480:              	}
481:              	else if(chrgFlag)
  037C    0841    LD	A,0x41
  037D    1903    SZB	0x3,2
  037E    2B73    JP	0x373
482:              	{
483:              		if(chrgFullFlag || count1s < 50)
  037F    0840    LD	A,0x40
  0380    1D03    SNZB	0x3,2
  0381    2B76    JP	0x376
  0382    3032    LDIA	0x32
  0383    0246    SUBA	0x46
  0384    1C03    SNZB	0x3,0
  0385    2B76    JP	0x376
  0386    2B73    JP	0x373
484:              		{
485:              			PORTA &= 0xFE;
486:              		}
487:              		else
488:              		{
489:              			PORTA |= 0x01;
490:              		}
491:              	}
492:              	else
493:              	{
494:              		PORTA |= 0x01;
495:              	}
496:              	
497:              }
498:              
499:              void pwmInit()
500:              {
501:              
502:              	PWMTH = 0x00;
  0412    0198    CLR	0x18
503:              	PWMTL = 73;
  0413    3049    LDIA	0x49
  0414    0097    LD	0x17,A
504:              	PWMD23H = 0x00;
  0415    1683    SETB	0x3,5
  0416    019E    CLR	0x1E
505:              	PWMD3L = 32;
  0417    3020    LDIA	0x20
  0418    009C    LD	0x1C,A
506:              	PWMCON1 = 0xC0;
  0419    30C0    LDIA	0xC0
  041A    1283    CLRB	0x3,5
  041B    0096    LD	0x16,A
507:              	PWMCON2 = 0x00;
  041C    019D    CLR	0x1D
508:              	PWMCON0 |= 0x28;
  041D    3028    LDIA	0x28
  041E    0495    ORR	0x15
  041F    0008    RET
509:              }
510:              
511:              void pwmStop()
512:              {
513:              	PWMD3L = 0;
  0E0F    1683    SETB	0x3,5
  0E10    019C    CLR	0x1C
514:              	PWMCON0 &= 0xF7;
  0E11    1283    CLRB	0x3,5
  0E12    1195    CLRB	0x15,3
515:              	PORTA &= 0xF7;
  0E13    1683    SETB	0x3,5
  0E14    1186    CLRB	0x6,3
  0E15    0008    RET
516:              }
517:              
518:              void fanInit()
519:              {
520:              
521:              	PWMTH = 0x00;
  03AB    0198    CLR	0x18
522:              	PWMT4L = 73;
  03AC    3049    LDIA	0x49
  03AD    009C    LD	0x1C,A
523:              	PWMD4L = fanDuty;
  03AE    0844    LD	A,0x44
  03AF    009B    LD	0x1B,A
524:              	PWMCON1 = 0xC0;
  03B0    30C0    LDIA	0xC0
  03B1    0096    LD	0x16,A
525:              	PWMCON2 = 0x00;
  03B2    019D    CLR	0x1D
526:              	PWMCON0 |= 0x30;
  03B3    3030    LDIA	0x30
  03B4    0495    ORR	0x15
  03B5    0008    RET
527:              }
528:              
529:              void fanStop()
530:              {
531:              	PWMD4L = 0;
  03B6    1283    CLRB	0x3,5
  03B7    019B    CLR	0x1B
532:              	PWMCON0 &= 0xEF;
  03B8    1215    CLRB	0x15,4
533:              	PORTA &= 0xEF;
  03B9    1683    SETB	0x3,5
  03BA    1206    CLRB	0x6,4
  03BB    0008    RET
534:              }
535:              
536:              void fanCtr()
537:              {
538:              	if(workStep > 0)
  0273    087B    LD	A,0x7B
  0274    1903    SZB	0x3,2
  0275    2AD9    JP	0x2D9
539:              	{
540:              		PORTA |= 0x02;
  0276    1486    SETB	0x6,1
541:              		u8t maxFanValue = 52;
  0277    3034    LDIA	0x34
  0278    1283    CLRB	0x3,5
  0279    00D7    LD	0x57,A
542:              		if(workStep == 1)
  027A    0B7B    SZDECA	0x7B
  027B    2A7E    JP	0x27E
543:              		{	
544:              			maxFanValue = 40;
  027C    3028    LDIA	0x28
  027D    2A83    JP	0x283
545:              		}
546:              		else if(workStep == 3)
  027E    3003    LDIA	0x3
  027F    067B    XORA	0x7B
  0280    1D03    SNZB	0x3,2
  0281    2A84    JP	0x284
547:              		{
548:              			maxFanValue = 10;
  0282    300A    LDIA	0xA
  0283    00D7    LD	0x57,A
  0284    3002    LDIA	0x2
549:              		}
550:              		test_adc = ADC_Sample(2, 0);
  0285    01F2    CLR	0x72
  0286    21A2    CALL	0x1A2
  0287    118A    CLRB	0xA,3
  0288    00B5    LD	0x35,A
551:              		if (0xA5 == test_adc)
  0289    30A5    LDIA	0xA5
  028A    0635    XORA	0x35
  028B    1D03    SNZB	0x3,2
  028C    2AB7    JP	0x2B7
552:              		{
553:              			volatile unsigned long fan_temp;
554:              			if(power_ad > 0)
  028D    0824    LD	A,0x24
  028E    0425    ORA	0x25
  028F    1903    SZB	0x3,2
  0290    2AB7    JP	0x2B7
555:              			{
556:              				fan_temp = ((unsigned long)1UL*adresult * power_ad)/4096;
  0291    0848    LD	A,0x48
  0292    00CA    LD	0x4A,A
  0293    0849    LD	A,0x49
  0294    00CB    LD	0x4B,A
  0295    01CC    CLR	0x4C
  0296    01CD    CLR	0x4D
  0297    0824    LD	A,0x24
  0298    00CE    LD	0x4E,A
  0299    0825    LD	A,0x25
  029A    00CF    LD	0x4F,A
  029B    01D0    CLR	0x50
  029C    01D1    CLR	0x51
  029D    22DF    CALL	0x2DF
  029E    118A    CLRB	0xA,3
  029F    084D    LD	A,0x4D
  02A0    00DB    LD	0x5B,A
  02A1    084C    LD	A,0x4C
  02A2    00DA    LD	0x5A,A
  02A3    084B    LD	A,0x4B
  02A4    00D9    LD	0x59,A
  02A5    084A    LD	A,0x4A
  02A6    00D8    LD	0x58,A
  02A7    300C    LDIA	0xC
  02A8    1003    CLRB	0x3,0
  02A9    0CDB    RRCR	0x5B
  02AA    0CDA    RRCR	0x5A
  02AB    0CD9    RRCR	0x59
  02AC    0CD8    RRCR	0x58
  02AD    3EFF    ADDIA	0xFF
  02AE    1D03    SNZB	0x3,2
  02AF    2AA8    JP	0x2A8
557:              				fanValue = (unsigned int)(fan_temp);
  02B0    0859    LD	A,0x59
  02B1    1683    SETB	0x3,5
  02B2    00C8    LD	0x48,A
  02B3    1283    CLRB	0x3,5
  02B4    0858    LD	A,0x58
  02B5    1683    SETB	0x3,5
  02B6    00C7    LD	0x47,A
558:              			}
559:              		}
560:              		if(fanValue > 1300)
  02B7    3005    LDIA	0x5
  02B8    1683    SETB	0x3,5
  02B9    0248    SUBA	0x48
  02BA    3015    LDIA	0x15
  02BB    1903    SZB	0x3,2
  02BC    0247    SUBA	0x47
  02BD    1C03    SNZB	0x3,0
  02BE    2ACC    JP	0x2CC
561:              		{
562:              			if(++fanOverTime > 50)
  02BF    3033    LDIA	0x33
  02C0    1283    CLRB	0x3,5
  02C1    0AC2    INCR	0x42
  02C2    0242    SUBA	0x42
  02C3    1C03    SNZB	0x3,0
  02C4    2ACE    JP	0x2CE
  02C5    30C2    LDIA	0xC2
563:              			{
564:              				fanOverTime = 0;
  02C6    01C2    CLR	0x42
565:              				workStep = 0;
  02C7    01FB    CLR	0x7B
566:              				shanshuoTime = 450;
  02C8    00AC    LD	0x2C,A
  02C9    3001    LDIA	0x1
  02CA    00AD    LD	0x2D,A
  02CB    2ACE    JP	0x2CE
567:              			}
568:              		}
569:              		else
570:              		{
571:              			fanOverTime = 0;
  02CC    1283    CLRB	0x3,5
  02CD    01C2    CLR	0x42
572:              		}
573:              		if(fanDuty < maxFanValue)
  02CE    0857    LD	A,0x57
  02CF    0244    SUBA	0x44
  02D0    1803    SZB	0x3,0
  02D1    2AD4    JP	0x2D4
574:              		{
575:              			fanDuty++;
  02D2    0AC4    INCR	0x44
576:              		}
  02D3    2AD8    JP	0x2D8
577:              		else if(fanDuty > maxFanValue)
  02D4    0844    LD	A,0x44
  02D5    0257    SUBA	0x57
  02D6    1C03    SNZB	0x3,0
578:              		{
579:              			fanDuty--;
  02D7    03C4    DECR	0x44
580:              		}
581:              		fanInit();
  02D8    2BAB    JP	0x3AB
582:              	}
583:              	else
584:              	{
585:              		fanStop();
  02D9    23B6    CALL	0x3B6
586:              		fanDuty = 0;
  02DA    1283    CLRB	0x3,5
  02DB    01C4    CLR	0x44
587:              		PORTA &= 0xFD;
  02DC    1683    SETB	0x3,5
  02DD    1086    CLRB	0x6,1
  02DE    0008    RET
588:              	}
589:              }
590:              
591:              void wuhuaCtr()
592:              {
593:              	if(count1s == 0)
  03BC    1283    CLRB	0x3,5
  03BD    0846    LD	A,0x46
  03BE    1D03    SNZB	0x3,2
  03BF    2BD7    JP	0x3D7
594:              	{
595:              		if(++count10s >= 20)
  03C0    3014    LDIA	0x14
  03C1    0AC3    INCR	0x43
  03C2    0243    SUBA	0x43
  03C3    1803    SZB	0x3,0
596:              		{
597:              			count10s = 0;
  03C4    01C3    CLR	0x43
598:              		}
599:              		if(workStep == 0 && wuhuaFlag == 0 && powerFlag > 0)
  03C5    087B    LD	A,0x7B
  03C6    1D03    SNZB	0x3,2
  03C7    2BD6    JP	0x3D6
  03C8    0845    LD	A,0x45
  03C9    1D03    SNZB	0x3,2
  03CA    2BD6    JP	0x3D6
  03CB    083A    LD	A,0x3A
  03CC    1903    SZB	0x3,2
  03CD    2BD6    JP	0x3D6
600:              		{
601:              			if(++closeTime > 200)
  03CE    30C9    LDIA	0xC9
  03CF    0AB8    INCR	0x38
  03D0    0238    SUBA	0x38
  03D1    1C03    SNZB	0x3,0
  03D2    2BD7    JP	0x3D7
602:              			{
603:              				closeTime = 0;
  03D3    01B8    CLR	0x38
604:              				powerFlag = 0;
  03D4    01BA    CLR	0x3A
  03D5    2BD7    JP	0x3D7
605:              			}
606:              		}
607:              		else
608:              		{
609:              			closeTime = 0;
  03D6    01B8    CLR	0x38
610:              		}
611:              	}
612:              	if(wuhuaFlag == 1 || (wuhuaFlag == 2 && count10s < 10))
  03D7    0345    DECA	0x45
  03D8    1903    SZB	0x3,2
  03D9    2BE2    JP	0x3E2
  03DA    3002    LDIA	0x2
  03DB    0645    XORA	0x45
  03DC    1D03    SNZB	0x3,2
  03DD    2BE3    JP	0x3E3
  03DE    300A    LDIA	0xA
  03DF    0243    SUBA	0x43
  03E0    1803    SZB	0x3,0
  03E1    2BE3    JP	0x3E3
613:              	{
614:              		pwmInit();
  03E2    2C12    JP	0x412
615:              		/*
616:              		if(++checkTime > 200)
617:              		{
618:              			if(lowWaterTime > 110)
619:              			{
620:              				//干烧状态
621:              				wuhuaFlag = 0;
622:              				shanshuoTime2 = 450;
623:              			}
624:              			checkTime = 0;
625:              			lowWaterTime = 0;
626:              		}
627:              		
628:              		test_adc = ADC_Sample(2, 0);
629:              		if (0xA5 == test_adc)
630:              		{
631:              			volatile unsigned long wuhua_temp;
632:              			if(power_ad > 0)
633:              			{
634:              				wuhua_temp = (unsigned long)(1UL*adresult * power_ad)/4096;
635:              				wuhuaValue = (unsigned int)(wuhua_temp);
636:              			}
637:              		}
638:              		if(wuhuaValue < 7)
639:              		{
640:              			lowWaterTime++;
641:              		}
642:              		*/
643:              	}
644:              	else
645:              	{
646:              		pwmStop();
  03E3    158A    SETB	0xA,3
  03E4    2E0F    JP	0x60F
647:              	}
648:              }
649:              
650:              void bujinCtr()
651:              {
652:              	if(bujinFlag || motorStopFlag)
  0F3E    1283    CLRB	0x3,5
  0F3F    083B    LD	A,0x3B
  0F40    1903    SZB	0x3,2
  0F41    0837    LD	A,0x37
  0F42    1903    SZB	0x3,2
  0F43    2FE4    JP	0x7E4
653:              	{
654:              		//马达启动或者切换原点定位
655:              		if(bujinStartFlag && zeroFlag)
  0F44    0836    LD	A,0x36
  0F45    1903    SZB	0x3,2
  0F46    2F67    JP	0x767
  0F47    086E    LD	A,0x6E
  0F48    1903    SZB	0x3,2
  0F49    2F67    JP	0x767
656:              		{
657:              			bujinStartFlag = 0;
  0F4A    01B6    CLR	0x36
658:              			if(bujinFlag == 1)
  0F4B    0B3B    SZDECA	0x3B
  0F4C    2F50    JP	0x750
659:              			{
660:              				maxMotorStep = 512;
  0F4D    3002    LDIA	0x2
  0F4E    01EC    CLR	0x6C
  0F4F    2F5D    JP	0x75D
661:              				motorStopFlag = 1;
  0F5E    01B7    CLR	0x37
  0F5F    0AB7    INCR	0x37
662:              			}
663:              			else if(bujinFlag == 2)
  0F50    3002    LDIA	0x2
  0F51    063B    XORA	0x3B
  0F52    1D03    SNZB	0x3,2
  0F53    2F56    JP	0x756
664:              			{
665:              				maxMotorStep = 1024;
  0F54    3004    LDIA	0x4
  0F55    2F4E    JP	0x74E
666:              				motorStopFlag = 1;
667:              			}
668:              			else if(bujinFlag == 3)
  0F56    3003    LDIA	0x3
  0F57    063B    XORA	0x3B
  0F58    1D03    SNZB	0x3,2
  0F59    2F60    JP	0x760
669:              			{
670:              				maxMotorStep = 1696;
  0F5A    30A0    LDIA	0xA0
  0F5B    00EC    LD	0x6C,A
  0F5C    3006    LDIA	0x6
  0F5D    00ED    LD	0x6D,A
671:              				motorStopFlag = 1;
672:              			}
673:              			motorStep = maxMotorStep/2;
  0F60    086D    LD	A,0x6D
  0F61    00A7    LD	0x27,A
  0F62    086C    LD	A,0x6C
  0F63    00A6    LD	0x26,A
  0F64    1003    CLRB	0x3,0
  0F65    0CA7    RRCR	0x27
  0F66    0CA6    RRCR	0x26
674:              		}
675:              		if(motorStep == maxMotorStep/2 || motorStep == ((maxMotorStep/2) + maxMotorStep))
  0F67    27EA    CALL	0x7EA
  0F68    158A    SETB	0xA,3
  0F69    0CF3    RRCR	0x73
  0F6A    0CF2    RRCR	0x72
  0F6B    0827    LD	A,0x27
  0F6C    0673    XORA	0x73
  0F6D    1D03    SNZB	0x3,2
  0F6E    2F71    JP	0x771
  0F6F    0826    LD	A,0x26
  0F70    0672    XORA	0x72
  0F71    1903    SZB	0x3,2
  0F72    2F86    JP	0x786
  0F73    27EA    CALL	0x7EA
  0F74    158A    SETB	0xA,3
  0F75    0CF3    RRCR	0x73
  0F76    0CF2    RRCR	0x72
  0F77    086C    LD	A,0x6C
  0F78    0772    ADDA	0x72
  0F79    00F4    LD	0x74,A
  0F7A    086D    LD	A,0x6D
  0F7B    1803    SZB	0x3,0
  0F7C    0A6D    INCA	0x6D
  0F7D    0773    ADDA	0x73
  0F7E    00F5    LD	0x75,A
  0F7F    0627    XORA	0x27
  0F80    1D03    SNZB	0x3,2
  0F81    2F84    JP	0x784
  0F82    0826    LD	A,0x26
  0F83    0674    XORA	0x74
  0F84    1D03    SNZB	0x3,2
  0F85    2F8D    JP	0x78D
676:              		{
677:              			zeroFlag = 1;
  0F86    01EE    CLR	0x6E
  0F87    0AEE    INCR	0x6E
678:              			if(bujinFlag == 0)
  0F88    083B    LD	A,0x3B
  0F89    1D03    SNZB	0x3,2
  0F8A    2F8E    JP	0x78E
679:              			{
680:              				motorStopFlag = 0;
  0F8B    01B7    CLR	0x37
  0F8C    2F8E    JP	0x78E
681:              			}
682:              		}
683:              		else
684:              		{
685:              			zeroFlag = 0;
  0F8D    01EE    CLR	0x6E
686:              		}
687:              		
688:              		
689:              		if(++motorStep >= (maxMotorStep*2))
  0F8E    27EA    CALL	0x7EA
  0F8F    158A    SETB	0xA,3
  0F90    0DF2    RLCR	0x72
  0F91    0DF3    RLCR	0x73
  0F92    0AA6    INCR	0x26
  0F93    1903    SZB	0x3,2
  0F94    0AA7    INCR	0x27
  0F95    0873    LD	A,0x73
  0F96    0227    SUBA	0x27
  0F97    1D03    SNZB	0x3,2
  0F98    2F9B    JP	0x79B
  0F99    0872    LD	A,0x72
  0F9A    0226    SUBA	0x26
  0F9B    1C03    SNZB	0x3,0
  0F9C    2F9F    JP	0x79F
690:              		{
691:              			motorStep = 0;
  0F9D    01A6    CLR	0x26
  0F9E    01A7    CLR	0x27
692:              		}
693:              		u8t	tempStep = motorStep % 8;
  0F9F    0826    LD	A,0x26
  0FA0    00F6    LD	0x76,A
  0FA1    3007    LDIA	0x7
  0FA2    05F6    ANDR	0x76
694:              		if(motorStep < maxMotorStep)
  0FA3    086D    LD	A,0x6D
  0FA4    0227    SUBA	0x27
  0FA5    1D03    SNZB	0x3,2
  0FA6    2FA9    JP	0x7A9
  0FA7    086C    LD	A,0x6C
  0FA8    0226    SUBA	0x26
  0FA9    1C03    SNZB	0x3,0
  0FAA    2FCC    JP	0x7CC
  0FAB    2FD8    JP	0x7D8
695:              		{
696:              			//正转
697:              			switch(tempStep)
698:              			{
699:              				case 0:
700:              				MOT1 = 1;MOT2 = 0;MOT3 = 0;MOT4 = 0;
  0FAC    1683    SETB	0x3,5
  0FAD    1686    SETB	0x6,5
  0FAE    1306    CLRB	0x6,6
  0FAF    1386    CLRB	0x6,7
  0FB0    1283    CLRB	0x3,5
  0FB1    1386    CLRB	0x6,7
701:              				break;
  0FB2    0008    RET
702:              				case 1:
703:              				MOT1 = 1;MOT2 = 1;MOT3 = 0;MOT4 = 0;
  0FB3    1683    SETB	0x3,5
  0FB4    1686    SETB	0x6,5
704:              				break;
  0FB5    2FF5    JP	0x7F5
705:              				case 2:
706:              				MOT1 = 0;MOT2 = 1;MOT3 = 0;MOT4 = 0;
  0FB6    1683    SETB	0x3,5
  0FB7    1286    CLRB	0x6,5
707:              				break;
  0FB8    2FF5    JP	0x7F5
708:              				case 3:
709:              				MOT1 = 0;MOT2 = 1;MOT3 = 1;MOT4 = 0;
  0FB9    1683    SETB	0x3,5
  0FBA    1286    CLRB	0x6,5
  0FBB    1706    SETB	0x6,6
  0FBC    1786    SETB	0x6,7
  0FBD    1283    CLRB	0x3,5
  0FBE    1386    CLRB	0x6,7
710:              				break;
  0FBF    0008    RET
711:              				case 4:
712:              				MOT1 = 0;MOT2 = 0;MOT3 = 1;MOT4 = 0;
  0FC0    27FA    CALL	0x7FA
  0FC1    1386    CLRB	0x6,7
713:              				break;
  0FC2    0008    RET
714:              				case 5:
715:              				MOT1 = 0;MOT2 = 0;MOT3 = 1;MOT4 = 1;
  0FC3    27FA    CALL	0x7FA
  0FC4    1786    SETB	0x6,7
716:              				break;
  0FC5    0008    RET
717:              				case 6:
718:              				MOT1 = 0;MOT2 = 0;MOT3 = 0;MOT4 = 1;
  0FC6    1683    SETB	0x3,5
  0FC7    1286    CLRB	0x6,5
719:              				break;
  0FC8    2FF0    JP	0x7F0
720:              				case 7:
721:              				MOT1 = 1;MOT2 = 0;MOT3 = 0;MOT4 = 1;
  0FC9    1683    SETB	0x3,5
  0FCA    1686    SETB	0x6,5
722:              				break;
  0FCB    2FF0    JP	0x7F0
  0FCC    0876    LD	A,0x76
  0FCD    0084    LD	0x4,A
  0FCE    3008    LDIA	0x8
  0FCF    0204    SUBA	0x4
  0FD0    1803    SZB	0x3,0
  0FD1    0008    RET
  0FD2    3008    LDIA	0x8
  0FD3    008A    LD	0xA,A
  0FD4    1003    CLRB	0x3,0
  0FD5    0D04    RLCA	0x4
  0FD6    3E17    ADDIA	0x17
  0FD7    0082    LD	0x2,A
  0FD8    0876    LD	A,0x76
  0FD9    0084    LD	0x4,A
  0FDA    3008    LDIA	0x8
  0FDB    0204    SUBA	0x4
  0FDC    1803    SZB	0x3,0
  0FDD    0008    RET
  0FDE    3008    LDIA	0x8
  0FDF    008A    LD	0xA,A
  0FE0    1003    CLRB	0x3,0
  0FE1    0D04    RLCA	0x4
  0FE2    3E27    ADDIA	0x27
  0FE3    0082    LD	0x2,A
723:              			}
724:              		}
725:              		else
726:              		{
727:              			//反转
728:              			switch(tempStep)
729:              			{
730:              				case 7:
731:              				MOT1 = 1;MOT2 = 0;MOT3 = 0;MOT4 = 0;
732:              				break;
733:              				case 6:
734:              				MOT1 = 1;MOT2 = 1;MOT3 = 0;MOT4 = 0;
735:              				break;
736:              				case 5:
737:              				MOT1 = 0;MOT2 = 1;MOT3 = 0;MOT4 = 0;
738:              				break;
739:              				case 4:
740:              				MOT1 = 0;MOT2 = 1;MOT3 = 1;MOT4 = 0;
741:              				break;
742:              				case 3:
743:              				MOT1 = 0;MOT2 = 0;MOT3 = 1;MOT4 = 0;
744:              				break;
745:              				case 2:
746:              				MOT1 = 0;MOT2 = 0;MOT3 = 1;MOT4 = 1;
747:              				break;
748:              				case 1:
749:              				MOT1 = 0;MOT2 = 0;MOT3 = 0;MOT4 = 1;
750:              				break;
751:              				case 0:
752:              				MOT1 = 1;MOT2 = 0;MOT3 = 0;MOT4 = 1;
753:              				break;
754:              			}
755:              		}
756:              	}
757:              	else
758:              	{
759:              		PORTA &= 0x1F;
  0FE4    301F    LDIA	0x1F
  0FE5    1683    SETB	0x3,5
  0FE6    0586    ANDR	0x6
760:              		PORTB &= 0x7F;
  0FE7    1283    CLRB	0x3,5
  0FE8    1386    CLRB	0x6,7
  0FE9    0008    RET
761:              	}
762:              }
763:              
764:              
765:              void workCtr()
  0025    301F    LDIA	0x1F
766:              {
767:              	test_adc = ADC_Sample(31, 0);		//测试内部基准1.2V相对电源的AD值
  0026    01F2    CLR	0x72
  0027    21A2    CALL	0x1A2
  0028    118A    CLRB	0xA,3
  0029    00B5    LD	0x35,A
768:              	if (0xA5 == test_adc)
  002A    30A5    LDIA	0xA5
  002B    0635    XORA	0x35
  002C    1D03    SNZB	0x3,2
  002D    285F    JP	0x5F
769:              	{
770:              		volatile unsigned long power_temp;
771:              			
772:              		power_temp = (unsigned long)((POWER_RATIO)/adresult);		//1.2*4096/AD=VDD，参数放大1000倍 
  002E    3096    LDIA	0x96
  002F    01D3    CLR	0x53
  0030    00D4    LD	0x54,A
  0031    304A    LDIA	0x4A
  0032    00D5    LD	0x55,A
  0033    0849    LD	A,0x49
  0034    00CE    LD	0x4E,A
  0035    0848    LD	A,0x48
  0036    00CD    LD	0x4D,A
  0037    2154    CALL	0x154
  0038    118A    CLRB	0xA,3
  0039    084D    LD	A,0x4D
  003A    00D0    LD	0x50,A
  003B    084E    LD	A,0x4E
  003C    00D1    LD	0x51,A
  003D    084F    LD	A,0x4F
  003E    00D2    LD	0x52,A
  003F    2099    CALL	0x99
  0040    118A    CLRB	0xA,3
  0041    0850    LD	A,0x50
  0042    00DF    LD	0x5F,A
  0043    0851    LD	A,0x51
  0044    00E0    LD	0x60,A
  0045    0852    LD	A,0x52
  0046    00E1    LD	0x61,A
  0047    20FB    CALL	0xFB
  0048    118A    CLRB	0xA,3
  0049    0862    LD	A,0x62
  004A    1683    SETB	0x3,5
  004B    00CC    LD	0x4C,A
  004C    1283    CLRB	0x3,5
  004D    0861    LD	A,0x61
  004E    1683    SETB	0x3,5
  004F    00CB    LD	0x4B,A
  0050    1283    CLRB	0x3,5
  0051    0860    LD	A,0x60
  0052    1683    SETB	0x3,5
  0053    00CA    LD	0x4A,A
  0054    1283    CLRB	0x3,5
  0055    085F    LD	A,0x5F
  0056    1683    SETB	0x3,5
  0057    00C9    LD	0x49,A
773:              		power_ad = (unsigned int)(power_temp);		//通过内部基准电压推出芯片VDD电压
  0058    084A    LD	A,0x4A
  0059    1283    CLRB	0x3,5
  005A    00A5    LD	0x25,A
  005B    1683    SETB	0x3,5
  005C    0849    LD	A,0x49
  005D    1283    CLRB	0x3,5
  005E    00A4    LD	0x24,A
774:              	}
775:              	if(workStep == 2 && power_ad < 2900)
  005F    3002    LDIA	0x2
  0060    067B    XORA	0x7B
  0061    1D03    SNZB	0x3,2
  0062    2873    JP	0x73
  0063    300B    LDIA	0xB
  0064    0225    SUBA	0x25
  0065    3054    LDIA	0x54
  0066    1903    SZB	0x3,2
  0067    0224    SUBA	0x24
  0068    1803    SZB	0x3,0
  0069    2873    JP	0x73
776:              	{
777:              		if(++lowFanTime > 200)
  006A    30C9    LDIA	0xC9
  006B    0ABC    INCR	0x3C
  006C    023C    SUBA	0x3C
  006D    1C03    SNZB	0x3,0
  006E    2874    JP	0x74
778:              		{
779:              			lowFanTime = 0;
  006F    01BC    CLR	0x3C
780:              			workStep = 1;
  0070    01FB    CLR	0x7B
  0071    0AFB    INCR	0x7B
  0072    2874    JP	0x74
781:              		}
782:              	}
783:              	else
784:              	{
785:              		lowFanTime = 0;
  0073    01BC    CLR	0x3C
786:              	}	
787:              	if(power_ad < 2700)
  0074    300A    LDIA	0xA
  0075    0225    SUBA	0x25
  0076    308C    LDIA	0x8C
  0077    1903    SZB	0x3,2
  0078    0224    SUBA	0x24
  0079    1803    SZB	0x3,0
  007A    2887    JP	0x87
788:              	{
789:              		if(++lowBatTime > 200)
  007B    30C9    LDIA	0xC9
  007C    0ABD    INCR	0x3D
  007D    023D    SUBA	0x3D
  007E    1C03    SNZB	0x3,0
  007F    2888    JP	0x88
790:              		{
791:              			lowBatTime = 0;
  0080    01BD    CLR	0x3D
792:              			lowBatLock = 1;
  0081    01BE    CLR	0x3E
  0082    0ABE    INCR	0x3E
793:              			workStep = 0;
  0083    01FB    CLR	0x7B
794:              			wuhuaFlag = 0;
  0084    01C5    CLR	0x45
795:              			bujinFlag = 0;
  0085    01BB    CLR	0x3B
  0086    2888    JP	0x88
796:              		}
797:              	}
798:              	else
799:              	{
800:              		lowBatTime = 0;
  0087    01BD    CLR	0x3D
801:              	}
802:              	if(firstTime > 0)
  0088    1683    SETB	0x3,5
  0089    084E    LD	A,0x4E
  008A    1903    SZB	0x3,2
  008B    2892    JP	0x92
803:              	{
804:              		firstTime--;
  008C    03CE    DECR	0x4E
805:              		PORTB = 0x00;
  008D    1283    CLRB	0x3,5
  008E    0186    CLR	0x6
806:              		PORTA = 0x00;
  008F    1683    SETB	0x3,5
  0090    0186    CLR	0x6
807:              	}
  0091    0008    RET
808:              	else
809:              	{
810:              		keyLedCtr();
  0092    2312    CALL	0x312
  0093    118A    CLRB	0xA,3
811:              		fanCtr();
  0094    2273    CALL	0x273
  0095    118A    CLRB	0xA,3
812:              		wuhuaCtr();
  0096    23BC    CALL	0x3BC
813:              		bujinCtr();
  0097    158A    SETB	0xA,3
  0098    2F3E    JP	0x73E
814:              		
815:              	}
816:              	
817:              }
818:              
819:              /***********************************************************
820:              主循环
821:              ***********************************************************/
822:              void main()
823:              {
824:              	Init_System();
  0E59    118A    CLRB	0xA,3
  0E5A    2420    CALL	0x420
  0E5B    158A    SETB	0xA,3
  0E5C    30C8    LDIA	0xC8
825:              	firstLock = 1;
  0E5D    01CD    CLR	0x4D
  0E5E    0ACD    INCR	0x4D
826:              	firstTime = 200;
  0E5F    00CE    LD	0x4E,A
827:              	while(1)
828:              	{
829:              		if(B_MainLoop)
  0E60    1F78    SNZB	0x78,6
  0E61    2E60    JP	0x660
830:              		{
831:              			B_MainLoop = 0;
  0E62    1378    CLRB	0x78,6
  0E63    0064    CLRWDT
832:              			CLRWDT();
833:              			
834:              			CheckTouchKey();
  0E64    118A    CLRB	0xA,3
  0E65    246C    CALL	0x46C
  0E66    158A    SETB	0xA,3
835:              			chrgCtr();
  0E67    158A    SETB	0xA,3
  0E68    2639    CALL	0x639
  0E69    158A    SETB	0xA,3
836:              			Refurbish_Sfr();
  0E6A    118A    CLRB	0xA,3
  0E6B    2784    CALL	0x784
  0E6C    158A    SETB	0xA,3
837:              			KeyServer();
  0E6D    158A    SETB	0xA,3
  0E6E    2699    CALL	0x699
  0E6F    158A    SETB	0xA,3
838:              			workCtr();
  0E70    118A    CLRB	0xA,3
  0E71    2025    CALL	0x25
  0E72    158A    SETB	0xA,3
839:              			if(firstTime == 0 && chrgFlag == 0 && workStep == 0 && wuhuaFlag == 0 && powerFlag == 0 && keyCount == 0 && bujinFlag == 0 && shanshuoTime == 0 && shanshuoTime2 == 0)
  0E73    1683    SETB	0x3,5
  0E74    084E    LD	A,0x4E
  0E75    1D03    SNZB	0x3,2
  0E76    2E60    JP	0x660
  0E77    1283    CLRB	0x3,5
  0E78    0841    LD	A,0x41
  0E79    1D03    SNZB	0x3,2
  0E7A    2E60    JP	0x660
  0E7B    087B    LD	A,0x7B
  0E7C    1D03    SNZB	0x3,2
  0E7D    2E60    JP	0x660
  0E7E    0845    LD	A,0x45
  0E7F    1D03    SNZB	0x3,2
  0E80    2E60    JP	0x660
  0E81    083A    LD	A,0x3A
  0E82    1D03    SNZB	0x3,2
  0E83    2E60    JP	0x660
  0E84    1683    SETB	0x3,5
  0E85    0845    LD	A,0x45
  0E86    0446    ORA	0x46
  0E87    1D03    SNZB	0x3,2
  0E88    2E60    JP	0x660
  0E89    1283    CLRB	0x3,5
  0E8A    083B    LD	A,0x3B
  0E8B    1D03    SNZB	0x3,2
  0E8C    2E60    JP	0x660
  0E8D    082C    LD	A,0x2C
  0E8E    042D    ORA	0x2D
  0E8F    1D03    SNZB	0x3,2
  0E90    2E60    JP	0x660
  0E91    082A    LD	A,0x2A
  0E92    042B    ORA	0x2B
  0E93    1D03    SNZB	0x3,2
  0E94    2E60    JP	0x660
840:              			{
841:              				WorkSleep();
  0E95    118A    CLRB	0xA,3
  0E96    243E    CALL	0x43E
  0E97    158A    SETB	0xA,3
  0E98    2E60    JP	0x660
842:              			}
843:              		}
844:              	}
845:              }
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\ftdiv.c ----------------------------------------------------------------------
1:                /*	Floating point routines.
2:                
3:                	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:                */
5:                
6:                // this is bigendian code right now. Need to parameterise it.
7:                
8:                #include	"ftarith.h"
9:                
10:               #define	f1_as_dividend	(*(unsigned short long *)&f1)
11:               #define	f2_as_divisor	(*(unsigned short long *)&f2)
12:               #define	f3_as_quot	(*(unsigned short long *)&f3)
13:               
14:               // floating addition
15:               #ifdef _OLDLIB
16:               #define	cntr		sign2
17:               float
18:               #ifdef _PIC18
19:               __ftdiv(float f1, float f2)
20:               #else
21:               __ftdiv(float f2, float f1)
22:               #endif
23:               {
24:               	unsigned char	exp1, exp2, sign1, sign2;
25:               	float	f3;
26:               	
27:               	f3_as_quot = 0;
28:               	sign1 = __ftunpack(&f1_as_dividend, &exp1);
29:               	if(exp1 == 0)
30:               		return f3;
31:               	sign2 = __ftunpack(&f2_as_divisor, &exp2);
32:               	if(exp2 == 0)
33:               		return f3;
34:               	exp1 -= exp2-127+8;	// compute new exponent
35:               	sign1 ^= sign2;
36:               	cntr = 16+8;
37:               	do {
38:               		f3_as_quot <<= 1;
39:               		if(f1_as_dividend >= f2_as_divisor) {
40:               			f1_as_dividend -= f2_as_divisor;
41:               			f3_as_quot |= 1;
42:               		}
43:               		f1_as_dividend <<= 1;
44:               	} while(--cntr != 0);
45:               	__ftpack(&f3_as_quot, exp1);
46:               	if(sign1)
47:               		f3_as_quot |= 0x800000;
48:               	return f3;
49:               }
50:               #else
51:               #define	exp2	sign
52:               float
53:               #ifdef _PIC18
54:               __ftdiv(float f1, float f2)
55:               #else
56:               __ftdiv(float f2, float f1)
  0099    0853    LD	A,0x53
  009A    00D6    LD	0x56,A
  009B    0854    LD	A,0x54
  009C    00D7    LD	0x57,A
  009D    0855    LD	A,0x55
  009E    00D8    LD	0x58,A
  009F    1003    CLRB	0x3,0
  00A0    0D57    RLCA	0x57
  00A1    0D58    RLCA	0x58
  00A2    00DD    LD	0x5D,A
  00A3    085D    LD	A,0x5D
  00A4    1D03    SNZB	0x3,2
  00A5    28A7    JP	0xA7
  00A6    2C0E    JP	0x40E
  00A7    0850    LD	A,0x50
  00A8    00D6    LD	0x56,A
  00A9    0851    LD	A,0x51
  00AA    00D7    LD	0x57,A
  00AB    0852    LD	A,0x52
  00AC    00D8    LD	0x58,A
  00AD    1003    CLRB	0x3,0
  00AE    0D57    RLCA	0x57
  00AF    0D58    RLCA	0x58
  00B0    00DE    LD	0x5E,A
  00B1    085E    LD	A,0x5E
  00B2    1D03    SNZB	0x3,2
  00B3    28B5    JP	0xB5
  00B4    2C0E    JP	0x40E
  00B5    3089    LDIA	0x89
  00B6    01DA    CLR	0x5A
  00B7    01DB    CLR	0x5B
  00B8    01DC    CLR	0x5C
  00B9    075E    ADDA	0x5E
  00BA    00D6    LD	0x56,A
  00BB    02DD    SUBR	0x5D
  00BC    0855    LD	A,0x55
  00BD    00DE    LD	0x5E,A
  00BE    0852    LD	A,0x52
  00BF    06DE    XORR	0x5E
  00C0    3080    LDIA	0x80
  00C1    05DE    ANDR	0x5E
  00C2    3018    LDIA	0x18
  00C3    17D4    SETB	0x54,7
  00C4    01D5    CLR	0x55
  00C5    17D1    SETB	0x51,7
  00C6    01D2    CLR	0x52
  00C7    00D9    LD	0x59,A
  00C8    1003    CLRB	0x3,0
  00C9    0DDA    RLCR	0x5A
  00CA    0DDB    RLCR	0x5B
  00CB    0DDC    RLCR	0x5C
  00CC    0852    LD	A,0x52
  00CD    0255    SUBA	0x55
  00CE    1D03    SNZB	0x3,2
  00CF    28D6    JP	0xD6
  00D0    0851    LD	A,0x51
  00D1    0254    SUBA	0x54
  00D2    1D03    SNZB	0x3,2
  00D3    28D6    JP	0xD6
  00D4    0850    LD	A,0x50
  00D5    0253    SUBA	0x53
  00D6    1C03    SNZB	0x3,0
  00D7    28E4    JP	0xE4
  00D8    0850    LD	A,0x50
  00D9    02D3    SUBR	0x53
  00DA    0851    LD	A,0x51
  00DB    1C03    SNZB	0x3,0
  00DC    0F51    SZINCA	0x51
  00DD    02D4    SUBR	0x54
  00DE    0852    LD	A,0x52
  00DF    1C03    SNZB	0x3,0
  00E0    0A52    INCA	0x52
  00E1    02D5    SUBR	0x55
  00E2    145A    SETB	0x5A,0
  00E3    1003    CLRB	0x3,0
  00E4    0DD3    RLCR	0x53
  00E5    0DD4    RLCR	0x54
  00E6    0DD5    RLCR	0x55
  00E7    0BD9    SZDECR	0x59
  00E8    28C8    JP	0xC8
  00E9    085A    LD	A,0x5A
  00EA    00F2    LD	0x72,A
  00EB    085B    LD	A,0x5B
  00EC    00F3    LD	0x73,A
  00ED    085C    LD	A,0x5C
  00EE    00F4    LD	0x74,A
  00EF    085D    LD	A,0x5D
  00F0    00F5    LD	0x75,A
  00F1    085E    LD	A,0x5E
  00F2    00F6    LD	0x76,A
  00F3    2164    CALL	0x164
  00F4    0872    LD	A,0x72
  00F5    00D0    LD	0x50,A
  00F6    0873    LD	A,0x73
  00F7    00D1    LD	0x51,A
  00F8    0874    LD	A,0x74
  00F9    00D2    LD	0x52,A
  00FA    0008    RET
57:               #endif
58:               {
59:               	unsigned char	exp, sign, cntr;
60:               	float	f3;
61:               	
62:               	// unpack the operands
63:               	if((exp = f1_as_dividend >> 15) == 0)
64:               		return 0.0;
65:               	if((exp2 = f2_as_divisor >> 15) == 0)
66:               		return 0.0;
67:               	f3_as_quot = 0;
68:               	exp -= exp2-127+8;	// compute new exponent
69:               	sign = f1_as_dividend >> 16;
70:               	sign ^= (unsigned char)(f2_as_divisor >> 16);
71:               	sign &= 0x80;
72:               	f1_as_dividend |= 0x8000UL;
73:               	f1_as_dividend &= 0xFFFFUL;
74:               	f2_as_divisor |= 0x8000UL;
75:               	f2_as_divisor &= 0xFFFFUL;
76:               	cntr = 16+8;
77:               	do {
78:               		f3_as_quot <<= 1;
79:               		if(f1_as_dividend >= f2_as_divisor) {
80:               			f1_as_dividend -= f2_as_divisor;
81:               			f3_as_quot |= 1;
82:               		}
83:               		f1_as_dividend <<= 1;
84:               	} while(--cntr != 0);
85:               	return __ftpack(f3_as_quot, exp, sign);
86:               }
87:               #endif	
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\fttol.c ----------------------------------------------------------------------
1:                /*	Floating point routines.
2:                
3:                	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:                */
5:                
6:                // this is bigendian code right now. Need to parameterise it.
7:                
8:                #include	"ftarith.h"
9:                
10:               #define	f1_as_mant1	(*(unsigned short long *)&f1)
11:               
12:               // Convert float to long
13:               
14:               #ifdef _OLDLIB
15:               long
16:               __fttol(float f1)
17:               {
18:               	unsigned char	sign1, exp1;
19:               	unsigned long	lval;
20:               
21:               	sign1 = __ftunpack(&f1_as_mant1, &exp1);
22:               	lval = f1_as_mant1;
23:               	exp1 -= 127+15;
24:               	if((signed char)exp1 < 0) {
25:               		if((signed char)exp1 < -15)
26:               			return 0;
27:               		do
28:               			lval >>= 1;
29:               		while(++exp1 != 0);
30:               	} else {
31:               		if(exp1 >= 32)
32:               			return 00;
33:               		while(exp1 != 0) {
34:               			lval <<= 1;
35:               			exp1--;
36:               		}
37:               	}
38:               	if(sign1)
39:               		lval = -lval;
40:               	return lval;
41:               }
42:               #else
43:               long
44:               __fttol(float f1)
  00FB    23FD    CALL	0x3FD
  00FC    118A    CLRB	0xA,3
  00FD    1003    CLRB	0x3,0
  00FE    0D64    RLCA	0x64
  00FF    0D65    RLCA	0x65
  0100    00EB    LD	0x6B,A
  0101    086B    LD	A,0x6B
  0102    1D03    SNZB	0x3,2
  0103    2909    JP	0x109
  0104    01DF    CLR	0x5F
  0105    01E0    CLR	0x60
  0106    01E1    CLR	0x61
  0107    01E2    CLR	0x62
  0108    0008    RET
  0109    23FD    CALL	0x3FD
  010A    118A    CLRB	0xA,3
  010B    3017    LDIA	0x17
  010C    1003    CLRB	0x3,0
  010D    0CE5    RRCR	0x65
  010E    0CE4    RRCR	0x64
  010F    0CE3    RRCR	0x63
  0110    3EFF    ADDIA	0xFF
  0111    1D03    SNZB	0x3,2
  0112    290C    JP	0x10C
  0113    0863    LD	A,0x63
  0114    00E6    LD	0x66,A
  0115    17E0    SETB	0x60,7
  0116    01E1    CLR	0x61
  0117    085F    LD	A,0x5F
  0118    00E7    LD	0x67,A
  0119    0860    LD	A,0x60
  011A    00E8    LD	0x68,A
  011B    0861    LD	A,0x61
  011C    00E9    LD	0x69,A
  011D    308E    LDIA	0x8E
  011E    01EA    CLR	0x6A
  011F    02EB    SUBR	0x6B
  0120    1FEB    SNZB	0x6B,7
  0121    292F    JP	0x12F
  0122    086B    LD	A,0x6B
  0123    3A80    XORIA	0x80
  0124    3E8F    ADDIA	0x8F
  0125    1C03    SNZB	0x3,0
  0126    2904    JP	0x104
  0127    1003    CLRB	0x3,0
  0128    0CEA    RRCR	0x6A
  0129    0CE9    RRCR	0x69
  012A    0CE8    RRCR	0x68
  012B    0CE7    RRCR	0x67
  012C    0FEB    SZINCR	0x6B
  012D    2927    JP	0x127
  012E    293D    JP	0x13D
  012F    3018    LDIA	0x18
  0130    026B    SUBA	0x6B
  0131    1803    SZB	0x3,0
  0132    2904    JP	0x104
  0133    086B    LD	A,0x6B
  0134    1903    SZB	0x3,2
  0135    293D    JP	0x13D
  0136    1003    CLRB	0x3,0
  0137    0DE7    RLCR	0x67
  0138    0DE8    RLCR	0x68
  0139    0DE9    RLCR	0x69
  013A    0DEA    RLCR	0x6A
  013B    03EB    DECR	0x6B
  013C    2933    JP	0x133
  013D    0866    LD	A,0x66
  013E    1903    SZB	0x3,2
  013F    294B    JP	0x14B
  0140    09E7    COMR	0x67
  0141    09E8    COMR	0x68
  0142    09E9    COMR	0x69
  0143    09EA    COMR	0x6A
  0144    0AE7    INCR	0x67
  0145    1903    SZB	0x3,2
  0146    0AE8    INCR	0x68
  0147    1903    SZB	0x3,2
  0148    0AE9    INCR	0x69
  0149    1903    SZB	0x3,2
  014A    0AEA    INCR	0x6A
  014B    086A    LD	A,0x6A
  014C    00E2    LD	0x62,A
  014D    0869    LD	A,0x69
  014E    00E1    LD	0x61,A
  014F    0868    LD	A,0x68
  0150    00E0    LD	0x60,A
  0151    0867    LD	A,0x67
  0152    00DF    LD	0x5F,A
  0153    0008    RET
45:               {
46:               	unsigned char	sign1, exp1;
47:               	unsigned long	lval;
48:               
49:               	if((exp1 = f1_as_mant1 >> 15) == 0)
50:               		return 0;
51:               	sign1 = f1_as_mant1 >> 23;
52:               	f1_as_mant1 |= 0x8000UL;
53:               	f1_as_mant1 &= 0xFFFFUL;
54:               	lval = f1_as_mant1;
55:               	exp1 -= 127+15;
56:               	if((signed char)exp1 < 0) {
57:               		if((signed char)exp1 < -15)
58:               			return 0;
59:               		do
60:               			lval >>= 1;
61:               		while(++exp1 != 0);
62:               	} else {
63:               		if(exp1 >= 24)
64:               			return 0;
65:               		while(exp1 != 0) {
66:               			lval <<= 1;
67:               			exp1--;
68:               		}
69:               	}
70:               	if(sign1)
71:               		lval = -lval;
72:               	return lval;
73:               }
74:               #endif
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\lwtoft.c ----------------------------------------------------------------------
1:                /*	Floating point routines.
2:                
3:                	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:                */
5:                
6:                // this is bigendian code right now. Need to parameterise it.
7:                
8:                #include	"ftarith.h"
9:                
10:               
11:               // Convert unsigned int to float
12:               
13:               #ifdef _OLDLIB
14:               #define	f1_as_mant1	(*(unsigned short long *)&f1)
15:               float
16:               __lwtoft(unsigned int c)
17:               {
18:               	float	f1;
19:               	
20:               	if(c == 0)
21:               		return 0.0;
22:               	f1_as_mant1 = c;
23:               	__ftpack(&f1_as_mant1, 127+15);
24:               	return f1;
25:               }
26:               #else
27:               float
28:               __lwtoft(unsigned int c)
  0154    084D    LD	A,0x4D
  0155    00F2    LD	0x72,A
  0156    084E    LD	A,0x4E
  0157    00F3    LD	0x73,A
  0158    308E    LDIA	0x8E
  0159    01F4    CLR	0x74
  015A    00F5    LD	0x75,A
  015B    01F6    CLR	0x76
  015C    2164    CALL	0x164
  015D    0872    LD	A,0x72
  015E    00CD    LD	0x4D,A
  015F    0873    LD	A,0x73
  0160    00CE    LD	0x4E,A
  0161    0874    LD	A,0x74
  0162    00CF    LD	0x4F,A
  0163    0008    RET
29:               {
30:               	return __ftpack(c, 127+15, 0);
31:               }
32:               #endif
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\float.c ----------------------------------------------------------------------
1:                /*	Floating point routines.
2:                
3:                	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:                */
5:                
6:                #include	"ftarith.h"
7:                
8:                
9:                //	unpack the operand pointed to. Store the exponent into the location pointed to by exp,
10:               //	and return the sign (zero is positive)
11:               
12:               #ifdef _OLDLIB
13:               
14:               unsigned char
15:               __ftunpack(unsigned short long * arg, unsigned char * exp)
16:               {
17:               	unsigned char	sign;
18:               
19:               	*exp = sign = *arg >> 15;
20:               	if(sign == 0) {
21:               		*arg = 0;
22:               		return 0;
23:               	}
24:               	sign = 0;
25:               	*arg |= 0x8000;
26:               	if(*arg & 0x800000)
27:               		sign++;
28:               	*arg &= 0xFFFF;
29:               	return sign;
30:               }
31:               
32:               // normalize and pack the supplied argument into floating point format
33:               
34:               void
35:               __ftpack(unsigned short long * arg, unsigned char exp)
36:               {
37:               	if(exp == 0 || *arg == 0) {
38:               		*arg = 0;
39:               		return;
40:               	}
41:               	while(*arg & 0xFE0000UL) {
42:               		exp++;
43:               		*arg >>= 1;
44:               	}
45:               	while(*arg & 0xFF0000UL) {
46:               		exp++;
47:               		(*arg)++;
48:               		*arg >>= 1;
49:               	}
50:               	while(!(*arg & 0x8000UL)) {
51:               		exp--;
52:               		*arg <<= 1;
53:               	}
54:               	if(!(exp & 1))
55:               		*arg &= ~0x8000L;
56:               	exp >>= 1;
57:               	*arg |= (unsigned short long)exp << 16;
58:               }
59:               
60:               #else
61:               float
62:               __ftpack(unsigned short long arg, unsigned char exp, unsigned char sign)
  0164    0875    LD	A,0x75
  0165    1903    SZB	0x3,2
  0166    296C    JP	0x16C
  0167    0874    LD	A,0x74
  0168    0473    ORA	0x73
  0169    0472    ORA	0x72
  016A    1D03    SNZB	0x3,2
  016B    2973    JP	0x173
  016C    01F2    CLR	0x72
  016D    01F3    CLR	0x73
  016E    01F4    CLR	0x74
  016F    0008    RET
  0170    0AF5    INCR	0x75
  0171    2404    CALL	0x404
  0172    118A    CLRB	0xA,3
  0173    30FE    LDIA	0xFE
  0174    0574    ANDA	0x74
  0175    1903    SZB	0x3,2
  0176    2980    JP	0x180
  0177    2970    JP	0x170
  0178    0AF5    INCR	0x75
  0179    0AF2    INCR	0x72
  017A    1903    SZB	0x3,2
  017B    0AF3    INCR	0x73
  017C    1903    SZB	0x3,2
  017D    0AF4    INCR	0x74
  017E    2404    CALL	0x404
  017F    118A    CLRB	0xA,3
  0180    30FF    LDIA	0xFF
  0181    0574    ANDA	0x74
  0182    1903    SZB	0x3,2
  0183    298E    JP	0x18E
  0184    2978    JP	0x178
  0185    3002    LDIA	0x2
  0186    0275    SUBA	0x75
  0187    1C03    SNZB	0x3,0
  0188    2990    JP	0x190
  0189    03F5    DECR	0x75
  018A    1003    CLRB	0x3,0
  018B    0DF2    RLCR	0x72
  018C    0DF3    RLCR	0x73
  018D    0DF4    RLCR	0x74
  018E    1FF3    SNZB	0x73,7
  018F    2985    JP	0x185
  0190    1C75    SNZB	0x75,0
  0191    13F3    CLRB	0x73,7
  0192    1003    CLRB	0x3,0
  0193    0CF5    RRCR	0x75
  0194    0875    LD	A,0x75
  0195    00CC    LD	0x4C,A
  0196    01CB    CLR	0x4B
  0197    01CA    CLR	0x4A
  0198    084A    LD	A,0x4A
  0199    04F2    ORR	0x72
  019A    084B    LD	A,0x4B
  019B    04F3    ORR	0x73
  019C    084C    LD	A,0x4C
  019D    04F4    ORR	0x74
  019E    0876    LD	A,0x76
  019F    1D03    SNZB	0x3,2
  01A0    17F4    SETB	0x74,7
  01A1    0008    RET
63:               {
64:               	if(exp == 0 || arg == 0)
65:               		return 0.0;
66:               	while(arg & 0xFE0000UL) {
67:               		exp++;
68:               		arg >>= 1;
69:               	}
70:               	while(arg & 0xFF0000UL) {
71:               		exp++;
72:               		(arg)++;
73:               		arg >>= 1;
74:               	}
75:               	while(!(arg & 0x8000UL) && exp > 1) {
76:               		exp--;
77:               		arg <<= 1;
78:               	}
79:               	if(!(exp & 1))
80:               		arg &= ~0x8000L;
81:               	exp >>= 1;
82:               	arg |= (unsigned short long)exp << 16;
83:               	if (sign)
84:               		arg |= 0x800000UL;
85:                  return *(float*)&arg;	
86:               }
87:               
88:               #endif
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\Umul32.c ----------------------------------------------------------------------
1:                // 32 x 32 bit multiplication with 32 bit result
2:                #ifdef _PIC18
3:                #define _Has_hardware_multiply 1
4:                #else
5:                #define _Has_hardware_multiply 0
6:                #endif
7:                
8:                #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:                #define _Has_large_call_stack 1
10:               #else
11:               #define _Has_large_call_stack 0
12:               #endif
13:               
14:               unsigned long
15:               __lmul(unsigned long multiplier, unsigned long multiplicand)
  02DF    01F2    CLR	0x72
  02E0    01F3    CLR	0x73
  02E1    01F4    CLR	0x74
  02E2    01F5    CLR	0x75
  02E3    1C4A    SNZB	0x4A,0
  02E4    2AF9    JP	0x2F9
  02E5    084E    LD	A,0x4E
  02E6    07F2    ADDR	0x72
  02E7    084F    LD	A,0x4F
  02E8    1103    CLRB	0x3,2
  02E9    1803    SZB	0x3,0
  02EA    3E01    ADDIA	0x1
  02EB    1D03    SNZB	0x3,2
  02EC    07F3    ADDR	0x73
  02ED    0850    LD	A,0x50
  02EE    1103    CLRB	0x3,2
  02EF    1803    SZB	0x3,0
  02F0    3E01    ADDIA	0x1
  02F1    1D03    SNZB	0x3,2
  02F2    07F4    ADDR	0x74
  02F3    0851    LD	A,0x51
  02F4    1103    CLRB	0x3,2
  02F5    1803    SZB	0x3,0
  02F6    3E01    ADDIA	0x1
  02F7    1D03    SNZB	0x3,2
  02F8    07F5    ADDR	0x75
  02F9    1003    CLRB	0x3,0
  02FA    0DCE    RLCR	0x4E
  02FB    0DCF    RLCR	0x4F
  02FC    0DD0    RLCR	0x50
  02FD    0DD1    RLCR	0x51
  02FE    1003    CLRB	0x3,0
  02FF    0CCD    RRCR	0x4D
  0300    0CCC    RRCR	0x4C
  0301    0CCB    RRCR	0x4B
  0302    0CCA    RRCR	0x4A
  0303    084D    LD	A,0x4D
  0304    044C    ORA	0x4C
  0305    044B    ORA	0x4B
  0306    044A    ORA	0x4A
  0307    1D03    SNZB	0x3,2
  0308    2AE3    JP	0x2E3
  0309    0875    LD	A,0x75
  030A    00CD    LD	0x4D,A
  030B    0874    LD	A,0x74
  030C    00CC    LD	0x4C,A
  030D    0873    LD	A,0x73
  030E    00CB    LD	0x4B,A
  030F    0872    LD	A,0x72
  0310    00CA    LD	0x4A,A
  0311    0008    RET
16:               {
17:               	unsigned long product;
18:               
19:               #define LOWBYTE(x)  (*(unsigned char *)(&x))
20:               #define LMIDBYTE(x) (*(((unsigned char *)(&x))+1))
21:               #define HMIDBYTE(x) (*(((unsigned char *)(&x))+2))
22:               #define HIGHBYTE(x) (*(((unsigned char *)(&x))+3))
23:               
24:               #if (_Has_hardware_multiply || _Has_large_call_stack) && defined(__OPTIMIZE_SPEED__)
25:               	{
26:               
27:               #define USE_SHRINK
28:               
29:               /*
30:               a 32-bit multiply can be decomposed into the sum of ten 8-bit multiplies
31:                            a  b  c  d
32:               *            e  f  g  h
33:               -----------------------
34:                          |         dh
35:                          |      ch  0
36:                          |   bh  0  0
37:                          |ah  0  0  0
38:                          |      dg  0
39:                          |   cg  0  0
40:                          |bg  0  0  0
41:                        ag| 0  0  0  0 (we ignore this intermediate product
42:                                        because it does not affect the low 32 bits of the result)
43:                          |   df  0  0
44:                          |cf  0  0  0
45:                        bf| 0  0  0  0 (ignore)
46:                     af  0| 0  0  0  0 (ignore)
47:                          |de  0  0  0
48:                        ce| 0  0  0  0 (ignore)
49:                     be  0| 0  0  0  0 (ignore)
50:               +  ae  0  0| 0  0  0  0 (ignore)
51:               =======================
52:                */
53:               		product =  (unsigned int)LOWBYTE(multiplier) * LOWBYTE(multiplicand);
54:               
55:               #if defined(USE_MASKS)
56:               		product += ((unsigned long)
57:               			     ((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand))
58:               			     +
59:               			     ((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
60:               			<< 8;
61:               
62:               		product += ((unsigned long)
63:               			    ((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand))
64:               			    +
65:               			    ((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
66:               			    +
67:               			    ((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
68:               			<< 16;
69:               
70:               		/* cast to smaller type to avoid adding high bits just to discard */
71:               		product += ((unsigned long)
72:               			    (unsigned char)
73:               			    ((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand))
74:               			    +
75:               			    (unsigned char)
76:               			    ((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand))
77:               			    +
78:               			    (unsigned char)
79:               			    ((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
80:               			    +
81:               			    (unsigned char)
82:               			    ((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand)))
83:               			<< 24;
84:               
85:               #elif defined(USE_SHRINK)
86:               		/* add direct to upper bytes, rather than shift and add all bytes */
87:               		*((unsigned short long*)(((unsigned char*)&product)+1)) +=
88:               			((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand));
89:               		*((unsigned short long*)(((unsigned char*)&product)+1)) +=
90:               			((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand));
91:               
92:               
93:               		*((unsigned int*)(((unsigned char*)&product)+2)) +=
94:               			((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand));
95:               		*((unsigned int*)(((unsigned char*)&product)+2)) +=
96:               			((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
97:               		*((unsigned int*)(((unsigned char*)&product)+2)) +=
98:               			((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand));
99:               
100:              		*(((unsigned char*)&product)+3) +=
101:              			(unsigned char)
102:              			((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand));
103:              		*(((unsigned char*)&product)+3) +=
104:              			(unsigned char)
105:              			((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand));
106:              		*(((unsigned char*)&product)+3) +=
107:              			(unsigned char)
108:              			((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
109:              		*(((unsigned char*)&product)+3) +=
110:              			(unsigned char)
111:              			((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand));
112:              
113:              #else
114:              #error No method chosen
115:              #endif
116:              	}
117:              #else
118:              
119:              	product = 0;
120:              	do {
121:              		if(multiplier & 1)
122:              			product += multiplicand;
123:              		multiplicand <<= 1;
124:              		multiplier >>= 1;
125:              	} while(multiplier != 0);
126:              
127:              #endif
128:              	return product;
129:              }
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\lwmod.c ----------------------------------------------------------------------
1:                // word unsigned modulus
2:                
3:                unsigned int
4:                #ifdef __PICC__
5:                #warning TODO: update cgpic and this file to use the other prototype
6:                __lwmod(unsigned int divisor, unsigned int dividend)
  0387    0872    LD	A,0x72
  0388    0473    ORA	0x73
  0389    1903    SZB	0x3,2
  038A    2BA6    JP	0x3A6
  038B    01F6    CLR	0x76
  038C    0AF6    INCR	0x76
  038D    1BF3    SZB	0x73,7
  038E    2B93    JP	0x393
  038F    1003    CLRB	0x3,0
  0390    0DF2    RLCR	0x72
  0391    0DF3    RLCR	0x73
  0392    2B8C    JP	0x38C
  0393    0873    LD	A,0x73
  0394    0275    SUBA	0x75
  0395    1D03    SNZB	0x3,2
  0396    2B99    JP	0x399
  0397    0872    LD	A,0x72
  0398    0274    SUBA	0x74
  0399    1C03    SNZB	0x3,0
  039A    2BA2    JP	0x3A2
  039B    0872    LD	A,0x72
  039C    02F4    SUBR	0x74
  039D    0873    LD	A,0x73
  039E    1C03    SNZB	0x3,0
  039F    03F5    DECR	0x75
  03A0    02F5    SUBR	0x75
  03A1    1003    CLRB	0x3,0
  03A2    0CF3    RRCR	0x73
  03A3    0CF2    RRCR	0x72
  03A4    0BF6    SZDECR	0x76
  03A5    2B93    JP	0x393
  03A6    0875    LD	A,0x75
  03A7    00F3    LD	0x73,A
  03A8    0874    LD	A,0x74
  03A9    00F2    LD	0x72,A
  03AA    0008    RET
7:                #else
8:                __lwmod(unsigned int dividend, unsigned int divisor)
9:                #endif
10:               {
11:               	unsigned char	counter;
12:               
13:               	if(divisor != 0) {
14:               		counter = 1;
15:               		while((divisor & 0x8000) == 0) {
16:               			divisor <<= 1;
17:               			counter++;
18:               		}
19:               		do {
20:               			if(divisor <= dividend)
21:               				dividend -= divisor;
22:               			divisor >>= 1;
23:               		} while(--counter != 0);
24:               	}
25:               	return dividend;
26:               }
---- library_code ------------------------------------------------------------------
  046C    1A78    SZB	0x78,4
  046D    2C7A    JP	0x47A
  046E    2529    CALL	0x529
  046F    118A    CLRB	0xA,3
  0470    3008    LDIA	0x8
  0471    1283    CLRB	0x3,5
  0472    1303    CLRB	0x3,6
  0473    0AB2    INCR	0x32
  0474    0232    SUBA	0x32
  0475    1C03    SNZB	0x3,0
  0476    2C98    JP	0x498
  0477    01B2    CLR	0x32
  0478    1678    SETB	0x78,4
  0479    2C98    JP	0x498
  047A    19F8    SZB	0x78,3
  047B    2C92    JP	0x492
  047C    2598    CALL	0x598
  047D    118A    CLRB	0xA,3
  047E    272D    CALL	0x72D
  047F    118A    CLRB	0xA,3
  0480    15F8    SETB	0x78,3
  0481    18F8    SZB	0x78,1
  0482    2C89    JP	0x489
  0483    3002    LDIA	0x2
  0484    1283    CLRB	0x3,5
  0485    1303    CLRB	0x3,6
  0486    0232    SUBA	0x32
  0487    1C03    SNZB	0x3,0
  0488    2C8E    JP	0x48E
  0489    2719    CALL	0x719
  048A    118A    CLRB	0xA,3
  048B    10F8    CLRB	0x78,1
  048C    1278    CLRB	0x78,4
  048D    11F8    CLRB	0x78,3
  048E    1283    CLRB	0x3,5
  048F    1303    CLRB	0x3,6
  0490    01B2    CLR	0x32
  0491    2C98    JP	0x498
  0492    26B1    CALL	0x6B1
  0493    118A    CLRB	0xA,3
  0494    2589    CALL	0x589
  0495    118A    CLRB	0xA,3
  0496    1278    CLRB	0x78,4
  0497    11F8    CLRB	0x78,3
  0498    2F5E    JP	0x75E
  0499    0064    CLRWDT
  049A    1683    SETB	0x3,5
  049B    1303    CLRB	0x3,6
  049C    0181    CLR	0x1
  049D    3007    LDIA	0x7
  049E    1283    CLRB	0x3,5
  049F    0481    ORR	0x1
  04A0    1581    SETB	0x1,3
  04A1    0064    CLRWDT
  04A2    300A    LDIA	0xA
  04A3    1283    CLRB	0x3,5
  04A4    1303    CLRB	0x3,6
  04A5    0081    LD	0x1,A
  04A6    0064    CLRWDT
  04A7    1283    CLRB	0x3,5
  04A8    1703    SETB	0x3,6
  04A9    0191    CLR	0x11
  04AA    0193    CLR	0x13
  04AB    3002    LDIA	0x2
  04AC    1303    CLRB	0x3,6
  04AD    0094    LD	0x14,A
  04AE    0063    STOP
  04AF    0000    NOP
  04B0    0064    CLRWDT
  04B1    3072    LDIA	0x72
  04B2    1283    CLRB	0x3,5
  04B3    1303    CLRB	0x3,6
  04B4    0094    LD	0x14,A
  04B5    3079    LDIA	0x79
  04B6    1703    SETB	0x3,6
  04B7    0093    LD	0x13,A
  04B8    2589    CALL	0x589
  04B9    118A    CLRB	0xA,3
  04BA    1478    SETB	0x78,0
  04BB    2529    CALL	0x529
  04BC    118A    CLRB	0xA,3
  04BD    1283    CLRB	0x3,5
  04BE    1303    CLRB	0x3,6
  04BF    27F0    CALL	0x7F0
  04C0    118A    CLRB	0xA,3
  04C1    1C0B    SNZB	0xB,0
  04C2    188B    SZB	0xB,1
  04C3    2CC6    JP	0x4C6
  04C4    1D8D    SNZB	0xD,3
  04C5    2CCD    JP	0x4CD
  04C6    2589    CALL	0x589
  04C7    1283    CLRB	0x3,5
  04C8    1303    CLRB	0x3,6
  04C9    01B2    CLR	0x32
  04CA    1278    CLRB	0x78,4
  04CB    11F8    CLRB	0x78,3
  04CC    0008    RET
  04CD    0850    LD	A,0x50
  04CE    3907    ANDIA	0x7
  04CF    1003    CLRB	0x3,0
  04D0    1903    SZB	0x3,2
  04D1    2D23    JP	0x523
  04D2    0D52    RLCA	0x52
  04D3    3EB8    ADDIA	0xB8
  04D4    0084    LD	0x4,A
  04D5    1383    CLRB	0x3,7
  04D6    0800    LD	A,0x0
  04D7    00CE    LD	0x4E,A
  04D8    0A84    INCR	0x4
  04D9    0800    LD	A,0x0
  04DA    00CF    LD	0x4F,A
  04DB    00CD    LD	0x4D,A
  04DC    084E    LD	A,0x4E
  04DD    00CC    LD	0x4C,A
  04DE    084E    LD	A,0x4E
  04DF    044F    ORA	0x4F
  04E0    1903    SZB	0x3,2
  04E1    2D22    JP	0x522
  04E2    0852    LD	A,0x52
  04E3    3E09    ADDIA	0x9
  04E4    0084    LD	0x4,A
  04E5    158A    SETB	0xA,3
  04E6    2000    CALL	0x0
  04E7    118A    CLRB	0xA,3
  04E8    07CC    ADDR	0x4C
  04E9    1803    SZB	0x3,0
  04EA    0ACD    INCR	0x4D
  04EB    1003    CLRB	0x3,0
  04EC    0D52    RLCA	0x52
  04ED    3EA6    ADDIA	0xA6
  04EE    27CF    CALL	0x7CF
  04EF    118A    CLRB	0xA,3
  04F0    084D    LD	A,0x4D
  04F1    024B    SUBA	0x4B
  04F2    1D03    SNZB	0x3,2
  04F3    2CF6    JP	0x4F6
  04F4    084C    LD	A,0x4C
  04F5    024A    SUBA	0x4A
  04F6    1C03    SNZB	0x3,0
  04F7    2D0A    JP	0x50A
  04F8    27F0    CALL	0x7F0
  04F9    118A    CLRB	0xA,3
  04FA    0850    LD	A,0x50
  04FB    3907    ANDIA	0x7
  04FC    1D03    SNZB	0x3,2
  04FD    2D01    JP	0x501
  04FE    0852    LD	A,0x52
  04FF    268E    CALL	0x68E
  0500    118A    CLRB	0xA,3
  0501    1283    CLRB	0x3,5
  0502    3003    LDIA	0x3
  0503    1303    CLRB	0x3,6
  0504    1003    CLRB	0x3,0
  0505    27F5    CALL	0x7F5
  0506    118A    CLRB	0xA,3
  0507    1803    SZB	0x3,0
  0508    2CC6    JP	0x4C6
  0509    2CFA    JP	0x4FA
  050A    0D52    RLCA	0x52
  050B    3EAC    ADDIA	0xAC
  050C    27CF    CALL	0x7CF
  050D    118A    CLRB	0xA,3
  050E    1003    CLRB	0x3,0
  050F    0D52    RLCA	0x52
  0510    3EA6    ADDIA	0xA6
  0511    27B9    CALL	0x7B9
  0512    118A    CLRB	0xA,3
  0513    0800    LD	A,0x0
  0514    00CA    LD	0x4A,A
  0515    0A84    INCR	0x4
  0516    0800    LD	A,0x0
  0517    00CB    LD	0x4B,A
  0518    1003    CLRB	0x3,0
  0519    0D52    RLCA	0x52
  051A    3EAC    ADDIA	0xAC
  051B    27B9    CALL	0x7B9
  051C    118A    CLRB	0xA,3
  051D    084E    LD	A,0x4E
  051E    0080    LD	0x0,A
  051F    0A84    INCR	0x4
  0520    084F    LD	A,0x4F
  0521    0080    LD	0x0,A
  0522    1003    CLRB	0x3,0
  0523    3003    LDIA	0x3
  0524    27F5    CALL	0x7F5
  0525    118A    CLRB	0xA,3
  0526    1803    SZB	0x3,0
  0527    2C99    JP	0x499
  0528    2CCD    JP	0x4CD
  0529    01F7    CLR	0x77
  052A    01F5    CLR	0x75
  052B    0AF5    INCR	0x75
  052C    01F6    CLR	0x76
  052D    1C78    SNZB	0x78,0
  052E    2D33    JP	0x533
  052F    0875    LD	A,0x75
  0530    3907    ANDIA	0x7
  0531    1903    SZB	0x3,2
  0532    2D7F    JP	0x57F
  0533    1283    CLRB	0x3,5
  0534    1703    SETB	0x3,6
  0535    0191    CLR	0x11
  0536    0192    CLR	0x12
  0537    3079    LDIA	0x79
  0538    0093    LD	0x13,A
  0539    1303    CLRB	0x3,6
  053A    1305    CLRB	0x5,6
  053B    1306    CLRB	0x6,6
  053C    0000    NOP
  053D    0000    NOP
  053E    0000    NOP
  053F    0000    NOP
  0540    0000    NOP
  0541    0000    NOP
  0542    0000    NOP
  0543    0000    NOP
  0544    1283    CLRB	0x3,5
  0545    1303    CLRB	0x3,6
  0546    1705    SETB	0x5,6
  0547    0877    LD	A,0x77
  0548    3E0C    ADDIA	0xC
  0549    0084    LD	0x4,A
  054A    158A    SETB	0xA,3
  054B    2000    CALL	0x0
  054C    118A    CLRB	0xA,3
  054D    1703    SETB	0x3,6
  054E    0091    LD	0x11,A
  054F    0877    LD	A,0x77
  0550    3E0F    ADDIA	0xF
  0551    0084    LD	0x4,A
  0552    158A    SETB	0xA,3
  0553    2000    CALL	0x0
  0554    118A    CLRB	0xA,3
  0555    0092    LD	0x12,A
  0556    0000    NOP
  0557    0000    NOP
  0558    0000    NOP
  0559    0000    NOP
  055A    1283    CLRB	0x3,5
  055B    1703    SETB	0x3,6
  055C    1411    SETB	0x11,0
  055D    30D0    LDIA	0xD0
  055E    00F3    LD	0x73,A
  055F    3007    LDIA	0x7
  0560    00F4    LD	0x74,A
  0561    1B91    SZB	0x11,7
  0562    2D6F    JP	0x56F
  0563    3001    LDIA	0x1
  0564    02F3    SUBR	0x73
  0565    1C03    SNZB	0x3,0
  0566    03F4    DECR	0x74
  0567    0873    LD	A,0x73
  0568    0474    ORA	0x74
  0569    1D03    SNZB	0x3,2
  056A    2D61    JP	0x561
  056B    30FF    LDIA	0xFF
  056C    1303    CLRB	0x3,6
  056D    00B2    LD	0x32,A
  056E    2D89    JP	0x589
  056F    1003    CLRB	0x3,0
  0570    0D77    RLCA	0x77
  0571    3EB8    ADDIA	0xB8
  0572    0084    LD	0x4,A
  0573    0816    LD	A,0x16
  0574    1383    CLRB	0x3,7
  0575    0780    ADDR	0x0
  0576    0F84    SZINCR	0x4
  0577    0800    LD	A,0x0
  0578    1803    SZB	0x3,0
  0579    0A00    INCA	0x0
  057A    00FF    LD	0x7F,A
  057B    0817    LD	A,0x17
  057C    077F    ADDA	0x7F
  057D    0080    LD	0x0,A
  057E    0384    DECR	0x4
  057F    3003    LDIA	0x3
  0580    1003    CLRB	0x3,0
  0581    0DF5    RLCR	0x75
  0582    0DF6    RLCR	0x76
  0583    0AF7    INCR	0x77
  0584    0277    SUBA	0x77
  0585    1C03    SNZB	0x3,0
  0586    2D2D    JP	0x52D
  0587    1078    CLRB	0x78,0
  0588    0008    RET
  0589    01F2    CLR	0x72
  058A    1003    CLRB	0x3,0
  058B    0D72    RLCA	0x72
  058C    3EB8    ADDIA	0xB8
  058D    0084    LD	0x4,A
  058E    3003    LDIA	0x3
  058F    1383    CLRB	0x3,7
  0590    0180    CLR	0x0
  0591    0A84    INCR	0x4
  0592    0180    CLR	0x0
  0593    0AF2    INCR	0x72
  0594    0272    SUBA	0x72
  0595    1803    SZB	0x3,0
  0596    0008    RET
  0597    2D8A    JP	0x58A
  0598    1283    CLRB	0x3,5
  0599    1303    CLRB	0x3,6
  059A    01D6    CLR	0x56
  059B    01A0    CLR	0x20
  059C    01A1    CLR	0x21
  059D    01B1    CLR	0x31
  059E    0856    LD	A,0x56
  059F    3907    ANDIA	0x7
  05A0    3E01    ADDIA	0x1
  05A1    0084    LD	0x4,A
  05A2    158A    SETB	0xA,3
  05A3    2000    CALL	0x0
  05A4    118A    CLRB	0xA,3
  05A5    00D0    LD	0x50,A
  05A6    1003    CLRB	0x3,0
  05A7    0D56    RLCA	0x56
  05A8    3EB8    ADDIA	0xB8
  05A9    0084    LD	0x4,A
  05AA    3003    LDIA	0x3
  05AB    0A84    INCR	0x4
  05AC    1003    CLRB	0x3,0
  05AD    1383    CLRB	0x3,7
  05AE    0C80    RRCR	0x0
  05AF    0384    DECR	0x4
  05B0    0C80    RRCR	0x0
  05B1    3EFF    ADDIA	0xFF
  05B2    1D03    SNZB	0x3,2
  05B3    2DAB    JP	0x5AB
  05B4    1003    CLRB	0x3,0
  05B5    0D56    RLCA	0x56
  05B6    3EB8    ADDIA	0xB8
  05B7    0084    LD	0x4,A
  05B8    0800    LD	A,0x0
  05B9    00D4    LD	0x54,A
  05BA    0A84    INCR	0x4
  05BB    0800    LD	A,0x0
  05BC    00D5    LD	0x55,A
  05BD    0856    LD	A,0x56
  05BE    3E09    ADDIA	0x9
  05BF    0084    LD	0x4,A
  05C0    158A    SETB	0xA,3
  05C1    2000    CALL	0x0
  05C2    118A    CLRB	0xA,3
  05C3    00D3    LD	0x53,A
  05C4    00D1    LD	0x51,A
  05C5    01D2    CLR	0x52
  05C6    0854    LD	A,0x54
  05C7    07D1    ADDR	0x51
  05C8    1803    SZB	0x3,0
  05C9    0AD2    INCR	0x52
  05CA    0855    LD	A,0x55
  05CB    07D2    ADDR	0x52
  05CC    0856    LD	A,0x56
  05CD    267E    CALL	0x67E
  05CE    118A    CLRB	0xA,3
  05CF    3A00    XORIA	0x0
  05D0    1D03    SNZB	0x3,2
  05D1    2E2F    JP	0x62F
  05D2    1283    CLRB	0x3,5
  05D3    1303    CLRB	0x3,6
  05D4    1003    CLRB	0x3,0
  05D5    0D56    RLCA	0x56
  05D6    3EA6    ADDIA	0xA6
  05D7    0084    LD	0x4,A
  05D8    1383    CLRB	0x3,7
  05D9    0800    LD	A,0x0
  05DA    00CE    LD	0x4E,A
  05DB    0A84    INCR	0x4
  05DC    0800    LD	A,0x0
  05DD    00CF    LD	0x4F,A
  05DE    1003    CLRB	0x3,0
  05DF    0D56    RLCA	0x56
  05E0    3EA0    ADDIA	0xA0
  05E1    27B2    CALL	0x7B2
  05E2    118A    CLRB	0xA,3
  05E3    0252    SUBA	0x52
  05E4    1D03    SNZB	0x3,2
  05E5    2DE8    JP	0x5E8
  05E6    084A    LD	A,0x4A
  05E7    0251    SUBA	0x51
  05E8    1803    SZB	0x3,0
  05E9    2DF7    JP	0x5F7
  05EA    1003    CLRB	0x3,0
  05EB    0D56    RLCA	0x56
  05EC    3EA0    ADDIA	0xA0
  05ED    27B2    CALL	0x7B2
  05EE    118A    CLRB	0xA,3
  05EF    0854    LD	A,0x54
  05F0    024A    SUBA	0x4A
  05F1    00D4    LD	0x54,A
  05F2    0855    LD	A,0x55
  05F3    1C03    SNZB	0x3,0
  05F4    0A55    INCA	0x55
  05F5    024B    SUBA	0x4B
  05F6    2E1B    JP	0x61B
  05F7    084F    LD	A,0x4F
  05F8    0252    SUBA	0x52
  05F9    1D03    SNZB	0x3,2
  05FA    2DFD    JP	0x5FD
  05FB    084E    LD	A,0x4E
  05FC    0251    SUBA	0x51
  05FD    1803    SZB	0x3,0
  05FE    2E76    JP	0x676
  05FF    1003    CLRB	0x3,0
  0600    0D56    RLCA	0x56
  0601    3EAC    ADDIA	0xAC
  0602    27B2    CALL	0x7B2
  0603    118A    CLRB	0xA,3
  0604    0252    SUBA	0x52
  0605    1D03    SNZB	0x3,2
  0606    2E09    JP	0x609
  0607    084A    LD	A,0x4A
  0608    0251    SUBA	0x51
  0609    1803    SZB	0x3,0
  060A    2E76    JP	0x676
  060B    1003    CLRB	0x3,0
  060C    0D56    RLCA	0x56
  060D    3EA0    ADDIA	0xA0
  060E    0084    LD	0x4,A
  060F    084E    LD	A,0x4E
  0610    0080    LD	0x0,A
  0611    0A84    INCR	0x4
  0612    084F    LD	A,0x4F
  0613    0080    LD	0x0,A
  0614    0854    LD	A,0x54
  0615    024E    SUBA	0x4E
  0616    00D4    LD	0x54,A
  0617    0855    LD	A,0x55
  0618    1C03    SNZB	0x3,0
  0619    0A55    INCA	0x55
  061A    024F    SUBA	0x4F
  061B    00D5    LD	0x55,A
  061C    0856    LD	A,0x56
  061D    3EBE    ADDIA	0xBE
  061E    0084    LD	0x4,A
  061F    0180    CLR	0x0
  0620    0855    LD	A,0x55
  0621    1903    SZB	0x3,2
  0622    2E25    JP	0x625
  0623    30FF    LDIA	0xFF
  0624    2E26    JP	0x626
  0625    0854    LD	A,0x54
  0626    00D3    LD	0x53,A
  0627    0231    SUBA	0x31
  0628    1803    SZB	0x3,0
  0629    2E2D    JP	0x62D
  062A    0853    LD	A,0x53
  062B    00B1    LD	0x31,A
  062C    2E70    JP	0x670
  062D    0AB2    INCR	0x32
  062E    2E76    JP	0x676
  062F    1283    CLRB	0x3,5
  0630    1303    CLRB	0x3,6
  0631    1003    CLRB	0x3,0
  0632    0D56    RLCA	0x56
  0633    3EA0    ADDIA	0xA0
  0634    0084    LD	0x4,A
  0635    1383    CLRB	0x3,7
  0636    0800    LD	A,0x0
  0637    00CA    LD	0x4A,A
  0638    0A84    INCR	0x4
  0639    0800    LD	A,0x0
  063A    00CB    LD	0x4B,A
  063B    084A    LD	A,0x4A
  063C    3E01    ADDIA	0x1
  063D    00CC    LD	0x4C,A
  063E    084B    LD	A,0x4B
  063F    1803    SZB	0x3,0
  0640    3E01    ADDIA	0x1
  0641    00CD    LD	0x4D,A
  0642    0852    LD	A,0x52
  0643    024D    SUBA	0x4D
  0644    1D03    SNZB	0x3,2
  0645    2E48    JP	0x648
  0646    0851    LD	A,0x51
  0647    024C    SUBA	0x4C
  0648    1C03    SNZB	0x3,0
  0649    2E76    JP	0x676
  064A    1003    CLRB	0x3,0
  064B    0D56    RLCA	0x56
  064C    3EA6    ADDIA	0xA6
  064D    0084    LD	0x4,A
  064E    0800    LD	A,0x0
  064F    27A0    CALL	0x7A0
  0650    118A    CLRB	0xA,3
  0651    1C03    SNZB	0x3,0
  0652    2E5C    JP	0x65C
  0653    1003    CLRB	0x3,0
  0654    0D56    RLCA	0x56
  0655    3EAC    ADDIA	0xAC
  0656    0084    LD	0x4,A
  0657    0800    LD	A,0x0
  0658    27A0    CALL	0x7A0
  0659    118A    CLRB	0xA,3
  065A    1803    SZB	0x3,0
  065B    2E68    JP	0x668
  065C    0856    LD	A,0x56
  065D    3EBE    ADDIA	0xBE
  065E    0084    LD	0x4,A
  065F    3009    LDIA	0x9
  0660    0A80    INCR	0x0
  0661    0200    SUBA	0x0
  0662    1C03    SNZB	0x3,0
  0663    2E6C    JP	0x66C
  0664    0856    LD	A,0x56
  0665    268E    CALL	0x68E
  0666    118A    CLRB	0xA,3
  0667    2E76    JP	0x676
  0668    0856    LD	A,0x56
  0669    3EBE    ADDIA	0xBE
  066A    0084    LD	0x4,A
  066B    0180    CLR	0x0
  066C    0821    LD	A,0x21
  066D    0420    ORA	0x20
  066E    1D03    SNZB	0x3,2
  066F    2E76    JP	0x676
  0670    0850    LD	A,0x50
  0671    00F2    LD	0x72,A
  0672    01F3    CLR	0x73
  0673    0856    LD	A,0x56
  0674    26A3    CALL	0x6A3
  0675    118A    CLRB	0xA,3
  0676    3003    LDIA	0x3
  0677    1283    CLRB	0x3,5
  0678    1303    CLRB	0x3,6
  0679    0AD6    INCR	0x56
  067A    0256    SUBA	0x56
  067B    1803    SZB	0x3,0
  067C    0008    RET
  067D    2D9E    JP	0x59E
  067E    00F3    LD	0x73,A
  067F    3907    ANDIA	0x7
  0680    3E01    ADDIA	0x1
  0681    0084    LD	0x4,A
  0682    158A    SETB	0xA,3
  0683    2000    CALL	0x0
  0684    118A    CLRB	0xA,3
  0685    00F2    LD	0x72,A
  0686    1DF3    SNZB	0x73,3
  0687    2E8A    JP	0x68A
  0688    087A    LD	A,0x7A
  0689    2E8B    JP	0x68B
  068A    0879    LD	A,0x79
  068B    05F2    ANDR	0x72
  068C    0872    LD	A,0x72
  068D    0008    RET
  068E    00F2    LD	0x72,A
  068F    1003    CLRB	0x3,0
  0690    0D72    RLCA	0x72
  0691    3EB2    ADDIA	0xB2
  0692    0084    LD	0x4,A
  0693    1383    CLRB	0x3,7
  0694    27DE    CALL	0x7DE
  0695    118A    CLRB	0xA,3
  0696    3EAC    ADDIA	0xAC
  0697    0084    LD	0x4,A
  0698    27DE    CALL	0x7DE
  0699    118A    CLRB	0xA,3
  069A    3EA6    ADDIA	0xA6
  069B    0084    LD	0x4,A
  069C    27DE    CALL	0x7DE
  069D    3EA0    ADDIA	0xA0
  069E    0084    LD	0x4,A
  069F    0180    CLR	0x0
  06A0    0A84    INCR	0x4
  06A1    0180    CLR	0x0
  06A2    0008    RET
  06A3    00F4    LD	0x74,A
  06A4    1283    CLRB	0x3,5
  06A5    1303    CLRB	0x3,6
  06A6    0AB2    INCR	0x32
  06A7    01A0    CLR	0x20
  06A8    01A1    CLR	0x21
  06A9    1DF4    SNZB	0x74,3
  06AA    2EAE    JP	0x6AE
  06AB    0872    LD	A,0x72
  06AC    00A1    LD	0x21,A
  06AD    0008    RET
  06AE    0872    LD	A,0x72
  06AF    00A0    LD	0x20,A
  06B0    0008    RET
  06B1    1283    CLRB	0x3,5
  06B2    3004    LDIA	0x4
  06B3    1303    CLRB	0x3,6
  06B4    01CE    CLR	0x4E
  06B5    0AB0    INCR	0x30
  06B6    0230    SUBA	0x30
  06B7    1C03    SNZB	0x3,0
  06B8    0008    RET
  06B9    01B0    CLR	0x30
  06BA    1003    CLRB	0x3,0
  06BB    0D4E    RLCA	0x4E
  06BC    3EB8    ADDIA	0xB8
  06BD    0084    LD	0x4,A
  06BE    1383    CLRB	0x3,7
  06BF    0800    LD	A,0x0
  06C0    00CA    LD	0x4A,A
  06C1    0A84    INCR	0x4
  06C2    0800    LD	A,0x0
  06C3    00CB    LD	0x4B,A
  06C4    084E    LD	A,0x4E
  06C5    267E    CALL	0x67E
  06C6    118A    CLRB	0xA,3
  06C7    3A00    XORIA	0x0
  06C8    1D03    SNZB	0x3,2
  06C9    2F00    JP	0x700
  06CA    1283    CLRB	0x3,5
  06CB    1303    CLRB	0x3,6
  06CC    1003    CLRB	0x3,0
  06CD    0D4E    RLCA	0x4E
  06CE    3EB2    ADDIA	0xB2
  06CF    0084    LD	0x4,A
  06D0    1383    CLRB	0x3,7
  06D1    2792    CALL	0x792
  06D2    118A    CLRB	0xA,3
  06D3    1903    SZB	0x3,2
  06D4    024C    SUBA	0x4C
  06D5    1C03    SNZB	0x3,0
  06D6    2EDD    JP	0x6DD
  06D7    0F4C    SZINCA	0x4C
  06D8    2F00    JP	0x700
  06D9    0A4D    INCA	0x4D
  06DA    1D03    SNZB	0x3,2
  06DB    2F00    JP	0x700
  06DC    1003    CLRB	0x3,0
  06DD    0D4E    RLCA	0x4E
  06DE    3EAC    ADDIA	0xAC
  06DF    0084    LD	0x4,A
  06E0    2792    CALL	0x792
  06E1    118A    CLRB	0xA,3
  06E2    1903    SZB	0x3,2
  06E3    024C    SUBA	0x4C
  06E4    1C03    SNZB	0x3,0
  06E5    2EEC    JP	0x6EC
  06E6    0F4C    SZINCA	0x4C
  06E7    2F00    JP	0x700
  06E8    0A4D    INCA	0x4D
  06E9    1D03    SNZB	0x3,2
  06EA    2F00    JP	0x700
  06EB    1003    CLRB	0x3,0
  06EC    0D4E    RLCA	0x4E
  06ED    3EA6    ADDIA	0xA6
  06EE    0084    LD	0x4,A
  06EF    2792    CALL	0x792
  06F0    118A    CLRB	0xA,3
  06F1    1903    SZB	0x3,2
  06F2    024C    SUBA	0x4C
  06F3    1C03    SNZB	0x3,0
  06F4    2EFB    JP	0x6FB
  06F5    0F4C    SZINCA	0x4C
  06F6    2F00    JP	0x700
  06F7    0A4D    INCA	0x4D
  06F8    1D03    SNZB	0x3,2
  06F9    2F00    JP	0x700
  06FA    1003    CLRB	0x3,0
  06FB    0D4E    RLCA	0x4E
  06FC    3EA0    ADDIA	0xA0
  06FD    0084    LD	0x4,A
  06FE    27EA    CALL	0x7EA
  06FF    118A    CLRB	0xA,3
  0700    1283    CLRB	0x3,5
  0701    1303    CLRB	0x3,6
  0702    1003    CLRB	0x3,0
  0703    0D4E    RLCA	0x4E
  0704    3EAC    ADDIA	0xAC
  0705    0084    LD	0x4,A
  0706    1383    CLRB	0x3,7
  0707    27D6    CALL	0x7D6
  0708    118A    CLRB	0xA,3
  0709    3EA6    ADDIA	0xA6
  070A    27C4    CALL	0x7C4
  070B    118A    CLRB	0xA,3
  070C    27D6    CALL	0x7D6
  070D    118A    CLRB	0xA,3
  070E    3EAC    ADDIA	0xAC
  070F    27C4    CALL	0x7C4
  0710    118A    CLRB	0xA,3
  0711    27EA    CALL	0x7EA
  0712    118A    CLRB	0xA,3
  0713    3003    LDIA	0x3
  0714    0ACE    INCR	0x4E
  0715    024E    SUBA	0x4E
  0716    1803    SZB	0x3,0
  0717    0008    RET
  0718    2EBA    JP	0x6BA
  0719    01F9    CLR	0x79
  071A    01FA    CLR	0x7A
  071B    01F3    CLR	0x73
  071C    1003    CLRB	0x3,0
  071D    0D73    RLCA	0x73
  071E    3EB8    ADDIA	0xB8
  071F    0084    LD	0x4,A
  0720    1383    CLRB	0x3,7
  0721    0180    CLR	0x0
  0722    0A84    INCR	0x4
  0723    0180    CLR	0x0
  0724    0873    LD	A,0x73
  0725    268E    CALL	0x68E
  0726    118A    CLRB	0xA,3
  0727    3003    LDIA	0x3
  0728    0AF3    INCR	0x73
  0729    0273    SUBA	0x73
  072A    1803    SZB	0x3,0
  072B    0008    RET
  072C    2F1C    JP	0x71C
  072D    1283    CLRB	0x3,5
  072E    1303    CLRB	0x3,6
  072F    0821    LD	A,0x21
  0730    0420    ORA	0x20
  0731    1903    SZB	0x3,2
  0732    2F51    JP	0x751
  0733    01AE    CLR	0x2E
  0734    0820    LD	A,0x20
  0735    0622    XORA	0x22
  0736    1D03    SNZB	0x3,2
  0737    2F4A    JP	0x74A
  0738    0821    LD	A,0x21
  0739    0623    XORA	0x23
  073A    1D03    SNZB	0x3,2
  073B    2F4A    JP	0x74A
  073C    3002    LDIA	0x2
  073D    0AAF    INCR	0x2F
  073E    022F    SUBA	0x2F
  073F    1C03    SNZB	0x3,0
  0740    0008    RET
  0741    01AF    CLR	0x2F
  0742    0820    LD	A,0x20
  0743    00F9    LD	0x79,A
  0744    0821    LD	A,0x21
  0745    00FA    LD	0x7A,A
  0746    1978    SZB	0x78,2
  0747    0008    RET
  0748    1578    SETB	0x78,2
  0749    2F74    JP	0x774
  074A    1178    CLRB	0x78,2
  074B    0820    LD	A,0x20
  074C    00A2    LD	0x22,A
  074D    0821    LD	A,0x21
  074E    00A3    LD	0x23,A
  074F    01AF    CLR	0x2F
  0750    0008    RET
  0751    01AF    CLR	0x2F
  0752    01A2    CLR	0x22
  0753    01A3    CLR	0x23
  0754    3002    LDIA	0x2
  0755    0AAE    INCR	0x2E
  0756    022E    SUBA	0x2E
  0757    1C03    SNZB	0x3,0
  0758    0008    RET
  0759    01AE    CLR	0x2E
  075A    01F9    CLR	0x79
  075B    01FA    CLR	0x7A
  075C    1178    CLRB	0x78,2
  075D    0008    RET
  075E    087A    LD	A,0x7A
  075F    0479    ORA	0x79
  0760    1903    SZB	0x3,2
  0761    2F6F    JP	0x76F
  0762    1683    SETB	0x3,5
  0763    1303    CLRB	0x3,6
  0764    0AC1    INCR	0x41
  0765    1903    SZB	0x3,2
  0766    0AC2    INCR	0x42
  0767    303A    LDIA	0x3A
  0768    0242    SUBA	0x42
  0769    3098    LDIA	0x98
  076A    1903    SZB	0x3,2
  076B    0241    SUBA	0x41
  076C    1C03    SNZB	0x3,0
  076D    0008    RET
  076E    14F8    SETB	0x78,1
  076F    1683    SETB	0x3,5
  0770    1303    CLRB	0x3,6
  0771    01C1    CLR	0x41
  0772    01C2    CLR	0x42
  0773    0008    RET
  0774    01F4    CLR	0x74
  0775    0874    LD	A,0x74
  0776    267E    CALL	0x67E
  0777    118A    CLRB	0xA,3
  0778    3A00    XORIA	0x0
  0779    1D03    SNZB	0x3,2
  077A    2F7E    JP	0x77E
  077B    0874    LD	A,0x74
  077C    268E    CALL	0x68E
  077D    118A    CLRB	0xA,3
  077E    3003    LDIA	0x3
  077F    0AF4    INCR	0x74
  0780    0274    SUBA	0x74
  0781    1803    SZB	0x3,0
  0782    0008    RET
  0783    2F75    JP	0x775
---- stringtab ------------------------------------------------------------------
  0800    3008    LDIA	0x8
  0801    008A    LD	0xA,A
  0802    0804    LD	A,0x4
  0803    0A84    INCR	0x4
  0804    0782    ADDR	0x2
  0805    3400    RET	0x0
---- reset_enter ------------------------------------------------------------------
  0000    118A    CLRB	0xA,3
  0001    280B    JP	0xB
  000B    118A    CLRB	0xA,3
  000C    280D    JP	0xD
---- start_initialization ------------------------------------------------------------------
  000D    3002    LDIA	0x2
  000E    01EC    CLR	0x6C
  000F    00ED    LD	0x6D,A
  0010    3001    LDIA	0x1
  0011    00EE    LD	0x6E,A
  0012    30A0    LDIA	0xA0
  0013    1383    CLRB	0x3,7
  0014    0084    LD	0x4,A
  0015    30C9    LDIA	0xC9
  0016    158A    SETB	0xA,3
  0017    2616    CALL	0x616
  0018    118A    CLRB	0xA,3
  0019    3020    LDIA	0x20
  001A    0084    LD	0x4,A
  001B    304A    LDIA	0x4A
  001C    158A    SETB	0xA,3
  001D    2616    CALL	0x616
  001E    01F9    CLR	0x79
  001F    01FA    CLR	0x7A
  0020    01FB    CLR	0x7B
  0021    01F8    CLR	0x78
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F0    LD	0x70,A
  0007    080A    LD	A,0xA
  0008    00F1    LD	0x71,A
  0009    158A    SETB	0xA,3
  000A    2E1E    JP	0x61E
---- common_function ------------------------------------------------------------------
  0022    0183    CLR	0x3
  0023    158A    SETB	0xA,3
  0024    2E59    JP	0x659
  03E5    00F4    LD	0x74,A
  03E6    01F5    CLR	0x75
  03E7    01F6    CLR	0x76
  03E8    0873    LD	A,0x73
  03E9    02CD    SUBR	0x4D
  03EA    0874    LD	A,0x74
  03EB    1C03    SNZB	0x3,0
  03EC    0F74    SZINCA	0x74
  03ED    02CE    SUBR	0x4E
  03EE    0875    LD	A,0x75
  03EF    1C03    SNZB	0x3,0
  03F0    0F75    SZINCA	0x75
  03F1    02CF    SUBR	0x4F
  03F2    0876    LD	A,0x76
  03F3    0008    RET
  03F4    01CD    CLR	0x4D
  03F5    01CE    CLR	0x4E
  03F6    01CF    CLR	0x4F
  03F7    01D0    CLR	0x50
  03F8    01D1    CLR	0x51
  03F9    01D2    CLR	0x52
  03FA    01D3    CLR	0x53
  03FB    01D4    CLR	0x54
  03FC    0008    RET
  03FD    085F    LD	A,0x5F
  03FE    00E3    LD	0x63,A
  03FF    0860    LD	A,0x60
  0400    00E4    LD	0x64,A
  0401    0861    LD	A,0x61
  0402    00E5    LD	0x65,A
  0403    0008    RET
  0404    1003    CLRB	0x3,0
  0405    0CF4    RRCR	0x74
  0406    0CF3    RRCR	0x73
  0407    0CF2    RRCR	0x72
  0408    0008    RET
  0409    0856    LD	A,0x56
  040A    00D4    LD	0x54,A
  040B    0855    LD	A,0x55
  040C    00D3    LD	0x53,A
  040D    0008    RET
  040E    01D0    CLR	0x50
  040F    01D1    CLR	0x51
  0410    01D2    CLR	0x52
  0411    0008    RET
  0792    0800    LD	A,0x0
  0793    00CC    LD	0x4C,A
  0794    0A84    INCR	0x4
  0795    0800    LD	A,0x0
  0796    00CD    LD	0x4D,A
  0797    084A    LD	A,0x4A
  0798    02CC    SUBR	0x4C
  0799    084B    LD	A,0x4B
  079A    1C03    SNZB	0x3,0
  079B    03CD    DECR	0x4D
  079C    02CD    SUBR	0x4D
  079D    3000    LDIA	0x0
  079E    024D    SUBA	0x4D
  079F    3402    RET	0x2
  07A0    00CA    LD	0x4A,A
  07A1    0A84    INCR	0x4
  07A2    0800    LD	A,0x0
  07A3    00CB    LD	0x4B,A
  07A4    0853    LD	A,0x53
  07A5    074A    ADDA	0x4A
  07A6    00CC    LD	0x4C,A
  07A7    084B    LD	A,0x4B
  07A8    1803    SZB	0x3,0
  07A9    0A4B    INCA	0x4B
  07AA    00CD    LD	0x4D,A
  07AB    0855    LD	A,0x55
  07AC    024D    SUBA	0x4D
  07AD    1D03    SNZB	0x3,2
  07AE    0008    RET
  07AF    0854    LD	A,0x54
  07B0    024C    SUBA	0x4C
  07B1    0008    RET
  07B2    0084    LD	0x4,A
  07B3    0800    LD	A,0x0
  07B4    00CA    LD	0x4A,A
  07B5    0A84    INCR	0x4
  07B6    0800    LD	A,0x0
  07B7    00CB    LD	0x4B,A
  07B8    0008    RET
  07B9    0084    LD	0x4,A
  07BA    084A    LD	A,0x4A
  07BB    0080    LD	0x0,A
  07BC    0A84    INCR	0x4
  07BD    084B    LD	A,0x4B
  07BE    0080    LD	0x0,A
  07BF    1003    CLRB	0x3,0
  07C0    0D52    RLCA	0x52
  07C1    3EB2    ADDIA	0xB2
  07C2    0084    LD	0x4,A
  07C3    0008    RET
  07C4    0084    LD	0x4,A
  07C5    0874    LD	A,0x74
  07C6    0080    LD	0x0,A
  07C7    0A84    INCR	0x4
  07C8    0875    LD	A,0x75
  07C9    0080    LD	0x0,A
  07CA    1003    CLRB	0x3,0
  07CB    0D4E    RLCA	0x4E
  07CC    3EB2    ADDIA	0xB2
  07CD    0084    LD	0x4,A
  07CE    0008    RET
  07CF    0084    LD	0x4,A
  07D0    0800    LD	A,0x0
  07D1    00CA    LD	0x4A,A
  07D2    0A84    INCR	0x4
  07D3    0800    LD	A,0x0
  07D4    00CB    LD	0x4B,A
  07D5    0008    RET
  07D6    0800    LD	A,0x0
  07D7    00F4    LD	0x74,A
  07D8    0A84    INCR	0x4
  07D9    0800    LD	A,0x0
  07DA    00F5    LD	0x75,A
  07DB    1003    CLRB	0x3,0
  07DC    0D4E    RLCA	0x4E
  07DD    0008    RET
  07DE    0180    CLR	0x0
  07DF    0A84    INCR	0x4
  07E0    0180    CLR	0x0
  07E1    1003    CLRB	0x3,0
  07E2    0D72    RLCA	0x72
  07E3    0008    RET
  07E4    3041    LDIA	0x41
  07E5    1683    SETB	0x3,5
  07E6    0095    LD	0x15,A
  07E7    1415    SETB	0x15,0
  07E8    0196    CLR	0x16
  07E9    0008    RET
  07EA    084A    LD	A,0x4A
  07EB    0080    LD	0x0,A
  07EC    0A84    INCR	0x4
  07ED    084B    LD	A,0x4B
  07EE    0080    LD	0x0,A
  07EF    0008    RET
  07F0    01D2    CLR	0x52
  07F1    01D0    CLR	0x50
  07F2    0AD0    INCR	0x50
  07F3    01D1    CLR	0x51
  07F4    0008    RET
  07F5    0DD0    RLCR	0x50
  07F6    0DD1    RLCR	0x51
  07F7    0AD2    INCR	0x52
  07F8    0252    SUBA	0x52
  07F9    0008    RET
  0806    3401    RET	0x1
  0807    3402    RET	0x2
  0808    3404    RET	0x4
  0809    3408    RET	0x8
  080A    3410    RET	0x10
  080B    3420    RET	0x20
  080C    3440    RET	0x40
  080D    3480    RET	0x80
  080E    340A    RET	0xA
  080F    340A    RET	0xA
  0810    340A    RET	0xA
  0811    3402    RET	0x2
  0812    3402    RET	0x2
  0813    3402    RET	0x2
  0814    3444    RET	0x44
  0815    3443    RET	0x43
  0816    3442    RET	0x42
  0817    158A    SETB	0xA,3
  0818    2FAC    JP	0x7AC
  0819    158A    SETB	0xA,3
  081A    2FB3    JP	0x7B3
  081B    158A    SETB	0xA,3
  081C    2FB6    JP	0x7B6
  081D    158A    SETB	0xA,3
  081E    2FB9    JP	0x7B9
  081F    158A    SETB	0xA,3
  0820    2FC0    JP	0x7C0
  0821    158A    SETB	0xA,3
  0822    2FC3    JP	0x7C3
  0823    158A    SETB	0xA,3
  0824    2FC6    JP	0x7C6
  0825    158A    SETB	0xA,3
  0826    2FC9    JP	0x7C9
  0827    158A    SETB	0xA,3
  0828    2FC9    JP	0x7C9
  0829    158A    SETB	0xA,3
  082A    2FC6    JP	0x7C6
  082B    158A    SETB	0xA,3
  082C    2FC3    JP	0x7C3
  082D    158A    SETB	0xA,3
  082E    2FC0    JP	0x7C0
  082F    158A    SETB	0xA,3
  0830    2FB9    JP	0x7B9
  0831    158A    SETB	0xA,3
  0832    2FB6    JP	0x7B6
  0833    158A    SETB	0xA,3
  0834    2FB3    JP	0x7B3
  0835    158A    SETB	0xA,3
  0836    2FAC    JP	0x7AC
  0E16    0064    CLRWDT
  0E17    0180    CLR	0x0
  0E18    0A84    INCR	0x4
  0E19    0604    XORA	0x4
  0E1A    1903    SZB	0x3,2
  0E1B    3400    RET	0x0
  0E1C    0604    XORA	0x4
  0E1D    2E17    JP	0x617
  0F39    30C2    LDIA	0xC2
  0F3A    00AC    LD	0x2C,A
  0F3B    3001    LDIA	0x1
  0F3C    00AD    LD	0x2D,A
  0F3D    0008    RET
  0FEA    086D    LD	A,0x6D
  0FEB    00F3    LD	0x73,A
  0FEC    086C    LD	A,0x6C
  0FED    00F2    LD	0x72,A
  0FEE    1003    CLRB	0x3,0
  0FEF    0008    RET
  0FF0    1306    CLRB	0x6,6
  0FF1    1386    CLRB	0x6,7
  0FF2    1283    CLRB	0x3,5
  0FF3    1786    SETB	0x6,7
  0FF4    0008    RET
  0FF5    1706    SETB	0x6,6
  0FF6    1386    CLRB	0x6,7
  0FF7    1283    CLRB	0x3,5
  0FF8    1386    CLRB	0x6,7
  0FF9    0008    RET
  0FFA    1683    SETB	0x3,5
  0FFB    1286    CLRB	0x6,5
  0FFC    1306    CLRB	0x6,6
  0FFD    1786    SETB	0x6,7
  0FFE    1283    CLRB	0x3,5
