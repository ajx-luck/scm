---- C:\mcuproject\scm\zdt\D108_8F083_tssop20_\D108_8F083_tssop20_\main.c ----------------------------------------------------------------------
1:                #include <sc.h>
2:                #include "Touch_Kscan_Library.h"
3:                
4:                #ifndef _XTAL_FREQ
5:                #define _XTAL_FREQ 8000000			//8MHz,使用内置延时函数必须定义主频，
6:                									//如用16M需改此参数为16000000
7:                #endif
8:                #define     POWER_RATIO  	(4096UL*1.2*1000)
9:                
10:               #define		uchar		unsigned char
11:               #define		u8t		unsigned char
12:               #define		uint			unsigned int
13:               #define		u16t			unsigned int
14:               #define		ulong		unsigned long
15:               #define		MOT1		RA5
16:               #define		MOT2		RA6
17:               #define		MOT3		RA7
18:               #define		MOT4		RB7
19:               
20:               volatile unsigned char MainTime;
21:               volatile bit	B_MainLoop,B_OnOff;
22:               u8t	count1s = 0;
23:               u8t	workStep = 0;
24:               u8t	wuhuaFlag = 0;
25:               u16t		shanshuoTime = 0;
26:               u16t		shanshuoTime2 = 0;
27:               u16t		shanshuoTime3 = 0;
28:               u16t		fanValue = 0;
29:               u16t		wuhuaValue = 0;
30:               u8t	fanDuty = 0;
31:               u8t	count10s = 0;
32:               u8t	fanOverTime = 0;
33:               u8t	firstTime = 0;
34:               u16t	checkTime = 0;
35:               u16t	lowWaterTime = 0;
36:               u8t		chrgFlag = 0;
37:               u8t		chrgFullFlag = 0;
38:               u8t		chrgFullTime = 0;
39:               u8t		firstLock = 0;
40:               u8t		lowBatLock = 0;
41:               u16t		lowBatTime = 0;	
42:               u8t		lowFanTime = 0;//风扇降低为1档的时间
43:               u8t		bujinFlag = 0;	
44:               u16t	motorStep = 0;
45:               u16t	maxMotorStep = 512;
46:               u8t		powerFlag = 0;
47:               u16t		keyCount = 0;
48:               u8t		longKeyFlag = 0;
49:               u8t		closeTime = 0;
50:               u8t		motorStopFlag = 0;
51:               u8t		zeroFlag = 1;	//默认在原点
52:               u8t		bujinStartFlag = 0;
53:               
54:               volatile unsigned int adresult;
55:               volatile unsigned int result;
56:               volatile unsigned char test_adc;
57:               volatile unsigned int power_ad;
58:               
59:               void chrgCtr();
60:               unsigned char ADC_Sample(unsigned char adch, unsigned char adldo);
61:               
62:               //系统初始化
63:               void Init_System()
  0025    0000    NOP
  0026    0064    CLRWDT
64:               {
65:               	asm("nop");
66:               	asm("clrwdt");
67:               	INTCON = 0;				//禁止中断
  0027    018B    CLR	0xB
68:               	OSCCON = 0X72;			//配置振荡为8M
  0028    3072    LDIA	0x72
  0029    1283    CLRB	0x3,5
  002A    1303    CLRB	0x3,6
  002B    0094    LD	0x14,A
69:               	OPTION_REG = 0;
  002C    0181    CLR	0x1
70:               	
71:               	
72:               	//延时等待电源电压稳定
73:               	//DelayXms(200);
74:               	TRISA = 0x04;
  002D    3004    LDIA	0x4
  002E    1683    SETB	0x3,5
  002F    0085    LD	0x5,A
75:               	PORTA = 0;
  0030    0186    CLR	0x6
76:               	TRISB = 0x20;
  0031    3020    LDIA	0x20
  0032    1283    CLRB	0x3,5
  0033    0085    LD	0x5,A
77:               	PORTB = 0;
  0034    0186    CLR	0x6
78:               	WPUB = 0x00;
  0035    0188    CLR	0x8
79:               	TRISC = 0;
  0036    1703    SETB	0x3,6
  0037    0185    CLR	0x5
80:               	PORTC = 0;
  0038    0186    CLR	0x6
81:               
82:               	PIE1 = 2;
  0039    3002    LDIA	0x2
  003A    1303    CLRB	0x3,6
  003B    008E    LD	0xE,A
83:               	PR2 = 250;				//8M下将TMR2设置为125us中断
  003C    30FA    LDIA	0xFA
  003D    0091    LD	0x11,A
84:               	T2CON = 4;				//使能定时器2
  003E    3004    LDIA	0x4
  003F    0093    LD	0x13,A
85:               
86:               	INTCON = 0XC0;			//使能中断
  0040    30C0    LDIA	0xC0
  0041    008B    LD	0xB,A
87:               	ADCON0 = 0X41;
88:               	ADON = 1;
89:               	ADCON1 = 0x00;
  0042    2BE9    JP	0x3E9
90:               }
91:               
92:               
93:               /**********************************************************
94:               函数名称：Refurbish_Sfr
95:               函数功能：刷新一些特殊功能寄存器
96:               入口参数：无
97:               出口参数：无
98:               备    注：每隔一定时间刷新一次SFR可增强抗干扰能力
99:               **********************************************************/
100:              void Refurbish_Sfr() 
101:              {
102:              	//刷新中断相关控制寄存器
103:              	PIE1 = 2;
  0389    3002    LDIA	0x2
  038A    1283    CLRB	0x3,5
  038B    008E    LD	0xE,A
104:              	PR2 = 250;
  038C    30FA    LDIA	0xFA
  038D    0091    LD	0x11,A
105:              	INTCON = 0XC0;
  038E    30C0    LDIA	0xC0
  038F    008B    LD	0xB,A
106:              	if (4 != T2CON)
  0390    3004    LDIA	0x4
  0391    0613    XORA	0x13
  0392    1903    SZB	0x3,2
  0393    0008    RET
107:              		T2CON = 4;
  0394    3004    LDIA	0x4
  0395    0093    LD	0x13,A
  0396    0008    RET
108:              }
109:              
110:              
111:              /***********************************************************
112:              键处理函数
113:              ***********************************************************/
114:              void KeyServer() 
115:              {
116:              	static unsigned char KeyOldFlag = 0;
117:              	if (KeyFlag[0]) 
  0EA1    0879    LD	A,0x79
  0EA2    1903    SZB	0x3,2
  0EA3    2F33    JP	0x733
118:              	{
119:              		if (KeyFlag[0] != KeyOldFlag) 
  0EA4    0879    LD	A,0x79
  0EA5    0634    XORA	0x34
  0EA6    1903    SZB	0x3,2
  0EA7    2F09    JP	0x709
120:              		{
121:              			//确定状态改变的按键
122:              			KeyOldFlag ^= KeyFlag[0];
  0EA8    0879    LD	A,0x79
  0EA9    06B4    XORR	0x34
123:              			if ((KeyOldFlag & 0x1) && (KeyFlag[0] & 0x1) && firstLock == 0 && powerFlag > 0) 
  0EAA    1834    SZB	0x34,0
  0EAB    1C79    SNZB	0x79,0
  0EAC    2ECB    JP	0x6CB
  0EAD    086E    LD	A,0x6E
  0EAE    1D03    SNZB	0x3,2
  0EAF    2ECB    JP	0x6CB
  0EB0    083A    LD	A,0x3A
  0EB1    1903    SZB	0x3,2
  0EB2    2ECB    JP	0x6CB
124:              			{
125:              				//KEY1被按下
126:              				if(lowBatLock == 1)
  0EB3    0B3D    SZDECA	0x3D
  0EB4    2EBA    JP	0x6BA
127:              				{
128:              					shanshuoTime2 = 450;
  0EB5    30C2    LDIA	0xC2
  0EB6    00AA    LD	0x2A,A
  0EB7    3001    LDIA	0x1
  0EB8    00AB    LD	0x2B,A
129:              				}
  0EB9    2EBF    JP	0x6BF
130:              				else if(++wuhuaFlag > 2)
  0EBA    3003    LDIA	0x3
  0EBB    0AC4    INCR	0x44
  0EBC    0244    SUBA	0x44
  0EBD    1803    SZB	0x3,0
131:              				{
132:              					wuhuaFlag = 0;
  0EBE    01C4    CLR	0x44
133:              				}
134:              				if(wuhuaFlag >= 2)
  0EBF    3002    LDIA	0x2
  0EC0    0244    SUBA	0x44
  0EC1    1C03    SNZB	0x3,0
  0EC2    2EC9    JP	0x6C9
135:              				{
136:              					shanshuoTime2 = 450;
  0EC3    30C2    LDIA	0xC2
  0EC4    00AA    LD	0x2A,A
  0EC5    3001    LDIA	0x1
  0EC6    00AB    LD	0x2B,A
137:              					count10s = 0;
  0EC7    01C2    CLR	0x42
138:              				}
  0EC8    2ECB    JP	0x6CB
139:              				else
140:              				{
141:              					shanshuoTime2 = 0;
  0EC9    01AA    CLR	0x2A
  0ECA    01AB    CLR	0x2B
142:              				}
143:              			}
144:              			if ((KeyOldFlag & 0x2) && (KeyFlag[0] & 0x2) && firstLock == 0 && powerFlag > 0) 
  0ECB    18B4    SZB	0x34,1
  0ECC    1CF9    SNZB	0x79,1
  0ECD    2EE9    JP	0x6E9
  0ECE    086E    LD	A,0x6E
  0ECF    1D03    SNZB	0x3,2
  0ED0    2EE9    JP	0x6E9
  0ED1    083A    LD	A,0x3A
  0ED2    1903    SZB	0x3,2
  0ED3    2EE9    JP	0x6E9
145:              			{
146:              				//KEY2被按下
147:              				if(lowBatLock == 1)
  0ED4    0B3D    SZDECA	0x3D
  0ED5    2ED9    JP	0x6D9
148:              				{
149:              					shanshuoTime = 450;
  0ED6    2739    CALL	0x739
  0ED7    158A    SETB	0xA,3
150:              				}
  0ED8    2EE0    JP	0x6E0
151:              				else if(++workStep > 3)
  0ED9    3004    LDIA	0x4
  0EDA    0AFB    INCR	0x7B
  0EDB    027B    SUBA	0x7B
  0EDC    1C03    SNZB	0x3,0
  0EDD    2EE0    JP	0x6E0
152:              				{
153:              					workStep = 0;
  0EDE    01FB    CLR	0x7B
154:              					bujinFlag = 0;
  0EDF    01BB    CLR	0x3B
155:              				}
156:              				if(workStep >= 2)
  0EE0    3002    LDIA	0x2
  0EE1    027B    SUBA	0x7B
  0EE2    1C03    SNZB	0x3,0
  0EE3    2EE7    JP	0x6E7
157:              				{
158:              					shanshuoTime = 450;
  0EE4    2739    CALL	0x739
  0EE5    158A    SETB	0xA,3
159:              				}
  0EE6    2EE9    JP	0x6E9
160:              				else
161:              				{
162:              					shanshuoTime = 0;
  0EE7    01AC    CLR	0x2C
  0EE8    01AD    CLR	0x2D
163:              				}
164:              				
165:              			}
166:              			if ((KeyOldFlag & 0x4) && (KeyFlag[0] & 0x4) && firstLock == 0 && workStep > 0 && powerFlag > 0) 
  0EE9    1934    SZB	0x34,2
  0EEA    1D79    SNZB	0x79,2
  0EEB    2F07    JP	0x707
  0EEC    086E    LD	A,0x6E
  0EED    1D03    SNZB	0x3,2
  0EEE    2F07    JP	0x707
  0EEF    087B    LD	A,0x7B
  0EF0    1903    SZB	0x3,2
  0EF1    2F07    JP	0x707
  0EF2    083A    LD	A,0x3A
  0EF3    1903    SZB	0x3,2
  0EF4    2F07    JP	0x707
167:              			{
168:              				//KEY3被按下
169:              				if(++bujinFlag > 3)
  0EF5    3004    LDIA	0x4
  0EF6    0ABB    INCR	0x3B
  0EF7    023B    SUBA	0x3B
  0EF8    1803    SZB	0x3,0
170:              				{
171:              					bujinFlag = 0;
  0EF9    01BB    CLR	0x3B
  0EFA    3002    LDIA	0x2
172:              				}
173:              				bujinStartFlag = 1;
  0EFB    01B6    CLR	0x36
  0EFC    0AB6    INCR	0x36
174:              				if(bujinFlag >= 2)
  0EFD    023B    SUBA	0x3B
  0EFE    1C03    SNZB	0x3,0
  0EFF    2F05    JP	0x705
175:              				{
176:              					shanshuoTime3 = 450;
  0F00    30C2    LDIA	0xC2
  0F01    00A8    LD	0x28,A
  0F02    3001    LDIA	0x1
  0F03    00A9    LD	0x29,A
177:              				}
  0F04    2F07    JP	0x707
178:              				else
179:              				{
180:              					shanshuoTime3 = 0;
  0F05    01A8    CLR	0x28
  0F06    01A9    CLR	0x29
181:              				}
182:              			}
183:              
184:              			KeyOldFlag = KeyFlag[0];
  0F07    0879    LD	A,0x79
  0F08    00B4    LD	0x34,A
185:              		}
186:              		if(firstLock == 0 && KeyOldFlag & 0x4)
  0F09    086E    LD	A,0x6E
  0F0A    1903    SZB	0x3,2
  0F0B    1D34    SNZB	0x34,2
  0F0C    0008    RET
187:              		{
188:              			if(++keyCount >= 400)
  0F0D    1683    SETB	0x3,5
  0F0E    0AC5    INCR	0x45
  0F0F    1903    SZB	0x3,2
  0F10    0AC6    INCR	0x46
  0F11    3001    LDIA	0x1
  0F12    0246    SUBA	0x46
  0F13    3090    LDIA	0x90
  0F14    1903    SZB	0x3,2
  0F15    0245    SUBA	0x45
  0F16    1C03    SNZB	0x3,0
  0F17    0008    RET
189:              			{
190:              				keyCount = 0;
  0F18    01C5    CLR	0x45
  0F19    01C6    CLR	0x46
191:              				if(longKeyFlag == 0)
  0F1A    1283    CLRB	0x3,5
  0F1B    0839    LD	A,0x39
  0F1C    1D03    SNZB	0x3,2
  0F1D    0008    RET
192:              				{
193:              					longKeyFlag = 1;
  0F1E    01B9    CLR	0x39
  0F1F    0AB9    INCR	0x39
194:              					if(powerFlag > 0)
  0F20    083A    LD	A,0x3A
  0F21    1903    SZB	0x3,2
  0F22    2F2A    JP	0x72A
195:              					{
196:              						powerFlag = 0;
  0F23    01BA    CLR	0x3A
197:              						workStep = 0;
  0F24    01FB    CLR	0x7B
198:              						wuhuaFlag = 0;
  0F25    01C4    CLR	0x44
199:              						bujinFlag = 0;
  0F26    01BB    CLR	0x3B
200:              						shanshuoTime3 = 0;
  0F27    01A8    CLR	0x28
  0F28    01A9    CLR	0x29
201:              					}
  0F29    0008    RET
  0F2A    30D0    LDIA	0xD0
202:              					else
203:              					{
204:              						powerFlag = 1;
  0F2B    01BA    CLR	0x3A
  0F2C    0ABA    INCR	0x3A
205:              						workStep = 1;
  0F2D    01FB    CLR	0x7B
  0F2E    0AFB    INCR	0x7B
206:              						shanshuoTime3 = 2000;
  0F2F    00A8    LD	0x28,A
  0F30    3007    LDIA	0x7
  0F31    00A9    LD	0x29,A
  0F32    0008    RET
207:              					}
208:              				}
209:              			}
210:              		}
211:              	} 
212:              	else 
213:              	{
214:              		KeyOldFlag = 0;
  0F33    01B4    CLR	0x34
215:              		longKeyFlag = 0;
  0F34    01B9    CLR	0x39
216:              		keyCount = 0;
  0F35    1683    SETB	0x3,5
  0F36    01C5    CLR	0x45
  0F37    01C6    CLR	0x46
  0F38    0008    RET
217:              	}
218:              }
219:              
220:              
221:              /***********************************************************
222:              中断服务函数
223:              ***********************************************************/
224:              void interrupt Isr_Timer()
225:              {
226:              	if(TMR2IF)				//若只使能了一个中断源,可以略去判断
  0E07    1283    CLRB	0x3,5
  0E08    1303    CLRB	0x3,6
  0E09    1C8D    SNZB	0xD,1
  0E0A    2E1A    JP	0x61A
227:              	{
228:              		TMR2IF = 0;
  0E0B    108D    CLRB	0xD,1
229:              		if(++MainTime >= 32)	//需根据你选择的触摸路数和触摸电容选择扫描一次按键的时间
  0E0C    3020    LDIA	0x20
  0E0D    0AC6    INCR	0x46
  0E0E    0246    SUBA	0x46
  0E0F    1C03    SNZB	0x3,0
  0E10    2E1B    JP	0x61B
230:              		{						//一般103电容，8路触摸，8M主频检测时间约4ms，故扫描一次的时间可选5ms
231:              			MainTime = 0;
  0E11    01C6    CLR	0x46
232:              			B_MainLoop = 1;
  0E12    1778    SETB	0x78,6
233:              			if(++count1s >= 250)
  0E13    30FA    LDIA	0xFA
  0E14    0AC5    INCR	0x45
  0E15    0245    SUBA	0x45
  0E16    1C03    SNZB	0x3,0
  0E17    2E1B    JP	0x61B
234:              			{
235:              				count1s = 0;
  0E18    01C5    CLR	0x45
  0E19    2E1B    JP	0x61B
236:              			}
237:              		}
238:              	}
239:              	else
240:              	{
241:              		PIR1 = 0;
  0E1A    018D    CLR	0xD
  0E1B    0871    LD	A,0x71
  0E1C    008A    LD	0xA,A
  0E1D    0E70    SWAPA	0x70
  0E1E    0083    LD	0x3,A
  0E1F    0EFE    SWAPR	0x7E
  0E20    0E7E    SWAPA	0x7E
  0E21    0009    RETI
242:              	}
243:              	
244:              }
245:              
246:              void WorkSleep()
247:              {
248:              #if (0 != C_KEY_WAKEUP)
249:              	static unsigned char time;
250:              	
251:              	if(B_OnOff)time = 0;
  0043    1AF8    SZB	0x78,5
  0044    01B3    CLR	0x33
252:              	
253:              	if(++time >= 125)
  0045    307D    LDIA	0x7D
  0046    0AB3    INCR	0x33
  0047    0233    SUBA	0x33
  0048    1C03    SNZB	0x3,0
  0049    0008    RET
254:              	{
255:              		time = 0;
  004A    01B3    CLR	0x33
256:              		INTCON = 0;			//;关断ADC模块及中断使能；
  004B    018B    CLR	0xB
257:              		PIE1 = 0;
  004C    018E    CLR	0xE
258:              		PIE2 = 0;
  004D    1703    SETB	0x3,6
  004E    0190    CLR	0x10
259:              		PIR1 = 0;
  004F    1303    CLRB	0x3,6
  0050    018D    CLR	0xD
260:              		PIR2 = 0;
  0051    1703    SETB	0x3,6
  0052    018F    CLR	0xF
261:              		T2CON = 0;
  0053    1303    CLRB	0x3,6
  0054    0193    CLR	0x13
262:              		ADCON1 = 0;
  0055    1683    SETB	0x3,5
  0056    0196    CLR	0x16
263:              
264:              		//进入休眠前关掉所有功能模块,以降低休眠电流
265:              		ADCON0 = 0;
  0057    0195    CLR	0x15
266:              	
267:              		//进入休眠前,必须固定口线电平,这儿全部输出低电平,并关闭所有上拉电阻
268:              		PORTA = 0x01;
  0058    3001    LDIA	0x1
  0059    0086    LD	0x6,A
269:              		PORTB = 0x00;
  005A    1283    CLRB	0x3,5
  005B    0186    CLR	0x6
270:              		TRISC = 0;
  005C    1703    SETB	0x3,6
  005D    0185    CLR	0x5
271:              		PORTC = 0x03;
  005E    3003    LDIA	0x3
  005F    0086    LD	0x6,A
272:              
273:              		TRISB5 =1;//输入
  0060    1303    CLRB	0x3,6
  0061    1685    SETB	0x5,5
274:              		//WPUB7 = 1;//上拉			
275:              		RBIF = 0;//清标志
  0062    100B    CLRB	0xB,0
276:              		RBIE = 1; //允许PB口电平变化中断
  0063    158B    SETB	0xB,3
277:              		IOCB5= 1;//允许PB1电平变化中断
  0064    1689    SETB	0x9,5
278:              		PORTB;//读一次PB口	
  0065    0806    LD	A,0x6
279:              /****如需要PA口中断唤醒，使能下列程序并按需修改****
280:              			TRISA0 =1;	//输入
281:              			WPUA0 = 1;	//上拉			
282:              			RAIF = 0;	//清标志
283:              			RAIE = 1;	//允许PA口电平变化中断
284:              			IOCA0 = 1;	//允许PA0电平变化中断
285:              			PEIE = 1;	//允许外设中断
286:              			PORTA;		//读一次PA口			
287:              ************************************/	
288:              
289:              		//进入休眠模式,触摸允许唤醒的按键后恢复正常工作
290:              		SystemEnterSleep();
  0066    209E    CALL	0x9E
  0067    118A    CLRB	0xA,3
291:              		if(RAIF) 
  0068    1D8D    SNZB	0xD,3
  0069    286D    JP	0x6D
292:              		{
293:              			RAIF = 0;
  006A    118D    CLRB	0xD,3
294:              			PORTA;
  006B    1683    SETB	0x3,5
  006C    0806    LD	A,0x6
295:              		}
296:              		//休眠被唤醒,重新配置中断等SFR,使系统进入正常工作
297:              		Refurbish_Sfr();
  006D    2389    CALL	0x389
  006E    118A    CLRB	0xA,3
298:              		PORTB &= 0xFD;
  006F    1086    CLRB	0x6,1
299:              		ADCON0 = 0X41;
300:              		ADON = 1;
301:              		ADCON1 = 0x00;
  0070    2BE9    JP	0x3E9
302:              	}
303:              #endif
304:              }
305:              
306:              
307:              /**********************************************************
308:              函数名称：AD_Sample
309:              函数功能：AD检测
310:              入口参数：adch - 检测通道
311:              出口参数：无
312:              备    注：采样通道需自行设置为输入口
313:              	      采样10次,取中间八次的平均值为采样结果存于adresult中
314:              
315:              	      adch 为输入AD通道 0-15，31
316:                           31  检测内部1.2V
317:              	
318:               		  adldo =5,开启内部LDO 2V 作为ADC 参考
319:               		  adldo =6,开启内部LDO 2.4V 作为ADC 参考
320:              		  adldo =7,开启内部LDO 3V 作为ADC 参考
321:               		  adldo =0,VDD 作为ADC 参考
322:               		  AD转换结果左对齐
323:               		  ADC参考电压从VDD切换到LDO时需要延时100us以上，才能进行AD转换
324:              **********************************************************/
325:              unsigned char ADC_Sample(unsigned char adch, unsigned char adldo) 
  0587    1283    CLRB	0x3,5
  0588    00CA    LD	0x4A,A
326:              {
327:              	volatile unsigned long adsum = 0;
328:              	volatile unsigned int admin = 0, admax = 0;
  0589    27B9    CALL	0x7B9
  058A    118A    CLRB	0xA,3
329:              	volatile unsigned int ad_temp = 0;
  058B    01D4    CLR	0x54
  058C    01D5    CLR	0x55
330:              
331:              	if ((!LDO_EN) && (adldo & 0x04) ) 
  058D    1683    SETB	0x3,5
  058E    1D16    SNZB	0x16,2
  058F    1D72    SNZB	0x72,2
  0590    2D99    JP	0x599
332:              	{
333:              								//如果AD参考从VDD换到内部LDO，需要延时100US以上
334:              		ADCON1 = adldo;			//左对齐,AD值取12位
  0591    0872    LD	A,0x72
  0592    0096    LD	0x16,A
335:              		__delay_us(100);		//IDE内置延时函数，延时100us
  0593    3042    LDIA	0x42
  0594    00F3    LD	0x73,A
  0595    0BF3    SZDECR	0x73
  0596    2D95    JP	0x595
  0597    0000    NOP
336:              	} 
  0598    2D9B    JP	0x59B
337:              	else
338:              		ADCON1 = adldo;			//如果ADCON1.7(ADFM)=1为右对齐，,AD值取10位
  0599    0872    LD	A,0x72
  059A    0096    LD	0x16,A
339:              
340:              	if(adch & 0x10) 
  059B    1283    CLRB	0x3,5
  059C    1303    CLRB	0x3,6
  059D    1E4A    SNZB	0x4A,4
  059E    2DA4    JP	0x5A4
341:              	{
342:              		CHS4 = 1;
  059F    1683    SETB	0x3,5
  05A0    1716    SETB	0x16,6
343:              		adch &= 0x0f;
  05A1    300F    LDIA	0xF
  05A2    1283    CLRB	0x3,5
  05A3    05CA    ANDR	0x4A
344:              	}
345:              	unsigned char i = 0;
346:              	for (i = 0; i < 10; i++) 
  05A4    01CB    CLR	0x4B
347:              	{
348:              		ADCON0 = (unsigned char)(0X41 | (adch << 2));	//16分频，如果主频为16M，则必须选16分频或以上
  05A5    084A    LD	A,0x4A
  05A6    00F3    LD	0x73,A
  05A7    3001    LDIA	0x1
  05A8    1003    CLRB	0x3,0
  05A9    0DF3    RLCR	0x73
  05AA    3EFF    ADDIA	0xFF
  05AB    1003    CLRB	0x3,0
  05AC    1D03    SNZB	0x3,2
  05AD    2DA9    JP	0x5A9
  05AE    0D73    RLCA	0x73
  05AF    3841    ORIA	0x41
  05B0    1683    SETB	0x3,5
  05B1    0095    LD	0x15,A
  05B2    0000    NOP
  05B3    0000    NOP
  05B4    0000    NOP
  05B5    0000    NOP
349:              		asm("nop");
350:              		asm("nop");
351:              		asm("nop");
352:              		asm("nop");				//选择通道后需延时1uS以上
353:              		GODONE = 1;				//开始转换
  05B6    1683    SETB	0x3,5
  05B7    1303    CLRB	0x3,6
  05B8    1495    SETB	0x15,1
354:              
355:              		unsigned char j = 0;
  05B9    1283    CLRB	0x3,5
  05BA    01C9    CLR	0x49
356:              		while (GODONE) 
  05BB    1683    SETB	0x3,5
  05BC    1C95    SNZB	0x15,1
  05BD    2DC5    JP	0x5C5
357:              		{
358:              			__delay_us(2);		//延时2us(编译器内置函数)
  05BE    2DBF    JP	0x5BF
  05BF    2DC0    JP	0x5C0
359:              
360:              			if (0 == (--j))		//延时0.5ms仍没有AD转换结束，跳出程序
  05C0    1283    CLRB	0x3,5
  05C1    1303    CLRB	0x3,6
  05C2    0BC9    SZDECR	0x49
  05C3    2DBB    JP	0x5BB
361:              			return 0;
  05C4    3400    RET	0x0
362:              		}
363:              
364:              		ad_temp = (unsigned int)((ADRESH << 4) + (ADRESL >> 4));	//计算12位AD值
  05C5    0819    LD	A,0x19
  05C6    1283    CLRB	0x3,5
  05C7    00D4    LD	0x54,A
  05C8    01D5    CLR	0x55
  05C9    0ED4    SWAPR	0x54
  05CA    0ED5    SWAPR	0x55
  05CB    30F0    LDIA	0xF0
  05CC    05D5    ANDR	0x55
  05CD    0854    LD	A,0x54
  05CE    390F    ANDIA	0xF
  05CF    04D5    ORR	0x55
  05D0    30F0    LDIA	0xF0
  05D1    05D4    ANDR	0x54
  05D2    1683    SETB	0x3,5
  05D3    0E18    SWAPA	0x18
  05D4    390F    ANDIA	0xF
  05D5    1283    CLRB	0x3,5
  05D6    07D4    ADDR	0x54
  05D7    1803    SZB	0x3,0
  05D8    0AD5    INCR	0x55
365:              
366:              		if (0 == admax) 
  05D9    0852    LD	A,0x52
  05DA    0453    ORA	0x53
  05DB    1D03    SNZB	0x3,2
  05DC    2DE0    JP	0x5E0
367:              		{
368:              			admax = ad_temp;
  05DD    27CE    CALL	0x7CE
  05DE    118A    CLRB	0xA,3
  05DF    2DF3    JP	0x5F3
369:              			admin = ad_temp;
370:              		} 
371:              		else if (ad_temp > admax)
  05E0    0855    LD	A,0x55
  05E1    0253    SUBA	0x53
  05E2    1D03    SNZB	0x3,2
  05E3    2DE6    JP	0x5E6
  05E4    0854    LD	A,0x54
  05E5    0252    SUBA	0x52
  05E6    1803    SZB	0x3,0
  05E7    2DEB    JP	0x5EB
372:              			admax = ad_temp;				//AD采样最大值
  05E8    27CE    CALL	0x7CE
  05E9    118A    CLRB	0xA,3
  05EA    2DF7    JP	0x5F7
373:              		else if (ad_temp < admin)
  05EB    0851    LD	A,0x51
  05EC    0255    SUBA	0x55
  05ED    1D03    SNZB	0x3,2
  05EE    2DF1    JP	0x5F1
  05EF    0850    LD	A,0x50
  05F0    0254    SUBA	0x54
  05F1    1803    SZB	0x3,0
  05F2    2DF7    JP	0x5F7
374:              			admin = ad_temp;				//AD采样最小值
  05F3    0855    LD	A,0x55
  05F4    00D1    LD	0x51,A
  05F5    0854    LD	A,0x54
  05F6    00D0    LD	0x50,A
375:              
376:              		adsum += ad_temp;
  05F7    0854    LD	A,0x54
  05F8    00F3    LD	0x73,A
  05F9    0855    LD	A,0x55
  05FA    00F4    LD	0x74,A
  05FB    01F5    CLR	0x75
  05FC    01F6    CLR	0x76
  05FD    0873    LD	A,0x73
  05FE    07CC    ADDR	0x4C
  05FF    0874    LD	A,0x74
  0600    1103    CLRB	0x3,2
  0601    1803    SZB	0x3,0
  0602    3E01    ADDIA	0x1
  0603    1D03    SNZB	0x3,2
  0604    07CD    ADDR	0x4D
  0605    0875    LD	A,0x75
  0606    1103    CLRB	0x3,2
  0607    1803    SZB	0x3,0
  0608    3E01    ADDIA	0x1
  0609    1D03    SNZB	0x3,2
  060A    07CE    ADDR	0x4E
  060B    0876    LD	A,0x76
  060C    1103    CLRB	0x3,2
  060D    1803    SZB	0x3,0
  060E    3E01    ADDIA	0x1
  060F    1D03    SNZB	0x3,2
  0610    07CF    ADDR	0x4F
  0611    300A    LDIA	0xA
  0612    0ACB    INCR	0x4B
  0613    024B    SUBA	0x4B
  0614    1C03    SNZB	0x3,0
  0615    2DA5    JP	0x5A5
377:              	}
378:              		adsum -= admax;
  0616    0852    LD	A,0x52
  0617    00F3    LD	0x73,A
  0618    0853    LD	A,0x53
  0619    27AA    CALL	0x7AA
  061A    118A    CLRB	0xA,3
  061B    1C03    SNZB	0x3,0
  061C    0F76    SZINCA	0x76
  061D    02CF    SUBR	0x4F
379:              		if (adsum >= admin)
  061E    0850    LD	A,0x50
  061F    00F3    LD	0x73,A
  0620    0851    LD	A,0x51
  0621    00F4    LD	0x74,A
  0622    01F5    CLR	0x75
  0623    01F6    CLR	0x76
  0624    0876    LD	A,0x76
  0625    024F    SUBA	0x4F
  0626    1D03    SNZB	0x3,2
  0627    2E32    JP	0x632
  0628    0875    LD	A,0x75
  0629    024E    SUBA	0x4E
  062A    1D03    SNZB	0x3,2
  062B    2E32    JP	0x632
  062C    0874    LD	A,0x74
  062D    024D    SUBA	0x4D
  062E    1D03    SNZB	0x3,2
  062F    2E32    JP	0x632
  0630    0873    LD	A,0x73
  0631    024C    SUBA	0x4C
  0632    1C03    SNZB	0x3,0
  0633    2E3D    JP	0x63D
380:              			adsum -= admin;
  0634    0850    LD	A,0x50
  0635    00F3    LD	0x73,A
  0636    0851    LD	A,0x51
  0637    27AA    CALL	0x7AA
  0638    118A    CLRB	0xA,3
  0639    1C03    SNZB	0x3,0
  063A    0F76    SZINCA	0x76
  063B    02CF    SUBR	0x4F
  063C    2E41    JP	0x641
381:              		else
382:              			adsum = 0;
  063D    01CC    CLR	0x4C
  063E    01CD    CLR	0x4D
  063F    01CE    CLR	0x4E
  0640    01CF    CLR	0x4F
383:              
384:              		adresult = adsum >> 3;		//8次平均值作为最终结果
  0641    084C    LD	A,0x4C
  0642    00F3    LD	0x73,A
  0643    084D    LD	A,0x4D
  0644    00F4    LD	0x74,A
  0645    084E    LD	A,0x4E
  0646    00F5    LD	0x75,A
  0647    084F    LD	A,0x4F
  0648    00F6    LD	0x76,A
  0649    3003    LDIA	0x3
  064A    1003    CLRB	0x3,0
  064B    0CF6    RRCR	0x76
  064C    0CF5    RRCR	0x75
  064D    0CF4    RRCR	0x74
  064E    0CF3    RRCR	0x73
  064F    3EFF    ADDIA	0xFF
  0650    1D03    SNZB	0x3,2
  0651    2E4A    JP	0x64A
  0652    0874    LD	A,0x74
  0653    00C8    LD	0x48,A
  0654    0873    LD	A,0x73
  0655    00C7    LD	0x47,A
385:              
386:              		adsum = 0;
387:              		admin = 0;
388:              		admax = 0;
  0656    27B9    CALL	0x7B9
389:              		return 0xA5;
  0657    34A5    RET	0xA5
390:              		
391:              }
392:              
393:              
394:              void chrgCtr()
395:              {
396:              	if(PORTB & 0x20)
  07D7    1283    CLRB	0x3,5
  07D8    1303    CLRB	0x3,6
  07D9    1E86    SNZB	0x6,5
  07DA    2FF1    JP	0x7F1
  07DB    3010    LDIA	0x10
397:              	{
398:              		chrgFlag = 1;
  07DC    01C0    CLR	0x40
  07DD    0AC0    INCR	0x40
399:              		firstLock = 0;
  07DE    01EE    CLR	0x6E
400:              		lowBatLock = 0;
  07DF    01BD    CLR	0x3D
401:              		if(power_ad > 4140)
  07E0    0225    SUBA	0x25
  07E1    302D    LDIA	0x2D
  07E2    1903    SZB	0x3,2
  07E3    0224    SUBA	0x24
  07E4    1C03    SNZB	0x3,0
  07E5    2FEF    JP	0x7EF
402:              		{
403:              			if(++chrgFullTime > 200)
  07E6    30C9    LDIA	0xC9
  07E7    0ABE    INCR	0x3E
  07E8    023E    SUBA	0x3E
  07E9    1C03    SNZB	0x3,0
  07EA    0008    RET
404:              			{
405:              				chrgFullTime = 0;
  07EB    01BE    CLR	0x3E
406:              				chrgFullFlag = 1;
  07EC    01BF    CLR	0x3F
  07ED    0ABF    INCR	0x3F
  07EE    0008    RET
407:              			}
408:              		}
409:              		else
410:              		{
411:              			chrgFullTime = 0;
  07EF    01BE    CLR	0x3E
  07F0    0008    RET
412:              		}
413:              
414:              	}
415:              	else
416:              	{
417:              		chrgFlag = 0;
  07F1    01C0    CLR	0x40
418:              		chrgFullTime = 0;
  07F2    01BE    CLR	0x3E
419:              		chrgFullFlag = 0;
  07F3    01BF    CLR	0x3F
  07F4    0008    RET
420:              		
421:              	}
422:              }
423:              
424:              void keyLedCtr()
425:              {
426:              	if(shanshuoTime > 0)
  0700    1283    CLRB	0x3,5
  0701    082C    LD	A,0x2C
  0702    042D    ORA	0x2D
  0703    1903    SZB	0x3,2
  0704    2F1E    JP	0x71E
427:              	{
428:              		shanshuoTime--;
  0705    3001    LDIA	0x1
  0706    02AC    SUBR	0x2C
  0707    3000    LDIA	0x0
  0708    1C03    SNZB	0x3,0
  0709    03AD    DECR	0x2D
  070A    02AD    SUBR	0x2D
429:              		if((shanshuoTime % 150) < 75)
  070B    3096    LDIA	0x96
  070C    00F2    LD	0x72,A
  070D    01F3    CLR	0x73
  070E    082D    LD	A,0x2D
  070F    00F5    LD	0x75,A
  0710    082C    LD	A,0x2C
  0711    00F4    LD	0x74,A
  0712    2775    CALL	0x775
  0713    118A    CLRB	0xA,3
  0714    3000    LDIA	0x0
  0715    0273    SUBA	0x73
  0716    304B    LDIA	0x4B
  0717    1903    SZB	0x3,2
  0718    0272    SUBA	0x72
  0719    1803    SZB	0x3,0
  071A    2F21    JP	0x721
430:              		{
431:              			PORTC |= 0x01;
  071B    1703    SETB	0x3,6
  071C    1406    SETB	0x6,0
432:              		}
  071D    2F23    JP	0x723
433:              		else
434:              		{
435:              			PORTC &= 0xFE;
  0721    1703    SETB	0x3,6
  0722    1006    CLRB	0x6,0
436:              		}
437:              	}
438:              	else if(workStep > 0)
  071E    087B    LD	A,0x7B
  071F    1903    SZB	0x3,2
  0720    2F1B    JP	0x71B
439:              	{
440:              		PORTC &= 0xFE;
441:              	}
442:              	else
443:              	{
444:              		PORTC |= 0x01;
445:              	}
446:              	
447:              	if(shanshuoTime2 > 0)
  0723    1303    CLRB	0x3,6
  0724    082A    LD	A,0x2A
  0725    042B    ORA	0x2B
  0726    1903    SZB	0x3,2
  0727    2F41    JP	0x741
448:              	{
449:              		shanshuoTime2--;
  0728    3001    LDIA	0x1
  0729    02AA    SUBR	0x2A
  072A    3000    LDIA	0x0
  072B    1C03    SNZB	0x3,0
  072C    03AB    DECR	0x2B
  072D    02AB    SUBR	0x2B
450:              		if((shanshuoTime2 % 150) < 75)
  072E    3096    LDIA	0x96
  072F    00F2    LD	0x72,A
  0730    01F3    CLR	0x73
  0731    082B    LD	A,0x2B
  0732    00F5    LD	0x75,A
  0733    082A    LD	A,0x2A
  0734    00F4    LD	0x74,A
  0735    2775    CALL	0x775
  0736    118A    CLRB	0xA,3
  0737    3000    LDIA	0x0
  0738    0273    SUBA	0x73
  0739    304B    LDIA	0x4B
  073A    1903    SZB	0x3,2
  073B    0272    SUBA	0x72
  073C    1803    SZB	0x3,0
  073D    2F44    JP	0x744
451:              		{
452:              			PORTC |= 0x02;
  073E    1703    SETB	0x3,6
  073F    1486    SETB	0x6,1
453:              		}
  0740    2F46    JP	0x746
454:              		else
455:              		{
456:              			PORTC &= 0xFD;
  0744    1703    SETB	0x3,6
  0745    1086    CLRB	0x6,1
457:              		}
458:              	}
459:              	else if(wuhuaFlag > 0)
  0741    0844    LD	A,0x44
  0742    1903    SZB	0x3,2
  0743    2F3E    JP	0x73E
460:              	{
461:              		PORTC &= 0xFD;
462:              	}
463:              	else
464:              	{
465:              		PORTC |= 0x02;
466:              	}
467:              	if(shanshuoTime3 > 0)
  0746    1303    CLRB	0x3,6
  0747    0828    LD	A,0x28
  0748    0429    ORA	0x29
  0749    1903    SZB	0x3,2
  074A    2F67    JP	0x767
468:              	{
469:              		shanshuoTime3--;
  074B    3001    LDIA	0x1
  074C    02A8    SUBR	0x28
  074D    3000    LDIA	0x0
  074E    1C03    SNZB	0x3,0
  074F    03A9    DECR	0x29
  0750    02A9    SUBR	0x29
470:              		if((shanshuoTime3 % 150) < 75)
  0751    3096    LDIA	0x96
  0752    00F2    LD	0x72,A
  0753    01F3    CLR	0x73
  0754    0829    LD	A,0x29
  0755    00F5    LD	0x75,A
  0756    0828    LD	A,0x28
  0757    00F4    LD	0x74,A
  0758    2775    CALL	0x775
  0759    118A    CLRB	0xA,3
  075A    3000    LDIA	0x0
  075B    0273    SUBA	0x73
  075C    304B    LDIA	0x4B
  075D    1903    SZB	0x3,2
  075E    0272    SUBA	0x72
  075F    1803    SZB	0x3,0
  0760    2F64    JP	0x764
471:              		{
472:              			PORTA |= 0x01;
  0761    1683    SETB	0x3,5
  0762    1406    SETB	0x6,0
473:              		}
  0763    0008    RET
474:              		else
475:              		{
476:              			PORTA &= 0xFE;
  0764    1683    SETB	0x3,5
  0765    1006    CLRB	0x6,0
  0766    0008    RET
477:              		}
478:              	}
479:              	else if(bujinFlag)
  0767    083B    LD	A,0x3B
  0768    1D03    SNZB	0x3,2
  0769    2F64    JP	0x764
480:              	{
481:              		PORTA &= 0xFE;
482:              	}
483:              	else if(chrgFlag)
  076A    0840    LD	A,0x40
  076B    1903    SZB	0x3,2
  076C    2F61    JP	0x761
484:              	{
485:              		if(chrgFullFlag || count1s < 50)
  076D    083F    LD	A,0x3F
  076E    1D03    SNZB	0x3,2
  076F    2F64    JP	0x764
  0770    3032    LDIA	0x32
  0771    0245    SUBA	0x45
  0772    1C03    SNZB	0x3,0
  0773    2F64    JP	0x764
  0774    2F61    JP	0x761
486:              		{
487:              			PORTA &= 0xFE;
488:              		}
489:              		else
490:              		{
491:              			PORTA |= 0x01;
492:              		}
493:              	}
494:              	else
495:              	{
496:              		PORTA |= 0x01;
497:              	}
498:              	
499:              }
500:              
501:              void pwmInit()
502:              {
503:              
504:              	PWMTH = 0x00;
  0E4A    0198    CLR	0x18
505:              	PWMTL = 73;
  0E4B    3049    LDIA	0x49
  0E4C    0097    LD	0x17,A
506:              	PWMD23H = 0x00;
  0E4D    1683    SETB	0x3,5
  0E4E    019E    CLR	0x1E
507:              	PWMD3L = 32;
  0E4F    3020    LDIA	0x20
  0E50    009C    LD	0x1C,A
508:              	PWMCON1 = 0xC0;
  0E51    30C0    LDIA	0xC0
  0E52    1283    CLRB	0x3,5
  0E53    0096    LD	0x16,A
509:              	PWMCON2 = 0x00;
  0E54    019D    CLR	0x1D
510:              	PWMCON0 |= 0x28;
  0E55    3028    LDIA	0x28
  0E56    0495    ORR	0x15
  0E57    0008    RET
511:              }
512:              
513:              void pwmStop()
514:              {
515:              	PWMD3L = 0;
  0E58    1683    SETB	0x3,5
  0E59    019C    CLR	0x1C
516:              	PWMCON0 &= 0xF7;
  0E5A    1283    CLRB	0x3,5
  0E5B    1195    CLRB	0x15,3
517:              	PORTA &= 0xF7;
  0E5C    1683    SETB	0x3,5
  0E5D    1186    CLRB	0x6,3
  0E5E    0008    RET
518:              }
519:              
520:              void fanInit()
521:              {
522:              
523:              	PWMTH = 0x00;
  0799    0198    CLR	0x18
524:              	PWMT4L = 73;
  079A    3049    LDIA	0x49
  079B    009C    LD	0x1C,A
525:              	PWMD4L = fanDuty;
  079C    0843    LD	A,0x43
  079D    009B    LD	0x1B,A
526:              	PWMCON1 = 0xC0;
  079E    30C0    LDIA	0xC0
  079F    0096    LD	0x16,A
527:              	PWMCON2 = 0x00;
  07A0    019D    CLR	0x1D
528:              	PWMCON0 |= 0x30;
  07A1    3030    LDIA	0x30
  07A2    0495    ORR	0x15
  07A3    0008    RET
529:              }
530:              
531:              void fanStop()
532:              {
533:              	PWMD4L = 0;
  07A4    1283    CLRB	0x3,5
  07A5    019B    CLR	0x1B
534:              	PWMCON0 &= 0xEF;
  07A6    1215    CLRB	0x15,4
535:              	PORTA &= 0xEF;
  07A7    1683    SETB	0x3,5
  07A8    1206    CLRB	0x6,4
  07A9    0008    RET
536:              }
537:              
538:              void fanCtr()
539:              {
540:              	if(workStep > 0)
  0658    087B    LD	A,0x7B
  0659    1903    SZB	0x3,2
  065A    2EC7    JP	0x6C7
541:              	{
542:              		PORTA |= 0x02;
  065B    1486    SETB	0x6,1
543:              		u8t maxFanValue = 52;
  065C    3034    LDIA	0x34
  065D    1283    CLRB	0x3,5
  065E    00D6    LD	0x56,A
544:              		if(workStep == 1)
  065F    0B7B    SZDECA	0x7B
  0660    2E63    JP	0x663
545:              		{	
546:              			maxFanValue = 40;
  0661    3028    LDIA	0x28
  0662    00D6    LD	0x56,A
547:              		}
548:              		if(power_ad < 3150)
  0663    300C    LDIA	0xC
  0664    0225    SUBA	0x25
  0665    304E    LDIA	0x4E
  0666    1903    SZB	0x3,2
  0667    0224    SUBA	0x24
  0668    1803    SZB	0x3,0
  0669    2E6C    JP	0x66C
549:              		{
550:              			maxFanValue = 32;
  066A    3020    LDIA	0x20
  066B    00D6    LD	0x56,A
551:              		}
552:              		if(workStep == 3)
  066C    3003    LDIA	0x3
  066D    067B    XORA	0x7B
  066E    1D03    SNZB	0x3,2
  066F    2E72    JP	0x672
553:              		{
554:              			maxFanValue = 10;
  0670    300A    LDIA	0xA
  0671    00D6    LD	0x56,A
  0672    3002    LDIA	0x2
555:              		}
556:              		test_adc = ADC_Sample(2, 0);
  0673    01F2    CLR	0x72
  0674    2587    CALL	0x587
  0675    118A    CLRB	0xA,3
  0676    00B5    LD	0x35,A
557:              		if (0xA5 == test_adc)
  0677    30A5    LDIA	0xA5
  0678    0635    XORA	0x35
  0679    1D03    SNZB	0x3,2
  067A    2EA5    JP	0x6A5
558:              		{
559:              			volatile unsigned long fan_temp;
560:              			if(power_ad > 0)
  067B    0824    LD	A,0x24
  067C    0425    ORA	0x25
  067D    1903    SZB	0x3,2
  067E    2EA5    JP	0x6A5
561:              			{
562:              				fan_temp = ((unsigned long)1UL*adresult * power_ad)/4096;
  067F    0847    LD	A,0x47
  0680    00C9    LD	0x49,A
  0681    0848    LD	A,0x48
  0682    00CA    LD	0x4A,A
  0683    01CB    CLR	0x4B
  0684    01CC    CLR	0x4C
  0685    0824    LD	A,0x24
  0686    00CD    LD	0x4D,A
  0687    0825    LD	A,0x25
  0688    00CE    LD	0x4E,A
  0689    01CF    CLR	0x4F
  068A    01D0    CLR	0x50
  068B    26CD    CALL	0x6CD
  068C    118A    CLRB	0xA,3
  068D    084C    LD	A,0x4C
  068E    00DA    LD	0x5A,A
  068F    084B    LD	A,0x4B
  0690    00D9    LD	0x59,A
  0691    084A    LD	A,0x4A
  0692    00D8    LD	0x58,A
  0693    0849    LD	A,0x49
  0694    00D7    LD	0x57,A
  0695    300C    LDIA	0xC
  0696    1003    CLRB	0x3,0
  0697    0CDA    RRCR	0x5A
  0698    0CD9    RRCR	0x59
  0699    0CD8    RRCR	0x58
  069A    0CD7    RRCR	0x57
  069B    3EFF    ADDIA	0xFF
  069C    1D03    SNZB	0x3,2
  069D    2E96    JP	0x696
563:              				fanValue = (unsigned int)(fan_temp);
  069E    0858    LD	A,0x58
  069F    1683    SETB	0x3,5
  06A0    00CA    LD	0x4A,A
  06A1    1283    CLRB	0x3,5
  06A2    0857    LD	A,0x57
  06A3    1683    SETB	0x3,5
  06A4    00C9    LD	0x49,A
564:              			}
565:              		}
566:              		if(fanValue > 1300)
  06A5    3005    LDIA	0x5
  06A6    1683    SETB	0x3,5
  06A7    024A    SUBA	0x4A
  06A8    3015    LDIA	0x15
  06A9    1903    SZB	0x3,2
  06AA    0249    SUBA	0x49
  06AB    1C03    SNZB	0x3,0
  06AC    2EBA    JP	0x6BA
567:              		{
568:              			if(++fanOverTime > 50)
  06AD    3033    LDIA	0x33
  06AE    1283    CLRB	0x3,5
  06AF    0AC1    INCR	0x41
  06B0    0241    SUBA	0x41
  06B1    1C03    SNZB	0x3,0
  06B2    2EBC    JP	0x6BC
  06B3    30C2    LDIA	0xC2
569:              			{
570:              				fanOverTime = 0;
  06B4    01C1    CLR	0x41
571:              				workStep = 0;
  06B5    01FB    CLR	0x7B
572:              				shanshuoTime = 450;
  06B6    00AC    LD	0x2C,A
  06B7    3001    LDIA	0x1
  06B8    00AD    LD	0x2D,A
  06B9    2EBC    JP	0x6BC
573:              			}
574:              		}
575:              		else
576:              		{
577:              			fanOverTime = 0;
  06BA    1283    CLRB	0x3,5
  06BB    01C1    CLR	0x41
578:              		}
579:              		if(fanDuty < maxFanValue)
  06BC    0856    LD	A,0x56
  06BD    0243    SUBA	0x43
  06BE    1803    SZB	0x3,0
  06BF    2EC2    JP	0x6C2
580:              		{
581:              			fanDuty++;
  06C0    0AC3    INCR	0x43
582:              		}
  06C1    2EC6    JP	0x6C6
583:              		else if(fanDuty > maxFanValue)
  06C2    0843    LD	A,0x43
  06C3    0256    SUBA	0x56
  06C4    1C03    SNZB	0x3,0
584:              		{
585:              			fanDuty--;
  06C5    03C3    DECR	0x43
586:              		}
587:              		fanInit();
  06C6    2F99    JP	0x799
588:              	}
589:              	else
590:              	{
591:              		fanStop();
  06C7    27A4    CALL	0x7A4
592:              		fanDuty = 0;
  06C8    1283    CLRB	0x3,5
  06C9    01C3    CLR	0x43
593:              		PORTA &= 0xFD;
  06CA    1683    SETB	0x3,5
  06CB    1086    CLRB	0x6,1
  06CC    0008    RET
594:              	}
595:              }
596:              
597:              void wuhuaCtr()
598:              {
599:              	if(count1s == 0)
  0E22    1283    CLRB	0x3,5
  0E23    0845    LD	A,0x45
  0E24    1D03    SNZB	0x3,2
  0E25    2E3D    JP	0x63D
600:              	{
601:              		if(++count10s >= 20)
  0E26    3014    LDIA	0x14
  0E27    0AC2    INCR	0x42
  0E28    0242    SUBA	0x42
  0E29    1803    SZB	0x3,0
602:              		{
603:              			count10s = 0;
  0E2A    01C2    CLR	0x42
604:              		}
605:              		if(workStep == 0 && wuhuaFlag == 0 && powerFlag > 0)
  0E2B    087B    LD	A,0x7B
  0E2C    1D03    SNZB	0x3,2
  0E2D    2E3C    JP	0x63C
  0E2E    0844    LD	A,0x44
  0E2F    1D03    SNZB	0x3,2
  0E30    2E3C    JP	0x63C
  0E31    083A    LD	A,0x3A
  0E32    1903    SZB	0x3,2
  0E33    2E3C    JP	0x63C
606:              		{
607:              			if(++closeTime > 200)
  0E34    30C9    LDIA	0xC9
  0E35    0AB8    INCR	0x38
  0E36    0238    SUBA	0x38
  0E37    1C03    SNZB	0x3,0
  0E38    2E3D    JP	0x63D
608:              			{
609:              				closeTime = 0;
  0E39    01B8    CLR	0x38
610:              				powerFlag = 0;
  0E3A    01BA    CLR	0x3A
  0E3B    2E3D    JP	0x63D
611:              			}
612:              		}
613:              		else
614:              		{
615:              			closeTime = 0;
  0E3C    01B8    CLR	0x38
616:              		}
617:              	}
618:              	if(wuhuaFlag == 1 || (wuhuaFlag == 2 && count10s < 10))
  0E3D    0344    DECA	0x44
  0E3E    1903    SZB	0x3,2
  0E3F    2E48    JP	0x648
  0E40    3002    LDIA	0x2
  0E41    0644    XORA	0x44
  0E42    1D03    SNZB	0x3,2
  0E43    2E49    JP	0x649
  0E44    300A    LDIA	0xA
  0E45    0242    SUBA	0x42
  0E46    1803    SZB	0x3,0
  0E47    2E49    JP	0x649
619:              	{
620:              		pwmInit();
  0E48    2E4A    JP	0x64A
621:              		/*
622:              		if(++checkTime > 200)
623:              		{
624:              			if(lowWaterTime > 110)
625:              			{
626:              				//干烧状态
627:              				wuhuaFlag = 0;
628:              				shanshuoTime2 = 450;
629:              			}
630:              			checkTime = 0;
631:              			lowWaterTime = 0;
632:              		}
633:              		
634:              		test_adc = ADC_Sample(2, 0);
635:              		if (0xA5 == test_adc)
636:              		{
637:              			volatile unsigned long wuhua_temp;
638:              			if(power_ad > 0)
639:              			{
640:              				wuhua_temp = (unsigned long)(1UL*adresult * power_ad)/4096;
641:              				wuhuaValue = (unsigned int)(wuhua_temp);
642:              			}
643:              		}
644:              		if(wuhuaValue < 7)
645:              		{
646:              			lowWaterTime++;
647:              		}
648:              		*/
649:              	}
650:              	else
651:              	{
652:              		pwmStop();
  0E49    2E58    JP	0x658
653:              	}
654:              }
655:              
656:              void bujinCtr()
657:              {
658:              	if(bujinFlag || motorStopFlag)
  0F3E    1283    CLRB	0x3,5
  0F3F    083B    LD	A,0x3B
  0F40    1903    SZB	0x3,2
  0F41    0837    LD	A,0x37
  0F42    1903    SZB	0x3,2
  0F43    2FE4    JP	0x7E4
659:              	{
660:              		//马达启动或者切换原点定位
661:              		if(bujinStartFlag && zeroFlag)
  0F44    0836    LD	A,0x36
  0F45    1903    SZB	0x3,2
  0F46    2F67    JP	0x767
  0F47    086D    LD	A,0x6D
  0F48    1903    SZB	0x3,2
  0F49    2F67    JP	0x767
662:              		{
663:              			bujinStartFlag = 0;
  0F4A    01B6    CLR	0x36
664:              			if(bujinFlag == 1)
  0F4B    0B3B    SZDECA	0x3B
  0F4C    2F50    JP	0x750
665:              			{
666:              				maxMotorStep = 512;
  0F4D    3002    LDIA	0x2
  0F4E    01EB    CLR	0x6B
  0F4F    2F5D    JP	0x75D
667:              				motorStopFlag = 1;
  0F5E    01B7    CLR	0x37
  0F5F    0AB7    INCR	0x37
668:              			}
669:              			else if(bujinFlag == 2)
  0F50    3002    LDIA	0x2
  0F51    063B    XORA	0x3B
  0F52    1D03    SNZB	0x3,2
  0F53    2F56    JP	0x756
670:              			{
671:              				maxMotorStep = 1024;
  0F54    3004    LDIA	0x4
  0F55    2F4E    JP	0x74E
672:              				motorStopFlag = 1;
673:              			}
674:              			else if(bujinFlag == 3)
  0F56    3003    LDIA	0x3
  0F57    063B    XORA	0x3B
  0F58    1D03    SNZB	0x3,2
  0F59    2F60    JP	0x760
675:              			{
676:              				maxMotorStep = 1696;		//1360 120度
  0F5A    30A0    LDIA	0xA0
  0F5B    00EB    LD	0x6B,A
  0F5C    3006    LDIA	0x6
  0F5D    00EC    LD	0x6C,A
677:              				motorStopFlag = 1;
678:              			}
679:              			motorStep = maxMotorStep/2;
  0F60    086C    LD	A,0x6C
  0F61    00A7    LD	0x27,A
  0F62    086B    LD	A,0x6B
  0F63    00A6    LD	0x26,A
  0F64    1003    CLRB	0x3,0
  0F65    0CA7    RRCR	0x27
  0F66    0CA6    RRCR	0x26
680:              		}
681:              		if(motorStep == maxMotorStep/2 || motorStep == ((maxMotorStep/2) + maxMotorStep))
  0F67    27EA    CALL	0x7EA
  0F68    158A    SETB	0xA,3
  0F69    0CF3    RRCR	0x73
  0F6A    0CF2    RRCR	0x72
  0F6B    0827    LD	A,0x27
  0F6C    0673    XORA	0x73
  0F6D    1D03    SNZB	0x3,2
  0F6E    2F71    JP	0x771
  0F6F    0826    LD	A,0x26
  0F70    0672    XORA	0x72
  0F71    1903    SZB	0x3,2
  0F72    2F86    JP	0x786
  0F73    27EA    CALL	0x7EA
  0F74    158A    SETB	0xA,3
  0F75    0CF3    RRCR	0x73
  0F76    0CF2    RRCR	0x72
  0F77    086B    LD	A,0x6B
  0F78    0772    ADDA	0x72
  0F79    00F4    LD	0x74,A
  0F7A    086C    LD	A,0x6C
  0F7B    1803    SZB	0x3,0
  0F7C    0A6C    INCA	0x6C
  0F7D    0773    ADDA	0x73
  0F7E    00F5    LD	0x75,A
  0F7F    0627    XORA	0x27
  0F80    1D03    SNZB	0x3,2
  0F81    2F84    JP	0x784
  0F82    0826    LD	A,0x26
  0F83    0674    XORA	0x74
  0F84    1D03    SNZB	0x3,2
  0F85    2F8D    JP	0x78D
682:              		{
683:              			zeroFlag = 1;
  0F86    01ED    CLR	0x6D
  0F87    0AED    INCR	0x6D
684:              			if(bujinFlag == 0)
  0F88    083B    LD	A,0x3B
  0F89    1D03    SNZB	0x3,2
  0F8A    2F8E    JP	0x78E
685:              			{
686:              				motorStopFlag = 0;
  0F8B    01B7    CLR	0x37
  0F8C    2F8E    JP	0x78E
687:              			}
688:              		}
689:              		else
690:              		{
691:              			zeroFlag = 0;
  0F8D    01ED    CLR	0x6D
692:              		}
693:              		
694:              		
695:              		if(++motorStep >= (maxMotorStep*2))
  0F8E    27EA    CALL	0x7EA
  0F8F    158A    SETB	0xA,3
  0F90    0DF2    RLCR	0x72
  0F91    0DF3    RLCR	0x73
  0F92    0AA6    INCR	0x26
  0F93    1903    SZB	0x3,2
  0F94    0AA7    INCR	0x27
  0F95    0873    LD	A,0x73
  0F96    0227    SUBA	0x27
  0F97    1D03    SNZB	0x3,2
  0F98    2F9B    JP	0x79B
  0F99    0872    LD	A,0x72
  0F9A    0226    SUBA	0x26
  0F9B    1C03    SNZB	0x3,0
  0F9C    2F9F    JP	0x79F
696:              		{
697:              			motorStep = 0;
  0F9D    01A6    CLR	0x26
  0F9E    01A7    CLR	0x27
698:              		}
699:              		u8t	tempStep = motorStep % 8;
  0F9F    0826    LD	A,0x26
  0FA0    00F6    LD	0x76,A
  0FA1    3007    LDIA	0x7
  0FA2    05F6    ANDR	0x76
700:              		if(motorStep < maxMotorStep)
  0FA3    086C    LD	A,0x6C
  0FA4    0227    SUBA	0x27
  0FA5    1D03    SNZB	0x3,2
  0FA6    2FA9    JP	0x7A9
  0FA7    086B    LD	A,0x6B
  0FA8    0226    SUBA	0x26
  0FA9    1C03    SNZB	0x3,0
  0FAA    2FCC    JP	0x7CC
  0FAB    2FD8    JP	0x7D8
701:              		{
702:              			//正转
703:              			switch(tempStep)
704:              			{
705:              				case 0:
706:              				MOT1 = 1;MOT2 = 0;MOT3 = 0;MOT4 = 0;
  0FAC    1683    SETB	0x3,5
  0FAD    1686    SETB	0x6,5
  0FAE    1306    CLRB	0x6,6
  0FAF    1386    CLRB	0x6,7
  0FB0    1283    CLRB	0x3,5
  0FB1    1386    CLRB	0x6,7
707:              				break;
  0FB2    0008    RET
708:              				case 1:
709:              				MOT1 = 1;MOT2 = 1;MOT3 = 0;MOT4 = 0;
  0FB3    1683    SETB	0x3,5
  0FB4    1686    SETB	0x6,5
710:              				break;
  0FB5    2FF5    JP	0x7F5
711:              				case 2:
712:              				MOT1 = 0;MOT2 = 1;MOT3 = 0;MOT4 = 0;
  0FB6    1683    SETB	0x3,5
  0FB7    1286    CLRB	0x6,5
713:              				break;
  0FB8    2FF5    JP	0x7F5
714:              				case 3:
715:              				MOT1 = 0;MOT2 = 1;MOT3 = 1;MOT4 = 0;
  0FB9    1683    SETB	0x3,5
  0FBA    1286    CLRB	0x6,5
  0FBB    1706    SETB	0x6,6
  0FBC    1786    SETB	0x6,7
  0FBD    1283    CLRB	0x3,5
  0FBE    1386    CLRB	0x6,7
716:              				break;
  0FBF    0008    RET
717:              				case 4:
718:              				MOT1 = 0;MOT2 = 0;MOT3 = 1;MOT4 = 0;
  0FC0    27FA    CALL	0x7FA
  0FC1    1386    CLRB	0x6,7
719:              				break;
  0FC2    0008    RET
720:              				case 5:
721:              				MOT1 = 0;MOT2 = 0;MOT3 = 1;MOT4 = 1;
  0FC3    27FA    CALL	0x7FA
  0FC4    1786    SETB	0x6,7
722:              				break;
  0FC5    0008    RET
723:              				case 6:
724:              				MOT1 = 0;MOT2 = 0;MOT3 = 0;MOT4 = 1;
  0FC6    1683    SETB	0x3,5
  0FC7    1286    CLRB	0x6,5
725:              				break;
  0FC8    2FF0    JP	0x7F0
726:              				case 7:
727:              				MOT1 = 1;MOT2 = 0;MOT3 = 0;MOT4 = 1;
  0FC9    1683    SETB	0x3,5
  0FCA    1686    SETB	0x6,5
728:              				break;
  0FCB    2FF0    JP	0x7F0
  0FCC    0876    LD	A,0x76
  0FCD    0084    LD	0x4,A
  0FCE    3008    LDIA	0x8
  0FCF    0204    SUBA	0x4
  0FD0    1803    SZB	0x3,0
  0FD1    0008    RET
  0FD2    3008    LDIA	0x8
  0FD3    008A    LD	0xA,A
  0FD4    1003    CLRB	0x3,0
  0FD5    0D04    RLCA	0x4
  0FD6    3E17    ADDIA	0x17
  0FD7    0082    LD	0x2,A
  0FD8    0876    LD	A,0x76
  0FD9    0084    LD	0x4,A
  0FDA    3008    LDIA	0x8
  0FDB    0204    SUBA	0x4
  0FDC    1803    SZB	0x3,0
  0FDD    0008    RET
  0FDE    3008    LDIA	0x8
  0FDF    008A    LD	0xA,A
  0FE0    1003    CLRB	0x3,0
  0FE1    0D04    RLCA	0x4
  0FE2    3E27    ADDIA	0x27
  0FE3    0082    LD	0x2,A
729:              			}
730:              		}
731:              		else
732:              		{
733:              			//反转
734:              			switch(tempStep)
735:              			{
736:              				case 7:
737:              				MOT1 = 1;MOT2 = 0;MOT3 = 0;MOT4 = 0;
738:              				break;
739:              				case 6:
740:              				MOT1 = 1;MOT2 = 1;MOT3 = 0;MOT4 = 0;
741:              				break;
742:              				case 5:
743:              				MOT1 = 0;MOT2 = 1;MOT3 = 0;MOT4 = 0;
744:              				break;
745:              				case 4:
746:              				MOT1 = 0;MOT2 = 1;MOT3 = 1;MOT4 = 0;
747:              				break;
748:              				case 3:
749:              				MOT1 = 0;MOT2 = 0;MOT3 = 1;MOT4 = 0;
750:              				break;
751:              				case 2:
752:              				MOT1 = 0;MOT2 = 0;MOT3 = 1;MOT4 = 1;
753:              				break;
754:              				case 1:
755:              				MOT1 = 0;MOT2 = 0;MOT3 = 0;MOT4 = 1;
756:              				break;
757:              				case 0:
758:              				MOT1 = 1;MOT2 = 0;MOT3 = 0;MOT4 = 1;
759:              				break;
760:              			}
761:              		}
762:              	}
763:              	else
764:              	{
765:              		PORTA &= 0x1F;
  0FE4    301F    LDIA	0x1F
  0FE5    1683    SETB	0x3,5
  0FE6    0586    ANDR	0x6
766:              		PORTB &= 0x7F;
  0FE7    1283    CLRB	0x3,5
  0FE8    1386    CLRB	0x6,7
  0FE9    0008    RET
767:              	}
768:              }
769:              
770:              
771:              void workCtr()
  03FF    301F    LDIA	0x1F
772:              {
773:              	test_adc = ADC_Sample(31, 0);		//测试内部基准1.2V相对电源的AD值
  0400    01F2    CLR	0x72
  0401    2587    CALL	0x587
  0402    118A    CLRB	0xA,3
  0403    00B5    LD	0x35,A
774:              	if (0xA5 == test_adc)
  0404    30A5    LDIA	0xA5
  0405    0635    XORA	0x35
  0406    1D03    SNZB	0x3,2
  0407    2C39    JP	0x439
775:              	{
776:              		volatile unsigned long power_temp;
777:              			
778:              		power_temp = (unsigned long)((POWER_RATIO)/adresult);		//1.2*4096/AD=VDD，参数放大1000倍 
  0408    3096    LDIA	0x96
  0409    01D2    CLR	0x52
  040A    00D3    LD	0x53,A
  040B    304A    LDIA	0x4A
  040C    00D4    LD	0x54,A
  040D    0848    LD	A,0x48
  040E    00CD    LD	0x4D,A
  040F    0847    LD	A,0x47
  0410    00CC    LD	0x4C,A
  0411    2539    CALL	0x539
  0412    118A    CLRB	0xA,3
  0413    084C    LD	A,0x4C
  0414    00CF    LD	0x4F,A
  0415    084D    LD	A,0x4D
  0416    00D0    LD	0x50,A
  0417    084E    LD	A,0x4E
  0418    00D1    LD	0x51,A
  0419    247E    CALL	0x47E
  041A    118A    CLRB	0xA,3
  041B    084F    LD	A,0x4F
  041C    00DE    LD	0x5E,A
  041D    0850    LD	A,0x50
  041E    00DF    LD	0x5F,A
  041F    0851    LD	A,0x51
  0420    00E0    LD	0x60,A
  0421    24E0    CALL	0x4E0
  0422    118A    CLRB	0xA,3
  0423    0861    LD	A,0x61
  0424    1683    SETB	0x3,5
  0425    00CE    LD	0x4E,A
  0426    1283    CLRB	0x3,5
  0427    0860    LD	A,0x60
  0428    1683    SETB	0x3,5
  0429    00CD    LD	0x4D,A
  042A    1283    CLRB	0x3,5
  042B    085F    LD	A,0x5F
  042C    1683    SETB	0x3,5
  042D    00CC    LD	0x4C,A
  042E    1283    CLRB	0x3,5
  042F    085E    LD	A,0x5E
  0430    1683    SETB	0x3,5
  0431    00CB    LD	0x4B,A
779:              		power_ad = (unsigned int)(power_temp);		//通过内部基准电压推出芯片VDD电压
  0432    084C    LD	A,0x4C
  0433    1283    CLRB	0x3,5
  0434    00A5    LD	0x25,A
  0435    1683    SETB	0x3,5
  0436    084B    LD	A,0x4B
  0437    1283    CLRB	0x3,5
  0438    00A4    LD	0x24,A
780:              	}
781:              	if(workStep == 2 && power_ad < 3300)
  0439    3002    LDIA	0x2
  043A    067B    XORA	0x7B
  043B    1D03    SNZB	0x3,2
  043C    2C4D    JP	0x44D
  043D    300C    LDIA	0xC
  043E    0225    SUBA	0x25
  043F    30E4    LDIA	0xE4
  0440    1903    SZB	0x3,2
  0441    0224    SUBA	0x24
  0442    1803    SZB	0x3,0
  0443    2C4D    JP	0x44D
782:              	{
783:              		if(++lowFanTime > 200)
  0444    30C9    LDIA	0xC9
  0445    0ABC    INCR	0x3C
  0446    023C    SUBA	0x3C
  0447    1C03    SNZB	0x3,0
  0448    2C4E    JP	0x44E
784:              		{
785:              			lowFanTime = 0;
  0449    01BC    CLR	0x3C
786:              			workStep = 1;
  044A    01FB    CLR	0x7B
  044B    0AFB    INCR	0x7B
  044C    2C4E    JP	0x44E
787:              		}
788:              	}
789:              	else
790:              	{
791:              		lowFanTime = 0;
  044D    01BC    CLR	0x3C
792:              	}	
793:              	if(power_ad < 2900)
  044E    300B    LDIA	0xB
  044F    0225    SUBA	0x25
  0450    3054    LDIA	0x54
  0451    1903    SZB	0x3,2
  0452    0224    SUBA	0x24
  0453    1803    SZB	0x3,0
  0454    2C69    JP	0x469
794:              	{
795:              		if(++lowBatTime > 1000)
  0455    1683    SETB	0x3,5
  0456    0AC7    INCR	0x47
  0457    1903    SZB	0x3,2
  0458    0AC8    INCR	0x48
  0459    3003    LDIA	0x3
  045A    0248    SUBA	0x48
  045B    30E9    LDIA	0xE9
  045C    1903    SZB	0x3,2
  045D    0247    SUBA	0x47
  045E    1C03    SNZB	0x3,0
  045F    2C6C    JP	0x46C
796:              		{
797:              			lowBatTime = 0;
  0460    01C7    CLR	0x47
  0461    01C8    CLR	0x48
798:              			lowBatLock = 1;
  0462    1283    CLRB	0x3,5
  0463    01BD    CLR	0x3D
  0464    0ABD    INCR	0x3D
799:              			workStep = 0;
  0465    01FB    CLR	0x7B
800:              			wuhuaFlag = 0;
  0466    01C4    CLR	0x44
801:              			bujinFlag = 0;
  0467    01BB    CLR	0x3B
  0468    2C6C    JP	0x46C
802:              		}
803:              	}
804:              	else
805:              	{
806:              		lowBatTime = 0;
  0469    1683    SETB	0x3,5
  046A    01C7    CLR	0x47
  046B    01C8    CLR	0x48
807:              	}
808:              	if(firstTime > 0)
  046C    1683    SETB	0x3,5
  046D    084F    LD	A,0x4F
  046E    1903    SZB	0x3,2
  046F    2C76    JP	0x476
809:              	{
810:              		firstTime--;
  0470    03CF    DECR	0x4F
811:              		PORTB = 0x00;
  0471    1283    CLRB	0x3,5
  0472    0186    CLR	0x6
812:              		PORTA = 0x00;
  0473    1683    SETB	0x3,5
  0474    0186    CLR	0x6
813:              	}
  0475    0008    RET
814:              	else
815:              	{
816:              		keyLedCtr();
  0476    2700    CALL	0x700
  0477    118A    CLRB	0xA,3
817:              		fanCtr();
  0478    2658    CALL	0x658
818:              		wuhuaCtr();
  0479    158A    SETB	0xA,3
  047A    2622    CALL	0x622
  047B    118A    CLRB	0xA,3
819:              		bujinCtr();
  047C    158A    SETB	0xA,3
  047D    2F3E    JP	0x73E
820:              		
821:              	}
822:              	
823:              }
824:              
825:              /***********************************************************
826:              主循环
827:              ***********************************************************/
828:              void main()
829:              {
830:              	Init_System();
  0E5F    118A    CLRB	0xA,3
  0E60    2025    CALL	0x25
  0E61    158A    SETB	0xA,3
831:              	firstLock = 1;
  0E62    1283    CLRB	0x3,5
  0E63    30C8    LDIA	0xC8
  0E64    01EE    CLR	0x6E
  0E65    0AEE    INCR	0x6E
832:              	firstTime = 200;
  0E66    1683    SETB	0x3,5
  0E67    00CF    LD	0x4F,A
833:              	while(1)
834:              	{
835:              		if(B_MainLoop)
  0E68    1F78    SNZB	0x78,6
  0E69    2E68    JP	0x668
836:              		{
837:              			B_MainLoop = 0;
  0E6A    1378    CLRB	0x78,6
  0E6B    0064    CLRWDT
838:              			CLRWDT();
839:              			
840:              			CheckTouchKey();
  0E6C    118A    CLRB	0xA,3
  0E6D    2071    CALL	0x71
  0E6E    158A    SETB	0xA,3
841:              			chrgCtr();
  0E6F    118A    CLRB	0xA,3
  0E70    27D7    CALL	0x7D7
  0E71    158A    SETB	0xA,3
842:              			Refurbish_Sfr();
  0E72    118A    CLRB	0xA,3
  0E73    2389    CALL	0x389
  0E74    158A    SETB	0xA,3
843:              			KeyServer();
  0E75    158A    SETB	0xA,3
  0E76    26A1    CALL	0x6A1
  0E77    158A    SETB	0xA,3
844:              			workCtr();
  0E78    118A    CLRB	0xA,3
  0E79    23FF    CALL	0x3FF
  0E7A    158A    SETB	0xA,3
845:              			if(firstTime == 0 && chrgFlag == 0 && workStep == 0 && wuhuaFlag == 0 && powerFlag == 0 && keyCount == 0 && bujinFlag == 0 && shanshuoTime == 0 && shanshuoTime2 == 0)
  0E7B    1683    SETB	0x3,5
  0E7C    084F    LD	A,0x4F
  0E7D    1D03    SNZB	0x3,2
  0E7E    2E68    JP	0x668
  0E7F    1283    CLRB	0x3,5
  0E80    0840    LD	A,0x40
  0E81    1D03    SNZB	0x3,2
  0E82    2E68    JP	0x668
  0E83    087B    LD	A,0x7B
  0E84    1D03    SNZB	0x3,2
  0E85    2E68    JP	0x668
  0E86    0844    LD	A,0x44
  0E87    1D03    SNZB	0x3,2
  0E88    2E68    JP	0x668
  0E89    083A    LD	A,0x3A
  0E8A    1D03    SNZB	0x3,2
  0E8B    2E68    JP	0x668
  0E8C    1683    SETB	0x3,5
  0E8D    0845    LD	A,0x45
  0E8E    0446    ORA	0x46
  0E8F    1D03    SNZB	0x3,2
  0E90    2E68    JP	0x668
  0E91    1283    CLRB	0x3,5
  0E92    083B    LD	A,0x3B
  0E93    1D03    SNZB	0x3,2
  0E94    2E68    JP	0x668
  0E95    082C    LD	A,0x2C
  0E96    042D    ORA	0x2D
  0E97    1D03    SNZB	0x3,2
  0E98    2E68    JP	0x668
  0E99    082A    LD	A,0x2A
  0E9A    042B    ORA	0x2B
  0E9B    1D03    SNZB	0x3,2
  0E9C    2E68    JP	0x668
846:              			{
847:              				WorkSleep();
  0E9D    118A    CLRB	0xA,3
  0E9E    2043    CALL	0x43
  0E9F    158A    SETB	0xA,3
  0EA0    2E68    JP	0x668
848:              			}
849:              		}
850:              	}
851:              }
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\ftdiv.c ----------------------------------------------------------------------
1:                /*	Floating point routines.
2:                
3:                	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:                */
5:                
6:                // this is bigendian code right now. Need to parameterise it.
7:                
8:                #include	"ftarith.h"
9:                
10:               #define	f1_as_dividend	(*(unsigned short long *)&f1)
11:               #define	f2_as_divisor	(*(unsigned short long *)&f2)
12:               #define	f3_as_quot	(*(unsigned short long *)&f3)
13:               
14:               // floating addition
15:               #ifdef _OLDLIB
16:               #define	cntr		sign2
17:               float
18:               #ifdef _PIC18
19:               __ftdiv(float f1, float f2)
20:               #else
21:               __ftdiv(float f2, float f1)
22:               #endif
23:               {
24:               	unsigned char	exp1, exp2, sign1, sign2;
25:               	float	f3;
26:               	
27:               	f3_as_quot = 0;
28:               	sign1 = __ftunpack(&f1_as_dividend, &exp1);
29:               	if(exp1 == 0)
30:               		return f3;
31:               	sign2 = __ftunpack(&f2_as_divisor, &exp2);
32:               	if(exp2 == 0)
33:               		return f3;
34:               	exp1 -= exp2-127+8;	// compute new exponent
35:               	sign1 ^= sign2;
36:               	cntr = 16+8;
37:               	do {
38:               		f3_as_quot <<= 1;
39:               		if(f1_as_dividend >= f2_as_divisor) {
40:               			f1_as_dividend -= f2_as_divisor;
41:               			f3_as_quot |= 1;
42:               		}
43:               		f1_as_dividend <<= 1;
44:               	} while(--cntr != 0);
45:               	__ftpack(&f3_as_quot, exp1);
46:               	if(sign1)
47:               		f3_as_quot |= 0x800000;
48:               	return f3;
49:               }
50:               #else
51:               #define	exp2	sign
52:               float
53:               #ifdef _PIC18
54:               __ftdiv(float f1, float f2)
55:               #else
56:               __ftdiv(float f2, float f1)
  047E    0852    LD	A,0x52
  047F    00D5    LD	0x55,A
  0480    0853    LD	A,0x53
  0481    00D6    LD	0x56,A
  0482    0854    LD	A,0x54
  0483    00D7    LD	0x57,A
  0484    1003    CLRB	0x3,0
  0485    0D56    RLCA	0x56
  0486    0D57    RLCA	0x57
  0487    00DC    LD	0x5C,A
  0488    085C    LD	A,0x5C
  0489    1D03    SNZB	0x3,2
  048A    2C8C    JP	0x48C
  048B    2FD3    JP	0x7D3
  048C    084F    LD	A,0x4F
  048D    00D5    LD	0x55,A
  048E    0850    LD	A,0x50
  048F    00D6    LD	0x56,A
  0490    0851    LD	A,0x51
  0491    00D7    LD	0x57,A
  0492    1003    CLRB	0x3,0
  0493    0D56    RLCA	0x56
  0494    0D57    RLCA	0x57
  0495    00DD    LD	0x5D,A
  0496    085D    LD	A,0x5D
  0497    1D03    SNZB	0x3,2
  0498    2C9A    JP	0x49A
  0499    2FD3    JP	0x7D3
  049A    3089    LDIA	0x89
  049B    01D9    CLR	0x59
  049C    01DA    CLR	0x5A
  049D    01DB    CLR	0x5B
  049E    075D    ADDA	0x5D
  049F    00D5    LD	0x55,A
  04A0    02DC    SUBR	0x5C
  04A1    0854    LD	A,0x54
  04A2    00DD    LD	0x5D,A
  04A3    0851    LD	A,0x51
  04A4    06DD    XORR	0x5D
  04A5    3080    LDIA	0x80
  04A6    05DD    ANDR	0x5D
  04A7    3018    LDIA	0x18
  04A8    17D3    SETB	0x53,7
  04A9    01D4    CLR	0x54
  04AA    17D0    SETB	0x50,7
  04AB    01D1    CLR	0x51
  04AC    00D8    LD	0x58,A
  04AD    1003    CLRB	0x3,0
  04AE    0DD9    RLCR	0x59
  04AF    0DDA    RLCR	0x5A
  04B0    0DDB    RLCR	0x5B
  04B1    0851    LD	A,0x51
  04B2    0254    SUBA	0x54
  04B3    1D03    SNZB	0x3,2
  04B4    2CBB    JP	0x4BB
  04B5    0850    LD	A,0x50
  04B6    0253    SUBA	0x53
  04B7    1D03    SNZB	0x3,2
  04B8    2CBB    JP	0x4BB
  04B9    084F    LD	A,0x4F
  04BA    0252    SUBA	0x52
  04BB    1C03    SNZB	0x3,0
  04BC    2CC9    JP	0x4C9
  04BD    084F    LD	A,0x4F
  04BE    02D2    SUBR	0x52
  04BF    0850    LD	A,0x50
  04C0    1C03    SNZB	0x3,0
  04C1    0F50    SZINCA	0x50
  04C2    02D3    SUBR	0x53
  04C3    0851    LD	A,0x51
  04C4    1C03    SNZB	0x3,0
  04C5    0A51    INCA	0x51
  04C6    02D4    SUBR	0x54
  04C7    1459    SETB	0x59,0
  04C8    1003    CLRB	0x3,0
  04C9    0DD2    RLCR	0x52
  04CA    0DD3    RLCR	0x53
  04CB    0DD4    RLCR	0x54
  04CC    0BD8    SZDECR	0x58
  04CD    2CAD    JP	0x4AD
  04CE    0859    LD	A,0x59
  04CF    00F2    LD	0x72,A
  04D0    085A    LD	A,0x5A
  04D1    00F3    LD	0x73,A
  04D2    085B    LD	A,0x5B
  04D3    00F4    LD	0x74,A
  04D4    085C    LD	A,0x5C
  04D5    00F5    LD	0x75,A
  04D6    085D    LD	A,0x5D
  04D7    00F6    LD	0x76,A
  04D8    2549    CALL	0x549
  04D9    0872    LD	A,0x72
  04DA    00CF    LD	0x4F,A
  04DB    0873    LD	A,0x73
  04DC    00D0    LD	0x50,A
  04DD    0874    LD	A,0x74
  04DE    00D1    LD	0x51,A
  04DF    0008    RET
57:               #endif
58:               {
59:               	unsigned char	exp, sign, cntr;
60:               	float	f3;
61:               	
62:               	// unpack the operands
63:               	if((exp = f1_as_dividend >> 15) == 0)
64:               		return 0.0;
65:               	if((exp2 = f2_as_divisor >> 15) == 0)
66:               		return 0.0;
67:               	f3_as_quot = 0;
68:               	exp -= exp2-127+8;	// compute new exponent
69:               	sign = f1_as_dividend >> 16;
70:               	sign ^= (unsigned char)(f2_as_divisor >> 16);
71:               	sign &= 0x80;
72:               	f1_as_dividend |= 0x8000UL;
73:               	f1_as_dividend &= 0xFFFFUL;
74:               	f2_as_divisor |= 0x8000UL;
75:               	f2_as_divisor &= 0xFFFFUL;
76:               	cntr = 16+8;
77:               	do {
78:               		f3_as_quot <<= 1;
79:               		if(f1_as_dividend >= f2_as_divisor) {
80:               			f1_as_dividend -= f2_as_divisor;
81:               			f3_as_quot |= 1;
82:               		}
83:               		f1_as_dividend <<= 1;
84:               	} while(--cntr != 0);
85:               	return __ftpack(f3_as_quot, exp, sign);
86:               }
87:               #endif	
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\fttol.c ----------------------------------------------------------------------
1:                /*	Floating point routines.
2:                
3:                	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:                */
5:                
6:                // this is bigendian code right now. Need to parameterise it.
7:                
8:                #include	"ftarith.h"
9:                
10:               #define	f1_as_mant1	(*(unsigned short long *)&f1)
11:               
12:               // Convert float to long
13:               
14:               #ifdef _OLDLIB
15:               long
16:               __fttol(float f1)
17:               {
18:               	unsigned char	sign1, exp1;
19:               	unsigned long	lval;
20:               
21:               	sign1 = __ftunpack(&f1_as_mant1, &exp1);
22:               	lval = f1_as_mant1;
23:               	exp1 -= 127+15;
24:               	if((signed char)exp1 < 0) {
25:               		if((signed char)exp1 < -15)
26:               			return 0;
27:               		do
28:               			lval >>= 1;
29:               		while(++exp1 != 0);
30:               	} else {
31:               		if(exp1 >= 32)
32:               			return 00;
33:               		while(exp1 != 0) {
34:               			lval <<= 1;
35:               			exp1--;
36:               		}
37:               	}
38:               	if(sign1)
39:               		lval = -lval;
40:               	return lval;
41:               }
42:               #else
43:               long
44:               __fttol(float f1)
  04E0    27C2    CALL	0x7C2
  04E1    118A    CLRB	0xA,3
  04E2    1003    CLRB	0x3,0
  04E3    0D63    RLCA	0x63
  04E4    0D64    RLCA	0x64
  04E5    00EA    LD	0x6A,A
  04E6    086A    LD	A,0x6A
  04E7    1D03    SNZB	0x3,2
  04E8    2CEE    JP	0x4EE
  04E9    01DE    CLR	0x5E
  04EA    01DF    CLR	0x5F
  04EB    01E0    CLR	0x60
  04EC    01E1    CLR	0x61
  04ED    0008    RET
  04EE    27C2    CALL	0x7C2
  04EF    118A    CLRB	0xA,3
  04F0    3017    LDIA	0x17
  04F1    1003    CLRB	0x3,0
  04F2    0CE4    RRCR	0x64
  04F3    0CE3    RRCR	0x63
  04F4    0CE2    RRCR	0x62
  04F5    3EFF    ADDIA	0xFF
  04F6    1D03    SNZB	0x3,2
  04F7    2CF1    JP	0x4F1
  04F8    0862    LD	A,0x62
  04F9    00E5    LD	0x65,A
  04FA    17DF    SETB	0x5F,7
  04FB    01E0    CLR	0x60
  04FC    085E    LD	A,0x5E
  04FD    00E6    LD	0x66,A
  04FE    085F    LD	A,0x5F
  04FF    00E7    LD	0x67,A
  0500    0860    LD	A,0x60
  0501    00E8    LD	0x68,A
  0502    308E    LDIA	0x8E
  0503    01E9    CLR	0x69
  0504    02EA    SUBR	0x6A
  0505    1FEA    SNZB	0x6A,7
  0506    2D14    JP	0x514
  0507    086A    LD	A,0x6A
  0508    3A80    XORIA	0x80
  0509    3E8F    ADDIA	0x8F
  050A    1C03    SNZB	0x3,0
  050B    2CE9    JP	0x4E9
  050C    1003    CLRB	0x3,0
  050D    0CE9    RRCR	0x69
  050E    0CE8    RRCR	0x68
  050F    0CE7    RRCR	0x67
  0510    0CE6    RRCR	0x66
  0511    0FEA    SZINCR	0x6A
  0512    2D0C    JP	0x50C
  0513    2D22    JP	0x522
  0514    3018    LDIA	0x18
  0515    026A    SUBA	0x6A
  0516    1803    SZB	0x3,0
  0517    2CE9    JP	0x4E9
  0518    086A    LD	A,0x6A
  0519    1903    SZB	0x3,2
  051A    2D22    JP	0x522
  051B    1003    CLRB	0x3,0
  051C    0DE6    RLCR	0x66
  051D    0DE7    RLCR	0x67
  051E    0DE8    RLCR	0x68
  051F    0DE9    RLCR	0x69
  0520    03EA    DECR	0x6A
  0521    2D18    JP	0x518
  0522    0865    LD	A,0x65
  0523    1903    SZB	0x3,2
  0524    2D30    JP	0x530
  0525    09E6    COMR	0x66
  0526    09E7    COMR	0x67
  0527    09E8    COMR	0x68
  0528    09E9    COMR	0x69
  0529    0AE6    INCR	0x66
  052A    1903    SZB	0x3,2
  052B    0AE7    INCR	0x67
  052C    1903    SZB	0x3,2
  052D    0AE8    INCR	0x68
  052E    1903    SZB	0x3,2
  052F    0AE9    INCR	0x69
  0530    0869    LD	A,0x69
  0531    00E1    LD	0x61,A
  0532    0868    LD	A,0x68
  0533    00E0    LD	0x60,A
  0534    0867    LD	A,0x67
  0535    00DF    LD	0x5F,A
  0536    0866    LD	A,0x66
  0537    00DE    LD	0x5E,A
  0538    0008    RET
45:               {
46:               	unsigned char	sign1, exp1;
47:               	unsigned long	lval;
48:               
49:               	if((exp1 = f1_as_mant1 >> 15) == 0)
50:               		return 0;
51:               	sign1 = f1_as_mant1 >> 23;
52:               	f1_as_mant1 |= 0x8000UL;
53:               	f1_as_mant1 &= 0xFFFFUL;
54:               	lval = f1_as_mant1;
55:               	exp1 -= 127+15;
56:               	if((signed char)exp1 < 0) {
57:               		if((signed char)exp1 < -15)
58:               			return 0;
59:               		do
60:               			lval >>= 1;
61:               		while(++exp1 != 0);
62:               	} else {
63:               		if(exp1 >= 24)
64:               			return 0;
65:               		while(exp1 != 0) {
66:               			lval <<= 1;
67:               			exp1--;
68:               		}
69:               	}
70:               	if(sign1)
71:               		lval = -lval;
72:               	return lval;
73:               }
74:               #endif
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\lwtoft.c ----------------------------------------------------------------------
1:                /*	Floating point routines.
2:                
3:                	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:                */
5:                
6:                // this is bigendian code right now. Need to parameterise it.
7:                
8:                #include	"ftarith.h"
9:                
10:               
11:               // Convert unsigned int to float
12:               
13:               #ifdef _OLDLIB
14:               #define	f1_as_mant1	(*(unsigned short long *)&f1)
15:               float
16:               __lwtoft(unsigned int c)
17:               {
18:               	float	f1;
19:               	
20:               	if(c == 0)
21:               		return 0.0;
22:               	f1_as_mant1 = c;
23:               	__ftpack(&f1_as_mant1, 127+15);
24:               	return f1;
25:               }
26:               #else
27:               float
28:               __lwtoft(unsigned int c)
  0539    084C    LD	A,0x4C
  053A    00F2    LD	0x72,A
  053B    084D    LD	A,0x4D
  053C    00F3    LD	0x73,A
  053D    308E    LDIA	0x8E
  053E    01F4    CLR	0x74
  053F    00F5    LD	0x75,A
  0540    01F6    CLR	0x76
  0541    2549    CALL	0x549
  0542    0872    LD	A,0x72
  0543    00CC    LD	0x4C,A
  0544    0873    LD	A,0x73
  0545    00CD    LD	0x4D,A
  0546    0874    LD	A,0x74
  0547    00CE    LD	0x4E,A
  0548    0008    RET
29:               {
30:               	return __ftpack(c, 127+15, 0);
31:               }
32:               #endif
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\float.c ----------------------------------------------------------------------
1:                /*	Floating point routines.
2:                
3:                	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:                */
5:                
6:                #include	"ftarith.h"
7:                
8:                
9:                //	unpack the operand pointed to. Store the exponent into the location pointed to by exp,
10:               //	and return the sign (zero is positive)
11:               
12:               #ifdef _OLDLIB
13:               
14:               unsigned char
15:               __ftunpack(unsigned short long * arg, unsigned char * exp)
16:               {
17:               	unsigned char	sign;
18:               
19:               	*exp = sign = *arg >> 15;
20:               	if(sign == 0) {
21:               		*arg = 0;
22:               		return 0;
23:               	}
24:               	sign = 0;
25:               	*arg |= 0x8000;
26:               	if(*arg & 0x800000)
27:               		sign++;
28:               	*arg &= 0xFFFF;
29:               	return sign;
30:               }
31:               
32:               // normalize and pack the supplied argument into floating point format
33:               
34:               void
35:               __ftpack(unsigned short long * arg, unsigned char exp)
36:               {
37:               	if(exp == 0 || *arg == 0) {
38:               		*arg = 0;
39:               		return;
40:               	}
41:               	while(*arg & 0xFE0000UL) {
42:               		exp++;
43:               		*arg >>= 1;
44:               	}
45:               	while(*arg & 0xFF0000UL) {
46:               		exp++;
47:               		(*arg)++;
48:               		*arg >>= 1;
49:               	}
50:               	while(!(*arg & 0x8000UL)) {
51:               		exp--;
52:               		*arg <<= 1;
53:               	}
54:               	if(!(exp & 1))
55:               		*arg &= ~0x8000L;
56:               	exp >>= 1;
57:               	*arg |= (unsigned short long)exp << 16;
58:               }
59:               
60:               #else
61:               float
62:               __ftpack(unsigned short long arg, unsigned char exp, unsigned char sign)
  0549    0875    LD	A,0x75
  054A    1903    SZB	0x3,2
  054B    2D51    JP	0x551
  054C    0874    LD	A,0x74
  054D    0473    ORA	0x73
  054E    0472    ORA	0x72
  054F    1D03    SNZB	0x3,2
  0550    2D58    JP	0x558
  0551    01F2    CLR	0x72
  0552    01F3    CLR	0x73
  0553    01F4    CLR	0x74
  0554    0008    RET
  0555    0AF5    INCR	0x75
  0556    27C9    CALL	0x7C9
  0557    118A    CLRB	0xA,3
  0558    30FE    LDIA	0xFE
  0559    0574    ANDA	0x74
  055A    1903    SZB	0x3,2
  055B    2D65    JP	0x565
  055C    2D55    JP	0x555
  055D    0AF5    INCR	0x75
  055E    0AF2    INCR	0x72
  055F    1903    SZB	0x3,2
  0560    0AF3    INCR	0x73
  0561    1903    SZB	0x3,2
  0562    0AF4    INCR	0x74
  0563    27C9    CALL	0x7C9
  0564    118A    CLRB	0xA,3
  0565    30FF    LDIA	0xFF
  0566    0574    ANDA	0x74
  0567    1903    SZB	0x3,2
  0568    2D73    JP	0x573
  0569    2D5D    JP	0x55D
  056A    3002    LDIA	0x2
  056B    0275    SUBA	0x75
  056C    1C03    SNZB	0x3,0
  056D    2D75    JP	0x575
  056E    03F5    DECR	0x75
  056F    1003    CLRB	0x3,0
  0570    0DF2    RLCR	0x72
  0571    0DF3    RLCR	0x73
  0572    0DF4    RLCR	0x74
  0573    1FF3    SNZB	0x73,7
  0574    2D6A    JP	0x56A
  0575    1C75    SNZB	0x75,0
  0576    13F3    CLRB	0x73,7
  0577    1003    CLRB	0x3,0
  0578    0CF5    RRCR	0x75
  0579    0875    LD	A,0x75
  057A    00CB    LD	0x4B,A
  057B    01CA    CLR	0x4A
  057C    01C9    CLR	0x49
  057D    0849    LD	A,0x49
  057E    04F2    ORR	0x72
  057F    084A    LD	A,0x4A
  0580    04F3    ORR	0x73
  0581    084B    LD	A,0x4B
  0582    04F4    ORR	0x74
  0583    0876    LD	A,0x76
  0584    1D03    SNZB	0x3,2
  0585    17F4    SETB	0x74,7
  0586    0008    RET
63:               {
64:               	if(exp == 0 || arg == 0)
65:               		return 0.0;
66:               	while(arg & 0xFE0000UL) {
67:               		exp++;
68:               		arg >>= 1;
69:               	}
70:               	while(arg & 0xFF0000UL) {
71:               		exp++;
72:               		(arg)++;
73:               		arg >>= 1;
74:               	}
75:               	while(!(arg & 0x8000UL) && exp > 1) {
76:               		exp--;
77:               		arg <<= 1;
78:               	}
79:               	if(!(exp & 1))
80:               		arg &= ~0x8000L;
81:               	exp >>= 1;
82:               	arg |= (unsigned short long)exp << 16;
83:               	if (sign)
84:               		arg |= 0x800000UL;
85:                  return *(float*)&arg;	
86:               }
87:               
88:               #endif
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\Umul32.c ----------------------------------------------------------------------
1:                // 32 x 32 bit multiplication with 32 bit result
2:                #ifdef _PIC18
3:                #define _Has_hardware_multiply 1
4:                #else
5:                #define _Has_hardware_multiply 0
6:                #endif
7:                
8:                #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:                #define _Has_large_call_stack 1
10:               #else
11:               #define _Has_large_call_stack 0
12:               #endif
13:               
14:               unsigned long
15:               __lmul(unsigned long multiplier, unsigned long multiplicand)
  06CD    01F2    CLR	0x72
  06CE    01F3    CLR	0x73
  06CF    01F4    CLR	0x74
  06D0    01F5    CLR	0x75
  06D1    1C49    SNZB	0x49,0
  06D2    2EE7    JP	0x6E7
  06D3    084D    LD	A,0x4D
  06D4    07F2    ADDR	0x72
  06D5    084E    LD	A,0x4E
  06D6    1103    CLRB	0x3,2
  06D7    1803    SZB	0x3,0
  06D8    3E01    ADDIA	0x1
  06D9    1D03    SNZB	0x3,2
  06DA    07F3    ADDR	0x73
  06DB    084F    LD	A,0x4F
  06DC    1103    CLRB	0x3,2
  06DD    1803    SZB	0x3,0
  06DE    3E01    ADDIA	0x1
  06DF    1D03    SNZB	0x3,2
  06E0    07F4    ADDR	0x74
  06E1    0850    LD	A,0x50
  06E2    1103    CLRB	0x3,2
  06E3    1803    SZB	0x3,0
  06E4    3E01    ADDIA	0x1
  06E5    1D03    SNZB	0x3,2
  06E6    07F5    ADDR	0x75
  06E7    1003    CLRB	0x3,0
  06E8    0DCD    RLCR	0x4D
  06E9    0DCE    RLCR	0x4E
  06EA    0DCF    RLCR	0x4F
  06EB    0DD0    RLCR	0x50
  06EC    1003    CLRB	0x3,0
  06ED    0CCC    RRCR	0x4C
  06EE    0CCB    RRCR	0x4B
  06EF    0CCA    RRCR	0x4A
  06F0    0CC9    RRCR	0x49
  06F1    084C    LD	A,0x4C
  06F2    044B    ORA	0x4B
  06F3    044A    ORA	0x4A
  06F4    0449    ORA	0x49
  06F5    1D03    SNZB	0x3,2
  06F6    2ED1    JP	0x6D1
  06F7    0875    LD	A,0x75
  06F8    00CC    LD	0x4C,A
  06F9    0874    LD	A,0x74
  06FA    00CB    LD	0x4B,A
  06FB    0873    LD	A,0x73
  06FC    00CA    LD	0x4A,A
  06FD    0872    LD	A,0x72
  06FE    00C9    LD	0x49,A
  06FF    0008    RET
16:               {
17:               	unsigned long product;
18:               
19:               #define LOWBYTE(x)  (*(unsigned char *)(&x))
20:               #define LMIDBYTE(x) (*(((unsigned char *)(&x))+1))
21:               #define HMIDBYTE(x) (*(((unsigned char *)(&x))+2))
22:               #define HIGHBYTE(x) (*(((unsigned char *)(&x))+3))
23:               
24:               #if (_Has_hardware_multiply || _Has_large_call_stack) && defined(__OPTIMIZE_SPEED__)
25:               	{
26:               
27:               #define USE_SHRINK
28:               
29:               /*
30:               a 32-bit multiply can be decomposed into the sum of ten 8-bit multiplies
31:                            a  b  c  d
32:               *            e  f  g  h
33:               -----------------------
34:                          |         dh
35:                          |      ch  0
36:                          |   bh  0  0
37:                          |ah  0  0  0
38:                          |      dg  0
39:                          |   cg  0  0
40:                          |bg  0  0  0
41:                        ag| 0  0  0  0 (we ignore this intermediate product
42:                                        because it does not affect the low 32 bits of the result)
43:                          |   df  0  0
44:                          |cf  0  0  0
45:                        bf| 0  0  0  0 (ignore)
46:                     af  0| 0  0  0  0 (ignore)
47:                          |de  0  0  0
48:                        ce| 0  0  0  0 (ignore)
49:                     be  0| 0  0  0  0 (ignore)
50:               +  ae  0  0| 0  0  0  0 (ignore)
51:               =======================
52:                */
53:               		product =  (unsigned int)LOWBYTE(multiplier) * LOWBYTE(multiplicand);
54:               
55:               #if defined(USE_MASKS)
56:               		product += ((unsigned long)
57:               			     ((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand))
58:               			     +
59:               			     ((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
60:               			<< 8;
61:               
62:               		product += ((unsigned long)
63:               			    ((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand))
64:               			    +
65:               			    ((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
66:               			    +
67:               			    ((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
68:               			<< 16;
69:               
70:               		/* cast to smaller type to avoid adding high bits just to discard */
71:               		product += ((unsigned long)
72:               			    (unsigned char)
73:               			    ((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand))
74:               			    +
75:               			    (unsigned char)
76:               			    ((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand))
77:               			    +
78:               			    (unsigned char)
79:               			    ((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
80:               			    +
81:               			    (unsigned char)
82:               			    ((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand)))
83:               			<< 24;
84:               
85:               #elif defined(USE_SHRINK)
86:               		/* add direct to upper bytes, rather than shift and add all bytes */
87:               		*((unsigned short long*)(((unsigned char*)&product)+1)) +=
88:               			((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand));
89:               		*((unsigned short long*)(((unsigned char*)&product)+1)) +=
90:               			((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand));
91:               
92:               
93:               		*((unsigned int*)(((unsigned char*)&product)+2)) +=
94:               			((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand));
95:               		*((unsigned int*)(((unsigned char*)&product)+2)) +=
96:               			((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
97:               		*((unsigned int*)(((unsigned char*)&product)+2)) +=
98:               			((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand));
99:               
100:              		*(((unsigned char*)&product)+3) +=
101:              			(unsigned char)
102:              			((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand));
103:              		*(((unsigned char*)&product)+3) +=
104:              			(unsigned char)
105:              			((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand));
106:              		*(((unsigned char*)&product)+3) +=
107:              			(unsigned char)
108:              			((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
109:              		*(((unsigned char*)&product)+3) +=
110:              			(unsigned char)
111:              			((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand));
112:              
113:              #else
114:              #error No method chosen
115:              #endif
116:              	}
117:              #else
118:              
119:              	product = 0;
120:              	do {
121:              		if(multiplier & 1)
122:              			product += multiplicand;
123:              		multiplicand <<= 1;
124:              		multiplier >>= 1;
125:              	} while(multiplier != 0);
126:              
127:              #endif
128:              	return product;
129:              }
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\lwmod.c ----------------------------------------------------------------------
1:                // word unsigned modulus
2:                
3:                unsigned int
4:                #ifdef __PICC__
5:                #warning TODO: update cgpic and this file to use the other prototype
6:                __lwmod(unsigned int divisor, unsigned int dividend)
  0775    0872    LD	A,0x72
  0776    0473    ORA	0x73
  0777    1903    SZB	0x3,2
  0778    2F94    JP	0x794
  0779    01F6    CLR	0x76
  077A    0AF6    INCR	0x76
  077B    1BF3    SZB	0x73,7
  077C    2F81    JP	0x781
  077D    1003    CLRB	0x3,0
  077E    0DF2    RLCR	0x72
  077F    0DF3    RLCR	0x73
  0780    2F7A    JP	0x77A
  0781    0873    LD	A,0x73
  0782    0275    SUBA	0x75
  0783    1D03    SNZB	0x3,2
  0784    2F87    JP	0x787
  0785    0872    LD	A,0x72
  0786    0274    SUBA	0x74
  0787    1C03    SNZB	0x3,0
  0788    2F90    JP	0x790
  0789    0872    LD	A,0x72
  078A    02F4    SUBR	0x74
  078B    0873    LD	A,0x73
  078C    1C03    SNZB	0x3,0
  078D    03F5    DECR	0x75
  078E    02F5    SUBR	0x75
  078F    1003    CLRB	0x3,0
  0790    0CF3    RRCR	0x73
  0791    0CF2    RRCR	0x72
  0792    0BF6    SZDECR	0x76
  0793    2F81    JP	0x781
  0794    0875    LD	A,0x75
  0795    00F3    LD	0x73,A
  0796    0874    LD	A,0x74
  0797    00F2    LD	0x72,A
  0798    0008    RET
7:                #else
8:                __lwmod(unsigned int dividend, unsigned int divisor)
9:                #endif
10:               {
11:               	unsigned char	counter;
12:               
13:               	if(divisor != 0) {
14:               		counter = 1;
15:               		while((divisor & 0x8000) == 0) {
16:               			divisor <<= 1;
17:               			counter++;
18:               		}
19:               		do {
20:               			if(divisor <= dividend)
21:               				dividend -= divisor;
22:               			divisor >>= 1;
23:               		} while(--counter != 0);
24:               	}
25:               	return dividend;
26:               }
---- library_code ------------------------------------------------------------------
  0071    1A78    SZB	0x78,4
  0072    287F    JP	0x7F
  0073    212E    CALL	0x12E
  0074    118A    CLRB	0xA,3
  0075    3008    LDIA	0x8
  0076    1283    CLRB	0x3,5
  0077    1303    CLRB	0x3,6
  0078    0AB2    INCR	0x32
  0079    0232    SUBA	0x32
  007A    1C03    SNZB	0x3,0
  007B    289D    JP	0x9D
  007C    01B2    CLR	0x32
  007D    1678    SETB	0x78,4
  007E    289D    JP	0x9D
  007F    19F8    SZB	0x78,3
  0080    2897    JP	0x97
  0081    219D    CALL	0x19D
  0082    118A    CLRB	0xA,3
  0083    2332    CALL	0x332
  0084    118A    CLRB	0xA,3
  0085    15F8    SETB	0x78,3
  0086    18F8    SZB	0x78,1
  0087    288E    JP	0x8E
  0088    3002    LDIA	0x2
  0089    1283    CLRB	0x3,5
  008A    1303    CLRB	0x3,6
  008B    0232    SUBA	0x32
  008C    1C03    SNZB	0x3,0
  008D    2893    JP	0x93
  008E    231E    CALL	0x31E
  008F    118A    CLRB	0xA,3
  0090    10F8    CLRB	0x78,1
  0091    1278    CLRB	0x78,4
  0092    11F8    CLRB	0x78,3
  0093    1283    CLRB	0x3,5
  0094    1303    CLRB	0x3,6
  0095    01B2    CLR	0x32
  0096    289D    JP	0x9D
  0097    22B6    CALL	0x2B6
  0098    118A    CLRB	0xA,3
  0099    218E    CALL	0x18E
  009A    118A    CLRB	0xA,3
  009B    1278    CLRB	0x78,4
  009C    11F8    CLRB	0x78,3
  009D    2B63    JP	0x363
  009E    0064    CLRWDT
  009F    1683    SETB	0x3,5
  00A0    1303    CLRB	0x3,6
  00A1    0181    CLR	0x1
  00A2    3007    LDIA	0x7
  00A3    1283    CLRB	0x3,5
  00A4    0481    ORR	0x1
  00A5    1581    SETB	0x1,3
  00A6    0064    CLRWDT
  00A7    300A    LDIA	0xA
  00A8    1283    CLRB	0x3,5
  00A9    1303    CLRB	0x3,6
  00AA    0081    LD	0x1,A
  00AB    0064    CLRWDT
  00AC    1283    CLRB	0x3,5
  00AD    1703    SETB	0x3,6
  00AE    0191    CLR	0x11
  00AF    0193    CLR	0x13
  00B0    3002    LDIA	0x2
  00B1    1303    CLRB	0x3,6
  00B2    0094    LD	0x14,A
  00B3    0063    STOP
  00B4    0000    NOP
  00B5    0064    CLRWDT
  00B6    3072    LDIA	0x72
  00B7    1283    CLRB	0x3,5
  00B8    1303    CLRB	0x3,6
  00B9    0094    LD	0x14,A
  00BA    3079    LDIA	0x79
  00BB    1703    SETB	0x3,6
  00BC    0093    LD	0x13,A
  00BD    218E    CALL	0x18E
  00BE    118A    CLRB	0xA,3
  00BF    1478    SETB	0x78,0
  00C0    212E    CALL	0x12E
  00C1    118A    CLRB	0xA,3
  00C2    1283    CLRB	0x3,5
  00C3    1303    CLRB	0x3,6
  00C4    23F5    CALL	0x3F5
  00C5    118A    CLRB	0xA,3
  00C6    1C0B    SNZB	0xB,0
  00C7    188B    SZB	0xB,1
  00C8    28CB    JP	0xCB
  00C9    1D8D    SNZB	0xD,3
  00CA    28D2    JP	0xD2
  00CB    218E    CALL	0x18E
  00CC    1283    CLRB	0x3,5
  00CD    1303    CLRB	0x3,6
  00CE    01B2    CLR	0x32
  00CF    1278    CLRB	0x78,4
  00D0    11F8    CLRB	0x78,3
  00D1    0008    RET
  00D2    084F    LD	A,0x4F
  00D3    3907    ANDIA	0x7
  00D4    1003    CLRB	0x3,0
  00D5    1903    SZB	0x3,2
  00D6    2928    JP	0x128
  00D7    0D51    RLCA	0x51
  00D8    3EB8    ADDIA	0xB8
  00D9    0084    LD	0x4,A
  00DA    1383    CLRB	0x3,7
  00DB    0800    LD	A,0x0
  00DC    00CD    LD	0x4D,A
  00DD    0A84    INCR	0x4
  00DE    0800    LD	A,0x0
  00DF    00CE    LD	0x4E,A
  00E0    00CC    LD	0x4C,A
  00E1    084D    LD	A,0x4D
  00E2    00CB    LD	0x4B,A
  00E3    084D    LD	A,0x4D
  00E4    044E    ORA	0x4E
  00E5    1903    SZB	0x3,2
  00E6    2927    JP	0x127
  00E7    0851    LD	A,0x51
  00E8    3E09    ADDIA	0x9
  00E9    0084    LD	0x4,A
  00EA    158A    SETB	0xA,3
  00EB    2000    CALL	0x0
  00EC    118A    CLRB	0xA,3
  00ED    07CB    ADDR	0x4B
  00EE    1803    SZB	0x3,0
  00EF    0ACC    INCR	0x4C
  00F0    1003    CLRB	0x3,0
  00F1    0D51    RLCA	0x51
  00F2    3EA6    ADDIA	0xA6
  00F3    23D4    CALL	0x3D4
  00F4    118A    CLRB	0xA,3
  00F5    084C    LD	A,0x4C
  00F6    024A    SUBA	0x4A
  00F7    1D03    SNZB	0x3,2
  00F8    28FB    JP	0xFB
  00F9    084B    LD	A,0x4B
  00FA    0249    SUBA	0x49
  00FB    1C03    SNZB	0x3,0
  00FC    290F    JP	0x10F
  00FD    23F5    CALL	0x3F5
  00FE    118A    CLRB	0xA,3
  00FF    084F    LD	A,0x4F
  0100    3907    ANDIA	0x7
  0101    1D03    SNZB	0x3,2
  0102    2906    JP	0x106
  0103    0851    LD	A,0x51
  0104    2293    CALL	0x293
  0105    118A    CLRB	0xA,3
  0106    1283    CLRB	0x3,5
  0107    3003    LDIA	0x3
  0108    1303    CLRB	0x3,6
  0109    1003    CLRB	0x3,0
  010A    23FA    CALL	0x3FA
  010B    118A    CLRB	0xA,3
  010C    1803    SZB	0x3,0
  010D    28CB    JP	0xCB
  010E    28FF    JP	0xFF
  010F    0D51    RLCA	0x51
  0110    3EAC    ADDIA	0xAC
  0111    23D4    CALL	0x3D4
  0112    118A    CLRB	0xA,3
  0113    1003    CLRB	0x3,0
  0114    0D51    RLCA	0x51
  0115    3EA6    ADDIA	0xA6
  0116    23BE    CALL	0x3BE
  0117    118A    CLRB	0xA,3
  0118    0800    LD	A,0x0
  0119    00C9    LD	0x49,A
  011A    0A84    INCR	0x4
  011B    0800    LD	A,0x0
  011C    00CA    LD	0x4A,A
  011D    1003    CLRB	0x3,0
  011E    0D51    RLCA	0x51
  011F    3EAC    ADDIA	0xAC
  0120    23BE    CALL	0x3BE
  0121    118A    CLRB	0xA,3
  0122    084D    LD	A,0x4D
  0123    0080    LD	0x0,A
  0124    0A84    INCR	0x4
  0125    084E    LD	A,0x4E
  0126    0080    LD	0x0,A
  0127    1003    CLRB	0x3,0
  0128    3003    LDIA	0x3
  0129    23FA    CALL	0x3FA
  012A    118A    CLRB	0xA,3
  012B    1803    SZB	0x3,0
  012C    289E    JP	0x9E
  012D    28D2    JP	0xD2
  012E    01F7    CLR	0x77
  012F    01F5    CLR	0x75
  0130    0AF5    INCR	0x75
  0131    01F6    CLR	0x76
  0132    1C78    SNZB	0x78,0
  0133    2938    JP	0x138
  0134    0875    LD	A,0x75
  0135    3907    ANDIA	0x7
  0136    1903    SZB	0x3,2
  0137    2984    JP	0x184
  0138    1283    CLRB	0x3,5
  0139    1703    SETB	0x3,6
  013A    0191    CLR	0x11
  013B    0192    CLR	0x12
  013C    3079    LDIA	0x79
  013D    0093    LD	0x13,A
  013E    1303    CLRB	0x3,6
  013F    1305    CLRB	0x5,6
  0140    1306    CLRB	0x6,6
  0141    0000    NOP
  0142    0000    NOP
  0143    0000    NOP
  0144    0000    NOP
  0145    0000    NOP
  0146    0000    NOP
  0147    0000    NOP
  0148    0000    NOP
  0149    1283    CLRB	0x3,5
  014A    1303    CLRB	0x3,6
  014B    1705    SETB	0x5,6
  014C    0877    LD	A,0x77
  014D    3E0C    ADDIA	0xC
  014E    0084    LD	0x4,A
  014F    158A    SETB	0xA,3
  0150    2000    CALL	0x0
  0151    118A    CLRB	0xA,3
  0152    1703    SETB	0x3,6
  0153    0091    LD	0x11,A
  0154    0877    LD	A,0x77
  0155    3E0F    ADDIA	0xF
  0156    0084    LD	0x4,A
  0157    158A    SETB	0xA,3
  0158    2000    CALL	0x0
  0159    118A    CLRB	0xA,3
  015A    0092    LD	0x12,A
  015B    0000    NOP
  015C    0000    NOP
  015D    0000    NOP
  015E    0000    NOP
  015F    1283    CLRB	0x3,5
  0160    1703    SETB	0x3,6
  0161    1411    SETB	0x11,0
  0162    30D0    LDIA	0xD0
  0163    00F3    LD	0x73,A
  0164    3007    LDIA	0x7
  0165    00F4    LD	0x74,A
  0166    1B91    SZB	0x11,7
  0167    2974    JP	0x174
  0168    3001    LDIA	0x1
  0169    02F3    SUBR	0x73
  016A    1C03    SNZB	0x3,0
  016B    03F4    DECR	0x74
  016C    0873    LD	A,0x73
  016D    0474    ORA	0x74
  016E    1D03    SNZB	0x3,2
  016F    2966    JP	0x166
  0170    30FF    LDIA	0xFF
  0171    1303    CLRB	0x3,6
  0172    00B2    LD	0x32,A
  0173    298E    JP	0x18E
  0174    1003    CLRB	0x3,0
  0175    0D77    RLCA	0x77
  0176    3EB8    ADDIA	0xB8
  0177    0084    LD	0x4,A
  0178    0816    LD	A,0x16
  0179    1383    CLRB	0x3,7
  017A    0780    ADDR	0x0
  017B    0F84    SZINCR	0x4
  017C    0800    LD	A,0x0
  017D    1803    SZB	0x3,0
  017E    0A00    INCA	0x0
  017F    00FF    LD	0x7F,A
  0180    0817    LD	A,0x17
  0181    077F    ADDA	0x7F
  0182    0080    LD	0x0,A
  0183    0384    DECR	0x4
  0184    3003    LDIA	0x3
  0185    1003    CLRB	0x3,0
  0186    0DF5    RLCR	0x75
  0187    0DF6    RLCR	0x76
  0188    0AF7    INCR	0x77
  0189    0277    SUBA	0x77
  018A    1C03    SNZB	0x3,0
  018B    2932    JP	0x132
  018C    1078    CLRB	0x78,0
  018D    0008    RET
  018E    01F2    CLR	0x72
  018F    1003    CLRB	0x3,0
  0190    0D72    RLCA	0x72
  0191    3EB8    ADDIA	0xB8
  0192    0084    LD	0x4,A
  0193    3003    LDIA	0x3
  0194    1383    CLRB	0x3,7
  0195    0180    CLR	0x0
  0196    0A84    INCR	0x4
  0197    0180    CLR	0x0
  0198    0AF2    INCR	0x72
  0199    0272    SUBA	0x72
  019A    1803    SZB	0x3,0
  019B    0008    RET
  019C    298F    JP	0x18F
  019D    1283    CLRB	0x3,5
  019E    1303    CLRB	0x3,6
  019F    01D5    CLR	0x55
  01A0    01A0    CLR	0x20
  01A1    01A1    CLR	0x21
  01A2    01B1    CLR	0x31
  01A3    0855    LD	A,0x55
  01A4    3907    ANDIA	0x7
  01A5    3E01    ADDIA	0x1
  01A6    0084    LD	0x4,A
  01A7    158A    SETB	0xA,3
  01A8    2000    CALL	0x0
  01A9    118A    CLRB	0xA,3
  01AA    00CF    LD	0x4F,A
  01AB    1003    CLRB	0x3,0
  01AC    0D55    RLCA	0x55
  01AD    3EB8    ADDIA	0xB8
  01AE    0084    LD	0x4,A
  01AF    3003    LDIA	0x3
  01B0    0A84    INCR	0x4
  01B1    1003    CLRB	0x3,0
  01B2    1383    CLRB	0x3,7
  01B3    0C80    RRCR	0x0
  01B4    0384    DECR	0x4
  01B5    0C80    RRCR	0x0
  01B6    3EFF    ADDIA	0xFF
  01B7    1D03    SNZB	0x3,2
  01B8    29B0    JP	0x1B0
  01B9    1003    CLRB	0x3,0
  01BA    0D55    RLCA	0x55
  01BB    3EB8    ADDIA	0xB8
  01BC    0084    LD	0x4,A
  01BD    0800    LD	A,0x0
  01BE    00D3    LD	0x53,A
  01BF    0A84    INCR	0x4
  01C0    0800    LD	A,0x0
  01C1    00D4    LD	0x54,A
  01C2    0855    LD	A,0x55
  01C3    3E09    ADDIA	0x9
  01C4    0084    LD	0x4,A
  01C5    158A    SETB	0xA,3
  01C6    2000    CALL	0x0
  01C7    118A    CLRB	0xA,3
  01C8    00D2    LD	0x52,A
  01C9    00D0    LD	0x50,A
  01CA    01D1    CLR	0x51
  01CB    0853    LD	A,0x53
  01CC    07D0    ADDR	0x50
  01CD    1803    SZB	0x3,0
  01CE    0AD1    INCR	0x51
  01CF    0854    LD	A,0x54
  01D0    07D1    ADDR	0x51
  01D1    0855    LD	A,0x55
  01D2    2283    CALL	0x283
  01D3    118A    CLRB	0xA,3
  01D4    3A00    XORIA	0x0
  01D5    1D03    SNZB	0x3,2
  01D6    2A34    JP	0x234
  01D7    1283    CLRB	0x3,5
  01D8    1303    CLRB	0x3,6
  01D9    1003    CLRB	0x3,0
  01DA    0D55    RLCA	0x55
  01DB    3EA6    ADDIA	0xA6
  01DC    0084    LD	0x4,A
  01DD    1383    CLRB	0x3,7
  01DE    0800    LD	A,0x0
  01DF    00CD    LD	0x4D,A
  01E0    0A84    INCR	0x4
  01E1    0800    LD	A,0x0
  01E2    00CE    LD	0x4E,A
  01E3    1003    CLRB	0x3,0
  01E4    0D55    RLCA	0x55
  01E5    3EA0    ADDIA	0xA0
  01E6    23B7    CALL	0x3B7
  01E7    118A    CLRB	0xA,3
  01E8    0251    SUBA	0x51
  01E9    1D03    SNZB	0x3,2
  01EA    29ED    JP	0x1ED
  01EB    0849    LD	A,0x49
  01EC    0250    SUBA	0x50
  01ED    1803    SZB	0x3,0
  01EE    29FC    JP	0x1FC
  01EF    1003    CLRB	0x3,0
  01F0    0D55    RLCA	0x55
  01F1    3EA0    ADDIA	0xA0
  01F2    23B7    CALL	0x3B7
  01F3    118A    CLRB	0xA,3
  01F4    0853    LD	A,0x53
  01F5    0249    SUBA	0x49
  01F6    00D3    LD	0x53,A
  01F7    0854    LD	A,0x54
  01F8    1C03    SNZB	0x3,0
  01F9    0A54    INCA	0x54
  01FA    024A    SUBA	0x4A
  01FB    2A20    JP	0x220
  01FC    084E    LD	A,0x4E
  01FD    0251    SUBA	0x51
  01FE    1D03    SNZB	0x3,2
  01FF    2A02    JP	0x202
  0200    084D    LD	A,0x4D
  0201    0250    SUBA	0x50
  0202    1803    SZB	0x3,0
  0203    2A7B    JP	0x27B
  0204    1003    CLRB	0x3,0
  0205    0D55    RLCA	0x55
  0206    3EAC    ADDIA	0xAC
  0207    23B7    CALL	0x3B7
  0208    118A    CLRB	0xA,3
  0209    0251    SUBA	0x51
  020A    1D03    SNZB	0x3,2
  020B    2A0E    JP	0x20E
  020C    0849    LD	A,0x49
  020D    0250    SUBA	0x50
  020E    1803    SZB	0x3,0
  020F    2A7B    JP	0x27B
  0210    1003    CLRB	0x3,0
  0211    0D55    RLCA	0x55
  0212    3EA0    ADDIA	0xA0
  0213    0084    LD	0x4,A
  0214    084D    LD	A,0x4D
  0215    0080    LD	0x0,A
  0216    0A84    INCR	0x4
  0217    084E    LD	A,0x4E
  0218    0080    LD	0x0,A
  0219    0853    LD	A,0x53
  021A    024D    SUBA	0x4D
  021B    00D3    LD	0x53,A
  021C    0854    LD	A,0x54
  021D    1C03    SNZB	0x3,0
  021E    0A54    INCA	0x54
  021F    024E    SUBA	0x4E
  0220    00D4    LD	0x54,A
  0221    0855    LD	A,0x55
  0222    3EBE    ADDIA	0xBE
  0223    0084    LD	0x4,A
  0224    0180    CLR	0x0
  0225    0854    LD	A,0x54
  0226    1903    SZB	0x3,2
  0227    2A2A    JP	0x22A
  0228    30FF    LDIA	0xFF
  0229    2A2B    JP	0x22B
  022A    0853    LD	A,0x53
  022B    00D2    LD	0x52,A
  022C    0231    SUBA	0x31
  022D    1803    SZB	0x3,0
  022E    2A32    JP	0x232
  022F    0852    LD	A,0x52
  0230    00B1    LD	0x31,A
  0231    2A75    JP	0x275
  0232    0AB2    INCR	0x32
  0233    2A7B    JP	0x27B
  0234    1283    CLRB	0x3,5
  0235    1303    CLRB	0x3,6
  0236    1003    CLRB	0x3,0
  0237    0D55    RLCA	0x55
  0238    3EA0    ADDIA	0xA0
  0239    0084    LD	0x4,A
  023A    1383    CLRB	0x3,7
  023B    0800    LD	A,0x0
  023C    00C9    LD	0x49,A
  023D    0A84    INCR	0x4
  023E    0800    LD	A,0x0
  023F    00CA    LD	0x4A,A
  0240    0849    LD	A,0x49
  0241    3E01    ADDIA	0x1
  0242    00CB    LD	0x4B,A
  0243    084A    LD	A,0x4A
  0244    1803    SZB	0x3,0
  0245    3E01    ADDIA	0x1
  0246    00CC    LD	0x4C,A
  0247    0851    LD	A,0x51
  0248    024C    SUBA	0x4C
  0249    1D03    SNZB	0x3,2
  024A    2A4D    JP	0x24D
  024B    0850    LD	A,0x50
  024C    024B    SUBA	0x4B
  024D    1C03    SNZB	0x3,0
  024E    2A7B    JP	0x27B
  024F    1003    CLRB	0x3,0
  0250    0D55    RLCA	0x55
  0251    3EA6    ADDIA	0xA6
  0252    0084    LD	0x4,A
  0253    0800    LD	A,0x0
  0254    23A5    CALL	0x3A5
  0255    118A    CLRB	0xA,3
  0256    1C03    SNZB	0x3,0
  0257    2A61    JP	0x261
  0258    1003    CLRB	0x3,0
  0259    0D55    RLCA	0x55
  025A    3EAC    ADDIA	0xAC
  025B    0084    LD	0x4,A
  025C    0800    LD	A,0x0
  025D    23A5    CALL	0x3A5
  025E    118A    CLRB	0xA,3
  025F    1803    SZB	0x3,0
  0260    2A6D    JP	0x26D
  0261    0855    LD	A,0x55
  0262    3EBE    ADDIA	0xBE
  0263    0084    LD	0x4,A
  0264    3009    LDIA	0x9
  0265    0A80    INCR	0x0
  0266    0200    SUBA	0x0
  0267    1C03    SNZB	0x3,0
  0268    2A71    JP	0x271
  0269    0855    LD	A,0x55
  026A    2293    CALL	0x293
  026B    118A    CLRB	0xA,3
  026C    2A7B    JP	0x27B
  026D    0855    LD	A,0x55
  026E    3EBE    ADDIA	0xBE
  026F    0084    LD	0x4,A
  0270    0180    CLR	0x0
  0271    0821    LD	A,0x21
  0272    0420    ORA	0x20
  0273    1D03    SNZB	0x3,2
  0274    2A7B    JP	0x27B
  0275    084F    LD	A,0x4F
  0276    00F2    LD	0x72,A
  0277    01F3    CLR	0x73
  0278    0855    LD	A,0x55
  0279    22A8    CALL	0x2A8
  027A    118A    CLRB	0xA,3
  027B    3003    LDIA	0x3
  027C    1283    CLRB	0x3,5
  027D    1303    CLRB	0x3,6
  027E    0AD5    INCR	0x55
  027F    0255    SUBA	0x55
  0280    1803    SZB	0x3,0
  0281    0008    RET
  0282    29A3    JP	0x1A3
  0283    00F3    LD	0x73,A
  0284    3907    ANDIA	0x7
  0285    3E01    ADDIA	0x1
  0286    0084    LD	0x4,A
  0287    158A    SETB	0xA,3
  0288    2000    CALL	0x0
  0289    118A    CLRB	0xA,3
  028A    00F2    LD	0x72,A
  028B    1DF3    SNZB	0x73,3
  028C    2A8F    JP	0x28F
  028D    087A    LD	A,0x7A
  028E    2A90    JP	0x290
  028F    0879    LD	A,0x79
  0290    05F2    ANDR	0x72
  0291    0872    LD	A,0x72
  0292    0008    RET
  0293    00F2    LD	0x72,A
  0294    1003    CLRB	0x3,0
  0295    0D72    RLCA	0x72
  0296    3EB2    ADDIA	0xB2
  0297    0084    LD	0x4,A
  0298    1383    CLRB	0x3,7
  0299    23E3    CALL	0x3E3
  029A    118A    CLRB	0xA,3
  029B    3EAC    ADDIA	0xAC
  029C    0084    LD	0x4,A
  029D    23E3    CALL	0x3E3
  029E    118A    CLRB	0xA,3
  029F    3EA6    ADDIA	0xA6
  02A0    0084    LD	0x4,A
  02A1    23E3    CALL	0x3E3
  02A2    3EA0    ADDIA	0xA0
  02A3    0084    LD	0x4,A
  02A4    0180    CLR	0x0
  02A5    0A84    INCR	0x4
  02A6    0180    CLR	0x0
  02A7    0008    RET
  02A8    00F4    LD	0x74,A
  02A9    1283    CLRB	0x3,5
  02AA    1303    CLRB	0x3,6
  02AB    0AB2    INCR	0x32
  02AC    01A0    CLR	0x20
  02AD    01A1    CLR	0x21
  02AE    1DF4    SNZB	0x74,3
  02AF    2AB3    JP	0x2B3
  02B0    0872    LD	A,0x72
  02B1    00A1    LD	0x21,A
  02B2    0008    RET
  02B3    0872    LD	A,0x72
  02B4    00A0    LD	0x20,A
  02B5    0008    RET
  02B6    1283    CLRB	0x3,5
  02B7    3004    LDIA	0x4
  02B8    1303    CLRB	0x3,6
  02B9    01CD    CLR	0x4D
  02BA    0AB0    INCR	0x30
  02BB    0230    SUBA	0x30
  02BC    1C03    SNZB	0x3,0
  02BD    0008    RET
  02BE    01B0    CLR	0x30
  02BF    1003    CLRB	0x3,0
  02C0    0D4D    RLCA	0x4D
  02C1    3EB8    ADDIA	0xB8
  02C2    0084    LD	0x4,A
  02C3    1383    CLRB	0x3,7
  02C4    0800    LD	A,0x0
  02C5    00C9    LD	0x49,A
  02C6    0A84    INCR	0x4
  02C7    0800    LD	A,0x0
  02C8    00CA    LD	0x4A,A
  02C9    084D    LD	A,0x4D
  02CA    2283    CALL	0x283
  02CB    118A    CLRB	0xA,3
  02CC    3A00    XORIA	0x0
  02CD    1D03    SNZB	0x3,2
  02CE    2B05    JP	0x305
  02CF    1283    CLRB	0x3,5
  02D0    1303    CLRB	0x3,6
  02D1    1003    CLRB	0x3,0
  02D2    0D4D    RLCA	0x4D
  02D3    3EB2    ADDIA	0xB2
  02D4    0084    LD	0x4,A
  02D5    1383    CLRB	0x3,7
  02D6    2397    CALL	0x397
  02D7    118A    CLRB	0xA,3
  02D8    1903    SZB	0x3,2
  02D9    024B    SUBA	0x4B
  02DA    1C03    SNZB	0x3,0
  02DB    2AE2    JP	0x2E2
  02DC    0F4B    SZINCA	0x4B
  02DD    2B05    JP	0x305
  02DE    0A4C    INCA	0x4C
  02DF    1D03    SNZB	0x3,2
  02E0    2B05    JP	0x305
  02E1    1003    CLRB	0x3,0
  02E2    0D4D    RLCA	0x4D
  02E3    3EAC    ADDIA	0xAC
  02E4    0084    LD	0x4,A
  02E5    2397    CALL	0x397
  02E6    118A    CLRB	0xA,3
  02E7    1903    SZB	0x3,2
  02E8    024B    SUBA	0x4B
  02E9    1C03    SNZB	0x3,0
  02EA    2AF1    JP	0x2F1
  02EB    0F4B    SZINCA	0x4B
  02EC    2B05    JP	0x305
  02ED    0A4C    INCA	0x4C
  02EE    1D03    SNZB	0x3,2
  02EF    2B05    JP	0x305
  02F0    1003    CLRB	0x3,0
  02F1    0D4D    RLCA	0x4D
  02F2    3EA6    ADDIA	0xA6
  02F3    0084    LD	0x4,A
  02F4    2397    CALL	0x397
  02F5    118A    CLRB	0xA,3
  02F6    1903    SZB	0x3,2
  02F7    024B    SUBA	0x4B
  02F8    1C03    SNZB	0x3,0
  02F9    2B00    JP	0x300
  02FA    0F4B    SZINCA	0x4B
  02FB    2B05    JP	0x305
  02FC    0A4C    INCA	0x4C
  02FD    1D03    SNZB	0x3,2
  02FE    2B05    JP	0x305
  02FF    1003    CLRB	0x3,0
  0300    0D4D    RLCA	0x4D
  0301    3EA0    ADDIA	0xA0
  0302    0084    LD	0x4,A
  0303    23EF    CALL	0x3EF
  0304    118A    CLRB	0xA,3
  0305    1283    CLRB	0x3,5
  0306    1303    CLRB	0x3,6
  0307    1003    CLRB	0x3,0
  0308    0D4D    RLCA	0x4D
  0309    3EAC    ADDIA	0xAC
  030A    0084    LD	0x4,A
  030B    1383    CLRB	0x3,7
  030C    23DB    CALL	0x3DB
  030D    118A    CLRB	0xA,3
  030E    3EA6    ADDIA	0xA6
  030F    23C9    CALL	0x3C9
  0310    118A    CLRB	0xA,3
  0311    23DB    CALL	0x3DB
  0312    118A    CLRB	0xA,3
  0313    3EAC    ADDIA	0xAC
  0314    23C9    CALL	0x3C9
  0315    118A    CLRB	0xA,3
  0316    23EF    CALL	0x3EF
  0317    118A    CLRB	0xA,3
  0318    3003    LDIA	0x3
  0319    0ACD    INCR	0x4D
  031A    024D    SUBA	0x4D
  031B    1803    SZB	0x3,0
  031C    0008    RET
  031D    2ABF    JP	0x2BF
  031E    01F9    CLR	0x79
  031F    01FA    CLR	0x7A
  0320    01F3    CLR	0x73
  0321    1003    CLRB	0x3,0
  0322    0D73    RLCA	0x73
  0323    3EB8    ADDIA	0xB8
  0324    0084    LD	0x4,A
  0325    1383    CLRB	0x3,7
  0326    0180    CLR	0x0
  0327    0A84    INCR	0x4
  0328    0180    CLR	0x0
  0329    0873    LD	A,0x73
  032A    2293    CALL	0x293
  032B    118A    CLRB	0xA,3
  032C    3003    LDIA	0x3
  032D    0AF3    INCR	0x73
  032E    0273    SUBA	0x73
  032F    1803    SZB	0x3,0
  0330    0008    RET
  0331    2B21    JP	0x321
  0332    1283    CLRB	0x3,5
  0333    1303    CLRB	0x3,6
  0334    0821    LD	A,0x21
  0335    0420    ORA	0x20
  0336    1903    SZB	0x3,2
  0337    2B56    JP	0x356
  0338    01AE    CLR	0x2E
  0339    0820    LD	A,0x20
  033A    0622    XORA	0x22
  033B    1D03    SNZB	0x3,2
  033C    2B4F    JP	0x34F
  033D    0821    LD	A,0x21
  033E    0623    XORA	0x23
  033F    1D03    SNZB	0x3,2
  0340    2B4F    JP	0x34F
  0341    3002    LDIA	0x2
  0342    0AAF    INCR	0x2F
  0343    022F    SUBA	0x2F
  0344    1C03    SNZB	0x3,0
  0345    0008    RET
  0346    01AF    CLR	0x2F
  0347    0820    LD	A,0x20
  0348    00F9    LD	0x79,A
  0349    0821    LD	A,0x21
  034A    00FA    LD	0x7A,A
  034B    1978    SZB	0x78,2
  034C    0008    RET
  034D    1578    SETB	0x78,2
  034E    2B79    JP	0x379
  034F    1178    CLRB	0x78,2
  0350    0820    LD	A,0x20
  0351    00A2    LD	0x22,A
  0352    0821    LD	A,0x21
  0353    00A3    LD	0x23,A
  0354    01AF    CLR	0x2F
  0355    0008    RET
  0356    01AF    CLR	0x2F
  0357    01A2    CLR	0x22
  0358    01A3    CLR	0x23
  0359    3002    LDIA	0x2
  035A    0AAE    INCR	0x2E
  035B    022E    SUBA	0x2E
  035C    1C03    SNZB	0x3,0
  035D    0008    RET
  035E    01AE    CLR	0x2E
  035F    01F9    CLR	0x79
  0360    01FA    CLR	0x7A
  0361    1178    CLRB	0x78,2
  0362    0008    RET
  0363    087A    LD	A,0x7A
  0364    0479    ORA	0x79
  0365    1903    SZB	0x3,2
  0366    2B74    JP	0x374
  0367    1683    SETB	0x3,5
  0368    1303    CLRB	0x3,6
  0369    0AC1    INCR	0x41
  036A    1903    SZB	0x3,2
  036B    0AC2    INCR	0x42
  036C    303A    LDIA	0x3A
  036D    0242    SUBA	0x42
  036E    3098    LDIA	0x98
  036F    1903    SZB	0x3,2
  0370    0241    SUBA	0x41
  0371    1C03    SNZB	0x3,0
  0372    0008    RET
  0373    14F8    SETB	0x78,1
  0374    1683    SETB	0x3,5
  0375    1303    CLRB	0x3,6
  0376    01C1    CLR	0x41
  0377    01C2    CLR	0x42
  0378    0008    RET
  0379    01F4    CLR	0x74
  037A    0874    LD	A,0x74
  037B    2283    CALL	0x283
  037C    118A    CLRB	0xA,3
  037D    3A00    XORIA	0x0
  037E    1D03    SNZB	0x3,2
  037F    2B83    JP	0x383
  0380    0874    LD	A,0x74
  0381    2293    CALL	0x293
  0382    118A    CLRB	0xA,3
  0383    3003    LDIA	0x3
  0384    0AF4    INCR	0x74
  0385    0274    SUBA	0x74
  0386    1803    SZB	0x3,0
  0387    0008    RET
  0388    2B7A    JP	0x37A
---- stringtab ------------------------------------------------------------------
  0800    3008    LDIA	0x8
  0801    008A    LD	0xA,A
  0802    0804    LD	A,0x4
  0803    0A84    INCR	0x4
  0804    0782    ADDR	0x2
  0805    3400    RET	0x0
---- reset_enter ------------------------------------------------------------------
  0000    118A    CLRB	0xA,3
  0001    280B    JP	0xB
  000B    118A    CLRB	0xA,3
  000C    280D    JP	0xD
---- start_initialization ------------------------------------------------------------------
  000D    3002    LDIA	0x2
  000E    01EB    CLR	0x6B
  000F    00EC    LD	0x6C,A
  0010    3001    LDIA	0x1
  0011    00ED    LD	0x6D,A
  0012    30A0    LDIA	0xA0
  0013    1383    CLRB	0x3,7
  0014    0084    LD	0x4,A
  0015    30CB    LDIA	0xCB
  0016    118A    CLRB	0xA,3
  0017    27F5    CALL	0x7F5
  0018    118A    CLRB	0xA,3
  0019    3020    LDIA	0x20
  001A    0084    LD	0x4,A
  001B    3049    LDIA	0x49
  001C    118A    CLRB	0xA,3
  001D    27F5    CALL	0x7F5
  001E    01F9    CLR	0x79
  001F    01FA    CLR	0x7A
  0020    01FB    CLR	0x7B
  0021    01F8    CLR	0x78
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F0    LD	0x70,A
  0007    080A    LD	A,0xA
  0008    00F1    LD	0x71,A
  0009    158A    SETB	0xA,3
  000A    2E07    JP	0x607
---- common_function ------------------------------------------------------------------
  0022    0183    CLR	0x3
  0023    158A    SETB	0xA,3
  0024    2E5F    JP	0x65F
  0397    0800    LD	A,0x0
  0398    00CB    LD	0x4B,A
  0399    0A84    INCR	0x4
  039A    0800    LD	A,0x0
  039B    00CC    LD	0x4C,A
  039C    0849    LD	A,0x49
  039D    02CB    SUBR	0x4B
  039E    084A    LD	A,0x4A
  039F    1C03    SNZB	0x3,0
  03A0    03CC    DECR	0x4C
  03A1    02CC    SUBR	0x4C
  03A2    3000    LDIA	0x0
  03A3    024C    SUBA	0x4C
  03A4    3402    RET	0x2
  03A5    00C9    LD	0x49,A
  03A6    0A84    INCR	0x4
  03A7    0800    LD	A,0x0
  03A8    00CA    LD	0x4A,A
  03A9    0852    LD	A,0x52
  03AA    0749    ADDA	0x49
  03AB    00CB    LD	0x4B,A
  03AC    084A    LD	A,0x4A
  03AD    1803    SZB	0x3,0
  03AE    0A4A    INCA	0x4A
  03AF    00CC    LD	0x4C,A
  03B0    0854    LD	A,0x54
  03B1    024C    SUBA	0x4C
  03B2    1D03    SNZB	0x3,2
  03B3    0008    RET
  03B4    0853    LD	A,0x53
  03B5    024B    SUBA	0x4B
  03B6    0008    RET
  03B7    0084    LD	0x4,A
  03B8    0800    LD	A,0x0
  03B9    00C9    LD	0x49,A
  03BA    0A84    INCR	0x4
  03BB    0800    LD	A,0x0
  03BC    00CA    LD	0x4A,A
  03BD    0008    RET
  03BE    0084    LD	0x4,A
  03BF    0849    LD	A,0x49
  03C0    0080    LD	0x0,A
  03C1    0A84    INCR	0x4
  03C2    084A    LD	A,0x4A
  03C3    0080    LD	0x0,A
  03C4    1003    CLRB	0x3,0
  03C5    0D51    RLCA	0x51
  03C6    3EB2    ADDIA	0xB2
  03C7    0084    LD	0x4,A
  03C8    0008    RET
  03C9    0084    LD	0x4,A
  03CA    0874    LD	A,0x74
  03CB    0080    LD	0x0,A
  03CC    0A84    INCR	0x4
  03CD    0875    LD	A,0x75
  03CE    0080    LD	0x0,A
  03CF    1003    CLRB	0x3,0
  03D0    0D4D    RLCA	0x4D
  03D1    3EB2    ADDIA	0xB2
  03D2    0084    LD	0x4,A
  03D3    0008    RET
  03D4    0084    LD	0x4,A
  03D5    0800    LD	A,0x0
  03D6    00C9    LD	0x49,A
  03D7    0A84    INCR	0x4
  03D8    0800    LD	A,0x0
  03D9    00CA    LD	0x4A,A
  03DA    0008    RET
  03DB    0800    LD	A,0x0
  03DC    00F4    LD	0x74,A
  03DD    0A84    INCR	0x4
  03DE    0800    LD	A,0x0
  03DF    00F5    LD	0x75,A
  03E0    1003    CLRB	0x3,0
  03E1    0D4D    RLCA	0x4D
  03E2    0008    RET
  03E3    0180    CLR	0x0
  03E4    0A84    INCR	0x4
  03E5    0180    CLR	0x0
  03E6    1003    CLRB	0x3,0
  03E7    0D72    RLCA	0x72
  03E8    0008    RET
  03E9    3041    LDIA	0x41
  03EA    1683    SETB	0x3,5
  03EB    0095    LD	0x15,A
  03EC    1415    SETB	0x15,0
  03ED    0196    CLR	0x16
  03EE    0008    RET
  03EF    0849    LD	A,0x49
  03F0    0080    LD	0x0,A
  03F1    0A84    INCR	0x4
  03F2    084A    LD	A,0x4A
  03F3    0080    LD	0x0,A
  03F4    0008    RET
  03F5    01D1    CLR	0x51
  03F6    01CF    CLR	0x4F
  03F7    0ACF    INCR	0x4F
  03F8    01D0    CLR	0x50
  03F9    0008    RET
  03FA    0DCF    RLCR	0x4F
  03FB    0DD0    RLCR	0x50
  03FC    0AD1    INCR	0x51
  03FD    0251    SUBA	0x51
  03FE    0008    RET
  07AA    00F4    LD	0x74,A
  07AB    01F5    CLR	0x75
  07AC    01F6    CLR	0x76
  07AD    0873    LD	A,0x73
  07AE    02CC    SUBR	0x4C
  07AF    0874    LD	A,0x74
  07B0    1C03    SNZB	0x3,0
  07B1    0F74    SZINCA	0x74
  07B2    02CD    SUBR	0x4D
  07B3    0875    LD	A,0x75
  07B4    1C03    SNZB	0x3,0
  07B5    0F75    SZINCA	0x75
  07B6    02CE    SUBR	0x4E
  07B7    0876    LD	A,0x76
  07B8    0008    RET
  07B9    01CC    CLR	0x4C
  07BA    01CD    CLR	0x4D
  07BB    01CE    CLR	0x4E
  07BC    01CF    CLR	0x4F
  07BD    01D0    CLR	0x50
  07BE    01D1    CLR	0x51
  07BF    01D2    CLR	0x52
  07C0    01D3    CLR	0x53
  07C1    0008    RET
  07C2    085E    LD	A,0x5E
  07C3    00E2    LD	0x62,A
  07C4    085F    LD	A,0x5F
  07C5    00E3    LD	0x63,A
  07C6    0860    LD	A,0x60
  07C7    00E4    LD	0x64,A
  07C8    0008    RET
  07C9    1003    CLRB	0x3,0
  07CA    0CF4    RRCR	0x74
  07CB    0CF3    RRCR	0x73
  07CC    0CF2    RRCR	0x72
  07CD    0008    RET
  07CE    0855    LD	A,0x55
  07CF    00D3    LD	0x53,A
  07D0    0854    LD	A,0x54
  07D1    00D2    LD	0x52,A
  07D2    0008    RET
  07D3    01CF    CLR	0x4F
  07D4    01D0    CLR	0x50
  07D5    01D1    CLR	0x51
  07D6    0008    RET
  07F5    0064    CLRWDT
  07F6    0180    CLR	0x0
  07F7    0A84    INCR	0x4
  07F8    0604    XORA	0x4
  07F9    1903    SZB	0x3,2
  07FA    3400    RET	0x0
  07FB    0604    XORA	0x4
  07FC    2FF6    JP	0x7F6
  0806    3401    RET	0x1
  0807    3402    RET	0x2
  0808    3404    RET	0x4
  0809    3408    RET	0x8
  080A    3410    RET	0x10
  080B    3420    RET	0x20
  080C    3440    RET	0x40
  080D    3480    RET	0x80
  080E    340A    RET	0xA
  080F    340A    RET	0xA
  0810    340A    RET	0xA
  0811    3402    RET	0x2
  0812    3402    RET	0x2
  0813    3402    RET	0x2
  0814    3444    RET	0x44
  0815    3443    RET	0x43
  0816    3442    RET	0x42
  0817    158A    SETB	0xA,3
  0818    2FAC    JP	0x7AC
  0819    158A    SETB	0xA,3
  081A    2FB3    JP	0x7B3
  081B    158A    SETB	0xA,3
  081C    2FB6    JP	0x7B6
  081D    158A    SETB	0xA,3
  081E    2FB9    JP	0x7B9
  081F    158A    SETB	0xA,3
  0820    2FC0    JP	0x7C0
  0821    158A    SETB	0xA,3
  0822    2FC3    JP	0x7C3
  0823    158A    SETB	0xA,3
  0824    2FC6    JP	0x7C6
  0825    158A    SETB	0xA,3
  0826    2FC9    JP	0x7C9
  0827    158A    SETB	0xA,3
  0828    2FC9    JP	0x7C9
  0829    158A    SETB	0xA,3
  082A    2FC6    JP	0x7C6
  082B    158A    SETB	0xA,3
  082C    2FC3    JP	0x7C3
  082D    158A    SETB	0xA,3
  082E    2FC0    JP	0x7C0
  082F    158A    SETB	0xA,3
  0830    2FB9    JP	0x7B9
  0831    158A    SETB	0xA,3
  0832    2FB6    JP	0x7B6
  0833    158A    SETB	0xA,3
  0834    2FB3    JP	0x7B3
  0835    158A    SETB	0xA,3
  0836    2FAC    JP	0x7AC
  0F39    30C2    LDIA	0xC2
  0F3A    00AC    LD	0x2C,A
  0F3B    3001    LDIA	0x1
  0F3C    00AD    LD	0x2D,A
  0F3D    0008    RET
  0FEA    086C    LD	A,0x6C
  0FEB    00F3    LD	0x73,A
  0FEC    086B    LD	A,0x6B
  0FED    00F2    LD	0x72,A
  0FEE    1003    CLRB	0x3,0
  0FEF    0008    RET
  0FF0    1306    CLRB	0x6,6
  0FF1    1386    CLRB	0x6,7
  0FF2    1283    CLRB	0x3,5
  0FF3    1786    SETB	0x6,7
  0FF4    0008    RET
  0FF5    1706    SETB	0x6,6
  0FF6    1386    CLRB	0x6,7
  0FF7    1283    CLRB	0x3,5
  0FF8    1386    CLRB	0x6,7
  0FF9    0008    RET
  0FFA    1683    SETB	0x3,5
  0FFB    1286    CLRB	0x6,5
  0FFC    1306    CLRB	0x6,6
  0FFD    1786    SETB	0x6,7
  0FFE    1283    CLRB	0x3,5
