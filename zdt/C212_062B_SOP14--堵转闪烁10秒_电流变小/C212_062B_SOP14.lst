---- C:\mcuproject\scm\zdt\C212_062B_SOP14--堵转闪烁10秒_电流变小\main.c ----------------------------------------------------------------------
1:                /**********************************************************
2:                AD检测范例程序
3:                **********************************************************/
4:                #pragma warning disable 752
5:                #pragma warning disable 373			//屏蔽掉编译的1个警告
6:                #include <sc.h>
7:                
8:                #ifndef _XTAL_FREQ
9:                #define _XTAL_FREQ 16000000			//16MHz,使用内置延时函数必须定义主频，
10:               									//如用FCPU_DIV选择2T，则定时赋值减半
11:               #endif
12:               #define		u8t		unsigned char
13:               #define		u16t	unsigned int
14:               #define     POWER_RATIO  	(4096UL*1.2*1000)
15:               
16:               volatile unsigned int adresult;
17:               volatile unsigned int result;
18:               volatile unsigned char test_adc;
19:               volatile unsigned int power_ad;
20:               u8t	intCount;
21:               u8t	count1s;
22:               u8t	IntFlag;
23:               u8t	chrgFlag;
24:               u8t	chrgFullFlag;
25:               u8t	intCount10;
26:               u16t	outADValue;
27:               u16t	batADValue;
28:               u8t		countHalfFull;
29:               u8t		protectFlag;
30:               u8t		workOverOutTime;
31:               u8t		workStep = 0;
32:               u8t		ledCnt;
33:               u8t		ledStep;
34:               u8t		keyCount;
35:               u8t		longPressFlag;
36:               u8t		maxDuty;
37:               u8t		overCount;
38:               u8t		addPowerCount;
39:               u8t		tempDuty;
40:               u8t		startTime;
41:               u8t		firstTime;
42:               u8t		overChrgTime;
43:               u8t		pwStep;
44:               u8t		prePwStep;
45:               u16t	count50s;
46:               u8t		reChrgCount;
47:               u8t		lockLedStep;
48:               u8t		showBatTime;
49:               u8t		chrgMode = 0;
50:               u8t		chrgMaxAD = 0;
51:               u8t		lockCount = 0;
52:               u16t	fullCount = 0;
53:               u8t addTime;
54:               u8t subTime;
55:               u8t chrgWaitTime;
56:               u8t	chrgMaxDuty = 0;
57:               u8t	ledCntTime;
58:               u16t	count5s = 0;
59:               u16t		overWorkTime;
60:               u8t		preLedStep;
61:               u16t	count8s;
62:               u16t	count900s;
63:               u8t		lowBatFlag = 0;
64:               u8t		sleepTime;
65:               u8t		startChrgTime = 0;
66:               
67:               
68:               unsigned char ADC_Sample(unsigned char adch, unsigned char adldo);
69:               void DelayXms(unsigned char x);
70:               unsigned char ADC_Result(unsigned char adch);
71:               void Init_System();
72:               void AD_Init();
73:               void Sleep_Mode();
74:               void pwmInit();
75:               void pwmStop();
76:               void chrgPwmInit();
77:               void chrgPwmStop();
78:               void chrgCtr();
79:               void checkOutA();
80:               void checkBatAD();
81:               void ledShow();
82:               void keyCtr();
83:               void workCtr();
84:               void ledCtr();
85:               char keyRead(char keyStatus);
86:               
87:               
88:               //#define _DEBUG			//调试程序用
89:               
90:               
91:               /***********************************************************
92:               中断服务函数
93:               函数名称：Isr_Timer()
94:               函数功能：中断处理函数
95:               入口参数：
96:               出口参数：
97:               备    注：125US定时2中断
98:               			所有中断都是在这个函数里面处理
99:               ***********************************************************/
100:              void interrupt Isr_Timer() 
101:              {
102:              	if(TMR2IF) 
  0555    1283    CLRB	0x3,5
  0556    1C8D    SNZB	0xD,1
  0557    2D69    JP	0x569
103:              	{			//若只使能了一个中断源,可以略去判断
104:              		TMR2IF = 0;
  0558    108D    CLRB	0xD,1
105:              		if(++intCount >= 160)
  0559    30A0    LDIA	0xA0
  055A    0AD5    INCR	0x55
  055B    0255    SUBA	0x55
  055C    1C03    SNZB	0x3,0
  055D    2D66    JP	0x566
  055E    3064    LDIA	0x64
106:              		{
107:              			intCount = 0;
  055F    01D5    CLR	0x55
108:              			IntFlag = 1;
  0560    01D3    CLR	0x53
  0561    0AD3    INCR	0x53
109:              			if(++count1s >= 100)
  0562    0AD4    INCR	0x54
  0563    0254    SUBA	0x54
  0564    1803    SZB	0x3,0
110:              			{
111:              				count1s = 0;
  0565    01D4    CLR	0x54
112:              			}
113:              		}
114:              		ledShow();
  0566    23B9    CALL	0x3B9
115:              		intCount10++;
  0567    1283    CLRB	0x3,5
  0568    0AD1    INCR	0x51
  0569    0872    LD	A,0x72
  056A    008A    LD	0xA,A
  056B    0871    LD	A,0x71
  056C    0084    LD	0x4,A
  056D    0E70    SWAPA	0x70
  056E    0083    LD	0x3,A
  056F    0EFE    SWAPR	0x7E
  0570    0E7E    SWAPA	0x7E
  0571    0009    RETI
116:              	}
117:              
118:              }
119:              
120:              
121:              /***********************************************************
122:              main主函数
123:              ***********************************************************/
124:              void main() 
125:              {
126:              	Init_System();
  044B    2515    CALL	0x515
127:              	AD_Init();
  044C    25C6    CALL	0x5C6
128:              	firstTime = 100;
  044D    3064    LDIA	0x64
  044E    1283    CLRB	0x3,5
  044F    00EA    LD	0x6A,A
129:              	while (1) 
  0450    0064    CLRWDT
130:              	{
131:              		asm("clrwdt");
132:              		if(intCount10 > 10)
  0451    300B    LDIA	0xB
  0452    1283    CLRB	0x3,5
  0453    0251    SUBA	0x51
  0454    1C03    SNZB	0x3,0
  0455    2C58    JP	0x458
133:              		{
134:              			intCount10 = 0;
  0456    01D1    CLR	0x51
135:              			checkOutA();
  0457    2201    CALL	0x201
136:              		}
137:              		if(!IntFlag)
  0458    1283    CLRB	0x3,5
  0459    0853    LD	A,0x53
  045A    1903    SZB	0x3,2
  045B    2C50    JP	0x450
138:                  		continue;			//10ms执行一次
139:                  	IntFlag = 0;
  045C    01D3    CLR	0x53
140:              		chrgCtr();
  045D    2018    CALL	0x18
141:              		checkBatAD();
  045E    22B1    CALL	0x2B1
142:              		if(chrgFlag == 0 && lowBatFlag == 0)
  045F    087A    LD	A,0x7A
  0460    1D03    SNZB	0x3,2
  0461    2C67    JP	0x467
  0462    1283    CLRB	0x3,5
  0463    0837    LD	A,0x37
  0464    1D03    SNZB	0x3,2
  0465    2C67    JP	0x467
143:              		{
144:              			keyCtr();
  0466    24C0    CALL	0x4C0
145:              		}
146:              		workCtr();
  0467    2486    CALL	0x486
147:              		ledCtr();
  0468    235C    CALL	0x35C
148:              		if(chrgFlag == 0 && workStep == 0 && keyCount == 0 && firstTime == 0 && showBatTime == 0 && overWorkTime == 0)
  0469    087A    LD	A,0x7A
  046A    1D03    SNZB	0x3,2
  046B    2C84    JP	0x484
  046C    0879    LD	A,0x79
  046D    1D03    SNZB	0x3,2
  046E    2C84    JP	0x484
  046F    084C    LD	A,0x4C
  0470    1D03    SNZB	0x3,2
  0471    2C84    JP	0x484
  0472    086A    LD	A,0x6A
  0473    1D03    SNZB	0x3,2
  0474    2C84    JP	0x484
  0475    0841    LD	A,0x41
  0476    1D03    SNZB	0x3,2
  0477    2C84    JP	0x484
  0478    0824    LD	A,0x24
  0479    0425    ORA	0x25
  047A    1D03    SNZB	0x3,2
  047B    2C84    JP	0x484
149:              		{
150:              			if(++sleepTime >= 200)
  047C    30C8    LDIA	0xC8
  047D    0AB6    INCR	0x36
  047E    0236    SUBA	0x36
  047F    1C03    SNZB	0x3,0
  0480    2C50    JP	0x450
151:              			{
152:              				sleepTime = 0;
  0481    01B6    CLR	0x36
153:              				Sleep_Mode();
  0482    240D    CALL	0x40D
  0483    2C50    JP	0x450
154:              			}
155:              		}
156:              		else
157:              		{
158:              			sleepTime = 0;
  0484    01B6    CLR	0x36
  0485    2C50    JP	0x450
159:              		}
160:              	}
161:              }
162:              
163:              void ledShow()
164:              {
165:              	if(++ledCntTime > 30)
  03B9    301F    LDIA	0x1F
  03BA    0AB9    INCR	0x39
  03BB    0239    SUBA	0x39
  03BC    1C03    SNZB	0x3,0
  03BD    0008    RET
  03BE    3006    LDIA	0x6
166:              	{
167:              		ledCntTime = 0;
  03BF    01B9    CLR	0x39
168:              		if(++ledCnt > 5)
  03C0    0ACD    INCR	0x4D
  03C1    024D    SUBA	0x4D
  03C2    1803    SZB	0x3,0
169:              		{
170:              			ledCnt = 0;
  03C3    01CD    CLR	0x4D
171:              		}
172:              		PORTA &= 0xDF;
  03C4    1683    SETB	0x3,5
  03C5    1286    CLRB	0x6,5
173:              		PORTB &= 0xC7;
  03C6    30C7    LDIA	0xC7
  03C7    1283    CLRB	0x3,5
  03C8    0586    ANDR	0x6
174:              		TRISA |= 0x20;
  03C9    1683    SETB	0x3,5
  03CA    1685    SETB	0x5,5
175:              		TRISB |= 0x38;
  03CB    3038    LDIA	0x38
  03CC    1283    CLRB	0x3,5
  03CD    0485    ORR	0x5
176:              		switch(ledCnt)
  03CE    2C01    JP	0x401
177:              		{
178:              			case 1:
179:              			if(ledStep > 0)
  03CF    0878    LD	A,0x78
  03D0    1903    SZB	0x3,2
  03D1    0008    RET
180:              			{
181:              				TRISB &= 0xE7;
  03D2    30E7    LDIA	0xE7
  03D3    0585    ANDR	0x5
182:              				PORTB |= 0x10;
  03D4    1606    SETB	0x6,4
  03D5    0008    RET
183:              			}
184:              			break;
185:              			case 2:
186:              			if(ledStep > 1)
  03D6    3002    LDIA	0x2
  03D7    0278    SUBA	0x78
  03D8    1C03    SNZB	0x3,0
  03D9    0008    RET
187:              			{
188:              				TRISB &= 0xCF;
  03DA    30CF    LDIA	0xCF
  03DB    0585    ANDR	0x5
189:              				PORTB |= 0x20;
  03DC    1686    SETB	0x6,5
  03DD    0008    RET
190:              			}
191:              			break;
192:              			case 3:
193:              			if(ledStep > 2)
  03DE    3003    LDIA	0x3
  03DF    0278    SUBA	0x78
  03E0    1C03    SNZB	0x3,0
  03E1    0008    RET
194:              			{
195:              				TRISB &= 0xE7;
  03E2    30E7    LDIA	0xE7
  03E3    0585    ANDR	0x5
196:              				PORTB |= 0x08;
  03E4    1586    SETB	0x6,3
  03E5    0008    RET
197:              			}
198:              			break;
199:              			case 4:
200:              			if(ledStep > 3)
  03E6    3004    LDIA	0x4
  03E7    0278    SUBA	0x78
  03E8    1C03    SNZB	0x3,0
  03E9    0008    RET
201:              			{
202:              				TRISB &= 0xCF;
  03EA    30CF    LDIA	0xCF
  03EB    2BD3    JP	0x3D3
203:              				PORTB |= 0x10;
204:              			}
205:              			break;
206:              			case 5:
207:              			if(ledStep > 4)
  03EC    3005    LDIA	0x5
  03ED    0278    SUBA	0x78
  03EE    1C03    SNZB	0x3,0
  03EF    0008    RET
208:              			{
209:              				TRISA &= 0xDF;
  03F0    1683    SETB	0x3,5
  03F1    1285    CLRB	0x5,5
210:              				TRISB &= 0xDF;
  03F2    1283    CLRB	0x3,5
  03F3    1285    CLRB	0x5,5
211:              				PORTB |= 0x20;
  03F4    1686    SETB	0x6,5
  03F5    0008    RET
212:              			}
213:              			break;
214:              			case 0:
215:              			if(ledStep > 5)
  03F6    3006    LDIA	0x6
  03F7    0278    SUBA	0x78
  03F8    1C03    SNZB	0x3,0
  03F9    0008    RET
216:              			{
217:              				TRISA &= 0xDF;
  03FA    1683    SETB	0x3,5
  03FB    1285    CLRB	0x5,5
218:              				TRISB &= 0xDF;
  03FC    1283    CLRB	0x3,5
  03FD    1285    CLRB	0x5,5
219:              				PORTA |= 0x20;
  03FE    1683    SETB	0x3,5
  03FF    1686    SETB	0x6,5
  0400    0008    RET
  0401    084D    LD	A,0x4D
  0402    0084    LD	0x4,A
  0403    3006    LDIA	0x6
  0404    0204    SUBA	0x4
  0405    1803    SZB	0x3,0
  0406    0008    RET
  0407    3005    LDIA	0x5
  0408    008A    LD	0xA,A
  0409    30CD    LDIA	0xCD
  040A    0704    ADDA	0x4
  040B    0082    LD	0x2,A
  040C    0008    RET
220:              			}
221:              			break;
222:              			default:
223:              			break;
224:              		}
225:              	}
226:              
227:              	
228:              }
229:              
230:              
231:              void ledCtr()
232:              {
233:              	if(firstTime > 0)
  035C    086A    LD	A,0x6A
  035D    1903    SZB	0x3,2
  035E    2B69    JP	0x369
  035F    3006    LDIA	0x6
234:              	{
235:              		firstTime--;
  0360    03EA    DECR	0x6A
236:              		ledStep = 6;
  0361    00F8    LD	0x78,A
237:              		if(prePwStep < pwStep)
  0362    0844    LD	A,0x44
  0363    0277    SUBA	0x77
  0364    1803    SZB	0x3,0
  0365    0008    RET
238:              		{
239:              			prePwStep = pwStep;
  0366    0844    LD	A,0x44
  0367    00F7    LD	0x77,A
  0368    0008    RET
240:              		}
241:              	}
242:              	else if(overWorkTime > 0)
  0369    0824    LD	A,0x24
  036A    0425    ORA	0x25
  036B    1903    SZB	0x3,2
  036C    2B87    JP	0x387
243:              	{
244:              		overWorkTime--;
  036D    3001    LDIA	0x1
  036E    02A4    SUBR	0x24
  036F    3000    LDIA	0x0
  0370    1C03    SNZB	0x3,0
  0371    03A5    DECR	0x25
  0372    02A5    SUBR	0x25
245:              		if(overWorkTime % 40 < 20)
  0373    3028    LDIA	0x28
  0374    00F3    LD	0x73,A
  0375    01F4    CLR	0x74
  0376    0825    LD	A,0x25
  0377    00F6    LD	0x76,A
  0378    0824    LD	A,0x24
  0379    00F5    LD	0x75,A
  037A    24F1    CALL	0x4F1
  037B    3000    LDIA	0x0
  037C    0274    SUBA	0x74
  037D    3014    LDIA	0x14
  037E    1903    SZB	0x3,2
  037F    0273    SUBA	0x73
  0380    1803    SZB	0x3,0
  0381    2B85    JP	0x385
246:              		{
247:              			ledStep = preLedStep;
  0382    0838    LD	A,0x38
  0383    00F8    LD	0x78,A
248:              		}
  0384    0008    RET
249:              		else
250:              		{
251:              			ledStep = 0;
  0385    01F8    CLR	0x78
  0386    0008    RET
252:              		}
253:              	}
254:              	else if(showBatTime > 0)
  0387    0841    LD	A,0x41
  0388    1903    SZB	0x3,2
  0389    2BA1    JP	0x3A1
  038A    300E    LDIA	0xE
255:              	{
256:              		showBatTime--;
  038B    03C1    DECR	0x41
257:              		if(prePwStep >= 14)
  038C    0277    SUBA	0x77
  038D    1C03    SNZB	0x3,0
  038E    2B95    JP	0x395
258:              		{
259:              			ledStep = prePwStep/14;
  038F    300E    LDIA	0xE
  0390    00F3    LD	0x73,A
  0391    0877    LD	A,0x77
  0392    258E    CALL	0x58E
  0393    00F8    LD	0x78,A
260:              		}
  0394    0008    RET
261:              		else if(prePwStep > 5)
  0395    3006    LDIA	0x6
  0396    0277    SUBA	0x77
  0397    1C03    SNZB	0x3,0
  0398    2B9C    JP	0x39C
262:              		{
263:              			ledStep = 1;
  0399    01F8    CLR	0x78
  039A    0AF8    INCR	0x78
264:              		}
  039B    0008    RET
265:              		else
266:              		{
267:              			if(count1s < 50)
  039C    3032    LDIA	0x32
  039D    0254    SUBA	0x54
  039E    1C03    SNZB	0x3,0
  039F    2B99    JP	0x399
  03A0    2B85    JP	0x385
268:              			{
269:              				ledStep = 1;
270:              			}
271:              			else
272:              			{
273:              				ledStep = 0;
274:              			}
275:              		}
276:              	}
277:              	else if(workStep > 0)
  03A1    0879    LD	A,0x79
  03A2    1903    SZB	0x3,2
  03A3    2BA7    JP	0x3A7
278:              	{
279:              		ledStep = workStep;
  03A4    0879    LD	A,0x79
  03A5    00F8    LD	0x78,A
280:              	}
  03A6    0008    RET
281:              	else if(chrgFlag)
  03A7    087A    LD	A,0x7A
  03A8    1903    SZB	0x3,2
  03A9    2B85    JP	0x385
282:              	{
283:              		if(count1s % 50 == 0)
  03AA    3032    LDIA	0x32
  03AB    00F3    LD	0x73,A
  03AC    0854    LD	A,0x54
  03AD    2572    CALL	0x572
  03AE    3A00    XORIA	0x0
  03AF    1D03    SNZB	0x3,2
  03B0    0008    RET
284:              		{
285:              			if(++ledStep > 6)
  03B1    3007    LDIA	0x7
  03B2    0AF8    INCR	0x78
  03B3    0278    SUBA	0x78
  03B4    1C03    SNZB	0x3,0
  03B5    0008    RET
286:              			{
287:              				ledStep = lockLedStep;
  03B6    0842    LD	A,0x42
  03B7    00F8    LD	0x78,A
  03B8    0008    RET
288:              			}
289:              		}
290:              	}
291:              	else
292:              	{
293:              		ledStep = 0;
294:              	}
295:              }
296:              
297:              
298:              
299:              void chrgCtr()
300:              {
301:              	if(PORTA & 0x02)
  0018    1683    SETB	0x3,5
  0019    1C86    SNZB	0x6,1
  001A    28F3    JP	0xF3
302:              	{
303:              		if(chrgFlag == 0)
  001B    087A    LD	A,0x7A
  001C    1D03    SNZB	0x3,2
  001D    2824    JP	0x24
304:              		{
305:              			chrgFlag = 1;
  001E    01FA    CLR	0x7A
  001F    0AFA    INCR	0x7A
306:              			ledStep = 0;
  0020    01F8    CLR	0x78
307:              			chrgMaxDuty = 0;
  0021    1283    CLRB	0x3,5
  0022    01BA    CLR	0x3A
308:              			chrgPwmStop();
  0023    25D6    CALL	0x5D6
309:              		}
310:              		workStep = 0;
  0024    01F9    CLR	0x79
311:              		lowBatFlag = 0;
  0025    1283    CLRB	0x3,5
  0026    01B7    CLR	0x37
312:              		if(prePwStep < pwStep)
  0027    0844    LD	A,0x44
  0028    0277    SUBA	0x77
  0029    1803    SZB	0x3,0
  002A    2834    JP	0x34
313:              		{
314:              			if(++count50s > 2000)
  002B    2112    CALL	0x112
  002C    1903    SZB	0x3,2
  002D    022A    SUBA	0x2A
  002E    1C03    SNZB	0x3,0
  002F    2836    JP	0x36
315:              			{
316:              				count50s = 0;
  0030    01AA    CLR	0x2A
  0031    01AB    CLR	0x2B
317:              				prePwStep++;
  0032    0AF7    INCR	0x77
  0033    2836    JP	0x36
318:              			}
319:              		}
320:              		else
321:              		{
322:              			count50s = 0;
  0034    01AA    CLR	0x2A
  0035    01AB    CLR	0x2B
323:              		}
324:              		if(protectFlag)
  0036    084F    LD	A,0x4F
  0037    1903    SZB	0x3,2
  0038    2859    JP	0x59
325:              		{
326:              			chrgPwmStop();
  0039    25D6    CALL	0x5D6
327:              			ledStep = 6;
  003A    3006    LDIA	0x6
  003B    00F8    LD	0x78,A
328:              			if(prePwStep < 99 && protectFlag == 1)
  003C    3063    LDIA	0x63
  003D    0277    SUBA	0x77
  003E    1803    SZB	0x3,0
  003F    2857    JP	0x57
  0040    0B4F    SZDECA	0x4F
  0041    2857    JP	0x57
329:              			{
330:              				if(++reChrgCount > 250)
  0042    30FB    LDIA	0xFB
  0043    0AC3    INCR	0x43
  0044    0243    SUBA	0x43
  0045    1C03    SNZB	0x3,0
  0046    0008    RET
  0047    300F    LDIA	0xF
331:              				{
332:              					reChrgCount = 0;
  0048    01C3    CLR	0x43
333:              					chrgFullFlag = 0;
  0049    01D2    CLR	0x52
334:              					protectFlag = 0;
  004A    01CF    CLR	0x4F
335:              					if(prePwStep > 14)
  004B    0277    SUBA	0x77
  004C    1C03    SNZB	0x3,0
  004D    2855    JP	0x55
336:              					{
337:              						lockLedStep = (prePwStep/14) - 1;
  004E    300E    LDIA	0xE
  004F    00F3    LD	0x73,A
  0050    0877    LD	A,0x77
  0051    258E    CALL	0x58E
  0052    3EFF    ADDIA	0xFF
  0053    00C2    LD	0x42,A
338:              					}
  0054    0008    RET
339:              					else
340:              					{
341:              						lockLedStep = 0;
  0055    01C2    CLR	0x42
  0056    0008    RET
342:              					}
343:              				}
344:              			}
345:              			else
346:              			{
347:              				reChrgCount = 0;
  0057    01C3    CLR	0x43
  0058    0008    RET
348:              			}
349:              			return;
350:              		}
351:              		if(batADValue < 1118)
  0059    3004    LDIA	0x4
  005A    022D    SUBA	0x2D
  005B    305E    LDIA	0x5E
  005C    1903    SZB	0x3,2
  005D    022C    SUBA	0x2C
  005E    1803    SZB	0x3,0
  005F    2863    JP	0x63
  0060    300F    LDIA	0xF
352:              		{
353:              			chrgMode = 0;
  0061    01C0    CLR	0x40
354:              			chrgMaxAD = 15;
  0062    287C    JP	0x7C
355:              		}
356:              		else if(batADValue < 1530)
  0063    3005    LDIA	0x5
  0064    022D    SUBA	0x2D
  0065    30FA    LDIA	0xFA
  0066    1903    SZB	0x3,2
  0067    022C    SUBA	0x2C
  0068    1803    SZB	0x3,0
  0069    2870    JP	0x70
  006A    3019    LDIA	0x19
357:              		{
358:              			chrgMode = 1;
  006B    01C0    CLR	0x40
  006C    0AC0    INCR	0x40
359:              			chrgMaxAD = 25;
  006D    00BF    LD	0x3F,A
360:              			lockCount = 0;
  006E    01BE    CLR	0x3E
361:              		}
  006F    287D    JP	0x7D
362:              		else if(count1s == 0)
  0070    0854    LD	A,0x54
  0071    1D03    SNZB	0x3,2
  0072    287D    JP	0x7D
363:              		{
364:              			if(++lockCount > 200)
  0073    30C9    LDIA	0xC9
  0074    0ABE    INCR	0x3E
  0075    023E    SUBA	0x3E
  0076    1C03    SNZB	0x3,0
  0077    287B    JP	0x7B
  0078    3002    LDIA	0x2
365:              			{
366:              				lockCount = 0;
  0079    01BE    CLR	0x3E
367:              				chrgMode = 2;
  007A    00C0    LD	0x40,A
368:              			}
369:              			
370:              			chrgMaxAD = 25;
  007B    3019    LDIA	0x19
  007C    00BF    LD	0x3F,A
371:              		}
372:              		if(chrgMode == 2 && outADValue < 5)
  007D    3002    LDIA	0x2
  007E    0640    XORA	0x40
  007F    1D03    SNZB	0x3,2
  0080    2897    JP	0x97
  0081    3000    LDIA	0x0
  0082    022F    SUBA	0x2F
  0083    3005    LDIA	0x5
  0084    1903    SZB	0x3,2
  0085    022E    SUBA	0x2E
  0086    1803    SZB	0x3,0
  0087    2897    JP	0x97
373:              		{
374:              			if(++fullCount >= 200)
  0088    0AA8    INCR	0x28
  0089    1903    SZB	0x3,2
  008A    0AA9    INCR	0x29
  008B    3000    LDIA	0x0
  008C    0229    SUBA	0x29
  008D    30C8    LDIA	0xC8
  008E    1903    SZB	0x3,2
  008F    0228    SUBA	0x28
  0090    1C03    SNZB	0x3,0
  0091    2899    JP	0x99
375:              			{
376:              				fullCount = 0;
  0092    01A8    CLR	0x28
  0093    01A9    CLR	0x29
377:              				chrgFullFlag = 1;
  0094    01D2    CLR	0x52
  0095    0AD2    INCR	0x52
  0096    2899    JP	0x99
378:              			}
379:              		}
380:              		else
381:              		{
382:              			fullCount = 0;
  0097    01A8    CLR	0x28
  0098    01A9    CLR	0x29
383:              		}
384:              		if(chrgFullFlag)
  0099    0852    LD	A,0x52
  009A    1903    SZB	0x3,2
  009B    289F    JP	0x9F
385:              		{
386:              			lockLedStep = 6;
  009C    3006    LDIA	0x6
  009D    00C2    LD	0x42,A
387:              			chrgPwmStop();
  009E    2DD6    JP	0x5D6
388:              		}
389:              		else
390:              		{
391:              				if(prePwStep < 15)
  009F    300F    LDIA	0xF
  00A0    0277    SUBA	0x77
  00A1    1803    SZB	0x3,0
  00A2    28A5    JP	0xA5
392:              				{
393:              					lockLedStep = 0;
  00A3    01C2    CLR	0x42
394:              				}
  00A4    28AB    JP	0xAB
395:              				else
396:              				{
397:              					lockLedStep = (prePwStep/14) - 1;
  00A5    300E    LDIA	0xE
  00A6    00F3    LD	0x73,A
  00A7    0877    LD	A,0x77
  00A8    258E    CALL	0x58E
  00A9    3EFF    ADDIA	0xFF
  00AA    00C2    LD	0x42,A
398:              				}
399:              				if(batADValue > 1545 || outADValue > (chrgMaxAD))
  00AB    3006    LDIA	0x6
  00AC    022D    SUBA	0x2D
  00AD    300A    LDIA	0xA
  00AE    1903    SZB	0x3,2
  00AF    022C    SUBA	0x2C
  00B0    1803    SZB	0x3,0
  00B1    28BD    JP	0xBD
  00B2    083F    LD	A,0x3F
  00B3    00D7    LD	0x57,A
  00B4    01D8    CLR	0x58
  00B5    082F    LD	A,0x2F
  00B6    0258    SUBA	0x58
  00B7    1D03    SNZB	0x3,2
  00B8    28BB    JP	0xBB
  00B9    082E    LD	A,0x2E
  00BA    0257    SUBA	0x57
  00BB    1803    SZB	0x3,0
  00BC    28CC    JP	0xCC
400:              				{
401:              					if(++subTime > chrgWaitTime)
  00BD    0ABC    INCR	0x3C
  00BE    083C    LD	A,0x3C
  00BF    023B    SUBA	0x3B
  00C0    1803    SZB	0x3,0
  00C1    28CA    JP	0xCA
402:              					{
403:              						if(chrgMaxDuty > 1)
  00C2    3002    LDIA	0x2
  00C3    023A    SUBA	0x3A
  00C4    1C03    SNZB	0x3,0
  00C5    28C7    JP	0xC7
404:              						{
405:              							chrgMaxDuty--;
  00C6    03BA    DECR	0x3A
  00C7    3032    LDIA	0x32
406:              						}
407:              						subTime = 0;
  00C8    01BC    CLR	0x3C
408:              						chrgWaitTime = 50;
  00C9    00BB    LD	0x3B,A
409:              					}
410:              					addTime = 0;
  00CA    01BD    CLR	0x3D
411:              				}
  00CB    28EC    JP	0xEC
412:              				else if(batADValue < 1545 && outADValue < (chrgMaxAD - 4))
  00CC    3006    LDIA	0x6
  00CD    022D    SUBA	0x2D
  00CE    3009    LDIA	0x9
  00CF    1903    SZB	0x3,2
  00D0    022C    SUBA	0x2C
  00D1    1803    SZB	0x3,0
  00D2    28EC    JP	0xEC
  00D3    083F    LD	A,0x3F
  00D4    3EFC    ADDIA	0xFC
  00D5    00D7    LD	0x57,A
  00D6    30FF    LDIA	0xFF
  00D7    1803    SZB	0x3,0
  00D8    3000    LDIA	0x0
  00D9    00D8    LD	0x58,A
  00DA    022F    SUBA	0x2F
  00DB    1D03    SNZB	0x3,2
  00DC    28DF    JP	0xDF
  00DD    0857    LD	A,0x57
  00DE    022E    SUBA	0x2E
  00DF    1803    SZB	0x3,0
  00E0    28EC    JP	0xEC
413:              				{
414:              					if(++addTime > chrgWaitTime)
  00E1    0ABD    INCR	0x3D
  00E2    083D    LD	A,0x3D
  00E3    023B    SUBA	0x3B
  00E4    1803    SZB	0x3,0
  00E5    28EB    JP	0xEB
  00E6    304B    LDIA	0x4B
415:              					{
416:              						addTime = 0;
  00E7    01BD    CLR	0x3D
417:              						if(chrgMaxDuty < 75)
  00E8    023A    SUBA	0x3A
  00E9    1C03    SNZB	0x3,0
418:              						{
419:              							chrgMaxDuty++;
  00EA    0ABA    INCR	0x3A
420:              						}
421:              					}
422:              					subTime = 0;
  00EB    01BC    CLR	0x3C
423:              				}
424:              				
425:              	
426:              				if((PWMCON0 & 0x01) == 0)
  00EC    1815    SZB	0x15,0
  00ED    28EF    JP	0xEF
427:              				{
428:              					chrgPwmInit();
  00EE    25A9    CALL	0x5A9
429:              				}
430:              				PWMD01H = 0X00;
  00EF    019E    CLR	0x1E
431:              				PWMD0L = chrgMaxDuty;
  00F0    083A    LD	A,0x3A
  00F1    0099    LD	0x19,A
  00F2    0008    RET
  00F3    3014    LDIA	0x14
432:              		}
433:              	}
434:              	else
435:              	{
436:              		startChrgTime = 0;
437:              		chrgFlag = 0;
  00F4    01FA    CLR	0x7A
438:              		chrgFullFlag = 0;
  00F5    1283    CLRB	0x3,5
  00F6    01D2    CLR	0x52
439:              		protectFlag = 0;
  00F7    01CF    CLR	0x4F
440:              		chrgMode = 0;
  00F8    01C0    CLR	0x40
441:              		chrgMaxAD = 0;
  00F9    01BF    CLR	0x3F
442:              		chrgMaxDuty = 0;
  00FA    01BA    CLR	0x3A
443:              		lockCount = 0;
  00FB    01BE    CLR	0x3E
444:              		lockLedStep = 0;
  00FC    01C2    CLR	0x42
445:              		chrgWaitTime = 20;
  00FD    00BB    LD	0x3B,A
446:              		chrgPwmStop();
  00FE    25D6    CALL	0x5D6
447:              		if(prePwStep > 0 && prePwStep > pwStep)
  00FF    0877    LD	A,0x77
  0100    1903    SZB	0x3,2
  0101    290F    JP	0x10F
  0102    0877    LD	A,0x77
  0103    0244    SUBA	0x44
  0104    1803    SZB	0x3,0
  0105    290F    JP	0x10F
448:              		{
449:              			if(++count50s > 2000)
  0106    2112    CALL	0x112
  0107    1903    SZB	0x3,2
  0108    022A    SUBA	0x2A
  0109    1C03    SNZB	0x3,0
  010A    0008    RET
450:              			{
451:              				count50s = 0;
  010B    01AA    CLR	0x2A
  010C    01AB    CLR	0x2B
452:              				prePwStep--;
  010D    03F7    DECR	0x77
  010E    0008    RET
453:              			}
454:              		}
455:              		else
456:              		{
457:              			count50s = 0;
  010F    01AA    CLR	0x2A
  0110    01AB    CLR	0x2B
  0111    0008    RET
458:              		}
459:              	}
460:              }
461:              
462:              
463:              
464:              char keyRead(char keyStatus)	
  0537    00F3    LD	0x73,A
465:              { 
466:              	if(keyStatus)
  0538    0873    LD	A,0x73
  0539    3064    LDIA	0x64
  053A    1903    SZB	0x3,2
  053B    2D49    JP	0x549
467:              	{
468:              		keyCount++;
  053C    0ACC    INCR	0x4C
469:              		if(keyCount >= 100)
  053D    024C    SUBA	0x4C
  053E    1C03    SNZB	0x3,0
  053F    3400    RET	0x0
470:              		{
471:              			keyCount = 100;
  0540    3064    LDIA	0x64
  0541    00CC    LD	0x4C,A
472:              			if(!longPressFlag)
  0542    084B    LD	A,0x4B
  0543    1D03    SNZB	0x3,2
  0544    3400    RET	0x0
  0545    3002    LDIA	0x2
473:              			{
474:              				longPressFlag = 1;
  0546    01CB    CLR	0x4B
  0547    0ACB    INCR	0x4B
475:              				return 2;
  0548    0008    RET
476:              			}
477:              		}
478:              	}
479:              	else
480:              	{
481:              		if(keyCount >= 100)
  0549    024C    SUBA	0x4C
  054A    1C03    SNZB	0x3,0
  054B    2D4F    JP	0x54F
482:              		{
483:              			keyCount = 0;
  054C    01CC    CLR	0x4C
484:              			longPressFlag = 0;
  054D    01CB    CLR	0x4B
485:              			return	0;
  054E    3400    RET	0x0
486:              		}
487:              		else if(keyCount >= 6)
  054F    3006    LDIA	0x6
  0550    024C    SUBA	0x4C
488:              		{
489:              			keyCount = 0;
  0551    01CC    CLR	0x4C
  0552    1803    SZB	0x3,0
490:              			return	1;
  0553    3401    RET	0x1
  0554    3400    RET	0x0
491:              		}
492:              		keyCount = 0;
493:              	}
494:              	return 0;
495:              }
496:              
497:              void keyCtr()
498:              {
499:              	char kclick = keyRead(0x04 & (~PORTB));
  04C0    0906    COMA	0x6
  04C1    3904    ANDIA	0x4
  04C2    2537    CALL	0x537
  04C3    00F4    LD	0x74,A
500:              	if(kclick == 1)
  04C4    0B74    SZDECA	0x74
  04C5    2CE3    JP	0x4E3
501:              	{
502:              		if(workStep > 0)
  04C6    0879    LD	A,0x79
  04C7    1903    SZB	0x3,2
  04C8    2CD1    JP	0x4D1
503:              		{
504:              			if(++workStep > 6)
  04C9    3007    LDIA	0x7
  04CA    0AF9    INCR	0x79
  04CB    0279    SUBA	0x79
  04CC    1C03    SNZB	0x3,0
  04CD    0008    RET
505:              			{
506:              				workStep = 1;
  04CE    01F9    CLR	0x79
  04CF    0AF9    INCR	0x79
  04D0    0008    RET
507:              			}
508:              		}
509:              		else if(overWorkTime > 0)
  04D1    0824    LD	A,0x24
  04D2    0425    ORA	0x25
  04D3    1903    SZB	0x3,2
  04D4    2CDA    JP	0x4DA
510:              		{
511:              			overWorkTime = 0;
  04D5    01A4    CLR	0x24
  04D6    01A5    CLR	0x25
512:              			workStep = preLedStep;
  04D7    0838    LD	A,0x38
  04D8    00F9    LD	0x79,A
513:              		}
  04D9    0008    RET
514:              		else if(showBatTime > 0)
  04DA    0841    LD	A,0x41
  04DB    1903    SZB	0x3,2
  04DC    2CDF    JP	0x4DF
515:              		{
516:              			showBatTime = 0;
  04DD    01C1    CLR	0x41
517:              		}
  04DE    0008    RET
518:              		else
519:              		{
520:              			showBatTime = 200;
  04DF    30C8    LDIA	0xC8
  04E0    00C1    LD	0x41,A
521:              			count1s = 0;
  04E1    01D4    CLR	0x54
  04E2    0008    RET
522:              		}
523:              	}
524:              	else if(kclick == 2)
  04E3    3002    LDIA	0x2
  04E4    0674    XORA	0x74
  04E5    1D03    SNZB	0x3,2
  04E6    0008    RET
525:              	{
526:              		if(workStep > 0)
  04E7    0879    LD	A,0x79
  04E8    1903    SZB	0x3,2
  04E9    2CEC    JP	0x4EC
527:              		{
528:              			workStep = 0;
  04EA    01F9    CLR	0x79
529:              		}
  04EB    0008    RET
  04EC    301E    LDIA	0x1E
530:              		else
531:              		{
532:              			workStep = 1;
  04ED    01F9    CLR	0x79
  04EE    0AF9    INCR	0x79
533:              			startTime = 30;
  04EF    00C6    LD	0x46,A
  04F0    2CDD    JP	0x4DD
534:              			showBatTime = 0;
535:              		}
536:              	}
537:              }
538:              
539:              void workCtr()
540:              {
541:              
542:              	if(startTime > 0)
  0486    1283    CLRB	0x3,5
  0487    0846    LD	A,0x46
  0488    1D03    SNZB	0x3,2
543:              	{
544:              		startTime--;
  0489    03C6    DECR	0x46
545:              	}
546:              	if(workStep > 0)
  048A    0879    LD	A,0x79
  048B    1903    SZB	0x3,2
  048C    2CBC    JP	0x4BC
547:              	{
548:              		if((PWMCON0 & 0x02) == 0)
  048D    1895    SZB	0x15,1
  048E    2C90    JP	0x490
549:              		{
550:              			pwmInit();
  048F    25BE    CALL	0x5BE
551:              		}
552:              		maxDuty = 43 + (workStep*2);
  0490    1003    CLRB	0x3,0
  0491    0D79    RLCA	0x79
  0492    3E2B    ADDIA	0x2B
  0493    00CA    LD	0x4A,A
553:              		if(overCount >= 5)
  0494    3005    LDIA	0x5
  0495    0249    SUBA	0x49
  0496    1C03    SNZB	0x3,0
  0497    2CAC    JP	0x4AC
554:              		{
555:              			if(++count5s > 500)
  0498    0AA6    INCR	0x26
  0499    1903    SZB	0x3,2
  049A    0AA7    INCR	0x27
  049B    3001    LDIA	0x1
  049C    0227    SUBA	0x27
  049D    30F5    LDIA	0xF5
  049E    1903    SZB	0x3,2
  049F    0226    SUBA	0x26
  04A0    1C03    SNZB	0x3,0
  04A1    2CAE    JP	0x4AE
  04A2    30E8    LDIA	0xE8
556:              			{
557:              				count5s = 0;
  04A3    01A6    CLR	0x26
  04A4    01A7    CLR	0x27
558:              				overWorkTime = 1000;
  04A5    00A4    LD	0x24,A
  04A6    3003    LDIA	0x3
  04A7    00A5    LD	0x25,A
559:              				preLedStep = workStep;
  04A8    0879    LD	A,0x79
  04A9    00B8    LD	0x38,A
560:              				workStep = 0;
  04AA    01F9    CLR	0x79
  04AB    2CAE    JP	0x4AE
561:              				
562:              			}
563:              		}
564:              		else
565:              		{
566:              			count5s = 0;
  04AC    01A6    CLR	0x26
  04AD    01A7    CLR	0x27
567:              		}
568:              		if(count1s == 0 && ++count900s >= 900)
  04AE    0854    LD	A,0x54
  04AF    1D03    SNZB	0x3,2
  04B0    0008    RET
  04B1    0AA0    INCR	0x20
  04B2    1903    SZB	0x3,2
  04B3    0AA1    INCR	0x21
  04B4    3003    LDIA	0x3
  04B5    0221    SUBA	0x21
  04B6    3084    LDIA	0x84
  04B7    1903    SZB	0x3,2
  04B8    0220    SUBA	0x20
  04B9    1803    SZB	0x3,0
569:              		{
570:              			workStep = 0;
  04BA    01F9    CLR	0x79
  04BB    0008    RET
571:              		}
572:              	}
573:              	else
574:              	{
575:              		pwmStop();
  04BC    25D3    CALL	0x5D3
576:              		count900s = 0;
  04BD    01A0    CLR	0x20
  04BE    01A1    CLR	0x21
  04BF    0008    RET
577:              	}
578:              }
579:              
580:              void checkOutA()
581:              {
582:              	if(chrgFlag)
  0201    087A    LD	A,0x7A
583:              	{
584:              		test_adc = ADC_Sample(4, 5);		//测试AN4口的AD值，参考电压2V
  0202    3005    LDIA	0x5
  0203    00F3    LD	0x73,A
  0204    1903    SZB	0x3,2
  0205    2A08    JP	0x208
  0206    3004    LDIA	0x4
  0207    2A09    JP	0x209
585:              	}
  0208    3000    LDIA	0x0
  0209    2118    CALL	0x118
  020A    00D6    LD	0x56,A
586:              	else
587:              	{
588:              		test_adc = ADC_Sample(0, 5);		//测试AN0口的AD值，参考电压2V
589:              	}
590:              	if (0xA5 == test_adc)				//测试完成，如因其他原因导致AD转换没有完成，则不处理
  020B    30A5    LDIA	0xA5
  020C    0656    XORA	0x56
  020D    1D03    SNZB	0x3,2
  020E    2AA9    JP	0x2A9
591:              	{
592:              		if(chrgFlag && adresult > 210)
  020F    087A    LD	A,0x7A
  0210    1903    SZB	0x3,2
  0211    2A22    JP	0x222
  0212    3000    LDIA	0x0
  0213    0235    SUBA	0x35
  0214    30D3    LDIA	0xD3
  0215    1903    SZB	0x3,2
  0216    0234    SUBA	0x34
  0217    1C03    SNZB	0x3,0
  0218    2A22    JP	0x222
593:              		{
594:              			if(++overChrgTime > 10)
  0219    300B    LDIA	0xB
  021A    0AC5    INCR	0x45
  021B    0245    SUBA	0x45
  021C    1C03    SNZB	0x3,0
  021D    2A23    JP	0x223
  021E    3002    LDIA	0x2
595:              			{
596:              				overChrgTime = 0;
  021F    01C5    CLR	0x45
597:              				protectFlag = 2;
  0220    00CF    LD	0x4F,A
  0221    2A23    JP	0x223
598:              			}
599:              			
600:              		}
601:              		else
602:              		{
603:              			overChrgTime = 0;
  0222    01C5    CLR	0x45
604:              		}
605:              		outADValue = adresult;
  0223    0835    LD	A,0x35
  0224    00AF    LD	0x2F,A
  0225    0834    LD	A,0x34
  0226    00AE    LD	0x2E,A
606:              		//电机坏了过载保护
607:                      if(workStep && (outADValue > 220))
  0227    0879    LD	A,0x79
  0228    1903    SZB	0x3,2
  0229    2A39    JP	0x239
  022A    3000    LDIA	0x0
  022B    022F    SUBA	0x2F
  022C    30DD    LDIA	0xDD
  022D    1903    SZB	0x3,2
  022E    022E    SUBA	0x2E
  022F    1C03    SNZB	0x3,0
  0230    2A39    JP	0x239
608:                      {
609:                      	if(++workOverOutTime > 50)
  0231    3033    LDIA	0x33
  0232    0ACE    INCR	0x4E
  0233    024E    SUBA	0x4E
  0234    1C03    SNZB	0x3,0
  0235    2A3A    JP	0x23A
610:                      	{
611:                      		workOverOutTime = 0;
  0236    01CE    CLR	0x4E
612:                      		workStep = 0;
  0237    01F9    CLR	0x79
  0238    2A3A    JP	0x23A
613:                      	}
614:                      }
615:              		else
616:              		{
617:              			workOverOutTime = 0;
  0239    01CE    CLR	0x4E
618:              		}
619:              		u8t maxtempV = 40;
620:              		if(workStep < 6 && outADValue > maxtempV)
  023A    3006    LDIA	0x6
  023B    0279    SUBA	0x79
  023C    3000    LDIA	0x0
  023D    1803    SZB	0x3,0
  023E    2A4E    JP	0x24E
  023F    022F    SUBA	0x2F
  0240    3029    LDIA	0x29
  0241    1903    SZB	0x3,2
  0242    022E    SUBA	0x2E
  0243    1C03    SNZB	0x3,0
  0244    2A4D    JP	0x24D
621:                      {
622:                      	if(++overCount > 5)
  0245    3006    LDIA	0x6
  0246    0AC9    INCR	0x49
  0247    0249    SUBA	0x49
  0248    1C03    SNZB	0x3,0
  0249    2AA5    JP	0x2A5
623:                      	{
624:                      		overCount = 5;
  024A    3005    LDIA	0x5
  024B    00C9    LD	0x49,A
  024C    2AA5    JP	0x2A5
625:                      	}
626:                      }
627:                      else if(outADValue > (maxtempV+3))
  024D    3000    LDIA	0x0
  024E    022F    SUBA	0x2F
  024F    302C    LDIA	0x2C
  0250    1903    SZB	0x3,2
  0251    022E    SUBA	0x2E
  0252    1803    SZB	0x3,0
  0253    2A45    JP	0x245
628:                      {
629:                      	if(++overCount > 5)
  0254    300B    LDIA	0xB
  0255    00E9    LD	0x69,A
630:                      	{
631:                      		overCount = 5;
632:                      	}
633:                      }
634:                      else
635:                      {
636:                      	u8t maxAout = 11;
637:                      	if(workStep == 1)
  0256    0B79    SZDECA	0x79
  0257    2A5A    JP	0x25A
638:                  		{
639:                  			maxAout = maxAout + 5;
  0258    3005    LDIA	0x5
  0259    2A77    JP	0x277
640:                  		}
641:              			else if(workStep == 2)
  025A    3002    LDIA	0x2
  025B    0679    XORA	0x79
  025C    1D03    SNZB	0x3,2
  025D    2A60    JP	0x260
642:                  		{
643:                  			maxAout = maxAout + 6;
  025E    3006    LDIA	0x6
  025F    2A77    JP	0x277
644:                  		}
645:              			else if(workStep == 3)
  0260    3003    LDIA	0x3
  0261    0679    XORA	0x79
  0262    1D03    SNZB	0x3,2
  0263    2A66    JP	0x266
646:                  		{
647:                  			maxAout = maxAout + 7;
  0264    3007    LDIA	0x7
  0265    2A77    JP	0x277
648:                  		}
649:                  		else if(workStep == 4)
  0266    3004    LDIA	0x4
  0267    0679    XORA	0x79
  0268    1D03    SNZB	0x3,2
  0269    2A6C    JP	0x26C
650:                  		{
651:                  			maxAout = maxAout + 8;
  026A    3008    LDIA	0x8
  026B    2A77    JP	0x277
652:                  		}
653:                  		else if(workStep == 5)
  026C    3005    LDIA	0x5
  026D    0679    XORA	0x79
  026E    1D03    SNZB	0x3,2
  026F    2A72    JP	0x272
654:                  		{
655:                  			maxAout = maxAout + 9;
  0270    3009    LDIA	0x9
  0271    2A77    JP	0x277
656:                  		}
657:                  		else if(workStep == 6)
  0272    3006    LDIA	0x6
  0273    0679    XORA	0x79
  0274    1D03    SNZB	0x3,2
  0275    2A78    JP	0x278
658:                  		{
659:                  			maxAout = maxAout + 10;
  0276    300A    LDIA	0xA
  0277    07E9    ADDR	0x69
660:                  		}
661:                      	if(overCount > 0)
  0278    0849    LD	A,0x49
  0279    1D03    SNZB	0x3,2
662:                      	{
663:                      		overCount--;
  027A    03C9    DECR	0x49
664:                      	}
665:                      	if(outADValue > maxAout)
  027B    0869    LD	A,0x69
  027C    00F4    LD	0x74,A
  027D    01F5    CLR	0x75
  027E    082F    LD	A,0x2F
  027F    0275    SUBA	0x75
  0280    1D03    SNZB	0x3,2
  0281    2A84    JP	0x284
  0282    082E    LD	A,0x2E
  0283    0274    SUBA	0x74
  0284    1803    SZB	0x3,0
  0285    2A9F    JP	0x29F
666:                      	{
667:                   				if(++addPowerCount > 3)
  0286    3004    LDIA	0x4
  0287    0AC8    INCR	0x48
  0288    0248    SUBA	0x48
  0289    1C03    SNZB	0x3,0
  028A    2AA5    JP	0x2A5
668:                   				{
669:              						addPowerCount = 3;
  028B    3003    LDIA	0x3
  028C    00C8    LD	0x48,A
670:              						if(startTime == 0)
  028D    0846    LD	A,0x46
  028E    1D03    SNZB	0x3,2
  028F    2A9C    JP	0x29C
671:              						{
672:              		        			tempDuty = 72 + (workStep*4);
  0290    0879    LD	A,0x79
  0291    00F4    LD	0x74,A
  0292    3001    LDIA	0x1
  0293    1003    CLRB	0x3,0
  0294    0DF4    RLCR	0x74
  0295    3EFF    ADDIA	0xFF
  0296    1003    CLRB	0x3,0
  0297    1D03    SNZB	0x3,2
  0298    2A94    JP	0x294
  0299    0D74    RLCA	0x74
  029A    3E48    ADDIA	0x48
  029B    2A9D    JP	0x29D
673:              		        			
674:              		        		}
675:              		        		else
676:              		        		{
677:              		        			tempDuty = maxDuty;
  029C    084A    LD	A,0x4A
  029D    00C7    LD	0x47,A
  029E    2AA5    JP	0x2A5
678:              		        		}
679:              	        		}
680:              	        		
681:                      	}
682:                      	else 
683:                      	{
684:                      		addPowerCount = 0;
  029F    01C8    CLR	0x48
685:                      		if(tempDuty > maxDuty)
  02A0    0847    LD	A,0x47
  02A1    024A    SUBA	0x4A
  02A2    1803    SZB	0x3,0
  02A3    2A9C    JP	0x29C
686:                      		{
687:                      			tempDuty--;
  02A4    03C7    DECR	0x47
688:                      		}
689:                      		else
690:                      		{
691:                      			tempDuty = maxDuty;
692:                      		}
693:              
694:                      	}
695:                 
696:                      }
697:              		PWMD01H = 0X00;
  02A5    019E    CLR	0x1E
698:                      PWMD1L = tempDuty;
  02A6    0847    LD	A,0x47
  02A7    009A    LD	0x1A,A
699:              	}
  02A8    0008    RET
700:              	else
701:              	{
702:              		ADCON0 = 0;						//如果转换没有完成，需初始化ADCON0,1
  02A9    1683    SETB	0x3,5
  02AA    0195    CLR	0x15
703:              		ADCON1 = 0;				
  02AB    0196    CLR	0x16
704:              		__delay_us(100);				//延时100us(编译器内置函数)
  02AC    3085    LDIA	0x85
  02AD    00F4    LD	0x74,A
  02AE    0BF4    SZDECR	0x74
  02AF    2AAE    JP	0x2AE
  02B0    0008    RET
705:              	}
706:              }
707:              
708:              void checkBatAD()
709:              {
710:              	test_adc = ADC_Sample(2, 5);		//测试AN2口的AD值，参考电压2V
  02B1    3005    LDIA	0x5
  02B2    00F3    LD	0x73,A
  02B3    3002    LDIA	0x2
  02B4    2118    CALL	0x118
  02B5    00D6    LD	0x56,A
711:              	if (0xA5 == test_adc)				//测试完成，如因其他原因导致AD转换没有完成，则不处理
  02B6    30A5    LDIA	0xA5
  02B7    0656    XORA	0x56
  02B8    1D03    SNZB	0x3,2
  02B9    2B19    JP	0x319
712:              	{
713:              		batADValue = adresult;
  02BA    0835    LD	A,0x35
  02BB    00AD    LD	0x2D,A
  02BC    0834    LD	A,0x34
  02BD    00AC    LD	0x2C,A
714:              		if(batADValue < 1117)
  02BE    3004    LDIA	0x4
  02BF    022D    SUBA	0x2D
  02C0    305D    LDIA	0x5D
  02C1    1903    SZB	0x3,2
  02C2    022C    SUBA	0x2C
  02C3    1803    SZB	0x3,0
  02C4    2ADF    JP	0x2DF
715:                      {
716:                      	pwStep = 0;
  02C5    01C4    CLR	0x44
717:              			if(++count8s > 800)
  02C6    0AA2    INCR	0x22
  02C7    1903    SZB	0x3,2
  02C8    0AA3    INCR	0x23
  02C9    3003    LDIA	0x3
  02CA    0223    SUBA	0x23
  02CB    3021    LDIA	0x21
  02CC    1903    SZB	0x3,2
  02CD    0222    SUBA	0x22
  02CE    1C03    SNZB	0x3,0
  02CF    2B0C    JP	0x30C
718:              			{
719:              				count8s = 0;
  02D0    01A2    CLR	0x22
  02D1    01A3    CLR	0x23
720:              				lowBatFlag = 1;
  02D2    01B7    CLR	0x37
  02D3    0AB7    INCR	0x37
721:              				if(workStep > 0)
  02D4    0879    LD	A,0x79
  02D5    1903    SZB	0x3,2
  02D6    2ADC    JP	0x2DC
722:              				{
723:              					overWorkTime = 120;
  02D7    3078    LDIA	0x78
  02D8    00A4    LD	0x24,A
  02D9    01A5    CLR	0x25
724:              					preLedStep = workStep;
  02DA    0879    LD	A,0x79
  02DB    00B8    LD	0x38,A
725:              				}
726:              				prePwStep = 0;
  02DC    01F7    CLR	0x77
727:              				workStep = 0;
  02DD    01F9    CLR	0x79
  02DE    2B0C    JP	0x30C
  02DF    3005    LDIA	0x5
728:              			}
729:                      }
730:                      else
731:                      {
732:              	        count8s = 0;
  02E0    01A2    CLR	0x22
  02E1    01A3    CLR	0x23
733:              			if(batADValue >= 1340)
  02E2    022D    SUBA	0x2D
  02E3    303C    LDIA	0x3C
  02E4    1903    SZB	0x3,2
  02E5    022C    SUBA	0x2C
734:              	    	{
735:              	    		pwStep = ((batADValue - 1340) /2) + 13;
  02E6    082C    LD	A,0x2C
  02E7    1C03    SNZB	0x3,0
  02E8    2AF6    JP	0x2F6
  02E9    3EC4    ADDIA	0xC4
  02EA    00F4    LD	0x74,A
  02EB    082D    LD	A,0x2D
  02EC    1803    SZB	0x3,0
  02ED    3E01    ADDIA	0x1
  02EE    3EFA    ADDIA	0xFA
  02EF    00F5    LD	0x75,A
  02F0    1003    CLRB	0x3,0
  02F1    0CF5    RRCR	0x75
  02F2    0CF4    RRCR	0x74
  02F3    0874    LD	A,0x74
  02F4    3E0D    ADDIA	0xD
  02F5    2B05    JP	0x305
736:              	    	}
  02F6    3EA3    ADDIA	0xA3
  02F7    00F4    LD	0x74,A
  02F8    082D    LD	A,0x2D
  02F9    1803    SZB	0x3,0
  02FA    3E01    ADDIA	0x1
  02FB    3EFB    ADDIA	0xFB
  02FC    00F5    LD	0x75,A
  02FD    3004    LDIA	0x4
  02FE    1003    CLRB	0x3,0
  02FF    0CF5    RRCR	0x75
  0300    0CF4    RRCR	0x74
  0301    3EFF    ADDIA	0xFF
  0302    1D03    SNZB	0x3,2
  0303    2AFE    JP	0x2FE
  0304    0874    LD	A,0x74
  0305    00C4    LD	0x44,A
737:              	    	else
738:              	    	{
739:              	    		pwStep = (batADValue - 1117) / 16;
740:              	    	}
741:              	    	if(pwStep > 99)
  0306    3064    LDIA	0x64
  0307    0244    SUBA	0x44
  0308    1C03    SNZB	0x3,0
  0309    2B0C    JP	0x30C
742:              	    	{
743:              	    		pwStep = 99;
  030A    3063    LDIA	0x63
  030B    00C4    LD	0x44,A
744:              	    	}
745:                  	}
746:              		if(chrgFlag && batADValue > 1861)
  030C    087A    LD	A,0x7A
  030D    1903    SZB	0x3,2
  030E    2B20    JP	0x320
  030F    3007    LDIA	0x7
  0310    022D    SUBA	0x2D
  0311    3046    LDIA	0x46
  0312    1903    SZB	0x3,2
  0313    022C    SUBA	0x2C
  0314    1C03    SNZB	0x3,0
  0315    2B20    JP	0x320
747:                      {
748:              	        protectFlag = 1;
  0316    01CF    CLR	0x4F
  0317    0ACF    INCR	0x4F
  0318    2B20    JP	0x320
749:                      }
750:              	}
751:              	else
752:              	{
753:              		ADCON0 = 0;						//如果转换没有完成，需初始化ADCON0,1
  0319    1683    SETB	0x3,5
  031A    0195    CLR	0x15
754:              		ADCON1 = 0;				
  031B    0196    CLR	0x16
755:              		__delay_us(100);				//延时100us(编译器内置函数)
  031C    3085    LDIA	0x85
  031D    00F4    LD	0x74,A
  031E    0BF4    SZDECR	0x74
  031F    2B1E    JP	0x31E
756:              	}
757:              	test_adc = ADC_Sample(3, 5);		//测试AN2口的AD值，参考电压2V
  0320    3005    LDIA	0x5
  0321    00F3    LD	0x73,A
  0322    3003    LDIA	0x3
  0323    2118    CALL	0x118
  0324    00D6    LD	0x56,A
758:              	if (0xA5 == test_adc)				//测试完成，如因其他原因导致AD转换没有完成，则不处理
  0325    30A5    LDIA	0xA5
  0326    0656    XORA	0x56
  0327    1D03    SNZB	0x3,2
  0328    2B54    JP	0x354
759:              	{
760:              		if(chrgFlag && adresult > 100)
  0329    087A    LD	A,0x7A
  032A    1903    SZB	0x3,2
  032B    0008    RET
  032C    3000    LDIA	0x0
  032D    0235    SUBA	0x35
  032E    3065    LDIA	0x65
  032F    1903    SZB	0x3,2
  0330    0234    SUBA	0x34
  0331    1C03    SNZB	0x3,0
  0332    0008    RET
761:              	    {
762:              	    	//有电池
763:              	    	if(adresult > 810 || (batADValue - adresult) > 810)
  0333    3003    LDIA	0x3
  0334    0235    SUBA	0x35
  0335    302B    LDIA	0x2B
  0336    1903    SZB	0x3,2
  0337    0234    SUBA	0x34
  0338    1803    SZB	0x3,0
  0339    2B49    JP	0x349
  033A    0834    LD	A,0x34
  033B    022C    SUBA	0x2C
  033C    00F4    LD	0x74,A
  033D    0835    LD	A,0x35
  033E    1C03    SNZB	0x3,0
  033F    0A35    INCA	0x35
  0340    022D    SUBA	0x2D
  0341    00F5    LD	0x75,A
  0342    3003    LDIA	0x3
  0343    0275    SUBA	0x75
  0344    302B    LDIA	0x2B
  0345    1903    SZB	0x3,2
  0346    0274    SUBA	0x74
  0347    1C03    SNZB	0x3,0
  0348    2B52    JP	0x352
764:              	    	{
765:              	    		//有一节电池已经满了
766:              	    		if(++countHalfFull > 250)
  0349    30FB    LDIA	0xFB
  034A    0AD0    INCR	0x50
  034B    0250    SUBA	0x50
  034C    1C03    SNZB	0x3,0
  034D    0008    RET
  034E    3002    LDIA	0x2
767:              	    		{
768:              	    			countHalfFull = 0;
  034F    01D0    CLR	0x50
769:              					protectFlag = 2;
  0350    00CF    LD	0x4F,A
  0351    0008    RET
770:              	    		}
771:              	    	}
772:              	    	else
773:              	    	{
774:              	    		countHalfFull = 0;
  0352    01D0    CLR	0x50
775:              	    	}
776:              	    }
777:              	}
  0353    0008    RET
778:              	else
779:              	{
780:              		ADCON0 = 0;						//如果转换没有完成，需初始化ADCON0,1
  0354    1683    SETB	0x3,5
  0355    0195    CLR	0x15
781:              		ADCON1 = 0;				
  0356    0196    CLR	0x16
782:              		__delay_us(100);				//延时100us(编译器内置函数)
  0357    3085    LDIA	0x85
  0358    00F4    LD	0x74,A
  0359    0BF4    SZDECR	0x74
  035A    2B59    JP	0x359
  035B    0008    RET
783:              	}
784:              }
785:              
786:              
787:              
788:              /**********************************************************
789:              函数名称：Init_System
790:              函数功能：系统初始化
791:              入口参数：无
792:              出口参数：无
793:              备    注：
794:              **********************************************************/
795:              void Init_System() 
  0515    0000    NOP
  0516    0064    CLRWDT
796:              {
797:              	asm("nop");
798:              	asm("clrwdt");
799:              	OPTION_REG = 0;					//预分频给TMR0 ，Timer0使用内部时钟Focs/4，预分频比为1:2
  0517    1283    CLRB	0x3,5
  0518    0181    CLR	0x1
  0519    0064    CLRWDT
800:              	asm("clrwdt");
801:              	OSCCON = 0X72;					//内部振荡器8M
  051A    3072    LDIA	0x72
  051B    1283    CLRB	0x3,5
  051C    0094    LD	0x14,A
802:              
803:              	WPUA = 0B00000000;				//配置上拉，1为使能上拉
  051D    1683    SETB	0x3,5
  051E    0188    CLR	0x8
804:              	WPDA = 0x02;					//RA1开下拉
  051F    3002    LDIA	0x2
  0520    0087    LD	0x7,A
805:              	WPUB = 0B00000100;
  0521    3004    LDIA	0x4
  0522    1283    CLRB	0x3,5
  0523    0088    LD	0x8,A
806:              
807:              	TRISA = 0x1F;				//配置IO状态，0为输出，1为输入
  0524    301F    LDIA	0x1F
  0525    1683    SETB	0x3,5
  0526    0085    LD	0x5,A
808:              	TRISB = 0B00000100;
  0527    3004    LDIA	0x4
  0528    1283    CLRB	0x3,5
  0529    0085    LD	0x5,A
809:              
810:              	PORTA = 0X00;
  052A    1683    SETB	0x3,5
  052B    0186    CLR	0x6
811:              	PORTB = 0X00;
  052C    1283    CLRB	0x3,5
  052D    0186    CLR	0x6
812:              
813:              //---------------------------------------
814:              //125us中断初始化
815:              	PR2 = 249;					//设定Timer初始值，定时周期是250*2/8M=62.5uS
  052E    30F9    LDIA	0xF9
  052F    0091    LD	0x11,A
816:              	TMR2IF = 0;
  0530    108D    CLRB	0xD,1
817:              	TMR2IE = 1;					//使能Timer2溢出中断
  0531    148E    SETB	0xE,1
818:              
819:              	T2CON = 0B00000100;			//开启Timer2,设置TMR2的分频比为1:1
  0532    3004    LDIA	0x4
  0533    0093    LD	0x13,A
820:              	INTCON = 0XC0;				//开启总中断
  0534    30C0    LDIA	0xC0
  0535    008B    LD	0xB,A
  0536    0008    RET
821:              }
822:              
823:              /***********************************************************
824:              中断服务函数
825:              函数名称：AD_Init()
826:              函数功能：AD初始化处理函数
827:              入口参数：
828:              出口参数：
829:              备    注：第一次打开AD允许位ADON，需延时20uS以上才能进入AD采样
830:              			如后继程序不关闭ADON，则不需要延时
831:              ***********************************************************/
832:              void AD_Init() 
833:              {
834:              	/*********** ADCON0 ****************************
835:              		Bit7~Bit6  ADCS<1:0>:  AD转换时钟选择位。
836:              			00=  F HSI /16
837:              			01=  F HSI /32
838:              			10=  F HSI /64
839:              			11=  F HSI /128
840:              		Bit5~Bit2  CHS<3:0>:  模拟通道选择位。与ADCON1寄存器CHS4组合CHS<3:0>
841:              			CHS<4:0>: 
842:              			00000=  AN0
843:              			00001=  AN1
844:              			00010=  AN2
845:              			00011=  AN3
846:              			00100=  AN4
847:              			00101=  AN5
848:              			00110=  保留
849:              			00111=  保留
850:              			01000=  AN8
851:              			… 
852:              			01101=  AN13
853:              			01110=  AN14
854:              			01111=  AN15
855:              			11111=  1.2V（固定参考电压）
856:              			其他=  保留
857:              		Bit1  GO/DONE: AD转换状态位。
858:              			1=  AD转换正在进行。将该位置1启动AD转换。当AD转换完成以后，该位由硬件自动清零。
859:              				当GO/DONE位从1变0或ADIF从0变1时，需至少等待两个TAD时间，才能再次启动AD转换。
860:              			0=  AD转换完成/或不在进行中。
861:              		Bit0  ADON:  ADC使能位。
862:              			1=  使能ADC；
863:              			0=  禁止ADC，不消耗工作电流。
864:              	*********************************************/
865:              	ADCON0 = 0X41;		//ADON开启，AD采样时间选为FSYS/16
  05C6    3041    LDIA	0x41
  05C7    1683    SETB	0x3,5
  05C8    0095    LD	0x15,A
866:              	
867:              	/*********** ADCON1 ****************************
868:              		Bit7  ADFM:  AD转换结果格式选择位；
869:              			1=  右对齐；
870:              			0=  左对齐。
871:              		Bit6  CHS4:  通道选择位
872:              		Bit5~Bit3  未用 
873:              		Bit2  LDO_EN:  内部参考电压使能位。
874:              			1=  使能ADC内部LDO参考电压；
875:              				当选择内部LDO作参考电压时，ADC最大有效精度为8位。
876:              			0=  VDD作为ADC参考电压。
877:              		Bit1~Bit0  LDO_SEL<1:0>:  参考电压选择位
878:              			0X=  2.0V
879:              			10=  2.4V
880:              			11=  3.0V
881:              	*********************************************/
882:              	ADCON1 = 0;
  05C9    0196    CLR	0x16
883:              	ANSEL0 = 0X1D;	
  05CA    301D    LDIA	0x1D
  05CB    0093    LD	0x13,A
  05CC    0008    RET
884:              }
885:              
886:              
887:              void chrgPwmInit()
888:              {
889:              		PWMCON1 = 0B00000000;	//PWM选择A组，死区2禁止，死区1使能，死区时钟源为Fosc/4
890:              		
891:              		PWMTH = 0X00;			//周期选择为0FF，则周期为（255+1）*1/8M，周期的时钟分频在PWMCON0选择
892:              		PWMTL = 100;			//PWM 周期=[PWMT+1]*Tosc*(CLKDIV 分频值)
893:              		
894:              	
895:              		
896:              		PWMD01H = 0;			//配置PWM1,PWM2的占空比，该值不能超过周期，否者为100%输出
  05A9    25B0    CALL	0x5B0
897:              		PWMD0L = 1;			//互补模式，PWM1的占空比与PWM0互补，和设置值无关
  05AA    3001    LDIA	0x1
  05AB    0099    LD	0x19,A
898:              		PWM01DT = 0X00;			//死区设为2uS，计算为（3+1）*1/8M*4
  05AC    019F    CLR	0x1F
899:              		
900:              		PWMCON0 = 0X01;			//打开PWM0 分频比为1
  05AD    0095    LD	0x15,A
901:              		PWMCON2 =0X00;			//PWM4输出反向
  05AE    019D    CLR	0x1D
  05AF    0008    RET
902:              }
903:              
904:              void chrgPwmStop()
905:              {
906:              	PWMCON0 &= 0xFE;	//关闭PWM0
  05D6    1015    CLRB	0x15,0
907:              	RB0 = 0;
  05D7    1006    CLRB	0x6,0
  05D8    0008    RET
908:              }
909:              
910:              void pwmInit()
911:              {
912:              		PWMCON1 = 0B00000000;	//PWM选择A组，死区2禁止，死区1使能，死区时钟源为Fosc/4
913:              		PWMTH = 0X00;			//周期选择为0FF，则周期为（255+1）*1/8M，周期的时钟分频在PWMCON0选择
914:              		PWMTL = 100;			//PWM 周期=[PWMT+1]*Tosc*(CLKDIV 分频值)
915:              		
916:              		
917:              		PWMD01H = 0;			//配置PWM1,PWM2的占空比，该值不能超过周期，否者为100%输出
  05BE    25B0    CALL	0x5B0
918:              		PWMD1L = 50;			//互补模式，PWM1的占空比与PWM0互补，和设置值无关
  05BF    3032    LDIA	0x32
  05C0    009A    LD	0x1A,A
919:              		PWM01DT = 0X00;			//死区设为2uS，计算为（3+1）*1/8M*4
  05C1    019F    CLR	0x1F
920:              
921:              		PWMCON0 = 0X62;			//打开PWM1 分频比为8
  05C2    3062    LDIA	0x62
  05C3    0095    LD	0x15,A
922:              		PWMCON2 =0X00;			//PWM4输出反向
  05C4    019D    CLR	0x1D
  05C5    0008    RET
923:              }
924:              
925:              void pwmStop()
926:              {
927:              	PWMCON0 &= 0XFD;
  05D3    1095    CLRB	0x15,1
928:              	RB1 = 0;
  05D4    1086    CLRB	0x6,1
  05D5    0008    RET
929:              }
930:              
931:              
932:              /***********************************************
933:              函数名称：Sleep_Mode
934:              函数功能：进入休眠模式
935:              入口参数：无
936:              出口参数：无
937:              备注：
938:              ************************************************/
939:              void Sleep_Mode()
940:              {
941:              	INTCON = 0;		
  040D    018B    CLR	0xB
942:              	
943:              	OPTION_REG = 0;
  040E    0181    CLR	0x1
944:              
945:              	TRISA = 0x1F; 		//关闭所有输出，RA0口做唤醒输入
  040F    301F    LDIA	0x1F
  0410    1683    SETB	0x3,5
  0411    0085    LD	0x5,A
946:              	WPUA  = 0B00000000;			//RA0 开上拉电阻
  0412    0188    CLR	0x8
947:              	PORTA = 0x00;
  0413    0186    CLR	0x6
948:              	TRISB = 0B00000100;			//关闭所有输出，RB3口做唤醒输入
  0414    3004    LDIA	0x4
  0415    1283    CLRB	0x3,5
  0416    0085    LD	0x5,A
949:              	PORTB = 0B00000000;
  0417    0186    CLR	0x6
950:              	WPUB  = 0B00000100;			//RB2 开上拉电阻
  0418    0088    LD	0x8,A
951:                 			
952:                 	ADCON0 = 0;					//关闭所有模块
  0419    1683    SETB	0x3,5
  041A    0195    CLR	0x15
953:              	ADCON1 = 0;
  041B    0196    CLR	0x16
954:              	
955:              	PWMCON0 = 0;
  041C    1283    CLRB	0x3,5
  041D    0195    CLR	0x15
956:              		
957:              	OSCCON = 0X70;				//配置振荡为8M,关闭WDT，需注意芯片工程选项里WDT必须选为DISABLE,否则无法软件关掉WDT
  041E    3070    LDIA	0x70
  041F    0094    LD	0x14,A
958:              	
959:              	IOCA = 0B00000010;			//允许RA1的IO电平变化中断
  0420    3002    LDIA	0x2
  0421    1683    SETB	0x3,5
  0422    0089    LD	0x9,A
960:              	IOCB = 0B00000100;			//允许RB3的IO口电平变化中断
  0423    3004    LDIA	0x4
  0424    1283    CLRB	0x3,5
  0425    0089    LD	0x9,A
961:              	
962:              	RAIE = 1;					//允许PORTA的IO电平变化中断
  0426    158E    SETB	0xE,3
963:              	PEIE = 1;					//要用RORTA中断唤醒，则PEIE必须设为1
  0427    170B    SETB	0xB,6
964:              	RBIE = 1;					//允许PORTB电平变化中断
  0428    158B    SETB	0xB,3
965:              	GIE = 0;					//唤醒后执行SLEEP后程序;
  0429    138B    CLRB	0xB,7
966:              	
967:              	PIE1 &= 0X08;				//关闭不需要的中断
  042A    3008    LDIA	0x8
  042B    058E    ANDR	0xE
968:              	PIR1 = 0;					//必须清不需要的中断标志位
  042C    018D    CLR	0xD
969:              	INTCON &= 0XC8;				//必须清不需要的中断标志位
  042D    30C8    LDIA	0xC8
  042E    058B    ANDR	0xB
970:              
971:              	PORTA;						//读PORTA值并锁存,用电平变化中断必须执行这一步
  042F    1683    SETB	0x3,5
  0430    0806    LD	A,0x6
972:              	RAIF = 0;					//清PORTA中断标志位
  0431    1283    CLRB	0x3,5
  0432    118D    CLRB	0xD,3
973:              	PORTB;						//读PORTB值并锁存	
  0433    0806    LD	A,0x6
974:              	RBIF = 0;					//清PORTB中断标志位		
  0434    100B    CLRB	0xB,0
  0435    0064    CLRWDT
  0436    0063    STOP
  0437    0000    NOP
  0438    0064    CLRWDT
  0439    0000    NOP
  043A    0000    NOP
  043B    0000    NOP
  043C    0000    NOP
  043D    0000    NOP
975:              	asm("clrwdt");
976:              
977:              	asm("sleep");				//进入休眠模式
978:              	
979:              	asm("nop");
980:              	asm("clrwdt");
981:              	asm("nop");
982:              	asm("nop");
983:              	asm("nop");
984:              	asm("nop");
985:              	asm("nop");
986:              	if(RAIF)  RAIF = 0;			//清中断标志
  043E    1283    CLRB	0x3,5
  043F    198D    SZB	0xD,3
  0440    118D    CLRB	0xD,3
987:              	if(RBIF)  RBIF = 0;			//清中断标志
  0441    180B    SZB	0xB,0
  0442    100B    CLRB	0xB,0
988:              	if(TMR2IF) TMR2IF = 0;
  0443    188D    SZB	0xD,1
  0444    108D    CLRB	0xD,1
989:              	IOCA = 0B00000000;			//允许RA1的IO电平变化中断
  0445    1683    SETB	0x3,5
  0446    0189    CLR	0x9
990:              	IOCB = 0B00000000;			//允许RB3的IO口电平变化中断
  0447    1283    CLRB	0x3,5
  0448    0189    CLR	0x9
991:              	Init_System();
  0449    2515    CALL	0x515
992:              	AD_Init();
  044A    2DC6    JP	0x5C6
993:              }
994:              
995:              
996:              
997:              /**********************************************************
998:              函数名称：AD_Sample
999:              函数功能：AD检测
1000:             入口参数：adch - 检测通道
1001:             出口参数：无
1002:             备    注：采样通道需自行设置为输入口
1003:             	      采样10次,取中间八次的平均值为采样结果存于adresult中
1004:             
1005:             	      adch 为输入AD通道 0-15，31
1006:                          31  检测内部1.2V
1007:             	
1008:              		  adldo =5,开启内部LDO 2V 作为ADC 参考
1009:              		  adldo =6,开启内部LDO 2.4V 作为ADC 参考
1010:             		  adldo =7,开启内部LDO 3V 作为ADC 参考
1011:              		  adldo =0,VDD 作为ADC 参考
1012:              		  AD转换结果左对齐
1013:              		  ADC参考电压从VDD切换到LDO时需要延时100us以上，才能进行AD转换
1014:             **********************************************************/
1015:             unsigned char ADC_Sample(unsigned char adch, unsigned char adldo) 
  0118    1283    CLRB	0x3,5
  0119    00DC    LD	0x5C,A
1016:             {
1017:             	volatile unsigned long adsum = 0;
1018:             	volatile unsigned int admin = 0, admax = 0;
  011A    21F3    CALL	0x1F3
1019:             	volatile unsigned int ad_temp = 0;
  011B    01E6    CLR	0x66
  011C    01E7    CLR	0x67
1020:             
1021:             	if ((!LDO_EN) && (adldo & 0x04) ) 
  011D    1683    SETB	0x3,5
  011E    1D16    SNZB	0x16,2
  011F    1D73    SNZB	0x73,2
  0120    292A    JP	0x12A
1022:             	{
1023:             								//如果AD参考从VDD换到内部LDO，需要延时100US以上
1024:             		ADCON1 = adldo;			//左对齐,AD值取12位
  0121    0873    LD	A,0x73
  0122    0096    LD	0x16,A
1025:             		__delay_us(100);		//IDE内置延时函数，延时100us
  0123    3084    LDIA	0x84
  0124    1283    CLRB	0x3,5
  0125    00D7    LD	0x57,A
  0126    0BD7    SZDECR	0x57
  0127    2926    JP	0x126
  0128    2929    JP	0x129
1026:             	} 
  0129    292C    JP	0x12C
1027:             	else
1028:             		ADCON1 = adldo;			//如果ADCON1.7(ADFM)=1为右对齐，,AD值取10位
  012A    0873    LD	A,0x73
  012B    0096    LD	0x16,A
1029:             
1030:             	if(adch & 0x10) 
  012C    1283    CLRB	0x3,5
  012D    1E5C    SNZB	0x5C,4
  012E    2934    JP	0x134
1031:             	{
1032:             		CHS4 = 1;
  012F    1683    SETB	0x3,5
  0130    1716    SETB	0x16,6
1033:             		adch &= 0x0f;
  0131    300F    LDIA	0xF
  0132    1283    CLRB	0x3,5
  0133    05DC    ANDR	0x5C
1034:             	}
1035:             	unsigned char i = 0;
1036:             	for (i = 0; i < 10; i++) 
  0134    01DD    CLR	0x5D
1037:             	{
1038:             		ADCON0 = (unsigned char)(0X41 | (adch << 2));	//16分频，如果主频为16M，则必须选16分频或以上
  0135    085C    LD	A,0x5C
  0136    00D7    LD	0x57,A
  0137    3001    LDIA	0x1
  0138    1003    CLRB	0x3,0
  0139    0DD7    RLCR	0x57
  013A    3EFF    ADDIA	0xFF
  013B    1003    CLRB	0x3,0
  013C    1D03    SNZB	0x3,2
  013D    2939    JP	0x139
  013E    0D57    RLCA	0x57
  013F    3841    ORIA	0x41
  0140    1683    SETB	0x3,5
  0141    0095    LD	0x15,A
  0142    0000    NOP
  0143    0000    NOP
  0144    0000    NOP
  0145    0000    NOP
1039:             		asm("nop");
1040:             		asm("nop");
1041:             		asm("nop");
1042:             		asm("nop");				//选择通道后需延时1uS以上
1043:             		GODONE = 1;				//开始转换
  0146    1683    SETB	0x3,5
  0147    1495    SETB	0x15,1
1044:             
1045:             		unsigned char j = 0;
  0148    1283    CLRB	0x3,5
  0149    01DB    CLR	0x5B
1046:             		while (GODONE) 
  014A    1683    SETB	0x3,5
  014B    1C95    SNZB	0x15,1
  014C    2955    JP	0x155
1047:             		{
1048:             			__delay_us(2);		//延时2us(编译器内置函数)
  014D    294E    JP	0x14E
  014E    294F    JP	0x14F
  014F    2950    JP	0x150
  0150    2951    JP	0x151
1049:             
1050:             			if (0 == (--j))		//延时0.5ms仍没有AD转换结束，跳出程序
  0151    1283    CLRB	0x3,5
  0152    0BDB    SZDECR	0x5B
  0153    294A    JP	0x14A
1051:             			return 0;
  0154    3400    RET	0x0
1052:             		}
1053:             
1054:             		ad_temp = (unsigned int)((ADRESH << 4) + (ADRESL >> 4));	//计算12位AD值
  0155    0819    LD	A,0x19
  0156    1283    CLRB	0x3,5
  0157    00E6    LD	0x66,A
  0158    01E7    CLR	0x67
  0159    0EE6    SWAPR	0x66
  015A    0EE7    SWAPR	0x67
  015B    30F0    LDIA	0xF0
  015C    05E7    ANDR	0x67
  015D    0866    LD	A,0x66
  015E    390F    ANDIA	0xF
  015F    04E7    ORR	0x67
  0160    30F0    LDIA	0xF0
  0161    05E6    ANDR	0x66
  0162    1683    SETB	0x3,5
  0163    0E18    SWAPA	0x18
  0164    390F    ANDIA	0xF
  0165    1283    CLRB	0x3,5
  0166    07E6    ADDR	0x66
  0167    1803    SZB	0x3,0
  0168    0AE7    INCR	0x67
1055:             
1056:             		if (0 == admax) 
  0169    0864    LD	A,0x64
  016A    0465    ORA	0x65
  016B    1D03    SNZB	0x3,2
  016C    296F    JP	0x16F
1057:             		{
1058:             			admax = ad_temp;
  016D    21FC    CALL	0x1FC
  016E    2981    JP	0x181
1059:             			admin = ad_temp;
1060:             		} 
1061:             		else if (ad_temp > admax)
  016F    0867    LD	A,0x67
  0170    0265    SUBA	0x65
  0171    1D03    SNZB	0x3,2
  0172    2975    JP	0x175
  0173    0866    LD	A,0x66
  0174    0264    SUBA	0x64
  0175    1803    SZB	0x3,0
  0176    2979    JP	0x179
1062:             			admax = ad_temp;				//AD采样最大值
  0177    21FC    CALL	0x1FC
  0178    2985    JP	0x185
1063:             		else if (ad_temp < admin)
  0179    0863    LD	A,0x63
  017A    0267    SUBA	0x67
  017B    1D03    SNZB	0x3,2
  017C    297F    JP	0x17F
  017D    0862    LD	A,0x62
  017E    0266    SUBA	0x66
  017F    1803    SZB	0x3,0
  0180    2985    JP	0x185
1064:             			admin = ad_temp;				//AD采样最小值
  0181    0867    LD	A,0x67
  0182    00E3    LD	0x63,A
  0183    0866    LD	A,0x66
  0184    00E2    LD	0x62,A
1065:             
1066:             		adsum += ad_temp;
  0185    0866    LD	A,0x66
  0186    00D7    LD	0x57,A
  0187    0867    LD	A,0x67
  0188    00D8    LD	0x58,A
  0189    01D9    CLR	0x59
  018A    01DA    CLR	0x5A
  018B    0857    LD	A,0x57
  018C    07DE    ADDR	0x5E
  018D    0858    LD	A,0x58
  018E    1103    CLRB	0x3,2
  018F    1803    SZB	0x3,0
  0190    3E01    ADDIA	0x1
  0191    1D03    SNZB	0x3,2
  0192    07DF    ADDR	0x5F
  0193    0859    LD	A,0x59
  0194    1103    CLRB	0x3,2
  0195    1803    SZB	0x3,0
  0196    3E01    ADDIA	0x1
  0197    1D03    SNZB	0x3,2
  0198    07E0    ADDR	0x60
  0199    085A    LD	A,0x5A
  019A    1103    CLRB	0x3,2
  019B    1803    SZB	0x3,0
  019C    3E01    ADDIA	0x1
  019D    1D03    SNZB	0x3,2
  019E    07E1    ADDR	0x61
  019F    300A    LDIA	0xA
  01A0    0ADD    INCR	0x5D
  01A1    025D    SUBA	0x5D
  01A2    1C03    SNZB	0x3,0
  01A3    2935    JP	0x135
1067:             	}
1068:             		adsum -= admax;
  01A4    0864    LD	A,0x64
  01A5    00D7    LD	0x57,A
  01A6    0865    LD	A,0x65
  01A7    21E4    CALL	0x1E4
  01A8    1C03    SNZB	0x3,0
  01A9    0F5A    SZINCA	0x5A
  01AA    02E1    SUBR	0x61
1069:             		if (adsum >= admin)
  01AB    0862    LD	A,0x62
  01AC    00D7    LD	0x57,A
  01AD    0863    LD	A,0x63
  01AE    00D8    LD	0x58,A
  01AF    01D9    CLR	0x59
  01B0    01DA    CLR	0x5A
  01B1    085A    LD	A,0x5A
  01B2    0261    SUBA	0x61
  01B3    1D03    SNZB	0x3,2
  01B4    29BF    JP	0x1BF
  01B5    0859    LD	A,0x59
  01B6    0260    SUBA	0x60
  01B7    1D03    SNZB	0x3,2
  01B8    29BF    JP	0x1BF
  01B9    0858    LD	A,0x58
  01BA    025F    SUBA	0x5F
  01BB    1D03    SNZB	0x3,2
  01BC    29BF    JP	0x1BF
  01BD    0857    LD	A,0x57
  01BE    025E    SUBA	0x5E
  01BF    1C03    SNZB	0x3,0
  01C0    29C9    JP	0x1C9
1070:             			adsum -= admin;
  01C1    0862    LD	A,0x62
  01C2    00D7    LD	0x57,A
  01C3    0863    LD	A,0x63
  01C4    21E4    CALL	0x1E4
  01C5    1C03    SNZB	0x3,0
  01C6    0F5A    SZINCA	0x5A
  01C7    02E1    SUBR	0x61
  01C8    29CD    JP	0x1CD
1071:             		else
1072:             			adsum = 0;
  01C9    01DE    CLR	0x5E
  01CA    01DF    CLR	0x5F
  01CB    01E0    CLR	0x60
  01CC    01E1    CLR	0x61
1073:             
1074:             		adresult = adsum >> 3;		//8次平均值作为最终结果
  01CD    085E    LD	A,0x5E
  01CE    00D7    LD	0x57,A
  01CF    085F    LD	A,0x5F
  01D0    00D8    LD	0x58,A
  01D1    0860    LD	A,0x60
  01D2    00D9    LD	0x59,A
  01D3    0861    LD	A,0x61
  01D4    00DA    LD	0x5A,A
  01D5    3003    LDIA	0x3
  01D6    1003    CLRB	0x3,0
  01D7    0CDA    RRCR	0x5A
  01D8    0CD9    RRCR	0x59
  01D9    0CD8    RRCR	0x58
  01DA    0CD7    RRCR	0x57
  01DB    3EFF    ADDIA	0xFF
  01DC    1D03    SNZB	0x3,2
  01DD    29D6    JP	0x1D6
  01DE    0858    LD	A,0x58
  01DF    00B5    LD	0x35,A
  01E0    0857    LD	A,0x57
  01E1    00B4    LD	0x34,A
1075:             
1076:             		adsum = 0;
1077:             		admin = 0;
1078:             		admax = 0;
  01E2    21F3    CALL	0x1F3
1079:             		return 0xA5;
  01E3    34A5    RET	0xA5
1080:             		
1081:             }
1082:             
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\lwmod.c ----------------------------------------------------------------------
1:                // word unsigned modulus
2:                
3:                unsigned int
4:                #ifdef __PICC__
5:                #warning TODO: update cgpic and this file to use the other prototype
6:                __lwmod(unsigned int divisor, unsigned int dividend)
  04F1    0873    LD	A,0x73
  04F2    0474    ORA	0x74
  04F3    1903    SZB	0x3,2
  04F4    2D10    JP	0x510
  04F5    01D7    CLR	0x57
  04F6    0AD7    INCR	0x57
  04F7    1BF4    SZB	0x74,7
  04F8    2CFD    JP	0x4FD
  04F9    1003    CLRB	0x3,0
  04FA    0DF3    RLCR	0x73
  04FB    0DF4    RLCR	0x74
  04FC    2CF6    JP	0x4F6
  04FD    0874    LD	A,0x74
  04FE    0276    SUBA	0x76
  04FF    1D03    SNZB	0x3,2
  0500    2D03    JP	0x503
  0501    0873    LD	A,0x73
  0502    0275    SUBA	0x75
  0503    1C03    SNZB	0x3,0
  0504    2D0C    JP	0x50C
  0505    0873    LD	A,0x73
  0506    02F5    SUBR	0x75
  0507    0874    LD	A,0x74
  0508    1C03    SNZB	0x3,0
  0509    03F6    DECR	0x76
  050A    02F6    SUBR	0x76
  050B    1003    CLRB	0x3,0
  050C    0CF4    RRCR	0x74
  050D    0CF3    RRCR	0x73
  050E    0BD7    SZDECR	0x57
  050F    2CFD    JP	0x4FD
  0510    0876    LD	A,0x76
  0511    00F4    LD	0x74,A
  0512    0875    LD	A,0x75
  0513    00F3    LD	0x73,A
  0514    0008    RET
7:                #else
8:                __lwmod(unsigned int dividend, unsigned int divisor)
9:                #endif
10:               {
11:               	unsigned char	counter;
12:               
13:               	if(divisor != 0) {
14:               		counter = 1;
15:               		while((divisor & 0x8000) == 0) {
16:               			divisor <<= 1;
17:               			counter++;
18:               		}
19:               		do {
20:               			if(divisor <= dividend)
21:               				dividend -= divisor;
22:               			divisor >>= 1;
23:               		} while(--counter != 0);
24:               	}
25:               	return dividend;
26:               }
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\lbmod.c ----------------------------------------------------------------------
1:                // byte unsigned modulus
2:                
3:                unsigned char
4:                __lbmod(unsigned char dividend, unsigned char divisor)
  0572    00D7    LD	0x57,A
  0573    3008    LDIA	0x8
  0574    00D8    LD	0x58,A
  0575    01D9    CLR	0x59
  0576    0857    LD	A,0x57
  0577    00F4    LD	0x74,A
  0578    3007    LDIA	0x7
  0579    1003    CLRB	0x3,0
  057A    0CF4    RRCR	0x74
  057B    3EFF    ADDIA	0xFF
  057C    1003    CLRB	0x3,0
  057D    1D03    SNZB	0x3,2
  057E    2D7A    JP	0x57A
  057F    0D59    RLCA	0x59
  0580    0474    ORA	0x74
  0581    00D9    LD	0x59,A
  0582    1003    CLRB	0x3,0
  0583    0DD7    RLCR	0x57
  0584    0873    LD	A,0x73
  0585    0259    SUBA	0x59
  0586    1C03    SNZB	0x3,0
  0587    2D8A    JP	0x58A
  0588    0873    LD	A,0x73
  0589    02D9    SUBR	0x59
  058A    0BD8    SZDECR	0x58
  058B    2D76    JP	0x576
  058C    0859    LD	A,0x59
  058D    0008    RET
5:                {
6:                	unsigned char	rem;
7:                	unsigned char	counter;
8:                
9:                	counter = 8;
10:               	rem = 0;
11:               	do {
12:               		rem = (rem << 1) | (dividend >> 7);
13:               		dividend <<= 1;
14:               		if(divisor <= rem)
15:               			rem -= divisor;
16:               	} while(--counter != 0);
17:               	return rem;
18:               }
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\lbdiv.c ----------------------------------------------------------------------
1:                // byte unsigned division
2:                
3:                unsigned char
4:                __lbdiv(unsigned char dividend, unsigned char divisor)
  058E    00F4    LD	0x74,A
  058F    01F6    CLR	0x76
  0590    0873    LD	A,0x73
  0591    1903    SZB	0x3,2
  0592    2DA7    JP	0x5A7
  0593    01F5    CLR	0x75
  0594    0AF5    INCR	0x75
  0595    1BF3    SZB	0x73,7
  0596    2D9A    JP	0x59A
  0597    1003    CLRB	0x3,0
  0598    0DF3    RLCR	0x73
  0599    2D94    JP	0x594
  059A    1003    CLRB	0x3,0
  059B    0DF6    RLCR	0x76
  059C    0873    LD	A,0x73
  059D    0274    SUBA	0x74
  059E    1C03    SNZB	0x3,0
  059F    2DA4    JP	0x5A4
  05A0    0873    LD	A,0x73
  05A1    02F4    SUBR	0x74
  05A2    1476    SETB	0x76,0
  05A3    1003    CLRB	0x3,0
  05A4    0CF3    RRCR	0x73
  05A5    0BF5    SZDECR	0x75
  05A6    2D9A    JP	0x59A
  05A7    0876    LD	A,0x76
  05A8    0008    RET
5:                {
6:                	unsigned char	quotient;
7:                	unsigned char	counter;
8:                
9:                	quotient = 0;
10:               	if(divisor != 0) {
11:               		counter = 1;
12:               		while((divisor & 0x80) == 0) {
13:               			divisor <<= 1;
14:               			counter++;
15:               		}
16:               		do {
17:               			quotient <<= 1;
18:               			if(divisor <= dividend) {
19:               				dividend -= divisor;
20:               				quotient |= 1;
21:               			}
22:               			divisor >>= 1;
23:               		} while(--counter != 0);
24:               	}
25:               	return quotient;
26:               }
---- stringtab ------------------------------------------------------------------
---- reset_enter ------------------------------------------------------------------
  0000    280C    JP	0xC
  000C    280D    JP	0xD
---- start_initialization ------------------------------------------------------------------
  000D    3077    LDIA	0x77
  000E    0084    LD	0x4,A
  000F    307B    LDIA	0x7B
  0010    25B6    CALL	0x5B6
  0011    3020    LDIA	0x20
  0012    1383    CLRB	0x3,7
  0013    0084    LD	0x4,A
  0014    3057    LDIA	0x57
  0015    25B6    CALL	0x5B6
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F0    LD	0x70,A
  0007    0804    LD	A,0x4
  0008    00F1    LD	0x71,A
  0009    080A    LD	A,0xA
  000A    00F2    LD	0x72,A
  000B    2D55    JP	0x555
---- common_function ------------------------------------------------------------------
  0016    0183    CLR	0x3
  0017    2C4B    JP	0x44B
  0112    0AAA    INCR	0x2A
  0113    1903    SZB	0x3,2
  0114    0AAB    INCR	0x2B
  0115    3007    LDIA	0x7
  0116    022B    SUBA	0x2B
  0117    34D1    RET	0xD1
  01E4    00D8    LD	0x58,A
  01E5    01D9    CLR	0x59
  01E6    01DA    CLR	0x5A
  01E7    0857    LD	A,0x57
  01E8    02DE    SUBR	0x5E
  01E9    0858    LD	A,0x58
  01EA    1C03    SNZB	0x3,0
  01EB    0F58    SZINCA	0x58
  01EC    02DF    SUBR	0x5F
  01ED    0859    LD	A,0x59
  01EE    1C03    SNZB	0x3,0
  01EF    0F59    SZINCA	0x59
  01F0    02E0    SUBR	0x60
  01F1    085A    LD	A,0x5A
  01F2    0008    RET
  01F3    01DE    CLR	0x5E
  01F4    01DF    CLR	0x5F
  01F5    01E0    CLR	0x60
  01F6    01E1    CLR	0x61
  01F7    01E2    CLR	0x62
  01F8    01E3    CLR	0x63
  01F9    01E4    CLR	0x64
  01FA    01E5    CLR	0x65
  01FB    0008    RET
  01FC    0867    LD	A,0x67
  01FD    00E5    LD	0x65,A
  01FE    0866    LD	A,0x66
  01FF    00E4    LD	0x64,A
  0200    0008    RET
  05B0    0196    CLR	0x16
  05B1    0198    CLR	0x18
  05B2    3064    LDIA	0x64
  05B3    0097    LD	0x17,A
  05B4    019E    CLR	0x1E
  05B5    0008    RET
  05B6    0064    CLRWDT
  05B7    0180    CLR	0x0
  05B8    0A84    INCR	0x4
  05B9    0604    XORA	0x4
  05BA    1903    SZB	0x3,2
  05BB    3400    RET	0x0
  05BC    0604    XORA	0x4
  05BD    2DB7    JP	0x5B7
  05CD    2BF6    JP	0x3F6
  05CE    2BCF    JP	0x3CF
  05CF    2BD6    JP	0x3D6
  05D0    2BDE    JP	0x3DE
  05D1    2BE6    JP	0x3E6
  05D2    2BEC    JP	0x3EC
