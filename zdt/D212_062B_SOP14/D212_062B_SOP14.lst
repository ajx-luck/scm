---- C:\mcuproject\scm\zdt\D212_062B_SOP14\main.c ----------------------------------------------------------------------
1:                /**********************************************************
2:                D212触摸带数码管震动环
3:                **********************************************************/
4:                #pragma warning disable 752
5:                #pragma warning disable 373			//屏蔽掉编译的1个警告
6:                #include <sc.h>
7:                
8:                #ifndef _XTAL_FREQ
9:                #define _XTAL_FREQ 16000000			//16MHz,使用内置延时函数必须定义主频，
10:               									//如用FCPU_DIV选择2T，则定时赋值减半
11:               #endif
12:               #define		u8t		unsigned char
13:               #define		u16t	unsigned int
14:               #define     POWER_RATIO  	(4096UL*1.2*1000)
15:               
16:               
17:               #define		A_LED5						 RA4
18:               #define		A_LED4						 RA3
19:               #define		A_LED3						 RB5
20:               #define		A_LED2						 RB0
21:               #define		A_LED1						 RB1
22:               
23:               
24:               #define		A_LED5_OUT					 TRISA	&= 0xEF
25:               #define		A_LED4_OUT					 TRISA	&= 0xF7
26:               #define		A_LED3_OUT					 TRISB	&= 0xDF
27:               #define		A_LED2_OUT					 TRISB	&= 0xFE
28:               #define		A_LED1_OUT					 TRISB	&= 0xFD
29:               
30:               const static unsigned char numArray[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x71,0x79,0x50,0x76};
31:               
32:               volatile unsigned int adresult;
33:               volatile unsigned int result;
34:               volatile unsigned char test_adc;
35:               volatile unsigned int power_ad;
36:               u8t	intCount;
37:               u8t	count1s;
38:               u8t	IntFlag;
39:               u8t	chrgFlag;
40:               u8t	chrgFullFlag;
41:               u8t	intCount10;
42:               u16t	outADValue;
43:               u16t	batADValue;
44:               u8t		countHalfFull;
45:               u8t		protectFlag;
46:               u8t		workOverOutTime;
47:               u8t		workStep = 0;
48:               u8t		ledCnt;
49:               u8t		ledStep;
50:               u8t		keyCount;
51:               u8t		keyCount2;
52:               u8t		longPressFlag;
53:               u8t		longPressFlag2;
54:               u8t		maxDuty;
55:               u8t		overCount;
56:               u8t		addPowerCount;
57:               u8t		tempDuty;
58:               u8t		startTime;
59:               u8t		firstTime;
60:               u8t		overChrgTime;
61:               u8t		pwStep;
62:               u8t		prePwStep;
63:               u16t	count50s;
64:               u8t		reChrgCount;
65:               u8t		lockLedStep;
66:               u8t		showBatTime;
67:               u8t		chrgMode = 0;
68:               u8t		chrgMaxAD = 0;
69:               u8t		lockCount = 0;
70:               u16t	fullCount = 0;
71:               u8t addTime;
72:               u8t subTime;
73:               u8t chrgWaitTime;
74:               u8t	chrgMaxDuty = 0;
75:               u8t	ledCntTime;
76:               u16t	count5s = 0;
77:               u8t		overWorkTime;
78:               u8t		preLedStep;
79:               u16t	count8s;
80:               u16t	count900s;
81:               u8t		lowBatFlag = 0;
82:               u8t		sleepTime;
83:               u8t		startChrgTime = 0;
84:               u8t shiweiNum = 0;	//十位
85:               u8t	geweiNum = 0;	//个位
86:               u8t	preWorkStep = 0;
87:               u8t	chrgPwmFlag = 0;
88:               u8t	motorPwmFlag = 0;
89:               u16t	workTime = 0;
90:               u8t		curDuty = 0;
91:               u8t		motorDuty = 0;
92:               u8t		motorTime = 0;
93:               u8t		motorMaxTime= 0;
94:               u16t		maxWorkTime = 0;
95:               
96:               unsigned char ADC_Sample(unsigned char adch, unsigned char adldo);
97:               void DelayXms(unsigned char x);
98:               unsigned char ADC_Result(unsigned char adch);
99:               void Init_System();
100:              void AD_Init();
101:              void Sleep_Mode();
102:              void pwmInit();
103:              void pwmStop();
104:              void chrgPwmInit();
105:              void chrgPwmStop();
106:              void chrgCtr();
107:              void checkOutA();
108:              void checkBatAD();
109:              void ledShow();
110:              void keyCtr();
111:              void workCtr();
112:              void workCtr2();
113:              void ledCtr();
114:              char keyRead(char keyStatus);
115:              
116:              
117:              
118:              //#define _DEBUG			//调试程序用
119:              
120:              
121:              /***********************************************************
122:              中断服务函数
123:              函数名称：Isr_Timer()
124:              函数功能：中断处理函数
125:              入口参数：
126:              出口参数：
127:              备    注：125US定时2中断
128:              			所有中断都是在这个函数里面处理
129:              ***********************************************************/
130:              void interrupt Isr_Timer() 
131:              {
132:              	if(TMR2IF) 
  050E    1283    CLRB	0x3,5
  050F    1C8D    SNZB	0xD,1
  0510    2D22    JP	0x522
133:              	{			//若只使能了一个中断源,可以略去判断
134:              		TMR2IF = 0;
  0511    108D    CLRB	0xD,1
135:              		if(++intCount >= 160)
  0512    30A0    LDIA	0xA0
  0513    0ACE    INCR	0x4E
  0514    024E    SUBA	0x4E
  0515    1C03    SNZB	0x3,0
  0516    2D1F    JP	0x51F
  0517    3064    LDIA	0x64
136:              		{
137:              			intCount = 0;
  0518    01CE    CLR	0x4E
138:              			IntFlag = 1;
  0519    01CC    CLR	0x4C
  051A    0ACC    INCR	0x4C
139:              			if(++count1s >= 100)
  051B    0ACD    INCR	0x4D
  051C    024D    SUBA	0x4D
  051D    1803    SZB	0x3,0
140:              			{
141:              				count1s = 0;
  051E    01CD    CLR	0x4D
142:              			}
143:              		}
144:              		ledShow();
  051F    21EB    CALL	0x1EB
145:              		intCount10++;
  0520    1283    CLRB	0x3,5
  0521    0ACA    INCR	0x4A
  0522    0872    LD	A,0x72
  0523    008A    LD	0xA,A
  0524    0871    LD	A,0x71
  0525    0084    LD	0x4,A
  0526    0E70    SWAPA	0x70
  0527    0083    LD	0x3,A
  0528    0EFE    SWAPR	0x7E
  0529    0E7E    SWAPA	0x7E
  052A    0009    RETI
146:              	}
147:              
148:              }
149:              
150:              
151:              /***********************************************************
152:              main主函数
153:              ***********************************************************/
154:              void main() 
155:              {
156:              	Init_System();
  03F0    2562    CALL	0x562
157:              	AD_Init();
  03F1    25D2    CALL	0x5D2
158:              	shiweiNum = geweiNum = numArray[8];
  03F2    3009    LDIA	0x9
  03F3    0084    LD	0x4,A
  03F4    257C    CALL	0x57C
  03F5    1283    CLRB	0x3,5
  03F6    00E1    LD	0x61,A
  03F7    00E2    LD	0x62,A
159:              	firstTime = 200;
  03F8    30C8    LDIA	0xC8
  03F9    00E3    LD	0x63,A
160:              	while (1) 
  03FA    0064    CLRWDT
161:              	{
162:              		asm("clrwdt");
163:              		if(intCount10 > 10)
  03FB    300B    LDIA	0xB
  03FC    1283    CLRB	0x3,5
  03FD    024A    SUBA	0x4A
  03FE    1C03    SNZB	0x3,0
  03FF    2C02    JP	0x402
164:              		{
165:              			intCount10 = 0;
  0400    01CA    CLR	0x4A
166:              			checkOutA();
  0401    2484    CALL	0x484
167:              		}
168:              		if(!IntFlag)
  0402    1283    CLRB	0x3,5
  0403    084C    LD	A,0x4C
  0404    1903    SZB	0x3,2
  0405    2BFA    JP	0x3FA
169:                  		continue;			//10ms执行一次
170:                  	IntFlag = 0;
  0406    01CC    CLR	0x4C
171:              		chrgCtr();
  0407    2018    CALL	0x18
172:              		checkBatAD();
  0408    2292    CALL	0x292
173:              		if(chrgFlag == 0 && lowBatFlag == 0 && firstTime == 0)
  0409    087A    LD	A,0x7A
  040A    1D03    SNZB	0x3,2
  040B    2C14    JP	0x414
  040C    1283    CLRB	0x3,5
  040D    0833    LD	A,0x33
  040E    1D03    SNZB	0x3,2
  040F    2C14    JP	0x414
  0410    0863    LD	A,0x63
  0411    1D03    SNZB	0x3,2
  0412    2C14    JP	0x414
174:              		{
175:              			keyCtr();
  0413    24EB    CALL	0x4EB
176:              		}
177:              		workCtr();
  0414    2398    CALL	0x398
178:              		if(count1s == 0 && ++count900s >= 900)
  0415    1283    CLRB	0x3,5
  0416    084D    LD	A,0x4D
  0417    1D03    SNZB	0x3,2
  0418    2C23    JP	0x423
  0419    0AA0    INCR	0x20
  041A    1903    SZB	0x3,2
  041B    0AA1    INCR	0x21
  041C    3003    LDIA	0x3
  041D    0221    SUBA	0x21
  041E    3084    LDIA	0x84
  041F    1903    SZB	0x3,2
  0420    0220    SUBA	0x20
  0421    1803    SZB	0x3,0
179:              		{
180:              			workStep = 0;
  0422    01F9    CLR	0x79
181:              		}
182:              		ledCtr();
  0423    2335    CALL	0x335
183:              		if(chrgFlag == 0 && workStep == 0 && keyCount == 0 && firstTime == 0 && showBatTime == 0 && overWorkTime == 0)
  0424    087A    LD	A,0x7A
  0425    1D03    SNZB	0x3,2
  0426    2C40    JP	0x440
  0427    0879    LD	A,0x79
  0428    1D03    SNZB	0x3,2
  0429    2C40    JP	0x440
  042A    0845    LD	A,0x45
  042B    1D03    SNZB	0x3,2
  042C    2C40    JP	0x440
  042D    0863    LD	A,0x63
  042E    1D03    SNZB	0x3,2
  042F    2C40    JP	0x440
  0430    083D    LD	A,0x3D
  0431    1D03    SNZB	0x3,2
  0432    2C40    JP	0x440
  0433    0834    LD	A,0x34
  0434    1D03    SNZB	0x3,2
  0435    2C40    JP	0x440
  0436    30C8    LDIA	0xC8
184:              		{
185:              			shiweiNum = geweiNum = 0;
  0437    01E1    CLR	0x61
  0438    01E2    CLR	0x62
186:              			if(++sleepTime >= 200)
  0439    0AB2    INCR	0x32
  043A    0232    SUBA	0x32
  043B    1C03    SNZB	0x3,0
  043C    2BFA    JP	0x3FA
187:              			{
188:              				sleepTime = 0;
  043D    01B2    CLR	0x32
189:              				Sleep_Mode();
  043E    2442    CALL	0x442
  043F    2BFA    JP	0x3FA
190:              			}
191:              		}
192:              		else
193:              		{
194:              			sleepTime = 0;
  0440    01B2    CLR	0x32
  0441    2BFA    JP	0x3FA
195:              		}
196:              	}
197:              }
198:              
199:              void ledShow()
200:              {
201:              	if(++ledCntTime > 5)
  01EB    3006    LDIA	0x6
  01EC    0AB5    INCR	0x35
  01ED    0235    SUBA	0x35
  01EE    1C03    SNZB	0x3,0
  01EF    0008    RET
  01F0    3011    LDIA	0x11
202:              	{
203:              		ledCntTime = 0;
  01F1    01B5    CLR	0x35
204:              		if(++ledCnt > 16)
  01F2    0AC6    INCR	0x46
  01F3    0246    SUBA	0x46
  01F4    1803    SZB	0x3,0
205:              		{
206:              			ledCnt = 0;
  01F5    01C6    CLR	0x46
207:              		}
208:              		PORTA &= 0xE7;
  01F6    30E7    LDIA	0xE7
  01F7    1683    SETB	0x3,5
  01F8    0586    ANDR	0x6
209:              		PORTB &= 0xDC;
  01F9    30DC    LDIA	0xDC
  01FA    1283    CLRB	0x3,5
  01FB    0586    ANDR	0x6
210:              		TRISA |= 0x18;
  01FC    3018    LDIA	0x18
  01FD    1683    SETB	0x3,5
  01FE    0485    ORR	0x5
211:              		TRISB |= 0x23;
  01FF    3023    LDIA	0x23
  0200    1283    CLRB	0x3,5
  0201    0485    ORR	0x5
212:              		switch(ledCnt)
  0202    2A86    JP	0x286
213:              		{
214:              			case 1:
215:              			if(shiweiNum & 0x01)
  0203    1C62    SNZB	0x62,0
  0204    0008    RET
216:              			{
217:              				A_LED3_OUT;
  0205    1285    CLRB	0x5,5
218:              				A_LED2_OUT;
  0206    1005    CLRB	0x5,0
219:              				A_LED3 = 1;
  0207    1686    SETB	0x6,5
220:              				A_LED2 = 0;
  0208    1006    CLRB	0x6,0
  0209    0008    RET
221:              			}
222:              			break;
223:              			case 2:
224:              			if(shiweiNum & 0x02)
  020A    1CE2    SNZB	0x62,1
  020B    0008    RET
225:              			{
226:              				A_LED3_OUT;
  020C    1285    CLRB	0x5,5
227:              				A_LED2_OUT;
  020D    1005    CLRB	0x5,0
228:              				A_LED2 = 1;
  020E    1406    SETB	0x6,0
229:              				A_LED3 = 0;
  020F    1286    CLRB	0x6,5
  0210    0008    RET
230:              			}
231:              			break;
232:              			case 3:
233:              			if(shiweiNum & 0x04)
  0211    1D62    SNZB	0x62,2
  0212    0008    RET
234:              			{
235:              				A_LED3_OUT;
  0213    1285    CLRB	0x5,5
236:              				A_LED4_OUT;
  0214    1683    SETB	0x3,5
  0215    1185    CLRB	0x5,3
237:              				A_LED3 = 1;
  0216    1283    CLRB	0x3,5
  0217    1686    SETB	0x6,5
238:              				A_LED4 = 0;
  0218    1683    SETB	0x3,5
  0219    1186    CLRB	0x6,3
  021A    0008    RET
239:              			}
240:              			break;
241:              			case 4:
242:              			if(shiweiNum & 0x08)
  021B    1DE2    SNZB	0x62,3
  021C    0008    RET
243:              			{
244:              				A_LED2_OUT;
  021D    1005    CLRB	0x5,0
245:              				A_LED4_OUT;
  021E    1683    SETB	0x3,5
  021F    1185    CLRB	0x5,3
246:              				A_LED2 = 1;
  0220    1283    CLRB	0x3,5
  0221    1406    SETB	0x6,0
247:              				A_LED4 = 0;
  0222    1683    SETB	0x3,5
  0223    1186    CLRB	0x6,3
  0224    0008    RET
248:              			}
249:              			break;
250:              			case 5:
251:              			if(shiweiNum & 0x10)
  0225    1E62    SNZB	0x62,4
  0226    0008    RET
252:              			{
253:              				A_LED2_OUT;
  0227    1005    CLRB	0x5,0
254:              				A_LED5_OUT;
  0228    1683    SETB	0x3,5
  0229    1205    CLRB	0x5,4
255:              				A_LED2 = 1;
  022A    1283    CLRB	0x3,5
  022B    1406    SETB	0x6,0
256:              				A_LED5 = 0;
  022C    1683    SETB	0x3,5
  022D    1206    CLRB	0x6,4
  022E    0008    RET
257:              			}
258:              			break;
259:              			case 6:
260:              			if(shiweiNum & 0x20)
  022F    1EE2    SNZB	0x62,5
  0230    0008    RET
261:              			{
262:              				A_LED3_OUT;
  0231    1285    CLRB	0x5,5
263:              				A_LED5_OUT;
  0232    1683    SETB	0x3,5
  0233    1205    CLRB	0x5,4
264:              				A_LED3 = 1;
  0234    1283    CLRB	0x3,5
  0235    1686    SETB	0x6,5
265:              				A_LED5 = 0;
  0236    1683    SETB	0x3,5
  0237    1206    CLRB	0x6,4
  0238    0008    RET
266:              			}
267:              			break;
268:              			case 7:
269:              			if(shiweiNum & 0x40)
  0239    1F62    SNZB	0x62,6
  023A    0008    RET
270:              			{
271:              				A_LED4_OUT;
  023B    1683    SETB	0x3,5
  023C    1185    CLRB	0x5,3
272:              				A_LED5_OUT;
  023D    1205    CLRB	0x5,4
273:              				A_LED4 = 1;
  023E    1586    SETB	0x6,3
274:              				A_LED5 = 0;
  023F    1206    CLRB	0x6,4
  0240    0008    RET
275:              			}
276:              			break;
277:              			case 8:
278:              			if(geweiNum & 0x01)
  0241    1C61    SNZB	0x61,0
  0242    0008    RET
279:              			{
280:              				A_LED1_OUT;
  0243    1085    CLRB	0x5,1
281:              				A_LED2_OUT;
  0244    1005    CLRB	0x5,0
282:              				A_LED2 = 1;
  0245    1406    SETB	0x6,0
283:              				A_LED1 = 0;
  0246    1086    CLRB	0x6,1
  0247    0008    RET
284:              			}
285:              			break;
286:              			case 9:
287:              			if(geweiNum & 0x02)
  0248    1CE1    SNZB	0x61,1
  0249    0008    RET
288:              			{
289:              				A_LED1_OUT;
  024A    1085    CLRB	0x5,1
290:              				A_LED2_OUT;
  024B    1005    CLRB	0x5,0
291:              				A_LED1 = 1;
  024C    1486    SETB	0x6,1
292:              				A_LED2 = 0;
  024D    1006    CLRB	0x6,0
  024E    0008    RET
293:              			}
294:              			break;
295:              			case 10:
296:              			if(geweiNum & 0x04)
  024F    1D61    SNZB	0x61,2
  0250    0008    RET
297:              			{
298:              				A_LED1_OUT;
  0251    1085    CLRB	0x5,1
299:              				A_LED3_OUT;
  0252    1285    CLRB	0x5,5
300:              				A_LED3 = 1;
  0253    1686    SETB	0x6,5
301:              				A_LED1 = 0;
  0254    1086    CLRB	0x6,1
  0255    0008    RET
302:              			}
303:              			break;
304:              			case 11:
305:              			if(geweiNum & 0x08)
  0256    1DE1    SNZB	0x61,3
  0257    0008    RET
306:              			{
307:              				A_LED1_OUT;
  0258    1085    CLRB	0x5,1
308:              				A_LED3_OUT;
  0259    1285    CLRB	0x5,5
309:              				A_LED1 = 1;
  025A    1486    SETB	0x6,1
310:              				A_LED3 = 0;
  025B    1286    CLRB	0x6,5
  025C    0008    RET
311:              			}
312:              			break;
313:              			case 12:
314:              			if(geweiNum & 0x10)
  025D    1E61    SNZB	0x61,4
  025E    0008    RET
315:              			{
316:              				A_LED1_OUT;
  025F    1085    CLRB	0x5,1
317:              				A_LED4_OUT;
  0260    1683    SETB	0x3,5
  0261    1185    CLRB	0x5,3
318:              				A_LED4 = 1;
  0262    1586    SETB	0x6,3
319:              				A_LED1 = 0;
  0263    1283    CLRB	0x3,5
  0264    1086    CLRB	0x6,1
  0265    0008    RET
320:              			}
321:              			break;
322:              			case 13:
323:              			if(geweiNum & 0x20)
  0266    1EE1    SNZB	0x61,5
  0267    0008    RET
324:              			{
325:              				A_LED1_OUT;
  0268    1085    CLRB	0x5,1
326:              				A_LED4_OUT;
  0269    1683    SETB	0x3,5
  026A    1185    CLRB	0x5,3
327:              				A_LED1 = 1;
  026B    1283    CLRB	0x3,5
  026C    1486    SETB	0x6,1
328:              				A_LED4 = 0;
  026D    1683    SETB	0x3,5
  026E    1186    CLRB	0x6,3
  026F    0008    RET
329:              			}
330:              			break;
331:              			case 0:
332:              			if(geweiNum & 0x40)
  0270    1F61    SNZB	0x61,6
  0271    0008    RET
333:              			{
334:              				A_LED1_OUT;
  0272    1085    CLRB	0x5,1
335:              				A_LED5_OUT;
  0273    1683    SETB	0x3,5
  0274    1205    CLRB	0x5,4
336:              				A_LED1 = 1;
  0275    1283    CLRB	0x3,5
  0276    1486    SETB	0x6,1
337:              				A_LED5 = 0;
  0277    1683    SETB	0x3,5
  0278    1206    CLRB	0x6,4
  0279    0008    RET
338:              			}
339:              			break;
340:              			case 14:
341:              			if(chrgFlag == 0 && RB2 == 0)
  027A    087A    LD	A,0x7A
  027B    1903    SZB	0x3,2
  027C    1906    SZB	0x6,2
  027D    0008    RET
342:              			{
343:              				A_LED2_OUT;
  027E    1005    CLRB	0x5,0
344:              				A_LED4_OUT;
  027F    1683    SETB	0x3,5
  0280    1185    CLRB	0x5,3
345:              				A_LED4 = 1;
  0281    1586    SETB	0x6,3
346:              				A_LED2 = 0;
  0282    1283    CLRB	0x3,5
  0283    1006    CLRB	0x6,0
  0284    0008    RET
347:              			}
348:              			break;
349:              			case 15:
350:              			if(chrgFlag == 0 && RB2 == 0)
  0285    2A7A    JP	0x27A
351:              			{
352:              				A_LED2_OUT;
353:              				A_LED4_OUT;
354:              				A_LED4 = 1;
355:              				A_LED2 = 0;
356:              			}
357:              			break;
358:              			case 16:
359:              			if(chrgFlag == 0 && RB2 == 0)
  0286    0846    LD	A,0x46
  0287    0084    LD	0x4,A
  0288    3011    LDIA	0x11
  0289    0204    SUBA	0x4
  028A    1803    SZB	0x3,0
  028B    0008    RET
  028C    3005    LDIA	0x5
  028D    008A    LD	0xA,A
  028E    30A1    LDIA	0xA1
  028F    0704    ADDA	0x4
  0290    0082    LD	0x2,A
  0291    0008    RET
360:              			{
361:              				A_LED2_OUT;
362:              				A_LED4_OUT;
363:              				A_LED4 = 1;
364:              				A_LED2 = 0;
365:              			}
366:              			break;
367:              			default:
368:              			break;
369:              		}
370:              	}
371:              	
372:              	
373:              }
374:              
375:              
376:              void ledCtr()
377:              {
378:              	if(firstTime > 0)
  0335    0863    LD	A,0x63
  0336    1903    SZB	0x3,2
  0337    2B40    JP	0x340
379:              	{
380:              		firstTime--;
  0338    03E3    DECR	0x63
381:              		if(prePwStep < pwStep)
  0339    0840    LD	A,0x40
  033A    023F    SUBA	0x3F
  033B    1803    SZB	0x3,0
  033C    0008    RET
382:              		{
383:              			prePwStep = pwStep;
  033D    0840    LD	A,0x40
  033E    00BF    LD	0x3F,A
  033F    0008    RET
384:              		}
385:              	}
386:              	else if(overWorkTime > 0)
  0340    0834    LD	A,0x34
  0341    1903    SZB	0x3,2
  0342    2B4B    JP	0x34B
  0343    3001    LDIA	0x1
387:              	{
388:              		overWorkTime--;
  0344    03B4    DECR	0x34
389:              		shiweiNum = numArray[0];
  0345    0084    LD	0x4,A
  0346    257C    CALL	0x57C
  0347    00E2    LD	0x62,A
390:              		geweiNum = 0x71;
  0348    3071    LDIA	0x71
  0349    00E1    LD	0x61,A
391:              	}
  034A    0008    RET
392:              	else if(showBatTime > 0)
  034B    083D    LD	A,0x3D
  034C    1903    SZB	0x3,2
  034D    2B5D    JP	0x35D
  034E    300A    LDIA	0xA
393:              	{
394:              		showBatTime--;
  034F    03BD    DECR	0x3D
395:              		shiweiNum = numArray[prePwStep/10];
  0350    00F3    LD	0x73,A
  0351    083F    LD	A,0x3F
  0352    2547    CALL	0x547
  0353    3E01    ADDIA	0x1
  0354    0084    LD	0x4,A
  0355    257C    CALL	0x57C
396:              		geweiNum = numArray[prePwStep%10];
  0356    2393    CALL	0x393
  0357    252B    CALL	0x52B
  0358    3E01    ADDIA	0x1
  0359    0084    LD	0x4,A
  035A    257C    CALL	0x57C
  035B    00E1    LD	0x61,A
397:              	}
  035C    0008    RET
398:              	else if(workStep > 0)
  035D    0879    LD	A,0x79
  035E    1903    SZB	0x3,2
  035F    2B78    JP	0x378
399:              	{
400:              		
401:              		if(workStep <  10)
  0360    300A    LDIA	0xA
  0361    0279    SUBA	0x79
  0362    1803    SZB	0x3,0
  0363    2B6E    JP	0x36E
402:              		{
403:              			shiweiNum = numArray[0];
  0364    3001    LDIA	0x1
  0365    0084    LD	0x4,A
  0366    257C    CALL	0x57C
  0367    00E2    LD	0x62,A
404:              			geweiNum = numArray[workStep];
  0368    0879    LD	A,0x79
  0369    3E01    ADDIA	0x1
  036A    0084    LD	0x4,A
  036B    257C    CALL	0x57C
  036C    00E1    LD	0x61,A
405:              		}
  036D    0008    RET
406:              		else
407:              		{
408:              			shiweiNum = numArray[1];
  036E    3002    LDIA	0x2
  036F    0084    LD	0x4,A
  0370    257C    CALL	0x57C
  0371    00E2    LD	0x62,A
409:              			geweiNum = numArray[workStep - 10];
  0372    0879    LD	A,0x79
  0373    3EF7    ADDIA	0xF7
  0374    0084    LD	0x4,A
  0375    257C    CALL	0x57C
  0376    00E1    LD	0x61,A
  0377    0008    RET
410:              		}
411:              
412:              	}
413:              	else if(chrgFullFlag || (chrgFlag && count1s < 50))
  0378    084B    LD	A,0x4B
  0379    1D03    SNZB	0x3,2
  037A    2B82    JP	0x382
  037B    087A    LD	A,0x7A
  037C    1903    SZB	0x3,2
  037D    2B90    JP	0x390
  037E    3032    LDIA	0x32
  037F    024D    SUBA	0x4D
  0380    1803    SZB	0x3,0
  0381    2B90    JP	0x390
414:              	{
415:              		shiweiNum = numArray[prePwStep/10];
  0382    300A    LDIA	0xA
  0383    00F3    LD	0x73,A
  0384    083F    LD	A,0x3F
  0385    2547    CALL	0x547
  0386    3E01    ADDIA	0x1
  0387    0084    LD	0x4,A
  0388    257C    CALL	0x57C
416:              		geweiNum = numArray[prePwStep%10];
  0389    2393    CALL	0x393
  038A    252B    CALL	0x52B
  038B    3E01    ADDIA	0x1
  038C    0084    LD	0x4,A
  038D    257C    CALL	0x57C
  038E    00E1    LD	0x61,A
417:              	}
  038F    0008    RET
418:              	else
419:              	{
420:              		shiweiNum = 0;
  0390    01E2    CLR	0x62
421:              		geweiNum = 0;
  0391    01E1    CLR	0x61
  0392    0008    RET
422:              	}
423:              }
424:              
425:              
426:              
427:              void chrgCtr()
428:              {
429:              	if(PORTA & 0x20)
  0018    1683    SETB	0x3,5
  0019    1E86    SNZB	0x6,5
  001A    28DE    JP	0xDE
430:              	{
431:              		if(chrgFlag == 0)
  001B    087A    LD	A,0x7A
  001C    1D03    SNZB	0x3,2
  001D    2823    JP	0x23
432:              		{
433:              			chrgFlag = 1;
  001E    01FA    CLR	0x7A
  001F    0AFA    INCR	0x7A
434:              			chrgMaxDuty = 0;
  0020    1283    CLRB	0x3,5
  0021    01B6    CLR	0x36
435:              			chrgPwmStop();
  0022    25DA    CALL	0x5DA
436:              		}
437:              		workStep = 0;
  0023    01F9    CLR	0x79
438:              		pwmStop();
  0024    25CA    CALL	0x5CA
439:              		lowBatFlag = 0;
  0025    01B3    CLR	0x33
440:              		if(prePwStep < pwStep)
  0026    0840    LD	A,0x40
  0027    023F    SUBA	0x3F
  0028    1803    SZB	0x3,0
  0029    2833    JP	0x33
441:              		{
442:              			if(++count50s > 3000)
  002A    20FC    CALL	0xFC
  002B    1903    SZB	0x3,2
  002C    0226    SUBA	0x26
  002D    1C03    SNZB	0x3,0
  002E    2835    JP	0x35
443:              			{
444:              				count50s = 0;
  002F    01A6    CLR	0x26
  0030    01A7    CLR	0x27
445:              				prePwStep++;
  0031    0ABF    INCR	0x3F
  0032    2835    JP	0x35
446:              			}
447:              		}
448:              		else
449:              		{
450:              			count50s = 0;
  0033    01A6    CLR	0x26
  0034    01A7    CLR	0x27
451:              		}
452:              		if(protectFlag)
  0035    0848    LD	A,0x48
  0036    1903    SZB	0x3,2
  0037    284A    JP	0x4A
453:              		{
454:              			chrgPwmStop();
  0038    25DA    CALL	0x5DA
455:              			if(prePwStep < 99 && protectFlag == 1)
  0039    3063    LDIA	0x63
  003A    023F    SUBA	0x3F
  003B    1803    SZB	0x3,0
  003C    2848    JP	0x48
  003D    0B48    SZDECA	0x48
  003E    2848    JP	0x48
456:              			{
457:              				if(++reChrgCount > 250)
  003F    30FB    LDIA	0xFB
  0040    0ABE    INCR	0x3E
  0041    023E    SUBA	0x3E
  0042    1C03    SNZB	0x3,0
  0043    0008    RET
458:              				{
459:              					reChrgCount = 0;
  0044    01BE    CLR	0x3E
460:              					chrgFullFlag = 0;
  0045    01CB    CLR	0x4B
461:              					protectFlag = 0;
  0046    01C8    CLR	0x48
  0047    0008    RET
462:              				}
463:              			}
464:              			else
465:              			{
466:              				reChrgCount = 0;
  0048    01BE    CLR	0x3E
  0049    0008    RET
467:              			}
468:              			return;
469:              		}
470:              		if(batADValue < 1118)
  004A    3004    LDIA	0x4
  004B    0229    SUBA	0x29
  004C    305E    LDIA	0x5E
  004D    1903    SZB	0x3,2
  004E    0228    SUBA	0x28
  004F    1803    SZB	0x3,0
  0050    2854    JP	0x54
  0051    300F    LDIA	0xF
471:              		{
472:              			chrgMode = 0;
  0052    01BC    CLR	0x3C
473:              			chrgMaxAD = 15;
  0053    286D    JP	0x6D
474:              		}
475:              		else if(batADValue < 1530)
  0054    3005    LDIA	0x5
  0055    0229    SUBA	0x29
  0056    30FA    LDIA	0xFA
  0057    1903    SZB	0x3,2
  0058    0228    SUBA	0x28
  0059    1803    SZB	0x3,0
  005A    2861    JP	0x61
  005B    304D    LDIA	0x4D
476:              		{
477:              			chrgMode = 1;
  005C    01BC    CLR	0x3C
  005D    0ABC    INCR	0x3C
478:              			chrgMaxAD = 77;
  005E    00BB    LD	0x3B,A
479:              			lockCount = 0;
  005F    01BA    CLR	0x3A
480:              		}
  0060    286E    JP	0x6E
481:              		else if(count1s == 0)
  0061    084D    LD	A,0x4D
  0062    1D03    SNZB	0x3,2
  0063    286E    JP	0x6E
482:              		{
483:              			if(++lockCount > 200)
  0064    30C9    LDIA	0xC9
  0065    0ABA    INCR	0x3A
  0066    023A    SUBA	0x3A
  0067    1C03    SNZB	0x3,0
  0068    286C    JP	0x6C
  0069    3002    LDIA	0x2
484:              			{
485:              				lockCount = 0;
  006A    01BA    CLR	0x3A
486:              				chrgMode = 2;
  006B    00BC    LD	0x3C,A
487:              			}
488:              			
489:              			chrgMaxAD = 77;
  006C    304D    LDIA	0x4D
  006D    00BB    LD	0x3B,A
490:              		}
491:              		if(chrgMode == 2 && outADValue < 8)
  006E    3002    LDIA	0x2
  006F    063C    XORA	0x3C
  0070    1D03    SNZB	0x3,2
  0071    2888    JP	0x88
  0072    3000    LDIA	0x0
  0073    022B    SUBA	0x2B
  0074    3008    LDIA	0x8
  0075    1903    SZB	0x3,2
  0076    022A    SUBA	0x2A
  0077    1803    SZB	0x3,0
  0078    2888    JP	0x88
492:              		{
493:              			if(++fullCount >= 200)
  0079    0AA4    INCR	0x24
  007A    1903    SZB	0x3,2
  007B    0AA5    INCR	0x25
  007C    3000    LDIA	0x0
  007D    0225    SUBA	0x25
  007E    30C8    LDIA	0xC8
  007F    1903    SZB	0x3,2
  0080    0224    SUBA	0x24
  0081    1C03    SNZB	0x3,0
  0082    288A    JP	0x8A
494:              			{
495:              				fullCount = 0;
  0083    01A4    CLR	0x24
  0084    01A5    CLR	0x25
496:              				chrgFullFlag = 1;
  0085    01CB    CLR	0x4B
  0086    0ACB    INCR	0x4B
  0087    288A    JP	0x8A
497:              			}
498:              		}
499:              		else
500:              		{
501:              			fullCount = 0;
  0088    01A4    CLR	0x24
  0089    01A5    CLR	0x25
502:              		}
503:              		if(chrgFullFlag)
  008A    084B    LD	A,0x4B
  008B    1903    SZB	0x3,2
  008C    288E    JP	0x8E
504:              		{
505:              			chrgPwmStop();
  008D    2DDA    JP	0x5DA
506:              		}
507:              		else
508:              		{
509:              				if(batADValue > 1550 || outADValue > (chrgMaxAD + 2))
  008E    3006    LDIA	0x6
  008F    0229    SUBA	0x29
  0090    300F    LDIA	0xF
  0091    1903    SZB	0x3,2
  0092    0228    SUBA	0x28
  0093    1803    SZB	0x3,0
  0094    28A4    JP	0xA4
  0095    083B    LD	A,0x3B
  0096    3E02    ADDIA	0x2
  0097    00F3    LD	0x73,A
  0098    3000    LDIA	0x0
  0099    1803    SZB	0x3,0
  009A    3001    LDIA	0x1
  009B    00F4    LD	0x74,A
  009C    082B    LD	A,0x2B
  009D    0274    SUBA	0x74
  009E    1D03    SNZB	0x3,2
  009F    28A2    JP	0xA2
  00A0    082A    LD	A,0x2A
  00A1    0273    SUBA	0x73
  00A2    1803    SZB	0x3,0
  00A3    28B3    JP	0xB3
510:              				{
511:              					if(++subTime > chrgWaitTime)
  00A4    0AB8    INCR	0x38
  00A5    0838    LD	A,0x38
  00A6    0237    SUBA	0x37
  00A7    1803    SZB	0x3,0
  00A8    28B1    JP	0xB1
512:              					{
513:              						if(chrgMaxDuty > 1)
  00A9    3002    LDIA	0x2
  00AA    0236    SUBA	0x36
  00AB    1C03    SNZB	0x3,0
  00AC    28AE    JP	0xAE
514:              						{
515:              							chrgMaxDuty--;
  00AD    03B6    DECR	0x36
  00AE    30FA    LDIA	0xFA
516:              						}
517:              						subTime = 0;
  00AF    01B8    CLR	0x38
518:              						chrgWaitTime = 250;
  00B0    00B7    LD	0x37,A
519:              					}
520:              					addTime = 0;
  00B1    01B9    CLR	0x39
521:              				}
  00B2    28D3    JP	0xD3
522:              				else if(batADValue < 1550 && outADValue < (chrgMaxAD - 4))
  00B3    3006    LDIA	0x6
  00B4    0229    SUBA	0x29
  00B5    300E    LDIA	0xE
  00B6    1903    SZB	0x3,2
  00B7    0228    SUBA	0x28
  00B8    1803    SZB	0x3,0
  00B9    28D3    JP	0xD3
  00BA    083B    LD	A,0x3B
  00BB    3EFC    ADDIA	0xFC
  00BC    00F3    LD	0x73,A
  00BD    30FF    LDIA	0xFF
  00BE    1803    SZB	0x3,0
  00BF    3000    LDIA	0x0
  00C0    00F4    LD	0x74,A
  00C1    022B    SUBA	0x2B
  00C2    1D03    SNZB	0x3,2
  00C3    28C6    JP	0xC6
  00C4    0873    LD	A,0x73
  00C5    022A    SUBA	0x2A
  00C6    1803    SZB	0x3,0
  00C7    28D3    JP	0xD3
523:              				{
524:              					if(++addTime > chrgWaitTime)
  00C8    0AB9    INCR	0x39
  00C9    0839    LD	A,0x39
  00CA    0237    SUBA	0x37
  00CB    1803    SZB	0x3,0
  00CC    28D2    JP	0xD2
  00CD    304B    LDIA	0x4B
525:              					{
526:              						addTime = 0;
  00CE    01B9    CLR	0x39
527:              						if(chrgMaxDuty < 75)
  00CF    0236    SUBA	0x36
  00D0    1C03    SNZB	0x3,0
528:              						{
529:              							chrgMaxDuty++;
  00D1    0AB6    INCR	0x36
530:              						}
531:              					}
532:              					subTime = 0;
  00D2    01B8    CLR	0x38
533:              				}
534:              				
535:              	
536:              				if(chrgPwmFlag == 0)
  00D3    0831    LD	A,0x31
  00D4    1D03    SNZB	0x3,2
  00D5    28D7    JP	0xD7
537:              				{
538:              					chrgPwmInit();
  00D6    2590    CALL	0x590
539:              				}
540:              				PWMD23H = 0X00;
  00D7    1683    SETB	0x3,5
  00D8    019E    CLR	0x1E
541:              				PWMD2L = chrgMaxDuty;
  00D9    1283    CLRB	0x3,5
  00DA    0836    LD	A,0x36
  00DB    1683    SETB	0x3,5
  00DC    009B    LD	0x1B,A
  00DD    0008    RET
  00DE    3014    LDIA	0x14
542:              		}
543:              	}
544:              	else
545:              	{
546:              		startChrgTime = 0;
547:              		chrgFlag = 0;
  00DF    01FA    CLR	0x7A
548:              		chrgFullFlag = 0;
  00E0    1283    CLRB	0x3,5
  00E1    01CB    CLR	0x4B
549:              		protectFlag = 0;
  00E2    01C8    CLR	0x48
550:              		chrgMode = 0;
  00E3    01BC    CLR	0x3C
551:              		chrgMaxAD = 0;
  00E4    01BB    CLR	0x3B
552:              		chrgMaxDuty = 0;
  00E5    01B6    CLR	0x36
553:              		lockCount = 0;
554:              		lockLedStep = 0;
  00E6    01BA    CLR	0x3A
555:              		chrgWaitTime = 20;
  00E7    00B7    LD	0x37,A
556:              		chrgPwmStop();
  00E8    25DA    CALL	0x5DA
557:              		if(prePwStep > 0 && prePwStep > pwStep)
  00E9    083F    LD	A,0x3F
  00EA    1903    SZB	0x3,2
  00EB    28F9    JP	0xF9
  00EC    083F    LD	A,0x3F
  00ED    0240    SUBA	0x40
  00EE    1803    SZB	0x3,0
  00EF    28F9    JP	0xF9
558:              		{
559:              			if(++count50s > 3000)
  00F0    20FC    CALL	0xFC
  00F1    1903    SZB	0x3,2
  00F2    0226    SUBA	0x26
  00F3    1C03    SNZB	0x3,0
  00F4    0008    RET
560:              			{
561:              				count50s = 0;
  00F5    01A6    CLR	0x26
  00F6    01A7    CLR	0x27
562:              				prePwStep--;
  00F7    03BF    DECR	0x3F
  00F8    0008    RET
563:              			}
564:              		}
565:              		else
566:              		{
567:              			count50s = 0;
  00F9    01A6    CLR	0x26
  00FA    01A7    CLR	0x27
  00FB    0008    RET
568:              		}
569:              	}
570:              }
571:              
572:              
573:              
574:              char keyRead(char keyStatus)	
  04C1    00F3    LD	0x73,A
575:              { 
576:              	if(keyStatus)
  04C2    0873    LD	A,0x73
  04C3    1903    SZB	0x3,2
  04C4    2CDE    JP	0x4DE
577:              	{
578:              		keyCount++;
  04C5    0AC5    INCR	0x45
579:              		if(overWorkTime > 0)
  04C6    0834    LD	A,0x34
  04C7    1903    SZB	0x3,2
  04C8    2CCC    JP	0x4CC
580:              		{
581:              			overWorkTime = 200;
  04C9    30C8    LDIA	0xC8
  04CA    00B4    LD	0x34,A
582:              		}
  04CB    2CD1    JP	0x4D1
583:              		else if(workStep == 0)
  04CC    0879    LD	A,0x79
  04CD    1D03    SNZB	0x3,2
  04CE    2CD1    JP	0x4D1
584:              		{
585:              			showBatTime = 200;
  04CF    30C8    LDIA	0xC8
  04D0    00BD    LD	0x3D,A
586:              		}
587:              		if(keyCount >= 100)
  04D1    3064    LDIA	0x64
  04D2    0245    SUBA	0x45
  04D3    1C03    SNZB	0x3,0
  04D4    3400    RET	0x0
588:              		{
589:              			keyCount = 100;
  04D5    3064    LDIA	0x64
  04D6    00C5    LD	0x45,A
590:              			if(!longPressFlag)
  04D7    0844    LD	A,0x44
  04D8    1D03    SNZB	0x3,2
  04D9    3400    RET	0x0
  04DA    3002    LDIA	0x2
591:              			{
592:              				longPressFlag = 1;
  04DB    01C4    CLR	0x44
  04DC    0AC4    INCR	0x44
593:              				return 2;
  04DD    0008    RET
594:              			}
595:              		}
596:              	}
597:              	else
598:              	{
599:              		if(keyCount >= 100)
  04DE    3064    LDIA	0x64
  04DF    0245    SUBA	0x45
  04E0    1C03    SNZB	0x3,0
  04E1    2CE5    JP	0x4E5
600:              		{
601:              			keyCount = 0;
  04E2    01C5    CLR	0x45
602:              			longPressFlag = 0;
  04E3    01C4    CLR	0x44
603:              			return	0;
  04E4    3400    RET	0x0
604:              		}
605:              		else if(keyCount >= 6)
  04E5    3006    LDIA	0x6
  04E6    0245    SUBA	0x45
606:              		{
607:              			keyCount = 0;
  04E7    01C5    CLR	0x45
  04E8    1803    SZB	0x3,0
608:              			return	1;
  04E9    3401    RET	0x1
  04EA    3400    RET	0x0
609:              		}
610:              		keyCount = 0;
611:              	}
612:              	return 0;
613:              }
614:              
615:              
616:              void keyCtr()
617:              {
618:              	char kclick = keyRead(0x04 & (~PORTB));
  04EB    0906    COMA	0x6
  04EC    3904    ANDIA	0x4
  04ED    24C1    CALL	0x4C1
  04EE    00F4    LD	0x74,A
619:              	if(kclick == 1 && workStep > 0)
  04EF    0B74    SZDECA	0x74
  04F0    2CFC    JP	0x4FC
  04F1    0879    LD	A,0x79
  04F2    1903    SZB	0x3,2
  04F3    2CFC    JP	0x4FC
620:              	{
621:              
622:              		if(++workStep > 12)
  04F4    300D    LDIA	0xD
  04F5    0AF9    INCR	0x79
  04F6    0279    SUBA	0x79
  04F7    1C03    SNZB	0x3,0
  04F8    0008    RET
623:              		{
624:              			workStep = 1;
  04F9    01F9    CLR	0x79
  04FA    0AF9    INCR	0x79
  04FB    0008    RET
625:              		}
626:              		curDuty = 158;
627:              
628:              	}
629:              	else if(kclick == 2)
  04FC    3002    LDIA	0x2
  04FD    0674    XORA	0x74
  04FE    1D03    SNZB	0x3,2
  04FF    0008    RET
630:              	{
631:              		if(workStep > 0)
  0500    0879    LD	A,0x79
  0501    1903    SZB	0x3,2
  0502    2D07    JP	0x507
  0503    30C8    LDIA	0xC8
632:              		{
633:              			workStep = 0;
  0504    01F9    CLR	0x79
634:              			overWorkTime = 200;
  0505    00B4    LD	0x34,A
635:              		}
  0506    0008    RET
  0507    301E    LDIA	0x1E
636:              		else
637:              		{
638:              			workStep = 1;
  0508    01F9    CLR	0x79
  0509    0AF9    INCR	0x79
639:              			startTime = 30;
  050A    00C2    LD	0x42,A
640:              			showBatTime = 0;
  050B    01BD    CLR	0x3D
641:              			overWorkTime = 0;
  050C    01B4    CLR	0x34
  050D    0008    RET
642:              		}
643:              	}
644:              }
645:              
646:              
647:              
648:              
649:              void workCtr()
650:              {
651:              
652:              	if(startTime > 0)
  0398    1283    CLRB	0x3,5
  0399    0842    LD	A,0x42
  039A    1D03    SNZB	0x3,2
653:              	{
654:              		startTime--;
  039B    03C2    DECR	0x42
655:              	}
656:              	if(workStep > 0)
  039C    0879    LD	A,0x79
  039D    1903    SZB	0x3,2
  039E    2BEC    JP	0x3EC
657:              	{
658:              		if(motorPwmFlag == 0)
  039F    0830    LD	A,0x30
  03A0    1D03    SNZB	0x3,2
  03A1    2BA3    JP	0x3A3
659:              		{
660:              			pwmInit();
  03A2    25B2    CALL	0x5B2
661:              			
662:              		}
663:              		if(workStep == 1)
  03A3    0B79    SZDECA	0x79
  03A4    2BA7    JP	0x3A7
664:              		{
665:              			maxDuty = 158;
  03A5    309E    LDIA	0x9E
  03A6    2BE4    JP	0x3E4
666:              		}
667:              		else if(workStep == 2)
  03A7    3002    LDIA	0x2
  03A8    0679    XORA	0x79
  03A9    1D03    SNZB	0x3,2
  03AA    2BAD    JP	0x3AD
668:              			maxDuty = 163;
  03AB    30A3    LDIA	0xA3
  03AC    2BE4    JP	0x3E4
669:              		else if(workStep == 3)
  03AD    3003    LDIA	0x3
  03AE    0679    XORA	0x79
  03AF    1D03    SNZB	0x3,2
  03B0    2BB3    JP	0x3B3
670:              			maxDuty = 167;
  03B1    30A7    LDIA	0xA7
  03B2    2BE4    JP	0x3E4
671:              		else if(workStep == 4)
  03B3    3004    LDIA	0x4
  03B4    0679    XORA	0x79
  03B5    1D03    SNZB	0x3,2
  03B6    2BB9    JP	0x3B9
672:              			maxDuty = 170;
  03B7    30AA    LDIA	0xAA
  03B8    2BE4    JP	0x3E4
673:              		else if(workStep == 5)
  03B9    3005    LDIA	0x5
  03BA    0679    XORA	0x79
  03BB    1D03    SNZB	0x3,2
  03BC    2BBF    JP	0x3BF
674:              			maxDuty = 173;
  03BD    30AD    LDIA	0xAD
  03BE    2BE4    JP	0x3E4
675:              		else if(workStep == 6)
  03BF    3006    LDIA	0x6
  03C0    0679    XORA	0x79
  03C1    1D03    SNZB	0x3,2
  03C2    2BC5    JP	0x3C5
676:              			maxDuty = 177;
  03C3    30B1    LDIA	0xB1
  03C4    2BE4    JP	0x3E4
677:              		else if(workStep == 7)
  03C5    3007    LDIA	0x7
  03C6    0679    XORA	0x79
  03C7    1D03    SNZB	0x3,2
  03C8    2BCB    JP	0x3CB
678:              			maxDuty = 180;
  03C9    30B4    LDIA	0xB4
  03CA    2BE4    JP	0x3E4
679:              		else if(workStep == 8)
  03CB    3008    LDIA	0x8
  03CC    0679    XORA	0x79
  03CD    1D03    SNZB	0x3,2
  03CE    2BD1    JP	0x3D1
680:              			maxDuty = 184;
  03CF    30B8    LDIA	0xB8
  03D0    2BE4    JP	0x3E4
681:              		else if(workStep == 9)
  03D1    3009    LDIA	0x9
  03D2    0679    XORA	0x79
  03D3    1D03    SNZB	0x3,2
  03D4    2BD7    JP	0x3D7
682:              			maxDuty = 188;
  03D5    30BC    LDIA	0xBC
  03D6    2BE4    JP	0x3E4
683:              		else if(workStep == 10)
  03D7    300A    LDIA	0xA
  03D8    0679    XORA	0x79
  03D9    1D03    SNZB	0x3,2
  03DA    2BDD    JP	0x3DD
684:              			maxDuty = 192;
  03DB    30C0    LDIA	0xC0
  03DC    2BE4    JP	0x3E4
685:              		else if(workStep == 11)
  03DD    300B    LDIA	0xB
  03DE    0679    XORA	0x79
  03DF    1D03    SNZB	0x3,2
  03E0    2BE3    JP	0x3E3
686:              			maxDuty = 196;
  03E1    30C4    LDIA	0xC4
  03E2    2BE4    JP	0x3E4
687:              		else
688:              		{
689:              			maxDuty = 200;
  03E3    30C8    LDIA	0xC8
  03E4    00C3    LD	0x43,A
690:              		}
691:              		PWMD23H = 0;
  03E5    1683    SETB	0x3,5
  03E6    019E    CLR	0x1E
692:              		PWMD3L = maxDuty;
  03E7    1283    CLRB	0x3,5
  03E8    0843    LD	A,0x43
  03E9    1683    SETB	0x3,5
  03EA    009C    LD	0x1C,A
693:              		
694:              		
695:              	}
  03EB    0008    RET
696:              	else
697:              	{
698:              		pwmStop();
  03EC    25CA    CALL	0x5CA
699:              		count900s = 0;
  03ED    01A0    CLR	0x20
  03EE    01A1    CLR	0x21
  03EF    0008    RET
700:              	}
701:              	
702:              }
703:              
704:              void checkOutA()
705:              {
706:              	test_adc = ADC_Sample(0, 5);		//测试AN0口的AD值，参考电压2V
  0484    3005    LDIA	0x5
  0485    00F3    LD	0x73,A
  0486    3000    LDIA	0x0
  0487    2102    CALL	0x102
  0488    00CF    LD	0x4F,A
707:              	if (0xA5 == test_adc)				//测试完成，如因其他原因导致AD转换没有完成，则不处理
  0489    30A5    LDIA	0xA5
  048A    064F    XORA	0x4F
  048B    1D03    SNZB	0x3,2
  048C    2CB9    JP	0x4B9
708:              	{
709:              		if(chrgFlag && adresult > 210)
  048D    087A    LD	A,0x7A
  048E    1903    SZB	0x3,2
  048F    2CA0    JP	0x4A0
  0490    3000    LDIA	0x0
  0491    0278    SUBA	0x78
  0492    30D3    LDIA	0xD3
  0493    1903    SZB	0x3,2
  0494    0277    SUBA	0x77
  0495    1C03    SNZB	0x3,0
  0496    2CA0    JP	0x4A0
710:              		{
711:              			if(++overChrgTime > 10)
  0497    300B    LDIA	0xB
  0498    0AC1    INCR	0x41
  0499    0241    SUBA	0x41
  049A    1C03    SNZB	0x3,0
  049B    2CA1    JP	0x4A1
  049C    3002    LDIA	0x2
712:              			{
713:              				overChrgTime = 0;
  049D    01C1    CLR	0x41
714:              				protectFlag = 2;
  049E    00C8    LD	0x48,A
  049F    2CA1    JP	0x4A1
715:              			}
716:              			
717:              		}
718:              		else
719:              		{
720:              			overChrgTime = 0;
  04A0    01C1    CLR	0x41
721:              		}
722:              		outADValue = adresult;
  04A1    0878    LD	A,0x78
  04A2    00AB    LD	0x2B,A
  04A3    0877    LD	A,0x77
  04A4    00AA    LD	0x2A,A
723:              		//电机坏了过载保护
724:                      if(workStep && (outADValue > 600))
  04A5    0879    LD	A,0x79
  04A6    1903    SZB	0x3,2
  04A7    2CB7    JP	0x4B7
  04A8    3002    LDIA	0x2
  04A9    022B    SUBA	0x2B
  04AA    3059    LDIA	0x59
  04AB    1903    SZB	0x3,2
  04AC    022A    SUBA	0x2A
  04AD    1C03    SNZB	0x3,0
  04AE    2CB7    JP	0x4B7
725:                      {
726:                      	if(++workOverOutTime > 50)
  04AF    3033    LDIA	0x33
  04B0    0AC7    INCR	0x47
  04B1    0247    SUBA	0x47
  04B2    1C03    SNZB	0x3,0
  04B3    0008    RET
727:                      	{
728:                      		workOverOutTime = 0;
  04B4    01C7    CLR	0x47
729:                      		workStep = 0;
  04B5    01F9    CLR	0x79
  04B6    0008    RET
730:                      	}
731:                      }
732:              		else
733:              		{
734:              			workOverOutTime = 0;
  04B7    01C7    CLR	0x47
  04B8    0008    RET
735:              		}
736:              		
737:              
738:              	}
739:              	else
740:              	{
741:              		ADCON0 = 0;						//如果转换没有完成，需初始化ADCON0,1
  04B9    1683    SETB	0x3,5
  04BA    0195    CLR	0x15
742:              		ADCON1 = 0;				
  04BB    0196    CLR	0x16
743:              		__delay_us(100);				//延时100us(编译器内置函数)
  04BC    3085    LDIA	0x85
  04BD    00F4    LD	0x74,A
  04BE    0BF4    SZDECR	0x74
  04BF    2CBE    JP	0x4BE
  04C0    0008    RET
744:              	}
745:              }
746:              
747:              void checkBatAD()
748:              {
749:              	test_adc = ADC_Sample(2, 5);		//测试AN2口的AD值，参考电压2V
  0292    3005    LDIA	0x5
  0293    00F3    LD	0x73,A
  0294    3002    LDIA	0x2
  0295    2102    CALL	0x102
  0296    00CF    LD	0x4F,A
750:              	if (0xA5 == test_adc)				//测试完成，如因其他原因导致AD转换没有完成，则不处理
  0297    30A5    LDIA	0xA5
  0298    064F    XORA	0x4F
  0299    1D03    SNZB	0x3,2
  029A    2AF2    JP	0x2F2
751:              	{
752:              		batADValue = adresult;
  029B    0878    LD	A,0x78
  029C    00A9    LD	0x29,A
  029D    0877    LD	A,0x77
  029E    00A8    LD	0x28,A
753:              		if(batADValue < 1117)
  029F    3004    LDIA	0x4
  02A0    0229    SUBA	0x29
  02A1    305D    LDIA	0x5D
  02A2    1903    SZB	0x3,2
  02A3    0228    SUBA	0x28
  02A4    1803    SZB	0x3,0
  02A5    2AB8    JP	0x2B8
754:                      {
755:                      	pwStep = 0;
  02A6    01C0    CLR	0x40
756:              			if(++count8s > 800)
  02A7    0AA2    INCR	0x22
  02A8    1903    SZB	0x3,2
  02A9    0AA3    INCR	0x23
  02AA    3003    LDIA	0x3
  02AB    0223    SUBA	0x23
  02AC    3021    LDIA	0x21
  02AD    1903    SZB	0x3,2
  02AE    0222    SUBA	0x22
  02AF    1C03    SNZB	0x3,0
  02B0    2AE5    JP	0x2E5
757:              			{
758:              				count8s = 0;
  02B1    01A2    CLR	0x22
  02B2    01A3    CLR	0x23
759:              				lowBatFlag = 1;
  02B3    01B3    CLR	0x33
  02B4    0AB3    INCR	0x33
760:              				prePwStep = 0;
  02B5    01BF    CLR	0x3F
761:              				workStep = 0;
  02B6    01F9    CLR	0x79
  02B7    2AE5    JP	0x2E5
  02B8    3005    LDIA	0x5
762:              			}
763:                      }
764:                      else
765:                      {
766:              	        count8s = 0;
  02B9    01A2    CLR	0x22
  02BA    01A3    CLR	0x23
767:              			if(batADValue >= 1340)
  02BB    0229    SUBA	0x29
  02BC    303C    LDIA	0x3C
  02BD    1903    SZB	0x3,2
  02BE    0228    SUBA	0x28
768:              	    	{
769:              	    		pwStep = ((batADValue - 1340) /2) + 13;
  02BF    0828    LD	A,0x28
  02C0    1C03    SNZB	0x3,0
  02C1    2ACF    JP	0x2CF
  02C2    3EC4    ADDIA	0xC4
  02C3    00F4    LD	0x74,A
  02C4    0829    LD	A,0x29
  02C5    1803    SZB	0x3,0
  02C6    3E01    ADDIA	0x1
  02C7    3EFA    ADDIA	0xFA
  02C8    00F5    LD	0x75,A
  02C9    1003    CLRB	0x3,0
  02CA    0CF5    RRCR	0x75
  02CB    0CF4    RRCR	0x74
  02CC    0874    LD	A,0x74
  02CD    3E0D    ADDIA	0xD
  02CE    2ADE    JP	0x2DE
770:              	    	}
  02CF    3EA3    ADDIA	0xA3
  02D0    00F4    LD	0x74,A
  02D1    0829    LD	A,0x29
  02D2    1803    SZB	0x3,0
  02D3    3E01    ADDIA	0x1
  02D4    3EFB    ADDIA	0xFB
  02D5    00F5    LD	0x75,A
  02D6    3004    LDIA	0x4
  02D7    1003    CLRB	0x3,0
  02D8    0CF5    RRCR	0x75
  02D9    0CF4    RRCR	0x74
  02DA    3EFF    ADDIA	0xFF
  02DB    1D03    SNZB	0x3,2
  02DC    2AD7    JP	0x2D7
  02DD    0874    LD	A,0x74
  02DE    00C0    LD	0x40,A
771:              	    	else
772:              	    	{
773:              	    		pwStep = (batADValue - 1117) / 16;
774:              	    	}
775:              	    	if(pwStep > 99)
  02DF    3064    LDIA	0x64
  02E0    0240    SUBA	0x40
  02E1    1C03    SNZB	0x3,0
  02E2    2AE5    JP	0x2E5
776:              	    	{
777:              	    		pwStep = 99;
  02E3    3063    LDIA	0x63
  02E4    00C0    LD	0x40,A
778:              	    	}
779:                  	}
780:              		if(chrgFlag && batADValue > 1861)
  02E5    087A    LD	A,0x7A
  02E6    1903    SZB	0x3,2
  02E7    2AF9    JP	0x2F9
  02E8    3007    LDIA	0x7
  02E9    0229    SUBA	0x29
  02EA    3046    LDIA	0x46
  02EB    1903    SZB	0x3,2
  02EC    0228    SUBA	0x28
  02ED    1C03    SNZB	0x3,0
  02EE    2AF9    JP	0x2F9
781:                      {
782:              	        protectFlag = 1;
  02EF    01C8    CLR	0x48
  02F0    0AC8    INCR	0x48
  02F1    2AF9    JP	0x2F9
783:                      }
784:              	}
785:              	else
786:              	{
787:              		ADCON0 = 0;						//如果转换没有完成，需初始化ADCON0,1
  02F2    1683    SETB	0x3,5
  02F3    0195    CLR	0x15
788:              		ADCON1 = 0;				
  02F4    0196    CLR	0x16
789:              		__delay_us(100);				//延时100us(编译器内置函数)
  02F5    3085    LDIA	0x85
  02F6    00F4    LD	0x74,A
  02F7    0BF4    SZDECR	0x74
  02F8    2AF7    JP	0x2F7
790:              	}
791:              
792:              	test_adc = ADC_Sample(1, 5);		//测试AN2口的AD值，参考电压2V
  02F9    3005    LDIA	0x5
  02FA    00F3    LD	0x73,A
  02FB    3001    LDIA	0x1
  02FC    2102    CALL	0x102
  02FD    00CF    LD	0x4F,A
793:              	if (0xA5 == test_adc)				//测试完成，如因其他原因导致AD转换没有完成，则不处理
  02FE    30A5    LDIA	0xA5
  02FF    064F    XORA	0x4F
  0300    1D03    SNZB	0x3,2
  0301    2B2D    JP	0x32D
794:              	{
795:              		if(chrgFlag && adresult > 100)
  0302    087A    LD	A,0x7A
  0303    1903    SZB	0x3,2
  0304    0008    RET
  0305    3000    LDIA	0x0
  0306    0278    SUBA	0x78
  0307    3065    LDIA	0x65
  0308    1903    SZB	0x3,2
  0309    0277    SUBA	0x77
  030A    1C03    SNZB	0x3,0
  030B    0008    RET
796:              	    {
797:              	    	//有电池
798:              	    	if(adresult > 810 || (batADValue - adresult) > 810)
  030C    3003    LDIA	0x3
  030D    0278    SUBA	0x78
  030E    302B    LDIA	0x2B
  030F    1903    SZB	0x3,2
  0310    0277    SUBA	0x77
  0311    1803    SZB	0x3,0
  0312    2B22    JP	0x322
  0313    0877    LD	A,0x77
  0314    0228    SUBA	0x28
  0315    00F4    LD	0x74,A
  0316    0878    LD	A,0x78
  0317    1C03    SNZB	0x3,0
  0318    0A78    INCA	0x78
  0319    0229    SUBA	0x29
  031A    00F5    LD	0x75,A
  031B    3003    LDIA	0x3
  031C    0275    SUBA	0x75
  031D    302B    LDIA	0x2B
  031E    1903    SZB	0x3,2
  031F    0274    SUBA	0x74
  0320    1C03    SNZB	0x3,0
  0321    2B2B    JP	0x32B
799:              	    	{
800:              	    		//有一节电池已经满了
801:              	    		if(++countHalfFull > 250)
  0322    30FB    LDIA	0xFB
  0323    0AC9    INCR	0x49
  0324    0249    SUBA	0x49
  0325    1C03    SNZB	0x3,0
  0326    0008    RET
  0327    3002    LDIA	0x2
802:              	    		{
803:              	    			countHalfFull = 0;
  0328    01C9    CLR	0x49
804:              					protectFlag = 2;
  0329    00C8    LD	0x48,A
  032A    0008    RET
805:              	    		}
806:              	    	}
807:              	    	else
808:              	    	{
809:              	    		countHalfFull = 0;
  032B    01C9    CLR	0x49
810:              	    	}
811:              	    }
812:              	}
  032C    0008    RET
813:              	else
814:              	{
815:              		ADCON0 = 0;						//如果转换没有完成，需初始化ADCON0,1
  032D    1683    SETB	0x3,5
  032E    0195    CLR	0x15
816:              		ADCON1 = 0;				
  032F    0196    CLR	0x16
817:              		__delay_us(100);				//延时100us(编译器内置函数)
  0330    3085    LDIA	0x85
  0331    00F4    LD	0x74,A
  0332    0BF4    SZDECR	0x74
  0333    2B32    JP	0x332
  0334    0008    RET
818:              	}
819:              	
820:              }
821:              
822:              
823:              
824:              /**********************************************************
825:              函数名称：Init_System
826:              函数功能：系统初始化
827:              入口参数：无
828:              出口参数：无
829:              备    注：
830:              **********************************************************/
831:              void Init_System() 
  0562    0000    NOP
  0563    0064    CLRWDT
832:              {
833:              	asm("nop");
834:              	asm("clrwdt");
835:              	OPTION_REG = 0;					//预分频给TMR0 ，Timer0使用内部时钟Focs/4，预分频比为1:2
  0564    1283    CLRB	0x3,5
  0565    0181    CLR	0x1
  0566    0064    CLRWDT
836:              	asm("clrwdt");
837:              	OSCCON = 0X72;					//内部振荡器8M
  0567    3072    LDIA	0x72
  0568    1283    CLRB	0x3,5
  0569    0094    LD	0x14,A
838:              
839:              	WPUA = 0B00000000;				//配置上拉，1为使能上拉
  056A    1683    SETB	0x3,5
  056B    0188    CLR	0x8
840:              	WPDA = 0x00;					//RA1开下拉
  056C    0187    CLR	0x7
841:              	WPUB = 0x04;
  056D    3004    LDIA	0x4
  056E    1283    CLRB	0x3,5
  056F    0088    LD	0x8,A
842:              
843:              	TRISA = 0x27;				//配置IO状态，0为输出，1为输入
  0570    3027    LDIA	0x27
  0571    1683    SETB	0x3,5
844:              	TRISB = 0x04;
845:              
846:              	PORTA = 0X00;
847:              	PORTB = 0X00;
  0572    247B    CALL	0x47B
848:              
849:              //---------------------------------------
850:              //125us中断初始化
851:              	PR2 = 249;					//设定Timer初始值，定时周期是250*2/8M=62.5uS
  0573    30F9    LDIA	0xF9
  0574    0091    LD	0x11,A
852:              	TMR2IF = 0;
  0575    108D    CLRB	0xD,1
853:              	TMR2IE = 1;					//使能Timer2溢出中断
  0576    148E    SETB	0xE,1
854:              
855:              	T2CON = 0B00000100;			//开启Timer2,设置TMR2的分频比为1:1
  0577    3004    LDIA	0x4
  0578    0093    LD	0x13,A
856:              	INTCON = 0XC0;				//开启总中断
  0579    30C0    LDIA	0xC0
  057A    008B    LD	0xB,A
  057B    0008    RET
857:              }
858:              
859:              /***********************************************************
860:              中断服务函数
861:              函数名称：AD_Init()
862:              函数功能：AD初始化处理函数
863:              入口参数：
864:              出口参数：
865:              备    注：第一次打开AD允许位ADON，需延时20uS以上才能进入AD采样
866:              			如后继程序不关闭ADON，则不需要延时
867:              ***********************************************************/
868:              void AD_Init() 
869:              {
870:              	/*********** ADCON0 ****************************
871:              		Bit7~Bit6  ADCS<1:0>:  AD转换时钟选择位。
872:              			00=  F HSI /16
873:              			01=  F HSI /32
874:              			10=  F HSI /64
875:              			11=  F HSI /128
876:              		Bit5~Bit2  CHS<3:0>:  模拟通道选择位。与ADCON1寄存器CHS4组合CHS<3:0>
877:              			CHS<4:0>: 
878:              			00000=  AN0
879:              			00001=  AN1
880:              			00010=  AN2
881:              			00011=  AN3
882:              			00100=  AN4
883:              			00101=  AN5
884:              			00110=  保留
885:              			00111=  保留
886:              			01000=  AN8
887:              			… 
888:              			01101=  AN13
889:              			01110=  AN14
890:              			01111=  AN15
891:              			11111=  1.2V（固定参考电压）
892:              			其他=  保留
893:              		Bit1  GO/DONE: AD转换状态位。
894:              			1=  AD转换正在进行。将该位置1启动AD转换。当AD转换完成以后，该位由硬件自动清零。
895:              				当GO/DONE位从1变0或ADIF从0变1时，需至少等待两个TAD时间，才能再次启动AD转换。
896:              			0=  AD转换完成/或不在进行中。
897:              		Bit0  ADON:  ADC使能位。
898:              			1=  使能ADC；
899:              			0=  禁止ADC，不消耗工作电流。
900:              	*********************************************/
901:              	ADCON0 = 0X41;		//ADON开启，AD采样时间选为FSYS/16
  05D2    3041    LDIA	0x41
  05D3    1683    SETB	0x3,5
  05D4    0095    LD	0x15,A
902:              	
903:              	/*********** ADCON1 ****************************
904:              		Bit7  ADFM:  AD转换结果格式选择位；
905:              			1=  右对齐；
906:              			0=  左对齐。
907:              		Bit6  CHS4:  通道选择位
908:              		Bit5~Bit3  未用 
909:              		Bit2  LDO_EN:  内部参考电压使能位。
910:              			1=  使能ADC内部LDO参考电压；
911:              				当选择内部LDO作参考电压时，ADC最大有效精度为8位。
912:              			0=  VDD作为ADC参考电压。
913:              		Bit1~Bit0  LDO_SEL<1:0>:  参考电压选择位
914:              			0X=  2.0V
915:              			10=  2.4V
916:              			11=  3.0V
917:              	*********************************************/
918:              	ADCON1 = 0;
  05D5    0196    CLR	0x16
919:              	ANSEL0 = 0X07;
  05D6    3007    LDIA	0x7
  05D7    0093    LD	0x13,A
920:              	ANSEL1 = 0x00;	
  05D8    0194    CLR	0x14
  05D9    0008    RET
921:              }
922:              
923:              
924:              void chrgPwmInit()
925:              {
926:              		chrgPwmFlag = 1;
  0590    01B1    CLR	0x31
  0591    0AB1    INCR	0x31
927:              		PWMCON1 = 0B00000000;	//PWM选择D组，死区2禁止，死区1使能，死区时钟源为Fosc/4
  0592    0196    CLR	0x16
928:              		
929:              		PWMTH = 0X00;			//周期选择为0FF，则周期为（255+1）*1/8M，周期的时钟分频在PWMCON0选择
  0593    0198    CLR	0x18
930:              		PWMTL = 100;			//PWM 周期=[PWMT+1]*Tosc*(CLKDIV 分频值)
  0594    3064    LDIA	0x64
  0595    0097    LD	0x17,A
931:              		
932:              	
933:              		
934:              		PWMD23H = 0;			//配置PWM1,PWM2的占空比，该值不能超过周期，否者为100%输出
  0596    1683    SETB	0x3,5
  0597    019E    CLR	0x1E
935:              		PWMD2L = 10;			//互补模式，PWM1的占空比与PWM0互补，和设置值无关
  0598    300A    LDIA	0xA
  0599    009B    LD	0x1B,A
936:              		PWM23DT = 0X00;			//死区设为2uS，计算为（3+1）*1/8M*4
  059A    019D    CLR	0x1D
937:              		
938:              		PWMCON0 = 0X04;			//打开PWM2 分频比为1
  059B    3004    LDIA	0x4
939:              		PWMCON2 =0X00;			//PWM4输出反向
  059C    2D9D    JP	0x59D
940:              }
941:              
942:              
943:              void chrgPwmStop()
944:              {
945:              	if(chrgPwmFlag)
  05DA    0831    LD	A,0x31
  05DB    1903    SZB	0x3,2
  05DC    0008    RET
946:              	{
947:              		chrgPwmFlag = 0;
  05DD    01B1    CLR	0x31
948:              		PWMCON0 &= 0xFB;	//关闭PWM2
  05DE    1115    CLRB	0x15,2
949:              		RB3 = 0;
  05DF    1186    CLRB	0x6,3
  05E0    0008    RET
950:              	}
951:              }
952:              
953:              void pwmInit()
954:              {
955:              		if(motorPwmFlag > 0)
  05B2    0830    LD	A,0x30
  05B3    1D03    SNZB	0x3,2
  05B4    0008    RET
956:              			return;
957:              		motorPwmFlag = 1;
  05B5    01B0    CLR	0x30
  05B6    0AB0    INCR	0x30
958:              		PWMCON1 = 0B00000000;	//PWM选择A组，死区2禁止，死区1使能，死区时钟源为Fosc/4
  05B7    0196    CLR	0x16
959:              		PWMTH = 0X00;			//周期选择为0FF，则周期为（255+1）*1/8M，周期的时钟分频在PWMCON0选择
  05B8    0198    CLR	0x18
960:              		PWMTL = 200;			//PWM 周期=[PWMT+1]*Tosc*(CLKDIV 分频值)
  05B9    30C8    LDIA	0xC8
  05BA    0097    LD	0x17,A
961:              		
962:              		
963:              		PWMD23H = 0;			//配置PWM1,PWM2的占空比，该值不能超过周期，否者为100%输出
  05BB    1683    SETB	0x3,5
  05BC    019E    CLR	0x1E
964:              		PWMD3L = 80;			//互补模式，PWM1的占空比与PWM0互补，和设置值无关
  05BD    3050    LDIA	0x50
  05BE    009C    LD	0x1C,A
965:              		PWM23DT = 0X00;			//死区设为2uS，计算为（3+1）*1/8M*4
  05BF    019D    CLR	0x1D
966:              
967:              		PWMCON0 = 0X48;			//打开PWM1 分频比为8
  05C0    3048    LDIA	0x48
968:              		PWMCON2 =0X00;			//PWM4输出反向
  05C1    2D9D    JP	0x59D
969:              }
970:              
971:              void pwmStop()
972:              {
973:              	if(motorPwmFlag)
  05CA    1283    CLRB	0x3,5
  05CB    0830    LD	A,0x30
  05CC    1903    SZB	0x3,2
  05CD    0008    RET
974:              	{
975:              		motorPwmFlag = 0;
  05CE    01B0    CLR	0x30
976:              		PWMCON0 &= 0XF7;
  05CF    1195    CLRB	0x15,3
977:              		RB4 = 0;
  05D0    1206    CLRB	0x6,4
  05D1    0008    RET
978:              	}
979:              }
980:              
981:              
982:              /***********************************************
983:              函数名称：Sleep_Mode
984:              函数功能：进入休眠模式
985:              入口参数：无
986:              出口参数：无
987:              备注：
988:              ************************************************/
989:              void Sleep_Mode()
990:              {
991:              	INTCON = 0;		
  0442    018B    CLR	0xB
992:              	
993:              	OPTION_REG = 0;
  0443    0181    CLR	0x1
994:              
995:              	WPUA  = 0B00000000;			//RA0 开上拉电阻
  0444    1683    SETB	0x3,5
  0445    0188    CLR	0x8
996:              	TRISA = 0x27;				//配置IO状态，0为输出，1为输入
  0446    3027    LDIA	0x27
997:              	TRISB = 0x04;
998:              
999:              	PORTA = 0X00;
1000:             	PORTB = 0X00;
  0447    247B    CALL	0x47B
1001:             	WPUB  = 0x04;			//RB2 开上拉电阻
  0448    0088    LD	0x8,A
1002:                			
1003:                	ADCON0 = 0;					//关闭所有模块
  0449    1683    SETB	0x3,5
  044A    0195    CLR	0x15
1004:             	ADCON1 = 0;
  044B    0196    CLR	0x16
1005:             	
1006:             	PWMCON0 = 0;
  044C    1283    CLRB	0x3,5
  044D    0195    CLR	0x15
1007:             		
1008:             	OSCCON = 0X70;				//配置振荡为8M,关闭WDT，需注意芯片工程选项里WDT必须选为DISABLE,否则无法软件关掉WDT
  044E    3070    LDIA	0x70
  044F    0094    LD	0x14,A
1009:             	
1010:             	IOCA = 0x20;			//允许RA1的IO电平变化中断
  0450    3020    LDIA	0x20
  0451    1683    SETB	0x3,5
  0452    0089    LD	0x9,A
1011:             	IOCB = 0x04;			//允许RB3的IO口电平变化中断
  0453    3004    LDIA	0x4
  0454    1283    CLRB	0x3,5
  0455    0089    LD	0x9,A
1012:             	
1013:             	RAIE = 1;					//允许PORTA的IO电平变化中断
  0456    158E    SETB	0xE,3
1014:             	PEIE = 1;					//要用RORTA中断唤醒，则PEIE必须设为1
  0457    170B    SETB	0xB,6
1015:             	RBIE = 1;					//允许PORTB电平变化中断
  0458    158B    SETB	0xB,3
1016:             	GIE = 0;					//唤醒后执行SLEEP后程序;
  0459    138B    CLRB	0xB,7
1017:             	
1018:             	PIE1 &= 0X08;				//关闭不需要的中断
  045A    3008    LDIA	0x8
  045B    058E    ANDR	0xE
1019:             	PIR1 = 0;					//必须清不需要的中断标志位
  045C    018D    CLR	0xD
1020:             	INTCON &= 0XC8;				//必须清不需要的中断标志位
  045D    30C8    LDIA	0xC8
  045E    058B    ANDR	0xB
1021:             
1022:             	PORTA;						//读PORTA值并锁存,用电平变化中断必须执行这一步
  045F    1683    SETB	0x3,5
  0460    0806    LD	A,0x6
1023:             	RAIF = 0;					//清PORTA中断标志位
  0461    1283    CLRB	0x3,5
  0462    118D    CLRB	0xD,3
1024:             	PORTB;						//读PORTB值并锁存	
  0463    0806    LD	A,0x6
1025:             	RBIF = 0;					//清PORTB中断标志位		
  0464    100B    CLRB	0xB,0
  0465    0064    CLRWDT
  0466    0063    STOP
  0467    0000    NOP
  0468    0064    CLRWDT
  0469    0000    NOP
  046A    0000    NOP
  046B    0000    NOP
  046C    0000    NOP
  046D    0000    NOP
1026:             	asm("clrwdt");
1027:             
1028:             	asm("sleep");				//进入休眠模式
1029:             	
1030:             	asm("nop");
1031:             	asm("clrwdt");
1032:             	asm("nop");
1033:             	asm("nop");
1034:             	asm("nop");
1035:             	asm("nop");
1036:             	asm("nop");
1037:             	if(RAIF)  RAIF = 0;			//清中断标志
  046E    1283    CLRB	0x3,5
  046F    198D    SZB	0xD,3
  0470    118D    CLRB	0xD,3
1038:             	if(RBIF)  RBIF = 0;			//清中断标志
  0471    180B    SZB	0xB,0
  0472    100B    CLRB	0xB,0
1039:             	if(TMR2IF) TMR2IF = 0;
  0473    188D    SZB	0xD,1
  0474    108D    CLRB	0xD,1
1040:             	IOCA = 0B00000000;			//允许RA1的IO电平变化中断
  0475    1683    SETB	0x3,5
  0476    0189    CLR	0x9
1041:             	IOCB = 0B00000000;			//允许RB3的IO口电平变化中断
  0477    1283    CLRB	0x3,5
  0478    0189    CLR	0x9
1042:             	Init_System();
  0479    2562    CALL	0x562
1043:             	AD_Init();
  047A    2DD2    JP	0x5D2
1044:             }
1045:             
1046:             
1047:             
1048:             /**********************************************************
1049:             函数名称：AD_Sample
1050:             函数功能：AD检测
1051:             入口参数：adch - 检测通道
1052:             出口参数：无
1053:             备    注：采样通道需自行设置为输入口
1054:             	      采样10次,取中间八次的平均值为采样结果存于adresult中
1055:             
1056:             	      adch 为输入AD通道 0-15，31
1057:                          31  检测内部1.2V
1058:             	
1059:              		  adldo =5,开启内部LDO 2V 作为ADC 参考
1060:              		  adldo =6,开启内部LDO 2.4V 作为ADC 参考
1061:             		  adldo =7,开启内部LDO 3V 作为ADC 参考
1062:              		  adldo =0,VDD 作为ADC 参考
1063:              		  AD转换结果左对齐
1064:              		  ADC参考电压从VDD切换到LDO时需要延时100us以上，才能进行AD转换
1065:             **********************************************************/
1066:             unsigned char ADC_Sample(unsigned char adch, unsigned char adldo) 
  0102    1283    CLRB	0x3,5
  0103    00D5    LD	0x55,A
1067:             {
1068:             	volatile unsigned long adsum = 0;
1069:             	volatile unsigned int admin = 0, admax = 0;
  0104    21DD    CALL	0x1DD
1070:             	volatile unsigned int ad_temp = 0;
  0105    01DF    CLR	0x5F
  0106    01E0    CLR	0x60
1071:             
1072:             	if ((!LDO_EN) && (adldo & 0x04) ) 
  0107    1683    SETB	0x3,5
  0108    1D16    SNZB	0x16,2
  0109    1D73    SNZB	0x73,2
  010A    2914    JP	0x114
1073:             	{
1074:             								//如果AD参考从VDD换到内部LDO，需要延时100US以上
1075:             		ADCON1 = adldo;			//左对齐,AD值取12位
  010B    0873    LD	A,0x73
  010C    0096    LD	0x16,A
1076:             		__delay_us(100);		//IDE内置延时函数，延时100us
  010D    3084    LDIA	0x84
  010E    1283    CLRB	0x3,5
  010F    00D0    LD	0x50,A
  0110    0BD0    SZDECR	0x50
  0111    2910    JP	0x110
  0112    2913    JP	0x113
1077:             	} 
  0113    2916    JP	0x116
1078:             	else
1079:             		ADCON1 = adldo;			//如果ADCON1.7(ADFM)=1为右对齐，,AD值取10位
  0114    0873    LD	A,0x73
  0115    0096    LD	0x16,A
1080:             
1081:             	if(adch & 0x10) 
  0116    1283    CLRB	0x3,5
  0117    1E55    SNZB	0x55,4
  0118    291E    JP	0x11E
1082:             	{
1083:             		CHS4 = 1;
  0119    1683    SETB	0x3,5
  011A    1716    SETB	0x16,6
1084:             		adch &= 0x0f;
  011B    300F    LDIA	0xF
  011C    1283    CLRB	0x3,5
  011D    05D5    ANDR	0x55
1085:             	}
1086:             	unsigned char i = 0;
1087:             	for (i = 0; i < 10; i++) 
  011E    01D6    CLR	0x56
1088:             	{
1089:             		ADCON0 = (unsigned char)(0X41 | (adch << 2));	//16分频，如果主频为16M，则必须选16分频或以上
  011F    0855    LD	A,0x55
  0120    00D0    LD	0x50,A
  0121    3001    LDIA	0x1
  0122    1003    CLRB	0x3,0
  0123    0DD0    RLCR	0x50
  0124    3EFF    ADDIA	0xFF
  0125    1003    CLRB	0x3,0
  0126    1D03    SNZB	0x3,2
  0127    2923    JP	0x123
  0128    0D50    RLCA	0x50
  0129    3841    ORIA	0x41
  012A    1683    SETB	0x3,5
  012B    0095    LD	0x15,A
  012C    0000    NOP
  012D    0000    NOP
  012E    0000    NOP
  012F    0000    NOP
1090:             		asm("nop");
1091:             		asm("nop");
1092:             		asm("nop");
1093:             		asm("nop");				//选择通道后需延时1uS以上
1094:             		GODONE = 1;				//开始转换
  0130    1683    SETB	0x3,5
  0131    1495    SETB	0x15,1
1095:             
1096:             		unsigned char j = 0;
  0132    1283    CLRB	0x3,5
  0133    01D4    CLR	0x54
1097:             		while (GODONE) 
  0134    1683    SETB	0x3,5
  0135    1C95    SNZB	0x15,1
  0136    293F    JP	0x13F
1098:             		{
1099:             			__delay_us(2);		//延时2us(编译器内置函数)
  0137    2938    JP	0x138
  0138    2939    JP	0x139
  0139    293A    JP	0x13A
  013A    293B    JP	0x13B
1100:             
1101:             			if (0 == (--j))		//延时0.5ms仍没有AD转换结束，跳出程序
  013B    1283    CLRB	0x3,5
  013C    0BD4    SZDECR	0x54
  013D    2934    JP	0x134
1102:             			return 0;
  013E    3400    RET	0x0
1103:             		}
1104:             
1105:             		ad_temp = (unsigned int)((ADRESH << 4) + (ADRESL >> 4));	//计算12位AD值
  013F    0819    LD	A,0x19
  0140    1283    CLRB	0x3,5
  0141    00DF    LD	0x5F,A
  0142    01E0    CLR	0x60
  0143    0EDF    SWAPR	0x5F
  0144    0EE0    SWAPR	0x60
  0145    30F0    LDIA	0xF0
  0146    05E0    ANDR	0x60
  0147    085F    LD	A,0x5F
  0148    390F    ANDIA	0xF
  0149    04E0    ORR	0x60
  014A    30F0    LDIA	0xF0
  014B    05DF    ANDR	0x5F
  014C    1683    SETB	0x3,5
  014D    0E18    SWAPA	0x18
  014E    390F    ANDIA	0xF
  014F    1283    CLRB	0x3,5
  0150    07DF    ADDR	0x5F
  0151    1803    SZB	0x3,0
  0152    0AE0    INCR	0x60
1106:             
1107:             		if (0 == admax) 
  0153    085D    LD	A,0x5D
  0154    045E    ORA	0x5E
  0155    1D03    SNZB	0x3,2
  0156    2959    JP	0x159
1108:             		{
1109:             			admax = ad_temp;
  0157    21E6    CALL	0x1E6
  0158    296B    JP	0x16B
1110:             			admin = ad_temp;
1111:             		} 
1112:             		else if (ad_temp > admax)
  0159    0860    LD	A,0x60
  015A    025E    SUBA	0x5E
  015B    1D03    SNZB	0x3,2
  015C    295F    JP	0x15F
  015D    085F    LD	A,0x5F
  015E    025D    SUBA	0x5D
  015F    1803    SZB	0x3,0
  0160    2963    JP	0x163
1113:             			admax = ad_temp;				//AD采样最大值
  0161    21E6    CALL	0x1E6
  0162    296F    JP	0x16F
1114:             		else if (ad_temp < admin)
  0163    085C    LD	A,0x5C
  0164    0260    SUBA	0x60
  0165    1D03    SNZB	0x3,2
  0166    2969    JP	0x169
  0167    085B    LD	A,0x5B
  0168    025F    SUBA	0x5F
  0169    1803    SZB	0x3,0
  016A    296F    JP	0x16F
1115:             			admin = ad_temp;				//AD采样最小值
  016B    0860    LD	A,0x60
  016C    00DC    LD	0x5C,A
  016D    085F    LD	A,0x5F
  016E    00DB    LD	0x5B,A
1116:             
1117:             		adsum += ad_temp;
  016F    085F    LD	A,0x5F
  0170    00D0    LD	0x50,A
  0171    0860    LD	A,0x60
  0172    00D1    LD	0x51,A
  0173    01D2    CLR	0x52
  0174    01D3    CLR	0x53
  0175    0850    LD	A,0x50
  0176    07D7    ADDR	0x57
  0177    0851    LD	A,0x51
  0178    1103    CLRB	0x3,2
  0179    1803    SZB	0x3,0
  017A    3E01    ADDIA	0x1
  017B    1D03    SNZB	0x3,2
  017C    07D8    ADDR	0x58
  017D    0852    LD	A,0x52
  017E    1103    CLRB	0x3,2
  017F    1803    SZB	0x3,0
  0180    3E01    ADDIA	0x1
  0181    1D03    SNZB	0x3,2
  0182    07D9    ADDR	0x59
  0183    0853    LD	A,0x53
  0184    1103    CLRB	0x3,2
  0185    1803    SZB	0x3,0
  0186    3E01    ADDIA	0x1
  0187    1D03    SNZB	0x3,2
  0188    07DA    ADDR	0x5A
  0189    300A    LDIA	0xA
  018A    0AD6    INCR	0x56
  018B    0256    SUBA	0x56
  018C    1C03    SNZB	0x3,0
  018D    291F    JP	0x11F
1118:             	}
1119:             		adsum -= admax;
  018E    085D    LD	A,0x5D
  018F    00D0    LD	0x50,A
  0190    085E    LD	A,0x5E
  0191    21CE    CALL	0x1CE
  0192    1C03    SNZB	0x3,0
  0193    0F53    SZINCA	0x53
  0194    02DA    SUBR	0x5A
1120:             		if (adsum >= admin)
  0195    085B    LD	A,0x5B
  0196    00D0    LD	0x50,A
  0197    085C    LD	A,0x5C
  0198    00D1    LD	0x51,A
  0199    01D2    CLR	0x52
  019A    01D3    CLR	0x53
  019B    0853    LD	A,0x53
  019C    025A    SUBA	0x5A
  019D    1D03    SNZB	0x3,2
  019E    29A9    JP	0x1A9
  019F    0852    LD	A,0x52
  01A0    0259    SUBA	0x59
  01A1    1D03    SNZB	0x3,2
  01A2    29A9    JP	0x1A9
  01A3    0851    LD	A,0x51
  01A4    0258    SUBA	0x58
  01A5    1D03    SNZB	0x3,2
  01A6    29A9    JP	0x1A9
  01A7    0850    LD	A,0x50
  01A8    0257    SUBA	0x57
  01A9    1C03    SNZB	0x3,0
  01AA    29B3    JP	0x1B3
1121:             			adsum -= admin;
  01AB    085B    LD	A,0x5B
  01AC    00D0    LD	0x50,A
  01AD    085C    LD	A,0x5C
  01AE    21CE    CALL	0x1CE
  01AF    1C03    SNZB	0x3,0
  01B0    0F53    SZINCA	0x53
  01B1    02DA    SUBR	0x5A
  01B2    29B7    JP	0x1B7
1122:             		else
1123:             			adsum = 0;
  01B3    01D7    CLR	0x57
  01B4    01D8    CLR	0x58
  01B5    01D9    CLR	0x59
  01B6    01DA    CLR	0x5A
1124:             
1125:             		adresult = adsum >> 3;		//8次平均值作为最终结果
  01B7    0857    LD	A,0x57
  01B8    00D0    LD	0x50,A
  01B9    0858    LD	A,0x58
  01BA    00D1    LD	0x51,A
  01BB    0859    LD	A,0x59
  01BC    00D2    LD	0x52,A
  01BD    085A    LD	A,0x5A
  01BE    00D3    LD	0x53,A
  01BF    3003    LDIA	0x3
  01C0    1003    CLRB	0x3,0
  01C1    0CD3    RRCR	0x53
  01C2    0CD2    RRCR	0x52
  01C3    0CD1    RRCR	0x51
  01C4    0CD0    RRCR	0x50
  01C5    3EFF    ADDIA	0xFF
  01C6    1D03    SNZB	0x3,2
  01C7    29C0    JP	0x1C0
  01C8    0851    LD	A,0x51
  01C9    00F8    LD	0x78,A
  01CA    0850    LD	A,0x50
  01CB    00F7    LD	0x77,A
1126:             
1127:             		adsum = 0;
1128:             		admin = 0;
1129:             		admax = 0;
  01CC    21DD    CALL	0x1DD
1130:             		return 0xA5;
  01CD    34A5    RET	0xA5
1131:             		
1132:             }
1133:             
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\lbmod.c ----------------------------------------------------------------------
1:                // byte unsigned modulus
2:                
3:                unsigned char
4:                __lbmod(unsigned char dividend, unsigned char divisor)
  052B    00D0    LD	0x50,A
  052C    3008    LDIA	0x8
  052D    00D1    LD	0x51,A
  052E    01D2    CLR	0x52
  052F    0850    LD	A,0x50
  0530    00F4    LD	0x74,A
  0531    3007    LDIA	0x7
  0532    1003    CLRB	0x3,0
  0533    0CF4    RRCR	0x74
  0534    3EFF    ADDIA	0xFF
  0535    1003    CLRB	0x3,0
  0536    1D03    SNZB	0x3,2
  0537    2D33    JP	0x533
  0538    0D52    RLCA	0x52
  0539    0474    ORA	0x74
  053A    00D2    LD	0x52,A
  053B    1003    CLRB	0x3,0
  053C    0DD0    RLCR	0x50
  053D    0873    LD	A,0x73
  053E    0252    SUBA	0x52
  053F    1C03    SNZB	0x3,0
  0540    2D43    JP	0x543
  0541    0873    LD	A,0x73
  0542    02D2    SUBR	0x52
  0543    0BD1    SZDECR	0x51
  0544    2D2F    JP	0x52F
  0545    0852    LD	A,0x52
  0546    0008    RET
5:                {
6:                	unsigned char	rem;
7:                	unsigned char	counter;
8:                
9:                	counter = 8;
10:               	rem = 0;
11:               	do {
12:               		rem = (rem << 1) | (dividend >> 7);
13:               		dividend <<= 1;
14:               		if(divisor <= rem)
15:               			rem -= divisor;
16:               	} while(--counter != 0);
17:               	return rem;
18:               }
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\lbdiv.c ----------------------------------------------------------------------
1:                // byte unsigned division
2:                
3:                unsigned char
4:                __lbdiv(unsigned char dividend, unsigned char divisor)
  0547    00F4    LD	0x74,A
  0548    01F6    CLR	0x76
  0549    0873    LD	A,0x73
  054A    1903    SZB	0x3,2
  054B    2D60    JP	0x560
  054C    01F5    CLR	0x75
  054D    0AF5    INCR	0x75
  054E    1BF3    SZB	0x73,7
  054F    2D53    JP	0x553
  0550    1003    CLRB	0x3,0
  0551    0DF3    RLCR	0x73
  0552    2D4D    JP	0x54D
  0553    1003    CLRB	0x3,0
  0554    0DF6    RLCR	0x76
  0555    0873    LD	A,0x73
  0556    0274    SUBA	0x74
  0557    1C03    SNZB	0x3,0
  0558    2D5D    JP	0x55D
  0559    0873    LD	A,0x73
  055A    02F4    SUBR	0x74
  055B    1476    SETB	0x76,0
  055C    1003    CLRB	0x3,0
  055D    0CF3    RRCR	0x73
  055E    0BF5    SZDECR	0x75
  055F    2D53    JP	0x553
  0560    0876    LD	A,0x76
  0561    0008    RET
5:                {
6:                	unsigned char	quotient;
7:                	unsigned char	counter;
8:                
9:                	quotient = 0;
10:               	if(divisor != 0) {
11:               		counter = 1;
12:               		while((divisor & 0x80) == 0) {
13:               			divisor <<= 1;
14:               			counter++;
15:               		}
16:               		do {
17:               			quotient <<= 1;
18:               			if(divisor <= dividend) {
19:               				dividend -= divisor;
20:               				quotient |= 1;
21:               			}
22:               			divisor >>= 1;
23:               		} while(--counter != 0);
24:               	}
25:               	return quotient;
26:               }
---- stringtab ------------------------------------------------------------------
  057C    3005    LDIA	0x5
  057D    008A    LD	0xA,A
  057E    0804    LD	A,0x4
  057F    0A84    INCR	0x4
  0580    0782    ADDR	0x2
  0581    3400    RET	0x0
---- reset_enter ------------------------------------------------------------------
  0000    280C    JP	0xC
  000C    280D    JP	0xD
---- start_initialization ------------------------------------------------------------------
  000D    3077    LDIA	0x77
  000E    0084    LD	0x4,A
  000F    307B    LDIA	0x7B
  0010    25C2    CALL	0x5C2
  0011    3020    LDIA	0x20
  0012    1383    CLRB	0x3,7
  0013    0084    LD	0x4,A
  0014    3050    LDIA	0x50
  0015    25C2    CALL	0x5C2
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F0    LD	0x70,A
  0007    0804    LD	A,0x4
  0008    00F1    LD	0x71,A
  0009    080A    LD	A,0xA
  000A    00F2    LD	0x72,A
  000B    2D0E    JP	0x50E
---- common_function ------------------------------------------------------------------
  0016    0183    CLR	0x3
  0017    2BF0    JP	0x3F0
  00FC    0AA6    INCR	0x26
  00FD    1903    SZB	0x3,2
  00FE    0AA7    INCR	0x27
  00FF    300B    LDIA	0xB
  0100    0227    SUBA	0x27
  0101    34B9    RET	0xB9
  01CE    00D1    LD	0x51,A
  01CF    01D2    CLR	0x52
  01D0    01D3    CLR	0x53
  01D1    0850    LD	A,0x50
  01D2    02D7    SUBR	0x57
  01D3    0851    LD	A,0x51
  01D4    1C03    SNZB	0x3,0
  01D5    0F51    SZINCA	0x51
  01D6    02D8    SUBR	0x58
  01D7    0852    LD	A,0x52
  01D8    1C03    SNZB	0x3,0
  01D9    0F52    SZINCA	0x52
  01DA    02D9    SUBR	0x59
  01DB    0853    LD	A,0x53
  01DC    0008    RET
  01DD    01D7    CLR	0x57
  01DE    01D8    CLR	0x58
  01DF    01D9    CLR	0x59
  01E0    01DA    CLR	0x5A
  01E1    01DB    CLR	0x5B
  01E2    01DC    CLR	0x5C
  01E3    01DD    CLR	0x5D
  01E4    01DE    CLR	0x5E
  01E5    0008    RET
  01E6    0860    LD	A,0x60
  01E7    00DE    LD	0x5E,A
  01E8    085F    LD	A,0x5F
  01E9    00DD    LD	0x5D,A
  01EA    0008    RET
  0393    00E2    LD	0x62,A
  0394    300A    LDIA	0xA
  0395    00F3    LD	0x73,A
  0396    083F    LD	A,0x3F
  0397    0008    RET
  047B    0085    LD	0x5,A
  047C    3004    LDIA	0x4
  047D    1283    CLRB	0x3,5
  047E    0085    LD	0x5,A
  047F    1683    SETB	0x3,5
  0480    0186    CLR	0x6
  0481    1283    CLRB	0x3,5
  0482    0186    CLR	0x6
  0483    0008    RET
  0582    343F    RET	0x3F
  0583    3406    RET	0x6
  0584    345B    RET	0x5B
  0585    344F    RET	0x4F
  0586    3466    RET	0x66
  0587    346D    RET	0x6D
  0588    347D    RET	0x7D
  0589    3407    RET	0x7
  058A    347F    RET	0x7F
  058B    346F    RET	0x6F
  058C    3471    RET	0x71
  058D    3479    RET	0x79
  058E    3450    RET	0x50
  058F    3476    RET	0x76
  059D    1283    CLRB	0x3,5
  059E    0095    LD	0x15,A
  059F    019D    CLR	0x1D
  05A0    0008    RET
  05A1    2A70    JP	0x270
  05A2    2A03    JP	0x203
  05A3    2A0A    JP	0x20A
  05A4    2A11    JP	0x211
  05A5    2A1B    JP	0x21B
  05A6    2A25    JP	0x225
  05A7    2A2F    JP	0x22F
  05A8    2A39    JP	0x239
  05A9    2A41    JP	0x241
  05AA    2A48    JP	0x248
  05AB    2A4F    JP	0x24F
  05AC    2A56    JP	0x256
  05AD    2A5D    JP	0x25D
  05AE    2A66    JP	0x266
  05AF    2A7A    JP	0x27A
  05B0    2A85    JP	0x285
  05B1    2A85    JP	0x285
  05C2    0064    CLRWDT
  05C3    0180    CLR	0x0
  05C4    0A84    INCR	0x4
  05C5    0604    XORA	0x4
  05C6    1903    SZB	0x3,2
  05C7    3400    RET	0x0
  05C8    0604    XORA	0x4
  05C9    2DC3    JP	0x5C3
