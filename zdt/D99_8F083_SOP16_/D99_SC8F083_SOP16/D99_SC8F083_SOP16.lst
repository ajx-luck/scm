---- C:\mcuproject\scm\zdt\D99_8F083_SOP16_\D99_SC8F083_SOP16\main.c ----------------------------------------------------------------------
1:                #include <sc.h>
2:                #include "Touch_Kscan_Library.h"
3:                
4:                #ifndef _XTAL_FREQ
5:                #define _XTAL_FREQ 8000000			//8MHz,使用内置延时函数必须定义主频，
6:                									//如用16M需改此参数为16000000
7:                #endif
8:                #define     POWER_RATIO  	(4096UL*1.2*1000)
9:                
10:               #define		uchar		unsigned char
11:               #define		u8t		unsigned char
12:               #define		uint			unsigned int
13:               #define		u16t			unsigned int
14:               #define		ulong		unsigned long
15:               
16:               
17:               
18:               #define		LED5						 RB4
19:               #define		LED4						 RA1
20:               #define		LED3						 RA3
21:               #define		LED2						 RA4
22:               #define		LED1						 RA0
23:               
24:               
25:               #define		LED5_OUT					 TRISB	&= 0xEF
26:               #define		LED4_OUT					 TRISA	&= 0xFD
27:               #define		LED3_OUT					 TRISA	&= 0xF7
28:               #define		LED2_OUT					 TRISA	&= 0xEF
29:               #define		LED1_OUT					 TRISA	&= 0xFE
30:               
31:               
32:               
33:               
34:               
35:               const static unsigned char numArray[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x71,0x79,0x50};
36:               volatile unsigned char MainTime;
37:               static unsigned int time;
38:               volatile bit	B_MainLoop,B_OnOff;
39:               u8t	count1s = 0;
40:               u8t	workStep = 0;
41:               u8t	wuhuaFlag = 0;
42:               u16t		shanshuoTime = 0;
43:               u16t		shanshuoTime2 = 0;
44:               u16t		fanValue = 0;
45:               u16t		wuhuaValue = 0;
46:               u8t	fanDuty = 0;
47:               u8t	count10s = 0;
48:               u8t	fanOverTime = 0;
49:               u8t	firstTime = 0;
50:               u16t	checkTime = 0;
51:               u16t	lowWaterTime = 0;
52:               u8t		chrgFlag = 0;
53:               u8t		chrgFullFlag = 0;
54:               u8t		chrgFullTime = 0;
55:               u8t		firstLock = 0;
56:               u8t		lowBatLock = 0;
57:               u16t		lowBatTime = 0;	
58:               u8t		lowFanTime = 0;//风扇降低为1档的时间
59:               u8t		ledCnt = 0;	
60:               u8t		showNumShi = 0x7F;
61:               u8t		showNumGe = 0x7F;
62:               u8t		fanKeyFlag = 0;
63:               u8t		wuhuaKeyFlag = 0;
64:               u8t		showBatStep = 0;
65:               u8t		curBatStep = 0;
66:               u16t	count30s = 0;
67:               u16t	count15s = 0;
68:               
69:               volatile unsigned int adresult;
70:               volatile unsigned int result;
71:               volatile unsigned char test_adc;
72:               volatile unsigned int power_ad;
73:               
74:               void chrgCtr();
75:               unsigned char ADC_Sample(unsigned char adch, unsigned char adldo);
76:               void ledShow();
77:               
78:               
79:               //系统初始化
80:               void Init_System()
  0024    0000    NOP
  0025    0064    CLRWDT
81:               {
82:               	asm("nop");
83:               	asm("clrwdt");
84:               	INTCON = 0;				//禁止中断
  0026    018B    CLR	0xB
85:               	OSCCON = 0X72;			//配置振荡为8M
  0027    3072    LDIA	0x72
  0028    1283    CLRB	0x3,5
  0029    1303    CLRB	0x3,6
  002A    0094    LD	0x14,A
86:               	OPTION_REG = 0;
  002B    0181    CLR	0x1
87:               	
88:               	
89:               	//延时等待电源电压稳定
90:               	//DelayXms(200);
91:               	TRISA = 0x00;
  002C    1683    SETB	0x3,5
  002D    0185    CLR	0x5
92:               	PORTA = 0;
  002E    0186    CLR	0x6
93:               	TRISB = 0x23;
  002F    3023    LDIA	0x23
  0030    1283    CLRB	0x3,5
  0031    0085    LD	0x5,A
94:               	PORTB = 0;
  0032    0186    CLR	0x6
95:               	WPUB = 0x02;
  0033    3002    LDIA	0x2
  0034    0088    LD	0x8,A
96:               	TRISC = 0;
  0035    1703    SETB	0x3,6
  0036    0185    CLR	0x5
97:               	PORTC = 0;
  0037    0186    CLR	0x6
98:               
99:               	PIE1 = 2;
  0038    1303    CLRB	0x3,6
  0039    008E    LD	0xE,A
100:              	PR2 = 250;				//8M下将TMR2设置为125us中断
  003A    30FA    LDIA	0xFA
  003B    0091    LD	0x11,A
101:              	T2CON = 4;				//使能定时器2
  003C    3004    LDIA	0x4
  003D    0093    LD	0x13,A
102:              
103:              	INTCON = 0XC0;			//使能中断
  003E    30C0    LDIA	0xC0
  003F    008B    LD	0xB,A
104:              	ADCON0 = 0X41;
105:              	ADON = 1;
106:              	ADCON1 = 0x00;
  0040    2BED    JP	0x3ED
107:              }
108:              
109:              
110:              /**********************************************************
111:              函数名称：Refurbish_Sfr
112:              函数功能：刷新一些特殊功能寄存器
113:              入口参数：无
114:              出口参数：无
115:              备    注：每隔一定时间刷新一次SFR可增强抗干扰能力
116:              **********************************************************/
117:              void Refurbish_Sfr() 
118:              {
119:              	//刷新中断相关控制寄存器
120:              	PIE1 = 2;
  0403    3002    LDIA	0x2
  0404    1283    CLRB	0x3,5
  0405    008E    LD	0xE,A
121:              	PR2 = 250;
  0406    30FA    LDIA	0xFA
  0407    0091    LD	0x11,A
122:              	INTCON = 0XC0;
  0408    30C0    LDIA	0xC0
  0409    008B    LD	0xB,A
123:              	if (4 != T2CON)
  040A    3004    LDIA	0x4
  040B    0613    XORA	0x13
  040C    1903    SZB	0x3,2
  040D    0008    RET
124:              		T2CON = 4;
  040E    3004    LDIA	0x4
  040F    0093    LD	0x13,A
  0410    0008    RET
125:              }
126:              
127:              
128:              /***********************************************************
129:              键处理函数
130:              ***********************************************************/
131:              void KeyServer() 
132:              {
133:              	static unsigned char KeyOldFlag = 0;
134:              	if (KeyFlag[0]) 
  0D89    082E    LD	A,0x2E
  0D8A    1903    SZB	0x3,2
  0D8B    2DD5    JP	0x5D5
135:              	{
136:              		time = 0;
  0D8C    1683    SETB	0x3,5
  0D8D    01BA    CLR	0x3A
  0D8E    01BB    CLR	0x3B
137:              		if (KeyFlag[0] != KeyOldFlag) 
  0D8F    1283    CLRB	0x3,5
  0D90    082E    LD	A,0x2E
  0D91    0635    XORA	0x35
  0D92    1903    SZB	0x3,2
  0D93    0008    RET
138:              		{
139:              			//确定状态改变的按键
140:              			KeyOldFlag ^= KeyFlag[0];
  0D94    082E    LD	A,0x2E
  0D95    06B5    XORR	0x35
141:              			if ((KeyOldFlag & 0x1) && (KeyFlag[0] & 0x1) && firstLock == 0) 
  0D96    1835    SZB	0x35,0
  0D97    1C2E    SNZB	0x2E,0
  0D98    2DB2    JP	0x5B2
  0D99    1683    SETB	0x3,5
  0D9A    0842    LD	A,0x42
  0D9B    1D03    SNZB	0x3,2
  0D9C    2DB2    JP	0x5B2
142:              			{
143:              				//KEY1被按下
144:              				if(lowBatLock == 1)
  0D9D    1283    CLRB	0x3,5
  0D9E    0B3D    SZDECA	0x3D
  0D9F    2DA4    JP	0x5A4
145:              				{
146:              					shanshuoTime = 225;
  0DA0    30E1    LDIA	0xE1
  0DA1    00AC    LD	0x2C,A
  0DA2    01AD    CLR	0x2D
147:              				}
  0DA3    2DA9    JP	0x5A9
148:              				else if(++workStep > 2)
  0DA4    3003    LDIA	0x3
  0DA5    0AC5    INCR	0x45
  0DA6    0245    SUBA	0x45
  0DA7    1803    SZB	0x3,0
149:              				{
150:              					workStep = 0;
  0DA8    01C5    CLR	0x45
151:              				}
152:              				if(workStep == 2)
  0DA9    3002    LDIA	0x2
  0DAA    0645    XORA	0x45
  0DAB    1D03    SNZB	0x3,2
  0DAC    2DB0    JP	0x5B0
153:              				{
154:              					shanshuoTime = 225;
  0DAD    30E1    LDIA	0xE1
  0DAE    00AC    LD	0x2C,A
  0DAF    2DB1    JP	0x5B1
155:              				}
156:              				else
157:              				{
158:              					shanshuoTime = 0;
  0DB0    01AC    CLR	0x2C
  0DB1    01AD    CLR	0x2D
159:              				}
160:              			}
161:              			if ((KeyOldFlag & 0x2) && (KeyFlag[0] & 0x2) && firstLock == 0) 
  0DB2    1283    CLRB	0x3,5
  0DB3    18B5    SZB	0x35,1
  0DB4    1CAE    SNZB	0x2E,1
  0DB5    2DD1    JP	0x5D1
  0DB6    1683    SETB	0x3,5
  0DB7    0842    LD	A,0x42
  0DB8    1D03    SNZB	0x3,2
  0DB9    2DD1    JP	0x5D1
162:              			{
163:              				//KEY2被按下
164:              				if(lowBatLock == 1)
  0DBA    1283    CLRB	0x3,5
  0DBB    0B3D    SZDECA	0x3D
  0DBC    2DC1    JP	0x5C1
165:              				{
166:              					shanshuoTime2 = 225;
  0DBD    30E1    LDIA	0xE1
  0DBE    00AA    LD	0x2A,A
  0DBF    01AB    CLR	0x2B
167:              				}
  0DC0    2DC6    JP	0x5C6
168:              				else if(++wuhuaFlag > 2)
  0DC1    3003    LDIA	0x3
  0DC2    0AC4    INCR	0x44
  0DC3    0244    SUBA	0x44
  0DC4    1803    SZB	0x3,0
169:              				{
170:              					wuhuaFlag = 0;
  0DC5    01C4    CLR	0x44
171:              				}
172:              				if(wuhuaFlag == 2)
  0DC6    3002    LDIA	0x2
  0DC7    0644    XORA	0x44
  0DC8    1D03    SNZB	0x3,2
  0DC9    2DCF    JP	0x5CF
173:              				{
174:              					shanshuoTime2 = 225;
  0DCA    30E1    LDIA	0xE1
  0DCB    00AA    LD	0x2A,A
  0DCC    01AB    CLR	0x2B
175:              					count10s = 0;
  0DCD    01C2    CLR	0x42
176:              				}
  0DCE    2DD1    JP	0x5D1
177:              				else
178:              				{
179:              					shanshuoTime2 = 0;
  0DCF    01AA    CLR	0x2A
  0DD0    01AB    CLR	0x2B
180:              				}
181:              			}
182:              			
183:              
184:              			KeyOldFlag = KeyFlag[0];
  0DD1    1283    CLRB	0x3,5
  0DD2    082E    LD	A,0x2E
  0DD3    00B5    LD	0x35,A
  0DD4    0008    RET
185:              		}
186:              	} 
187:              	else 
188:              	{
189:              		KeyOldFlag = 0;
  0DD5    01B5    CLR	0x35
  0DD6    0008    RET
190:              	}
191:              }
192:              
193:              
194:              /***********************************************************
195:              中断服务函数
196:              ***********************************************************/
197:              void interrupt Isr_Timer()
198:              {
199:              	if(TMR2IF)				//若只使能了一个中断源,可以略去判断
  0E55    1283    CLRB	0x3,5
  0E56    1303    CLRB	0x3,6
  0E57    1C8D    SNZB	0xD,1
  0E58    2E76    JP	0x676
200:              	{
201:              		TMR2IF = 0;
  0E59    108D    CLRB	0xD,1
202:              		if(firstTime > 0 || workStep > 0 || wuhuaFlag > 0 || chrgFlag > 0)
  0E5A    086E    LD	A,0x6E
  0E5B    1D03    SNZB	0x3,2
  0E5C    2E65    JP	0x665
  0E5D    0845    LD	A,0x45
  0E5E    1D03    SNZB	0x3,2
  0E5F    2E65    JP	0x665
  0E60    0844    LD	A,0x44
  0E61    1903    SZB	0x3,2
  0E62    0840    LD	A,0x40
  0E63    1903    SZB	0x3,2
  0E64    2E67    JP	0x667
203:              		{
204:              			ledShow();
  0E65    2680    CALL	0x680
  0E66    158A    SETB	0xA,3
205:              		}
206:              		if(++MainTime >= 64)	//需根据你选择的触摸路数和触摸电容选择扫描一次按键的时间
  0E67    3040    LDIA	0x40
  0E68    1283    CLRB	0x3,5
  0E69    0AC7    INCR	0x47
  0E6A    0247    SUBA	0x47
  0E6B    1C03    SNZB	0x3,0
  0E6C    2E77    JP	0x677
207:              		{						//一般103电容，8路触摸，8M主频检测时间约4ms，故扫描一次的时间可选5ms
208:              			MainTime = 0;
  0E6D    01C7    CLR	0x47
209:              			B_MainLoop = 1;
  0E6E    1778    SETB	0x78,6
210:              			if(++count1s >= 250)
  0E6F    30FA    LDIA	0xFA
  0E70    0AC6    INCR	0x46
  0E71    0246    SUBA	0x46
  0E72    1C03    SNZB	0x3,0
  0E73    2E77    JP	0x677
211:              			{
212:              				count1s = 0;
  0E74    01C6    CLR	0x46
  0E75    2E77    JP	0x677
213:              			}
214:              		}
215:              	}
216:              	else
217:              	{
218:              		PIR1 = 0;
  0E76    018D    CLR	0xD
  0E77    0872    LD	A,0x72
  0E78    008A    LD	0xA,A
  0E79    0871    LD	A,0x71
  0E7A    0084    LD	0x4,A
  0E7B    0E70    SWAPA	0x70
  0E7C    0083    LD	0x3,A
  0E7D    0EFE    SWAPR	0x7E
  0E7E    0E7E    SWAPA	0x7E
  0E7F    0009    RETI
219:              	}
220:              	
221:              }
222:              
223:              void WorkSleep()
224:              {
225:              #if (0 != C_KEY_WAKEUP)
226:              	
227:              	
228:              	if(B_OnOff)time = 0;
  0041    1EF8    SNZB	0x78,5
  0042    2846    JP	0x46
  0043    1683    SETB	0x3,5
  0044    01BA    CLR	0x3A
  0045    01BB    CLR	0x3B
229:              	
230:              	if(++time >= 1000)
  0046    1683    SETB	0x3,5
  0047    0ABA    INCR	0x3A
  0048    1903    SZB	0x3,2
  0049    0ABB    INCR	0x3B
  004A    3003    LDIA	0x3
  004B    023B    SUBA	0x3B
  004C    30E8    LDIA	0xE8
  004D    1903    SZB	0x3,2
  004E    023A    SUBA	0x3A
  004F    1C03    SNZB	0x3,0
  0050    0008    RET
231:              	{
232:              		time = 0;
  0051    01BA    CLR	0x3A
  0052    01BB    CLR	0x3B
233:              		INTCON = 0;			//;关断ADC模块及中断使能；
  0053    018B    CLR	0xB
234:              		PIE1 = 0;
  0054    1283    CLRB	0x3,5
  0055    018E    CLR	0xE
235:              		PIE2 = 0;
  0056    1703    SETB	0x3,6
  0057    0190    CLR	0x10
236:              		PIR1 = 0;
  0058    1303    CLRB	0x3,6
  0059    018D    CLR	0xD
237:              		PIR2 = 0;
  005A    1703    SETB	0x3,6
  005B    018F    CLR	0xF
238:              		T2CON = 0;
  005C    1303    CLRB	0x3,6
  005D    0193    CLR	0x13
239:              		ADCON1 = 0;
  005E    1683    SETB	0x3,5
  005F    0196    CLR	0x16
240:              
241:              		//进入休眠前关掉所有功能模块,以降低休眠电流
242:              		ADCON0 = 0;
  0060    0195    CLR	0x15
243:              	
244:              		//进入休眠前,必须固定口线电平,这儿全部输出低电平,并关闭所有上拉电阻
245:              		TRISA &= 0xE4;
  0061    30E4    LDIA	0xE4
  0062    0585    ANDR	0x5
246:              		TRISB &= 0xEF;
  0063    1283    CLRB	0x3,5
  0064    1205    CLRB	0x5,4
247:              		PORTA = 0x00;
  0065    1683    SETB	0x3,5
  0066    0186    CLR	0x6
248:              		PORTB = 0x00;
  0067    1283    CLRB	0x3,5
  0068    0186    CLR	0x6
249:              		TRISC = 0;
  0069    1703    SETB	0x3,6
  006A    0185    CLR	0x5
250:              		PORTC = 0;
  006B    0186    CLR	0x6
251:              
252:              		TRISB0 =1;//输入
  006C    1303    CLRB	0x3,6
  006D    1405    SETB	0x5,0
253:              		//WPUB7 = 1;//上拉			
254:              		RBIF = 0;//清标志
  006E    100B    CLRB	0xB,0
255:              		RBIE = 1; //允许PB口电平变化中断
  006F    158B    SETB	0xB,3
256:              		IOCB0= 1;//允许PB0电平变化中断
  0070    1409    SETB	0x9,0
257:              		PORTB;//读一次PB口	
  0071    0806    LD	A,0x6
258:              /****如需要PA口中断唤醒，使能下列程序并按需修改****
259:              			TRISA0 =1;	//输入
260:              			WPUA0 = 1;	//上拉			
261:              			RAIF = 0;	//清标志
262:              			RAIE = 1;	//允许PA口电平变化中断
263:              			IOCA0 = 1;	//允许PA0电平变化中断
264:              			PEIE = 1;	//允许外设中断
265:              			PORTA;		//读一次PA口			
266:              ************************************/	
267:              
268:              		//进入休眠模式,触摸允许唤醒的按键后恢复正常工作
269:              		SystemEnterSleep();
  0072    20A9    CALL	0xA9
  0073    118A    CLRB	0xA,3
270:              		if(RAIF) 
  0074    1D8D    SNZB	0xD,3
  0075    2879    JP	0x79
271:              		{
272:              			RAIF = 0;
  0076    118D    CLRB	0xD,3
273:              			PORTA;
  0077    1683    SETB	0x3,5
  0078    0806    LD	A,0x6
274:              		}
275:              		//休眠被唤醒,重新配置中断等SFR,使系统进入正常工作
276:              		Refurbish_Sfr();
  0079    2403    CALL	0x403
  007A    118A    CLRB	0xA,3
277:              		ADCON0 = 0X41;
278:              		ADON = 1;
279:              		ADCON1 = 0x00;
  007B    2BED    JP	0x3ED
280:              	}
281:              #endif
282:              }
283:              
284:              
285:              /**********************************************************
286:              函数名称：AD_Sample
287:              函数功能：AD检测
288:              入口参数：adch - 检测通道
289:              出口参数：无
290:              备    注：采样通道需自行设置为输入口
291:              	      采样10次,取中间八次的平均值为采样结果存于adresult中
292:              
293:              	      adch 为输入AD通道 0-15，31
294:                           31  检测内部1.2V
295:              	
296:               		  adldo =5,开启内部LDO 2V 作为ADC 参考
297:               		  adldo =6,开启内部LDO 2.4V 作为ADC 参考
298:              		  adldo =7,开启内部LDO 3V 作为ADC 参考
299:               		  adldo =0,VDD 作为ADC 参考
300:               		  AD转换结果左对齐
301:               		  ADC参考电压从VDD切换到LDO时需要延时100us以上，才能进行AD转换
302:              **********************************************************/
303:              unsigned char ADC_Sample(unsigned char adch, unsigned char adldo) 
  0631    00CB    LD	0x4B,A
304:              {
305:              	volatile unsigned long adsum = 0;
306:              	volatile unsigned int admin = 0, admax = 0;
  0632    27AF    CALL	0x7AF
  0633    118A    CLRB	0xA,3
307:              	volatile unsigned int ad_temp = 0;
  0634    01D5    CLR	0x55
  0635    01D6    CLR	0x56
308:              
309:              	if ((!LDO_EN) && (adldo & 0x04) ) 
  0636    1683    SETB	0x3,5
  0637    1D16    SNZB	0x16,2
  0638    1D73    SNZB	0x73,2
  0639    2E42    JP	0x642
310:              	{
311:              								//如果AD参考从VDD换到内部LDO，需要延时100US以上
312:              		ADCON1 = adldo;			//左对齐,AD值取12位
  063A    0873    LD	A,0x73
  063B    0096    LD	0x16,A
313:              		__delay_us(100);		//IDE内置延时函数，延时100us
  063C    3042    LDIA	0x42
  063D    00F4    LD	0x74,A
  063E    0BF4    SZDECR	0x74
  063F    2E3E    JP	0x63E
  0640    0000    NOP
314:              	} 
  0641    2E44    JP	0x644
315:              	else
316:              		ADCON1 = adldo;			//如果ADCON1.7(ADFM)=1为右对齐，,AD值取10位
  0642    0873    LD	A,0x73
  0643    0096    LD	0x16,A
317:              
318:              	if(adch & 0x10) 
  0644    1283    CLRB	0x3,5
  0645    1303    CLRB	0x3,6
  0646    1E4B    SNZB	0x4B,4
  0647    2E4D    JP	0x64D
319:              	{
320:              		CHS4 = 1;
  0648    1683    SETB	0x3,5
  0649    1716    SETB	0x16,6
321:              		adch &= 0x0f;
  064A    300F    LDIA	0xF
  064B    1283    CLRB	0x3,5
  064C    05CB    ANDR	0x4B
322:              	}
323:              	unsigned char i = 0;
324:              	for (i = 0; i < 10; i++) 
  064D    01CC    CLR	0x4C
325:              	{
326:              		ADCON0 = (unsigned char)(0X41 | (adch << 2));	//16分频，如果主频为16M，则必须选16分频或以上
  064E    084B    LD	A,0x4B
  064F    00F4    LD	0x74,A
  0650    3001    LDIA	0x1
  0651    1003    CLRB	0x3,0
  0652    0DF4    RLCR	0x74
  0653    3EFF    ADDIA	0xFF
  0654    1003    CLRB	0x3,0
  0655    1D03    SNZB	0x3,2
  0656    2E52    JP	0x652
  0657    0D74    RLCA	0x74
  0658    3841    ORIA	0x41
  0659    1683    SETB	0x3,5
  065A    0095    LD	0x15,A
  065B    0000    NOP
  065C    0000    NOP
  065D    0000    NOP
  065E    0000    NOP
327:              		asm("nop");
328:              		asm("nop");
329:              		asm("nop");
330:              		asm("nop");				//选择通道后需延时1uS以上
331:              		GODONE = 1;				//开始转换
  065F    1683    SETB	0x3,5
  0660    1303    CLRB	0x3,6
  0661    1495    SETB	0x15,1
332:              
333:              		unsigned char j = 0;
  0662    1283    CLRB	0x3,5
  0663    01CA    CLR	0x4A
334:              		while (GODONE) 
  0664    1683    SETB	0x3,5
  0665    1C95    SNZB	0x15,1
  0666    2E6E    JP	0x66E
335:              		{
336:              			__delay_us(2);		//延时2us(编译器内置函数)
  0667    2E68    JP	0x668
  0668    2E69    JP	0x669
337:              
338:              			if (0 == (--j))		//延时0.5ms仍没有AD转换结束，跳出程序
  0669    1283    CLRB	0x3,5
  066A    1303    CLRB	0x3,6
  066B    0BCA    SZDECR	0x4A
  066C    2E64    JP	0x664
339:              			return 0;
  066D    3400    RET	0x0
340:              		}
341:              
342:              		ad_temp = (unsigned int)((ADRESH << 4) + (ADRESL >> 4));	//计算12位AD值
  066E    0819    LD	A,0x19
  066F    1283    CLRB	0x3,5
  0670    00D5    LD	0x55,A
  0671    01D6    CLR	0x56
  0672    0ED5    SWAPR	0x55
  0673    0ED6    SWAPR	0x56
  0674    30F0    LDIA	0xF0
  0675    05D6    ANDR	0x56
  0676    0855    LD	A,0x55
  0677    390F    ANDIA	0xF
  0678    04D6    ORR	0x56
  0679    30F0    LDIA	0xF0
  067A    05D5    ANDR	0x55
  067B    1683    SETB	0x3,5
  067C    0E18    SWAPA	0x18
  067D    390F    ANDIA	0xF
  067E    1283    CLRB	0x3,5
  067F    07D5    ADDR	0x55
  0680    1803    SZB	0x3,0
  0681    0AD6    INCR	0x56
343:              
344:              		if (0 == admax) 
  0682    0853    LD	A,0x53
  0683    0454    ORA	0x54
  0684    1D03    SNZB	0x3,2
  0685    2E89    JP	0x689
345:              		{
346:              			admax = ad_temp;
  0686    27C4    CALL	0x7C4
  0687    118A    CLRB	0xA,3
  0688    2E9C    JP	0x69C
347:              			admin = ad_temp;
348:              		} 
349:              		else if (ad_temp > admax)
  0689    0856    LD	A,0x56
  068A    0254    SUBA	0x54
  068B    1D03    SNZB	0x3,2
  068C    2E8F    JP	0x68F
  068D    0855    LD	A,0x55
  068E    0253    SUBA	0x53
  068F    1803    SZB	0x3,0
  0690    2E94    JP	0x694
350:              			admax = ad_temp;				//AD采样最大值
  0691    27C4    CALL	0x7C4
  0692    118A    CLRB	0xA,3
  0693    2EA0    JP	0x6A0
351:              		else if (ad_temp < admin)
  0694    0852    LD	A,0x52
  0695    0256    SUBA	0x56
  0696    1D03    SNZB	0x3,2
  0697    2E9A    JP	0x69A
  0698    0851    LD	A,0x51
  0699    0255    SUBA	0x55
  069A    1803    SZB	0x3,0
  069B    2EA0    JP	0x6A0
352:              			admin = ad_temp;				//AD采样最小值
  069C    0856    LD	A,0x56
  069D    00D2    LD	0x52,A
  069E    0855    LD	A,0x55
  069F    00D1    LD	0x51,A
353:              
354:              		adsum += ad_temp;
  06A0    0855    LD	A,0x55
  06A1    00F4    LD	0x74,A
  06A2    0856    LD	A,0x56
  06A3    00F5    LD	0x75,A
  06A4    01F6    CLR	0x76
  06A5    01F7    CLR	0x77
  06A6    0874    LD	A,0x74
  06A7    07CD    ADDR	0x4D
  06A8    0875    LD	A,0x75
  06A9    1103    CLRB	0x3,2
  06AA    1803    SZB	0x3,0
  06AB    3E01    ADDIA	0x1
  06AC    1D03    SNZB	0x3,2
  06AD    07CE    ADDR	0x4E
  06AE    0876    LD	A,0x76
  06AF    1103    CLRB	0x3,2
  06B0    1803    SZB	0x3,0
  06B1    3E01    ADDIA	0x1
  06B2    1D03    SNZB	0x3,2
  06B3    07CF    ADDR	0x4F
  06B4    0877    LD	A,0x77
  06B5    1103    CLRB	0x3,2
  06B6    1803    SZB	0x3,0
  06B7    3E01    ADDIA	0x1
  06B8    1D03    SNZB	0x3,2
  06B9    07D0    ADDR	0x50
  06BA    300A    LDIA	0xA
  06BB    0ACC    INCR	0x4C
  06BC    024C    SUBA	0x4C
  06BD    1C03    SNZB	0x3,0
  06BE    2E4E    JP	0x64E
355:              	}
356:              		adsum -= admax;
  06BF    0853    LD	A,0x53
  06C0    00F4    LD	0x74,A
  06C1    0854    LD	A,0x54
  06C2    27A0    CALL	0x7A0
  06C3    118A    CLRB	0xA,3
  06C4    1C03    SNZB	0x3,0
  06C5    0F77    SZINCA	0x77
  06C6    02D0    SUBR	0x50
357:              		if (adsum >= admin)
  06C7    0851    LD	A,0x51
  06C8    00F4    LD	0x74,A
  06C9    0852    LD	A,0x52
  06CA    00F5    LD	0x75,A
  06CB    01F6    CLR	0x76
  06CC    01F7    CLR	0x77
  06CD    0877    LD	A,0x77
  06CE    0250    SUBA	0x50
  06CF    1D03    SNZB	0x3,2
  06D0    2EDB    JP	0x6DB
  06D1    0876    LD	A,0x76
  06D2    024F    SUBA	0x4F
  06D3    1D03    SNZB	0x3,2
  06D4    2EDB    JP	0x6DB
  06D5    0875    LD	A,0x75
  06D6    024E    SUBA	0x4E
  06D7    1D03    SNZB	0x3,2
  06D8    2EDB    JP	0x6DB
  06D9    0874    LD	A,0x74
  06DA    024D    SUBA	0x4D
  06DB    1C03    SNZB	0x3,0
  06DC    2EE6    JP	0x6E6
358:              			adsum -= admin;
  06DD    0851    LD	A,0x51
  06DE    00F4    LD	0x74,A
  06DF    0852    LD	A,0x52
  06E0    27A0    CALL	0x7A0
  06E1    118A    CLRB	0xA,3
  06E2    1C03    SNZB	0x3,0
  06E3    0F77    SZINCA	0x77
  06E4    02D0    SUBR	0x50
  06E5    2EEA    JP	0x6EA
359:              		else
360:              			adsum = 0;
  06E6    01CD    CLR	0x4D
  06E7    01CE    CLR	0x4E
  06E8    01CF    CLR	0x4F
  06E9    01D0    CLR	0x50
361:              
362:              		adresult = adsum >> 3;		//8次平均值作为最终结果
  06EA    084D    LD	A,0x4D
  06EB    00F4    LD	0x74,A
  06EC    084E    LD	A,0x4E
  06ED    00F5    LD	0x75,A
  06EE    084F    LD	A,0x4F
  06EF    00F6    LD	0x76,A
  06F0    0850    LD	A,0x50
  06F1    00F7    LD	0x77,A
  06F2    3003    LDIA	0x3
  06F3    1003    CLRB	0x3,0
  06F4    0CF7    RRCR	0x77
  06F5    0CF6    RRCR	0x76
  06F6    0CF5    RRCR	0x75
  06F7    0CF4    RRCR	0x74
  06F8    3EFF    ADDIA	0xFF
  06F9    1D03    SNZB	0x3,2
  06FA    2EF3    JP	0x6F3
  06FB    0875    LD	A,0x75
  06FC    00C9    LD	0x49,A
  06FD    0874    LD	A,0x74
  06FE    00C8    LD	0x48,A
363:              
364:              		adsum = 0;
365:              		admin = 0;
366:              		admax = 0;
  06FF    27AF    CALL	0x7AF
367:              		return 0xA5;
  0700    34A5    RET	0xA5
368:              		
369:              }
370:              
371:              void ledShow()
372:              {
373:              
374:              	if(++ledCnt > 19)
  0E80    3014    LDIA	0x14
  0E81    0ABB    INCR	0x3B
  0E82    023B    SUBA	0x3B
  0E83    1803    SZB	0x3,0
375:              	{
376:              		ledCnt = 0;
  0E84    01BB    CLR	0x3B
377:              	
378:              	}
379:              	PORTA &= 0xE4;
380:              	PORTB &= 0xEF;
381:              	TRISA |= 0x1B;
382:              	TRISB |= 0x10;
  0E85    158A    SETB	0xA,3
  0E86    257E    CALL	0x57E
  0E87    158A    SETB	0xA,3
383:              	switch(ledCnt)
  0E88    2F18    JP	0x718
384:              	{
385:              		case 0:
386:              		break;
387:              		case 1:
388:              		if(showNumShi & 0x01)
  0E89    1C6D    SNZB	0x6D,0
  0E8A    0008    RET
389:              		{
390:              			LED1_OUT;
  0E8B    1683    SETB	0x3,5
  0E8C    1005    CLRB	0x5,0
391:              			LED2_OUT;
  0E8D    1205    CLRB	0x5,4
392:              			LED2 = 1;
  0E8E    1606    SETB	0x6,4
  0E8F    0008    RET
393:              		}
394:              		break;
395:              		case 2:
396:              		if(showNumShi & 0x02)
  0E90    1CED    SNZB	0x6D,1
  0E91    0008    RET
397:              		{
398:              			LED1_OUT;
  0E92    1683    SETB	0x3,5
  0E93    1005    CLRB	0x5,0
399:              			LED3_OUT;
  0E94    1185    CLRB	0x5,3
400:              			LED3 = 1;
  0E95    1586    SETB	0x6,3
  0E96    0008    RET
401:              		}
402:              		break;
403:              		case 3:
404:              		if(showNumShi & 0x04)
  0E97    1D6D    SNZB	0x6D,2
  0E98    0008    RET
405:              		{
406:              			LED1_OUT;
  0E99    1683    SETB	0x3,5
  0E9A    1005    CLRB	0x5,0
407:              			LED4_OUT;
  0E9B    1085    CLRB	0x5,1
408:              			LED4 = 1;
  0E9C    1486    SETB	0x6,1
  0E9D    0008    RET
409:              		}
410:              		break;
411:              		case 4:
412:              		if(showNumShi & 0x08)
  0E9E    1DED    SNZB	0x6D,3
  0E9F    0008    RET
413:              		{
414:              			LED1_OUT;
  0EA0    1683    SETB	0x3,5
  0EA1    1005    CLRB	0x5,0
415:              			LED5_OUT;
416:              			LED5 = 1;
  0EA2    2F25    JP	0x725
417:              		}
418:              		break;
419:              		case 5:
420:              		if(showNumShi & 0x10)
  0EA3    1E6D    SNZB	0x6D,4
  0EA4    0008    RET
421:              		{
422:              			LED2_OUT;
  0EA5    1683    SETB	0x3,5
  0EA6    1205    CLRB	0x5,4
423:              			LED1_OUT;
  0EA7    1005    CLRB	0x5,0
424:              			LED1 = 1;
  0EA8    1406    SETB	0x6,0
  0EA9    0008    RET
425:              		}
426:              		break;
427:              		case 6:
428:              		if(showNumShi & 0x20)
  0EAA    1EED    SNZB	0x6D,5
  0EAB    0008    RET
429:              		{
430:              			LED2_OUT;
  0EAC    1683    SETB	0x3,5
  0EAD    1205    CLRB	0x5,4
431:              			LED3_OUT;
  0EAE    1185    CLRB	0x5,3
432:              			LED3 = 1;
  0EAF    1586    SETB	0x6,3
  0EB0    0008    RET
433:              		}
434:              		break;
435:              		case 7:
436:              		if(showNumShi & 0x40)
  0EB1    1F6D    SNZB	0x6D,6
  0EB2    0008    RET
437:              		{
438:              			LED2_OUT;
  0EB3    1683    SETB	0x3,5
  0EB4    1205    CLRB	0x5,4
439:              			LED4_OUT;
  0EB5    1085    CLRB	0x5,1
440:              			LED4 = 1;
  0EB6    1486    SETB	0x6,1
  0EB7    0008    RET
441:              		}
442:              		break;
443:              		case 8:
444:              		if(showNumGe & 0x01)
  0EB8    1C6C    SNZB	0x6C,0
  0EB9    0008    RET
445:              		{
446:              			LED2_OUT;
  0EBA    1683    SETB	0x3,5
  0EBB    1205    CLRB	0x5,4
447:              			LED5_OUT;
448:              			LED5 = 1;
  0EBC    2F25    JP	0x725
449:              		}
450:              		break;
451:              		case 9:
452:              		if(showNumGe & 0x02)
  0EBD    1CEC    SNZB	0x6C,1
  0EBE    0008    RET
453:              		{
454:              			LED3_OUT;
  0EBF    1683    SETB	0x3,5
  0EC0    1185    CLRB	0x5,3
455:              			LED1_OUT;
  0EC1    1005    CLRB	0x5,0
456:              			LED1 = 1;
  0EC2    1406    SETB	0x6,0
  0EC3    0008    RET
457:              		}
458:              		break;
459:              		case 10:
460:              		if(showNumGe & 0x04)
  0EC4    1D6C    SNZB	0x6C,2
  0EC5    0008    RET
461:              		{
462:              			LED3_OUT;
  0EC6    1683    SETB	0x3,5
  0EC7    1185    CLRB	0x5,3
463:              			LED2_OUT;
  0EC8    1205    CLRB	0x5,4
464:              			LED2 = 1;
  0EC9    1606    SETB	0x6,4
  0ECA    0008    RET
465:              		}
466:              		break;
467:              		case 11:
468:              		if(showNumGe & 0x08)
  0ECB    1DEC    SNZB	0x6C,3
  0ECC    0008    RET
469:              		{
470:              			LED3_OUT;
  0ECD    1683    SETB	0x3,5
  0ECE    1185    CLRB	0x5,3
471:              			LED4_OUT;
  0ECF    1085    CLRB	0x5,1
472:              			LED4 = 1;
  0ED0    1486    SETB	0x6,1
  0ED1    0008    RET
473:              		}
474:              		break;
475:              		case 12:
476:              		if(showNumGe & 0x10)
  0ED2    1E6C    SNZB	0x6C,4
  0ED3    0008    RET
477:              		{
478:              			LED3_OUT;
  0ED4    1683    SETB	0x3,5
  0ED5    1185    CLRB	0x5,3
479:              			LED5_OUT;
480:              			LED5 = 1;
  0ED6    2F25    JP	0x725
481:              		}
482:              		break;
483:              		case 13:
484:              		if(showNumGe & 0x20)
  0ED7    1EEC    SNZB	0x6C,5
  0ED8    0008    RET
485:              		{
486:              			LED4_OUT;
  0ED9    1683    SETB	0x3,5
  0EDA    1085    CLRB	0x5,1
487:              			LED1_OUT;
  0EDB    1005    CLRB	0x5,0
488:              			LED1 = 1;
  0EDC    1406    SETB	0x6,0
  0EDD    0008    RET
489:              		}
490:              		break;
491:              		case 14:
492:              		if(showNumGe & 0x40)
  0EDE    1F6C    SNZB	0x6C,6
  0EDF    0008    RET
493:              		{
494:              			LED4_OUT;
  0EE0    1683    SETB	0x3,5
  0EE1    1085    CLRB	0x5,1
495:              			LED2_OUT;
  0EE2    1205    CLRB	0x5,4
496:              			LED2 = 1;
  0EE3    1606    SETB	0x6,4
  0EE4    0008    RET
497:              		}
498:              		break;
499:              		case 15:
500:              		if(firstTime || showNumGe || showNumShi)
  0EE5    086E    LD	A,0x6E
  0EE6    1D03    SNZB	0x3,2
  0EE7    2EED    JP	0x6ED
  0EE8    086C    LD	A,0x6C
  0EE9    1903    SZB	0x3,2
  0EEA    086D    LD	A,0x6D
  0EEB    1903    SZB	0x3,2
  0EEC    0008    RET
501:              		{
502:              			LED4_OUT;
  0EED    1683    SETB	0x3,5
  0EEE    1085    CLRB	0x5,1
503:              			LED3_OUT;
  0EEF    1185    CLRB	0x5,3
504:              			LED3 = 1;
  0EF0    1586    SETB	0x6,3
  0EF1    0008    RET
505:              		}
506:              		break;
507:              		case 16:
508:              		if(firstTime > 0 || wuhuaFlag > 0)
  0EF2    086E    LD	A,0x6E
  0EF3    1903    SZB	0x3,2
  0EF4    0844    LD	A,0x44
  0EF5    1903    SZB	0x3,2
  0EF6    0008    RET
509:              		{
510:              			LED4_OUT;
  0EF7    1683    SETB	0x3,5
  0EF8    1085    CLRB	0x5,1
511:              			LED5_OUT;
512:              			LED5 = 1;
  0EF9    2F25    JP	0x725
513:              		}
514:              		break;
515:              		case 17:
516:              		if(firstTime > 0 ||workStep > 0)
  0EFA    086E    LD	A,0x6E
  0EFB    1903    SZB	0x3,2
  0EFC    0845    LD	A,0x45
  0EFD    1903    SZB	0x3,2
  0EFE    0008    RET
517:              		{
518:              			LED5_OUT;
  0EFF    1205    CLRB	0x5,4
519:              			LED1_OUT;
  0F00    1683    SETB	0x3,5
  0F01    1005    CLRB	0x5,0
520:              			LED1 = 1;
  0F02    1406    SETB	0x6,0
  0F03    0008    RET
521:              		}
522:              		break;
523:              		case 18:
524:              		if(firstTime > 0 ||fanKeyFlag > 0)
  0F04    086E    LD	A,0x6E
  0F05    1903    SZB	0x3,2
  0F06    083A    LD	A,0x3A
  0F07    1903    SZB	0x3,2
  0F08    0008    RET
525:              		{
526:              			LED5_OUT;
  0F09    1205    CLRB	0x5,4
527:              			LED2_OUT;
  0F0A    1683    SETB	0x3,5
  0F0B    1205    CLRB	0x5,4
528:              			LED2 = 1;
  0F0C    1606    SETB	0x6,4
  0F0D    0008    RET
529:              		}
530:              		break;
531:              		case 19:
532:              		if(firstTime > 0 ||wuhuaKeyFlag > 0)
  0F0E    086E    LD	A,0x6E
  0F0F    1903    SZB	0x3,2
  0F10    0839    LD	A,0x39
  0F11    1903    SZB	0x3,2
  0F12    0008    RET
533:              		{
534:              			LED5_OUT;
  0F13    1205    CLRB	0x5,4
535:              			LED4_OUT;
  0F14    1683    SETB	0x3,5
  0F15    1085    CLRB	0x5,1
536:              			LED4 = 1;
  0F16    1486    SETB	0x6,1
  0F17    0008    RET
  0F18    083B    LD	A,0x3B
  0F19    0084    LD	0x4,A
  0F1A    3014    LDIA	0x14
  0F1B    0204    SUBA	0x4
  0F1C    1803    SZB	0x3,0
  0F1D    0008    RET
  0F1E    3007    LDIA	0x7
  0F1F    008A    LD	0xA,A
  0F20    1003    CLRB	0x3,0
  0F21    0D04    RLCA	0x4
  0F22    3ECD    ADDIA	0xCD
  0F23    0082    LD	0x2,A
  0F24    0008    RET
537:              		}
538:              		break;
539:              		default:
540:              		break;
541:              	}
542:              
543:              }
544:              
545:              void showBatLed()
546:              {
547:              	showNumShi = numArray[showBatStep/10];
  0E0A    300A    LDIA	0xA
  0E0B    00F3    LD	0x73,A
  0E0C    0838    LD	A,0x38
  0E0D    261E    CALL	0x61E
  0E0E    3E01    ADDIA	0x1
  0E0F    0084    LD	0x4,A
  0E10    158A    SETB	0xA,3
  0E11    2000    CALL	0x0
  0E12    158A    SETB	0xA,3
  0E13    00ED    LD	0x6D,A
548:              	showNumGe = numArray[showBatStep%10];
  0E14    300A    LDIA	0xA
  0E15    00F3    LD	0x73,A
  0E16    0838    LD	A,0x38
  0E17    2639    CALL	0x639
  0E18    3E01    ADDIA	0x1
  0E19    0084    LD	0x4,A
  0E1A    158A    SETB	0xA,3
  0E1B    2000    CALL	0x0
  0E1C    00EC    LD	0x6C,A
  0E1D    0008    RET
549:              }
550:              
551:              void setBatStep()
552:              {
553:              	if(lowBatLock == 1)
  0F29    1283    CLRB	0x3,5
  0F2A    0B3D    SZDECA	0x3D
  0F2B    2F2F    JP	0x72F
554:              	{
555:              		showBatStep = 0;
  0F2C    01B8    CLR	0x38
556:              		curBatStep = 0;
  0F2D    01B7    CLR	0x37
557:              	}
  0F2E    0008    RET
558:              	else if(power_ad < 2800)
  0F2F    300A    LDIA	0xA
  0F30    0227    SUBA	0x27
  0F31    30F0    LDIA	0xF0
  0F32    1903    SZB	0x3,2
  0F33    0226    SUBA	0x26
  0F34    1803    SZB	0x3,0
  0F35    2F4C    JP	0x74C
559:              	{
560:              		if(count10s == 0 && count1s == 0)
  0F36    0842    LD	A,0x42
  0F37    1D03    SNZB	0x3,2
  0F38    2F49    JP	0x749
  0F39    0846    LD	A,0x46
  0F3A    1D03    SNZB	0x3,2
  0F3B    2F49    JP	0x749
561:              		{
562:              			if(showBatStep > 1)
  0F3C    3002    LDIA	0x2
  0F3D    0238    SUBA	0x38
  0F3E    1C03    SNZB	0x3,0
  0F3F    2F45    JP	0x745
563:              			{
564:              				if(chrgFlag == 0)
  0F40    0840    LD	A,0x40
  0F41    1D03    SNZB	0x3,2
  0F42    2F47    JP	0x747
565:              					showBatStep--;
  0F43    03B8    DECR	0x38
  0F44    2F47    JP	0x747
566:              			}
567:              			else
568:              			{
569:              				showBatStep = 1;
  0F45    01B8    CLR	0x38
  0F46    0AB8    INCR	0x38
570:              			}
571:              			curBatStep = 1;
  0F47    01B7    CLR	0x37
  0F48    0AB7    INCR	0x37
572:              		}
573:              		curBatStep = 1;
  0F49    01B7    CLR	0x37
  0F4A    0AB7    INCR	0x37
574:              	}
  0F4B    0008    RET
575:              	else
576:              	{
577:              		if(power_ad < 3600)
  0F4C    300E    LDIA	0xE
  0F4D    0227    SUBA	0x27
  0F4E    3010    LDIA	0x10
  0F4F    1903    SZB	0x3,2
  0F50    0226    SUBA	0x26
  0F51    1803    SZB	0x3,0
  0F52    2F62    JP	0x762
578:              		{
579:              			curBatStep = (power_ad - 2800)/80;
  0F53    3050    LDIA	0x50
  0F54    00F3    LD	0x73,A
  0F55    01F4    CLR	0x74
  0F56    0826    LD	A,0x26
  0F57    3E10    ADDIA	0x10
  0F58    00F5    LD	0x75,A
  0F59    0827    LD	A,0x27
  0F5A    1803    SZB	0x3,0
  0F5B    3E01    ADDIA	0x1
  0F5C    3EF5    ADDIA	0xF5
  0F5D    00F6    LD	0x76,A
  0F5E    27D6    CALL	0x7D6
  0F5F    158A    SETB	0xA,3
  0F60    0873    LD	A,0x73
  0F61    2F71    JP	0x771
580:              		}
581:              		else
582:              		{
583:              			curBatStep = 20 + ((power_ad - 3600)/5);
  0F62    3005    LDIA	0x5
  0F63    00F3    LD	0x73,A
  0F64    01F4    CLR	0x74
  0F65    0826    LD	A,0x26
  0F66    3EF0    ADDIA	0xF0
  0F67    00F5    LD	0x75,A
  0F68    0827    LD	A,0x27
  0F69    1803    SZB	0x3,0
  0F6A    3E01    ADDIA	0x1
  0F6B    3EF1    ADDIA	0xF1
  0F6C    00F6    LD	0x76,A
  0F6D    27D6    CALL	0x7D6
  0F6E    158A    SETB	0xA,3
  0F6F    0873    LD	A,0x73
  0F70    3E14    ADDIA	0x14
  0F71    00B7    LD	0x37,A
584:              		}
585:              		if(curBatStep > 99)
  0F72    3064    LDIA	0x64
  0F73    0237    SUBA	0x37
  0F74    1C03    SNZB	0x3,0
  0F75    2F78    JP	0x778
586:              		{
587:              			curBatStep = 99;
  0F76    3063    LDIA	0x63
  0F77    00B7    LD	0x37,A
588:              		}
589:              
590:              		if(chrgFlag)
  0F78    0840    LD	A,0x40
  0F79    1903    SZB	0x3,2
  0F7A    2FAF    JP	0x7AF
591:              		{
592:              			if(chrgFullFlag && showBatStep < 99)
  0F7B    083F    LD	A,0x3F
  0F7C    1903    SZB	0x3,2
  0F7D    2F92    JP	0x792
  0F7E    3063    LDIA	0x63
  0F7F    0238    SUBA	0x38
  0F80    1803    SZB	0x3,0
  0F81    2F92    JP	0x792
593:              			{
594:              				if(++count15s >= 7500)
  0F82    1683    SETB	0x3,5
  0F83    0AB4    INCR	0x34
  0F84    1903    SZB	0x3,2
  0F85    0AB5    INCR	0x35
  0F86    301D    LDIA	0x1D
  0F87    0235    SUBA	0x35
  0F88    304C    LDIA	0x4C
  0F89    1903    SZB	0x3,2
  0F8A    0234    SUBA	0x34
  0F8B    1C03    SNZB	0x3,0
  0F8C    2F95    JP	0x795
595:              				{
596:              					count15s = 0;
  0F8D    01B4    CLR	0x34
  0F8E    01B5    CLR	0x35
597:              					showBatStep++;
  0F8F    1283    CLRB	0x3,5
  0F90    0AB8    INCR	0x38
  0F91    2F95    JP	0x795
598:              				}
599:              			}
600:              			else
601:              			{
602:              				count15s = 0;
  0F92    1683    SETB	0x3,5
  0F93    01B4    CLR	0x34
  0F94    01B5    CLR	0x35
603:              			}
604:              			if(curBatStep > showBatStep)
  0F95    1283    CLRB	0x3,5
  0F96    0837    LD	A,0x37
  0F97    0238    SUBA	0x38
  0F98    1803    SZB	0x3,0
  0F99    2FAC    JP	0x7AC
605:              			{
606:              				if(++count30s >= 15000 && showBatStep < 99)	//60s
  0F9A    0AA8    INCR	0x28
  0F9B    1903    SZB	0x3,2
  0F9C    0AA9    INCR	0x29
  0F9D    303A    LDIA	0x3A
  0F9E    0229    SUBA	0x29
  0F9F    3098    LDIA	0x98
  0FA0    1903    SZB	0x3,2
  0FA1    0228    SUBA	0x28
  0FA2    1C03    SNZB	0x3,0
  0FA3    0008    RET
  0FA4    3063    LDIA	0x63
  0FA5    0238    SUBA	0x38
  0FA6    1803    SZB	0x3,0
  0FA7    0008    RET
607:              				{	
608:              					count30s = 0;
  0FA8    01A8    CLR	0x28
  0FA9    01A9    CLR	0x29
609:              					showBatStep++;
  0FAA    0AB8    INCR	0x38
  0FAB    0008    RET
610:              				}
611:              				
612:              			}
613:              			else
614:              			{
615:              				count30s = 0;
  0FAC    01A8    CLR	0x28
  0FAD    01A9    CLR	0x29
  0FAE    0008    RET
616:              			}
617:              		}
618:              		else
619:              		{
620:              			u16t tempSubBatTime = 15000;
  0FAF    3098    LDIA	0x98
  0FB0    00CD    LD	0x4D,A
  0FB1    303A    LDIA	0x3A
  0FB2    00CE    LD	0x4E,A
621:              			if(showBatStep < 40)
  0FB3    3028    LDIA	0x28
  0FB4    0238    SUBA	0x38
  0FB5    1803    SZB	0x3,0
  0FB6    2FBB    JP	0x7BB
622:              			{
623:              				tempSubBatTime = 8000;
  0FB7    3040    LDIA	0x40
  0FB8    00CD    LD	0x4D,A
  0FB9    301F    LDIA	0x1F
  0FBA    00CE    LD	0x4E,A
624:              			}
625:              			if(curBatStep < showBatStep && showBatStep > 1)
  0FBB    0838    LD	A,0x38
  0FBC    0237    SUBA	0x37
  0FBD    1803    SZB	0x3,0
  0FBE    2FAC    JP	0x7AC
  0FBF    3002    LDIA	0x2
  0FC0    0238    SUBA	0x38
  0FC1    1C03    SNZB	0x3,0
  0FC2    2FAC    JP	0x7AC
626:              			{
627:              				if(++count30s >= tempSubBatTime && showBatStep > 1)	//60s
  0FC3    0AA8    INCR	0x28
  0FC4    1903    SZB	0x3,2
  0FC5    0AA9    INCR	0x29
  0FC6    084E    LD	A,0x4E
  0FC7    0229    SUBA	0x29
  0FC8    1D03    SNZB	0x3,2
  0FC9    2FCC    JP	0x7CC
  0FCA    084D    LD	A,0x4D
  0FCB    0228    SUBA	0x28
  0FCC    1C03    SNZB	0x3,0
  0FCD    0008    RET
  0FCE    3002    LDIA	0x2
  0FCF    0238    SUBA	0x38
  0FD0    1C03    SNZB	0x3,0
  0FD1    0008    RET
628:              				{	
629:              					count30s = 0;
  0FD2    01A8    CLR	0x28
  0FD3    01A9    CLR	0x29
630:              					showBatStep--;
  0FD4    03B8    DECR	0x38
  0FD5    0008    RET
631:              				}
632:              			}
633:              			else
634:              			{
635:              				count30s = 0;
636:              			}
637:              		}
638:              		
639:              	}
640:              }
641:              
642:              void chrgCtr()
643:              {
644:              	if(PORTB & 0x01)
  0DD7    1283    CLRB	0x3,5
  0DD8    1303    CLRB	0x3,6
  0DD9    1C06    SNZB	0x6,0
  0DDA    2DF0    JP	0x5F0
645:              	{
646:              		chrgFlag = 1;
  0DDB    01C0    CLR	0x40
  0DDC    0AC0    INCR	0x40
647:              		firstLock = 0;
  0DDD    1683    SETB	0x3,5
  0DDE    01C2    CLR	0x42
648:              		lowBatLock = 0;
  0DDF    1283    CLRB	0x3,5
  0DE0    01BD    CLR	0x3D
649:              		showBatLed();
  0DE1    260A    CALL	0x60A
  0DE2    158A    SETB	0xA,3
650:              		if(PORTB & 0x02)
  0DE3    1C86    SNZB	0x6,1
  0DE4    2DEE    JP	0x5EE
651:              		{
652:              			if(++chrgFullTime > 200)
  0DE5    30C9    LDIA	0xC9
  0DE6    0ABE    INCR	0x3E
  0DE7    023E    SUBA	0x3E
  0DE8    1C03    SNZB	0x3,0
  0DE9    0008    RET
653:              			{
654:              				chrgFullTime = 0;
  0DEA    01BE    CLR	0x3E
655:              				chrgFullFlag = 1;
  0DEB    01BF    CLR	0x3F
  0DEC    0ABF    INCR	0x3F
  0DED    0008    RET
656:              			}
657:              		}
658:              		else
659:              		{
660:              			chrgFullTime = 0;
  0DEE    01BE    CLR	0x3E
  0DEF    0008    RET
661:              		}
662:              
663:              	}
664:              	else
665:              	{
666:              		chrgFlag = 0;
  0DF0    01C0    CLR	0x40
667:              		chrgFullTime = 0;
  0DF1    01BE    CLR	0x3E
668:              		chrgFullFlag = 0;
  0DF2    01BF    CLR	0x3F
669:              		
670:              		if(firstTime == 0)
  0DF3    086E    LD	A,0x6E
  0DF4    1D03    SNZB	0x3,2
  0DF5    2E00    JP	0x600
671:              		{
672:              			if(workStep == 0 && wuhuaFlag == 0)
  0DF6    0845    LD	A,0x45
  0DF7    1D03    SNZB	0x3,2
  0DF8    2DFF    JP	0x5FF
  0DF9    0844    LD	A,0x44
  0DFA    1D03    SNZB	0x3,2
  0DFB    2DFF    JP	0x5FF
673:              			{
674:              				showNumShi = 0;
  0DFC    01ED    CLR	0x6D
675:              				showNumGe = 0;
  0DFD    01EC    CLR	0x6C
676:              			}
  0DFE    0008    RET
677:              			else
678:              			{
679:              				showBatLed();
  0DFF    2E0A    JP	0x60A
680:              			}
681:              		}
682:              		else
683:              		{
684:              			if(showBatStep < curBatStep)
  0E00    0837    LD	A,0x37
  0E01    0238    SUBA	0x38
  0E02    1803    SZB	0x3,0
  0E03    2E06    JP	0x606
685:              			{
686:              				showBatStep = curBatStep;
  0E04    0837    LD	A,0x37
  0E05    00B8    LD	0x38,A
687:              			}
688:              			showNumShi = 0x7F;
  0E06    307F    LDIA	0x7F
  0E07    00ED    LD	0x6D,A
689:              			showNumGe = 0x7F;
  0E08    00EC    LD	0x6C,A
  0E09    0008    RET
690:              		}
691:              	}
692:              }
693:              
694:              void keyLedCtr()
695:              {
696:              	if(shanshuoTime > 0)
  0701    082C    LD	A,0x2C
  0702    042D    ORA	0x2D
  0703    1903    SZB	0x3,2
  0704    2F1D    JP	0x71D
697:              	{
698:              		shanshuoTime--;
  0705    3001    LDIA	0x1
  0706    02AC    SUBR	0x2C
  0707    3000    LDIA	0x0
  0708    1C03    SNZB	0x3,0
  0709    03AD    DECR	0x2D
  070A    02AD    SUBR	0x2D
699:              		if((shanshuoTime % 75) < 37)
  070B    304B    LDIA	0x4B
  070C    00F3    LD	0x73,A
  070D    01F4    CLR	0x74
  070E    082D    LD	A,0x2D
  070F    00F6    LD	0x76,A
  0710    082C    LD	A,0x2C
  0711    00F5    LD	0x75,A
  0712    2745    CALL	0x745
  0713    118A    CLRB	0xA,3
  0714    3000    LDIA	0x0
  0715    0274    SUBA	0x74
  0716    3025    LDIA	0x25
  0717    1903    SZB	0x3,2
  0718    0273    SUBA	0x73
  0719    1803    SZB	0x3,0
  071A    2F20    JP	0x720
700:              		{
701:              			fanKeyFlag = 0;
  071B    01BA    CLR	0x3A
702:              		}
  071C    2F22    JP	0x722
703:              		else
704:              		{
705:              			fanKeyFlag = 1;
  0720    01BA    CLR	0x3A
  0721    0ABA    INCR	0x3A
706:              		}
707:              	}
708:              	else if(workStep > 0)
  071D    0845    LD	A,0x45
  071E    1903    SZB	0x3,2
  071F    2F1B    JP	0x71B
709:              	{
710:              		fanKeyFlag = 1;
711:              	}
712:              	else
713:              	{
714:              		fanKeyFlag = 0;
715:              	}
716:              	
717:              	if(shanshuoTime2 > 0)
  0722    082A    LD	A,0x2A
  0723    042B    ORA	0x2B
  0724    1903    SZB	0x3,2
  0725    2F41    JP	0x741
718:              	{
719:              		shanshuoTime2--;
  0726    3001    LDIA	0x1
  0727    02AA    SUBR	0x2A
  0728    3000    LDIA	0x0
  0729    1C03    SNZB	0x3,0
  072A    03AB    DECR	0x2B
  072B    02AB    SUBR	0x2B
720:              		if((shanshuoTime2 % 75) < 37)
  072C    304B    LDIA	0x4B
  072D    00F3    LD	0x73,A
  072E    01F4    CLR	0x74
  072F    082B    LD	A,0x2B
  0730    00F6    LD	0x76,A
  0731    082A    LD	A,0x2A
  0732    00F5    LD	0x75,A
  0733    2745    CALL	0x745
  0734    118A    CLRB	0xA,3
  0735    3000    LDIA	0x0
  0736    0274    SUBA	0x74
  0737    3025    LDIA	0x25
  0738    1903    SZB	0x3,2
  0739    0273    SUBA	0x73
  073A    1803    SZB	0x3,0
  073B    2F3E    JP	0x73E
721:              		{
722:              			wuhuaKeyFlag = 0;
  073C    01B9    CLR	0x39
723:              		}
  073D    0008    RET
724:              		else
725:              		{
726:              			wuhuaKeyFlag = 1;
  073E    01B9    CLR	0x39
  073F    0AB9    INCR	0x39
  0740    0008    RET
727:              		}
728:              	}
729:              	else if(wuhuaFlag > 0)
  0741    0844    LD	A,0x44
  0742    1D03    SNZB	0x3,2
  0743    2F3E    JP	0x73E
  0744    2F3C    JP	0x73C
730:              	{
731:              		wuhuaKeyFlag = 1;
732:              	}
733:              	else
734:              	{
735:              		wuhuaKeyFlag = 0;
736:              	}
737:              	
738:              }
739:              
740:              void pwmInit()
741:              {
742:              
743:              	PWMTH = 0x00;
  078F    0198    CLR	0x18
744:              	PWMTL = 73;
  0790    3049    LDIA	0x49
  0791    0097    LD	0x17,A
745:              	PWMD01H = 0x00;
  0792    019E    CLR	0x1E
746:              	PWMD0L = 32;
  0793    3020    LDIA	0x20
  0794    0099    LD	0x19,A
747:              	PWMCON1 = 0x40;
  0795    3040    LDIA	0x40
  0796    0096    LD	0x16,A
748:              	PWMCON2 = 0x00;
  0797    019D    CLR	0x1D
749:              	PWMCON0 |= 0x21;
  0798    3021    LDIA	0x21
  0799    0495    ORR	0x15
  079A    0008    RET
750:              }
751:              
752:              void pwmStop()
753:              {
754:              	PWMD0L = 0;
  079B    0199    CLR	0x19
755:              	PWMCON0 &= 0xFE;
  079C    1015    CLRB	0x15,0
756:              	PORTA &= 0xDF;
  079D    1683    SETB	0x3,5
  079E    1286    CLRB	0x6,5
  079F    0008    RET
757:              }
758:              
759:              void fanInit()
760:              {
761:              
762:              	PWMTH = 0x00;
  0769    0198    CLR	0x18
763:              	PWMTL = 73;
  076A    3049    LDIA	0x49
  076B    0097    LD	0x17,A
764:              	PWMD01H = 0x00;
  076C    019E    CLR	0x1E
765:              	PWMD1L = fanDuty;
  076D    0843    LD	A,0x43
  076E    009A    LD	0x1A,A
766:              	PWMCON1 = 0x40;
  076F    3040    LDIA	0x40
  0770    0096    LD	0x16,A
767:              	PWMCON2 = 0x00;
  0771    019D    CLR	0x1D
768:              	PWMCON0 |= 0x22;
  0772    3022    LDIA	0x22
  0773    0495    ORR	0x15
  0774    0008    RET
769:              }
770:              
771:              void fanStop()
772:              {
773:              	PWMD1L = 0;
  0775    019A    CLR	0x1A
774:              	PWMCON0 &= 0xFD;
  0776    1095    CLRB	0x15,1
775:              	PORTB &= 0x7F;
  0777    1386    CLRB	0x6,7
  0778    0008    RET
776:              }
777:              
778:              void fanCtr()
779:              {
780:              	if(workStep > 0)
  0411    0845    LD	A,0x45
  0412    1903    SZB	0x3,2
  0413    2C79    JP	0x479
781:              	{
782:              		PORTA |= 0x04;
  0414    1683    SETB	0x3,5
  0415    1506    SETB	0x6,2
783:              		u8t maxFanValue = 52;
  0416    3034    LDIA	0x34
  0417    1283    CLRB	0x3,5
  0418    00D7    LD	0x57,A
784:              		if(workStep == 1 || power_ad < 3150)
  0419    0345    DECA	0x45
  041A    1903    SZB	0x3,2
  041B    2C23    JP	0x423
  041C    300C    LDIA	0xC
  041D    0227    SUBA	0x27
  041E    304E    LDIA	0x4E
  041F    1903    SZB	0x3,2
  0420    0226    SUBA	0x26
  0421    1803    SZB	0x3,0
  0422    2C25    JP	0x425
785:              		{	
786:              			maxFanValue = 38;
  0423    3026    LDIA	0x26
  0424    00D7    LD	0x57,A
  0425    300D    LDIA	0xD
787:              		}
788:              		test_adc = ADC_Sample(13, 0);
  0426    01F3    CLR	0x73
  0427    2631    CALL	0x631
  0428    118A    CLRB	0xA,3
  0429    00B6    LD	0x36,A
789:              		if (0xA5 == test_adc)
  042A    30A5    LDIA	0xA5
  042B    0636    XORA	0x36
  042C    1D03    SNZB	0x3,2
  042D    2C58    JP	0x458
790:              		{
791:              			volatile unsigned long fan_temp;
792:              			if(power_ad > 0)
  042E    0826    LD	A,0x26
  042F    0427    ORA	0x27
  0430    1903    SZB	0x3,2
  0431    2C58    JP	0x458
793:              			{
794:              				fan_temp = ((unsigned long)1UL*adresult * power_ad)/4096;
  0432    0848    LD	A,0x48
  0433    00CA    LD	0x4A,A
  0434    0849    LD	A,0x49
  0435    00CB    LD	0x4B,A
  0436    01CC    CLR	0x4C
  0437    01CD    CLR	0x4D
  0438    0826    LD	A,0x26
  0439    00CE    LD	0x4E,A
  043A    0827    LD	A,0x27
  043B    00CF    LD	0x4F,A
  043C    01D0    CLR	0x50
  043D    01D1    CLR	0x51
  043E    247E    CALL	0x47E
  043F    118A    CLRB	0xA,3
  0440    084D    LD	A,0x4D
  0441    00DB    LD	0x5B,A
  0442    084C    LD	A,0x4C
  0443    00DA    LD	0x5A,A
  0444    084B    LD	A,0x4B
  0445    00D9    LD	0x59,A
  0446    084A    LD	A,0x4A
  0447    00D8    LD	0x58,A
  0448    300C    LDIA	0xC
  0449    1003    CLRB	0x3,0
  044A    0CDB    RRCR	0x5B
  044B    0CDA    RRCR	0x5A
  044C    0CD9    RRCR	0x59
  044D    0CD8    RRCR	0x58
  044E    3EFF    ADDIA	0xFF
  044F    1D03    SNZB	0x3,2
  0450    2C49    JP	0x449
795:              				fanValue = (unsigned int)(fan_temp);
  0451    0859    LD	A,0x59
  0452    1683    SETB	0x3,5
  0453    00B9    LD	0x39,A
  0454    1283    CLRB	0x3,5
  0455    0858    LD	A,0x58
  0456    1683    SETB	0x3,5
  0457    00B8    LD	0x38,A
796:              			}
797:              		}
798:              		if(fanValue > 1300)		//原来的值是1.3V
  0458    3005    LDIA	0x5
  0459    1683    SETB	0x3,5
  045A    0239    SUBA	0x39
  045B    3015    LDIA	0x15
  045C    1903    SZB	0x3,2
  045D    0238    SUBA	0x38
  045E    1C03    SNZB	0x3,0
  045F    2C6C    JP	0x46C
799:              		{
800:              			if(++fanOverTime > 25)
  0460    301A    LDIA	0x1A
  0461    1283    CLRB	0x3,5
  0462    0AC1    INCR	0x41
  0463    0241    SUBA	0x41
  0464    1C03    SNZB	0x3,0
  0465    2C6E    JP	0x46E
  0466    30E1    LDIA	0xE1
801:              			{
802:              				fanOverTime = 0;
  0467    01C1    CLR	0x41
803:              				workStep = 0;
  0468    01C5    CLR	0x45
804:              				shanshuoTime = 225;
  0469    00AC    LD	0x2C,A
  046A    01AD    CLR	0x2D
  046B    2C6E    JP	0x46E
805:              			}
806:              		}
807:              		else
808:              		{
809:              			fanOverTime = 0;
  046C    1283    CLRB	0x3,5
  046D    01C1    CLR	0x41
810:              		}
811:              		if(fanDuty < maxFanValue)
  046E    0857    LD	A,0x57
  046F    0243    SUBA	0x43
  0470    1803    SZB	0x3,0
  0471    2C74    JP	0x474
812:              		{
813:              			fanDuty++;
  0472    0AC3    INCR	0x43
814:              		}
  0473    2C78    JP	0x478
815:              		else if(fanDuty > maxFanValue)
  0474    0843    LD	A,0x43
  0475    0257    SUBA	0x57
  0476    1C03    SNZB	0x3,0
816:              		{
817:              			fanDuty--;
  0477    03C3    DECR	0x43
818:              		}
819:              		fanInit();
  0478    2F69    JP	0x769
820:              	}
821:              	else
822:              	{
823:              		fanStop();
  0479    2775    CALL	0x775
824:              		fanDuty = 0;
  047A    01C3    CLR	0x43
825:              		PORTA &= 0xFB;
  047B    1683    SETB	0x3,5
  047C    1106    CLRB	0x6,2
  047D    0008    RET
826:              	}
827:              }
828:              
829:              void wuhuaCtr()
830:              {
831:              	if(count1s == 0)
  0779    1283    CLRB	0x3,5
  077A    0846    LD	A,0x46
  077B    1D03    SNZB	0x3,2
  077C    2F82    JP	0x782
832:              	{
833:              		if(++count10s >= 10)
  077D    300A    LDIA	0xA
  077E    0AC2    INCR	0x42
  077F    0242    SUBA	0x42
  0780    1803    SZB	0x3,0
834:              		{
835:              			count10s = 0;
  0781    01C2    CLR	0x42
836:              		}
837:              	}
838:              	if(wuhuaFlag == 1 || (wuhuaFlag == 2 && count10s < 5))
  0782    0344    DECA	0x44
  0783    1903    SZB	0x3,2
  0784    2F8D    JP	0x78D
  0785    3002    LDIA	0x2
  0786    0644    XORA	0x44
  0787    1D03    SNZB	0x3,2
  0788    2F8E    JP	0x78E
  0789    3005    LDIA	0x5
  078A    0242    SUBA	0x42
  078B    1803    SZB	0x3,0
  078C    2F8E    JP	0x78E
839:              	{
840:              		pwmInit();
  078D    2F8F    JP	0x78F
841:              		/*
842:              		if(++checkTime > 200)
843:              		{
844:              			if(lowWaterTime > 110)
845:              			{
846:              				//干烧状态
847:              				wuhuaFlag = 0;
848:              				shanshuoTime2 = 450;
849:              			}
850:              			checkTime = 0;
851:              			lowWaterTime = 0;
852:              		}
853:              		*/
854:              		
855:              	}
856:              	else
857:              	{
858:              		pwmStop();
  078E    2F9B    JP	0x79B
859:              	}
860:              }
861:              
862:              
863:              void workCtr()
  04B1    301F    LDIA	0x1F
864:              {
865:              	test_adc = ADC_Sample(31, 0);		//测试内部基准1.2V相对电源的AD值
  04B2    01F3    CLR	0x73
  04B3    2631    CALL	0x631
  04B4    118A    CLRB	0xA,3
  04B5    00B6    LD	0x36,A
866:              	if (0xA5 == test_adc)
  04B6    30A5    LDIA	0xA5
  04B7    0636    XORA	0x36
  04B8    1D03    SNZB	0x3,2
  04B9    2CEB    JP	0x4EB
867:              	{
868:              		volatile unsigned long power_temp;
869:              			
870:              		power_temp = (unsigned long)((POWER_RATIO)/adresult);		//1.2*4096/AD=VDD，参数放大1000倍 
  04BA    3096    LDIA	0x96
  04BB    01D3    CLR	0x53
  04BC    00D4    LD	0x54,A
  04BD    304A    LDIA	0x4A
  04BE    00D5    LD	0x55,A
  04BF    0849    LD	A,0x49
  04C0    00CE    LD	0x4E,A
  04C1    0848    LD	A,0x48
  04C2    00CD    LD	0x4D,A
  04C3    25E3    CALL	0x5E3
  04C4    118A    CLRB	0xA,3
  04C5    084D    LD	A,0x4D
  04C6    00D0    LD	0x50,A
  04C7    084E    LD	A,0x4E
  04C8    00D1    LD	0x51,A
  04C9    084F    LD	A,0x4F
  04CA    00D2    LD	0x52,A
  04CB    2528    CALL	0x528
  04CC    118A    CLRB	0xA,3
  04CD    0850    LD	A,0x50
  04CE    00DF    LD	0x5F,A
  04CF    0851    LD	A,0x51
  04D0    00E0    LD	0x60,A
  04D1    0852    LD	A,0x52
  04D2    00E1    LD	0x61,A
  04D3    258A    CALL	0x58A
  04D4    118A    CLRB	0xA,3
  04D5    0862    LD	A,0x62
  04D6    1683    SETB	0x3,5
  04D7    00C1    LD	0x41,A
  04D8    1283    CLRB	0x3,5
  04D9    0861    LD	A,0x61
  04DA    1683    SETB	0x3,5
  04DB    00C0    LD	0x40,A
  04DC    1283    CLRB	0x3,5
  04DD    0860    LD	A,0x60
  04DE    1683    SETB	0x3,5
  04DF    00BF    LD	0x3F,A
  04E0    1283    CLRB	0x3,5
  04E1    085F    LD	A,0x5F
  04E2    1683    SETB	0x3,5
  04E3    00BE    LD	0x3E,A
871:              		power_ad = (unsigned int)(power_temp);		//通过内部基准电压推出芯片VDD电压
  04E4    083F    LD	A,0x3F
  04E5    1283    CLRB	0x3,5
  04E6    00A7    LD	0x27,A
  04E7    1683    SETB	0x3,5
  04E8    083E    LD	A,0x3E
  04E9    1283    CLRB	0x3,5
  04EA    00A6    LD	0x26,A
872:              	}
873:              	if(workStep == 2 && power_ad < 3300)
  04EB    3002    LDIA	0x2
  04EC    0645    XORA	0x45
  04ED    1D03    SNZB	0x3,2
  04EE    2CFF    JP	0x4FF
  04EF    300C    LDIA	0xC
  04F0    0227    SUBA	0x27
  04F1    30E4    LDIA	0xE4
  04F2    1903    SZB	0x3,2
  04F3    0226    SUBA	0x26
  04F4    1803    SZB	0x3,0
  04F5    2CFF    JP	0x4FF
874:              	{
875:              		if(++lowFanTime > 200)
  04F6    30C9    LDIA	0xC9
  04F7    0ABC    INCR	0x3C
  04F8    023C    SUBA	0x3C
  04F9    1C03    SNZB	0x3,0
  04FA    2D00    JP	0x500
876:              		{
877:              			lowFanTime = 0;
  04FB    01BC    CLR	0x3C
878:              			workStep = 1;
  04FC    01C5    CLR	0x45
  04FD    0AC5    INCR	0x45
  04FE    2D00    JP	0x500
879:              		}
880:              	}
881:              	else
882:              	{
883:              		lowFanTime = 0;
  04FF    01BC    CLR	0x3C
884:              	}	
885:              	if(power_ad < 2900)
  0500    300B    LDIA	0xB
  0501    0227    SUBA	0x27
  0502    3054    LDIA	0x54
  0503    1903    SZB	0x3,2
  0504    0226    SUBA	0x26
  0505    1803    SZB	0x3,0
  0506    2D1A    JP	0x51A
886:              	{
887:              		if(++lowBatTime > 1000)
  0507    1683    SETB	0x3,5
  0508    0AB6    INCR	0x36
  0509    1903    SZB	0x3,2
  050A    0AB7    INCR	0x37
  050B    3003    LDIA	0x3
  050C    0237    SUBA	0x37
  050D    30E9    LDIA	0xE9
  050E    1903    SZB	0x3,2
  050F    0236    SUBA	0x36
  0510    1C03    SNZB	0x3,0
  0511    2D1D    JP	0x51D
888:              		{
889:              			lowBatTime = 0;
  0512    01B6    CLR	0x36
  0513    01B7    CLR	0x37
890:              			lowBatLock = 1;
  0514    1283    CLRB	0x3,5
  0515    01BD    CLR	0x3D
  0516    0ABD    INCR	0x3D
891:              			workStep = 0;
  0517    01C5    CLR	0x45
892:              			wuhuaFlag = 0;
  0518    01C4    CLR	0x44
  0519    2D1D    JP	0x51D
893:              		}
894:              	}
895:              	else
896:              	{
897:              		lowBatTime = 0;
  051A    1683    SETB	0x3,5
  051B    01B6    CLR	0x36
  051C    01B7    CLR	0x37
898:              	}
899:              	if(firstTime > 0)
  051D    1283    CLRB	0x3,5
  051E    086E    LD	A,0x6E
  051F    1903    SZB	0x3,2
  0520    2D23    JP	0x523
900:              	{
901:              		firstTime--;
  0521    03EE    DECR	0x6E
902:              	}
  0522    0008    RET
903:              	else
904:              	{
905:              		keyLedCtr();
  0523    2701    CALL	0x701
  0524    118A    CLRB	0xA,3
906:              		fanCtr();
  0525    2411    CALL	0x411
  0526    118A    CLRB	0xA,3
907:              		wuhuaCtr();
  0527    2F79    JP	0x779
908:              	}
909:              	
910:              }
911:              
912:              /***********************************************************
913:              主循环
914:              ***********************************************************/
915:              void main()
916:              {
917:              	Init_System();
  0D43    118A    CLRB	0xA,3
  0D44    2024    CALL	0x24
  0D45    158A    SETB	0xA,3
  0D46    30FA    LDIA	0xFA
918:              	firstLock = 1;
  0D47    01C2    CLR	0x42
  0D48    0AC2    INCR	0x42
919:              	firstTime = 250;
  0D49    1283    CLRB	0x3,5
  0D4A    00EE    LD	0x6E,A
920:              	while(1)
921:              	{
922:              
923:              		if(B_MainLoop)
  0D4B    1F78    SNZB	0x78,6
  0D4C    2D4B    JP	0x54B
924:              		{
925:              			B_MainLoop = 0;
  0D4D    1378    CLRB	0x78,6
  0D4E    0064    CLRWDT
926:              			CLRWDT();
927:              			CheckTouchKey();
  0D4F    118A    CLRB	0xA,3
  0D50    207C    CALL	0x7C
  0D51    158A    SETB	0xA,3
928:              			chrgCtr();
  0D52    158A    SETB	0xA,3
  0D53    25D7    CALL	0x5D7
  0D54    158A    SETB	0xA,3
929:              			Refurbish_Sfr();
  0D55    118A    CLRB	0xA,3
  0D56    2403    CALL	0x403
  0D57    158A    SETB	0xA,3
930:              			KeyServer();
  0D58    158A    SETB	0xA,3
  0D59    2589    CALL	0x589
  0D5A    158A    SETB	0xA,3
931:              			workCtr();
  0D5B    118A    CLRB	0xA,3
  0D5C    24B1    CALL	0x4B1
  0D5D    158A    SETB	0xA,3
932:              			setBatStep();
  0D5E    158A    SETB	0xA,3
  0D5F    2729    CALL	0x729
  0D60    158A    SETB	0xA,3
933:              			if(firstTime == 0 && chrgFlag == 0 && workStep == 0 && wuhuaFlag == 0 && shanshuoTime == 0 && shanshuoTime2 == 0)
  0D61    086E    LD	A,0x6E
  0D62    1D03    SNZB	0x3,2
  0D63    2D7A    JP	0x57A
  0D64    0840    LD	A,0x40
  0D65    1D03    SNZB	0x3,2
  0D66    2D7A    JP	0x57A
  0D67    0845    LD	A,0x45
  0D68    1D03    SNZB	0x3,2
  0D69    2D7A    JP	0x57A
  0D6A    0844    LD	A,0x44
  0D6B    1D03    SNZB	0x3,2
  0D6C    2D7A    JP	0x57A
  0D6D    082C    LD	A,0x2C
  0D6E    042D    ORA	0x2D
  0D6F    1D03    SNZB	0x3,2
  0D70    2D7A    JP	0x57A
  0D71    082A    LD	A,0x2A
  0D72    042B    ORA	0x2B
  0D73    1D03    SNZB	0x3,2
  0D74    2D7A    JP	0x57A
934:              			{
935:              				PORTA &= 0xE4;
936:              				PORTB &= 0xEF;
937:              				TRISA |= 0x1B;
938:              				TRISB |= 0x10;
  0D75    257E    CALL	0x57E
939:              				WorkSleep();
  0D76    118A    CLRB	0xA,3
  0D77    2041    CALL	0x41
  0D78    158A    SETB	0xA,3
940:              			}
  0D79    2D4B    JP	0x54B
941:              			else
942:              			{
943:              				time = 0;
  0D7A    1683    SETB	0x3,5
  0D7B    01BA    CLR	0x3A
  0D7C    01BB    CLR	0x3B
  0D7D    2D4B    JP	0x54B
944:              			}
945:              		}
946:              	}
947:              }
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\Umul32.c ----------------------------------------------------------------------
1:                // 32 x 32 bit multiplication with 32 bit result
2:                #ifdef _PIC18
3:                #define _Has_hardware_multiply 1
4:                #else
5:                #define _Has_hardware_multiply 0
6:                #endif
7:                
8:                #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:                #define _Has_large_call_stack 1
10:               #else
11:               #define _Has_large_call_stack 0
12:               #endif
13:               
14:               unsigned long
15:               __lmul(unsigned long multiplier, unsigned long multiplicand)
  047E    01F3    CLR	0x73
  047F    01F4    CLR	0x74
  0480    01F5    CLR	0x75
  0481    01F6    CLR	0x76
  0482    1C4A    SNZB	0x4A,0
  0483    2C98    JP	0x498
  0484    084E    LD	A,0x4E
  0485    07F3    ADDR	0x73
  0486    084F    LD	A,0x4F
  0487    1103    CLRB	0x3,2
  0488    1803    SZB	0x3,0
  0489    3E01    ADDIA	0x1
  048A    1D03    SNZB	0x3,2
  048B    07F4    ADDR	0x74
  048C    0850    LD	A,0x50
  048D    1103    CLRB	0x3,2
  048E    1803    SZB	0x3,0
  048F    3E01    ADDIA	0x1
  0490    1D03    SNZB	0x3,2
  0491    07F5    ADDR	0x75
  0492    0851    LD	A,0x51
  0493    1103    CLRB	0x3,2
  0494    1803    SZB	0x3,0
  0495    3E01    ADDIA	0x1
  0496    1D03    SNZB	0x3,2
  0497    07F6    ADDR	0x76
  0498    1003    CLRB	0x3,0
  0499    0DCE    RLCR	0x4E
  049A    0DCF    RLCR	0x4F
  049B    0DD0    RLCR	0x50
  049C    0DD1    RLCR	0x51
  049D    1003    CLRB	0x3,0
  049E    0CCD    RRCR	0x4D
  049F    0CCC    RRCR	0x4C
  04A0    0CCB    RRCR	0x4B
  04A1    0CCA    RRCR	0x4A
  04A2    084D    LD	A,0x4D
  04A3    044C    ORA	0x4C
  04A4    044B    ORA	0x4B
  04A5    044A    ORA	0x4A
  04A6    1D03    SNZB	0x3,2
  04A7    2C82    JP	0x482
  04A8    0876    LD	A,0x76
  04A9    00CD    LD	0x4D,A
  04AA    0875    LD	A,0x75
  04AB    00CC    LD	0x4C,A
  04AC    0874    LD	A,0x74
  04AD    00CB    LD	0x4B,A
  04AE    0873    LD	A,0x73
  04AF    00CA    LD	0x4A,A
  04B0    0008    RET
16:               {
17:               	unsigned long product;
18:               
19:               #define LOWBYTE(x)  (*(unsigned char *)(&x))
20:               #define LMIDBYTE(x) (*(((unsigned char *)(&x))+1))
21:               #define HMIDBYTE(x) (*(((unsigned char *)(&x))+2))
22:               #define HIGHBYTE(x) (*(((unsigned char *)(&x))+3))
23:               
24:               #if (_Has_hardware_multiply || _Has_large_call_stack) && defined(__OPTIMIZE_SPEED__)
25:               	{
26:               
27:               #define USE_SHRINK
28:               
29:               /*
30:               a 32-bit multiply can be decomposed into the sum of ten 8-bit multiplies
31:                            a  b  c  d
32:               *            e  f  g  h
33:               -----------------------
34:                          |         dh
35:                          |      ch  0
36:                          |   bh  0  0
37:                          |ah  0  0  0
38:                          |      dg  0
39:                          |   cg  0  0
40:                          |bg  0  0  0
41:                        ag| 0  0  0  0 (we ignore this intermediate product
42:                                        because it does not affect the low 32 bits of the result)
43:                          |   df  0  0
44:                          |cf  0  0  0
45:                        bf| 0  0  0  0 (ignore)
46:                     af  0| 0  0  0  0 (ignore)
47:                          |de  0  0  0
48:                        ce| 0  0  0  0 (ignore)
49:                     be  0| 0  0  0  0 (ignore)
50:               +  ae  0  0| 0  0  0  0 (ignore)
51:               =======================
52:                */
53:               		product =  (unsigned int)LOWBYTE(multiplier) * LOWBYTE(multiplicand);
54:               
55:               #if defined(USE_MASKS)
56:               		product += ((unsigned long)
57:               			     ((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand))
58:               			     +
59:               			     ((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
60:               			<< 8;
61:               
62:               		product += ((unsigned long)
63:               			    ((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand))
64:               			    +
65:               			    ((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
66:               			    +
67:               			    ((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
68:               			<< 16;
69:               
70:               		/* cast to smaller type to avoid adding high bits just to discard */
71:               		product += ((unsigned long)
72:               			    (unsigned char)
73:               			    ((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand))
74:               			    +
75:               			    (unsigned char)
76:               			    ((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand))
77:               			    +
78:               			    (unsigned char)
79:               			    ((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
80:               			    +
81:               			    (unsigned char)
82:               			    ((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand)))
83:               			<< 24;
84:               
85:               #elif defined(USE_SHRINK)
86:               		/* add direct to upper bytes, rather than shift and add all bytes */
87:               		*((unsigned short long*)(((unsigned char*)&product)+1)) +=
88:               			((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand));
89:               		*((unsigned short long*)(((unsigned char*)&product)+1)) +=
90:               			((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand));
91:               
92:               
93:               		*((unsigned int*)(((unsigned char*)&product)+2)) +=
94:               			((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand));
95:               		*((unsigned int*)(((unsigned char*)&product)+2)) +=
96:               			((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
97:               		*((unsigned int*)(((unsigned char*)&product)+2)) +=
98:               			((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand));
99:               
100:              		*(((unsigned char*)&product)+3) +=
101:              			(unsigned char)
102:              			((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand));
103:              		*(((unsigned char*)&product)+3) +=
104:              			(unsigned char)
105:              			((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand));
106:              		*(((unsigned char*)&product)+3) +=
107:              			(unsigned char)
108:              			((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
109:              		*(((unsigned char*)&product)+3) +=
110:              			(unsigned char)
111:              			((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand));
112:              
113:              #else
114:              #error No method chosen
115:              #endif
116:              	}
117:              #else
118:              
119:              	product = 0;
120:              	do {
121:              		if(multiplier & 1)
122:              			product += multiplicand;
123:              		multiplicand <<= 1;
124:              		multiplier >>= 1;
125:              	} while(multiplier != 0);
126:              
127:              #endif
128:              	return product;
129:              }
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\ftdiv.c ----------------------------------------------------------------------
1:                /*	Floating point routines.
2:                
3:                	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:                */
5:                
6:                // this is bigendian code right now. Need to parameterise it.
7:                
8:                #include	"ftarith.h"
9:                
10:               #define	f1_as_dividend	(*(unsigned short long *)&f1)
11:               #define	f2_as_divisor	(*(unsigned short long *)&f2)
12:               #define	f3_as_quot	(*(unsigned short long *)&f3)
13:               
14:               // floating addition
15:               #ifdef _OLDLIB
16:               #define	cntr		sign2
17:               float
18:               #ifdef _PIC18
19:               __ftdiv(float f1, float f2)
20:               #else
21:               __ftdiv(float f2, float f1)
22:               #endif
23:               {
24:               	unsigned char	exp1, exp2, sign1, sign2;
25:               	float	f3;
26:               	
27:               	f3_as_quot = 0;
28:               	sign1 = __ftunpack(&f1_as_dividend, &exp1);
29:               	if(exp1 == 0)
30:               		return f3;
31:               	sign2 = __ftunpack(&f2_as_divisor, &exp2);
32:               	if(exp2 == 0)
33:               		return f3;
34:               	exp1 -= exp2-127+8;	// compute new exponent
35:               	sign1 ^= sign2;
36:               	cntr = 16+8;
37:               	do {
38:               		f3_as_quot <<= 1;
39:               		if(f1_as_dividend >= f2_as_divisor) {
40:               			f1_as_dividend -= f2_as_divisor;
41:               			f3_as_quot |= 1;
42:               		}
43:               		f1_as_dividend <<= 1;
44:               	} while(--cntr != 0);
45:               	__ftpack(&f3_as_quot, exp1);
46:               	if(sign1)
47:               		f3_as_quot |= 0x800000;
48:               	return f3;
49:               }
50:               #else
51:               #define	exp2	sign
52:               float
53:               #ifdef _PIC18
54:               __ftdiv(float f1, float f2)
55:               #else
56:               __ftdiv(float f2, float f1)
  0528    0853    LD	A,0x53
  0529    00D6    LD	0x56,A
  052A    0854    LD	A,0x54
  052B    00D7    LD	0x57,A
  052C    0855    LD	A,0x55
  052D    00D8    LD	0x58,A
  052E    1003    CLRB	0x3,0
  052F    0D57    RLCA	0x57
  0530    0D58    RLCA	0x58
  0531    00DD    LD	0x5D,A
  0532    085D    LD	A,0x5D
  0533    1D03    SNZB	0x3,2
  0534    2D36    JP	0x536
  0535    2FC9    JP	0x7C9
  0536    0850    LD	A,0x50
  0537    00D6    LD	0x56,A
  0538    0851    LD	A,0x51
  0539    00D7    LD	0x57,A
  053A    0852    LD	A,0x52
  053B    00D8    LD	0x58,A
  053C    1003    CLRB	0x3,0
  053D    0D57    RLCA	0x57
  053E    0D58    RLCA	0x58
  053F    00DE    LD	0x5E,A
  0540    085E    LD	A,0x5E
  0541    1D03    SNZB	0x3,2
  0542    2D44    JP	0x544
  0543    2FC9    JP	0x7C9
  0544    3089    LDIA	0x89
  0545    01DA    CLR	0x5A
  0546    01DB    CLR	0x5B
  0547    01DC    CLR	0x5C
  0548    075E    ADDA	0x5E
  0549    00D6    LD	0x56,A
  054A    02DD    SUBR	0x5D
  054B    0855    LD	A,0x55
  054C    00DE    LD	0x5E,A
  054D    0852    LD	A,0x52
  054E    06DE    XORR	0x5E
  054F    3080    LDIA	0x80
  0550    05DE    ANDR	0x5E
  0551    3018    LDIA	0x18
  0552    17D4    SETB	0x54,7
  0553    01D5    CLR	0x55
  0554    17D1    SETB	0x51,7
  0555    01D2    CLR	0x52
  0556    00D9    LD	0x59,A
  0557    1003    CLRB	0x3,0
  0558    0DDA    RLCR	0x5A
  0559    0DDB    RLCR	0x5B
  055A    0DDC    RLCR	0x5C
  055B    0852    LD	A,0x52
  055C    0255    SUBA	0x55
  055D    1D03    SNZB	0x3,2
  055E    2D65    JP	0x565
  055F    0851    LD	A,0x51
  0560    0254    SUBA	0x54
  0561    1D03    SNZB	0x3,2
  0562    2D65    JP	0x565
  0563    0850    LD	A,0x50
  0564    0253    SUBA	0x53
  0565    1C03    SNZB	0x3,0
  0566    2D73    JP	0x573
  0567    0850    LD	A,0x50
  0568    02D3    SUBR	0x53
  0569    0851    LD	A,0x51
  056A    1C03    SNZB	0x3,0
  056B    0F51    SZINCA	0x51
  056C    02D4    SUBR	0x54
  056D    0852    LD	A,0x52
  056E    1C03    SNZB	0x3,0
  056F    0A52    INCA	0x52
  0570    02D5    SUBR	0x55
  0571    145A    SETB	0x5A,0
  0572    1003    CLRB	0x3,0
  0573    0DD3    RLCR	0x53
  0574    0DD4    RLCR	0x54
  0575    0DD5    RLCR	0x55
  0576    0BD9    SZDECR	0x59
  0577    2D57    JP	0x557
  0578    085A    LD	A,0x5A
  0579    00F3    LD	0x73,A
  057A    085B    LD	A,0x5B
  057B    00F4    LD	0x74,A
  057C    085C    LD	A,0x5C
  057D    00F5    LD	0x75,A
  057E    085D    LD	A,0x5D
  057F    00F6    LD	0x76,A
  0580    085E    LD	A,0x5E
  0581    00F7    LD	0x77,A
  0582    25F3    CALL	0x5F3
  0583    0873    LD	A,0x73
  0584    00D0    LD	0x50,A
  0585    0874    LD	A,0x74
  0586    00D1    LD	0x51,A
  0587    0875    LD	A,0x75
  0588    00D2    LD	0x52,A
  0589    0008    RET
57:               #endif
58:               {
59:               	unsigned char	exp, sign, cntr;
60:               	float	f3;
61:               	
62:               	// unpack the operands
63:               	if((exp = f1_as_dividend >> 15) == 0)
64:               		return 0.0;
65:               	if((exp2 = f2_as_divisor >> 15) == 0)
66:               		return 0.0;
67:               	f3_as_quot = 0;
68:               	exp -= exp2-127+8;	// compute new exponent
69:               	sign = f1_as_dividend >> 16;
70:               	sign ^= (unsigned char)(f2_as_divisor >> 16);
71:               	sign &= 0x80;
72:               	f1_as_dividend |= 0x8000UL;
73:               	f1_as_dividend &= 0xFFFFUL;
74:               	f2_as_divisor |= 0x8000UL;
75:               	f2_as_divisor &= 0xFFFFUL;
76:               	cntr = 16+8;
77:               	do {
78:               		f3_as_quot <<= 1;
79:               		if(f1_as_dividend >= f2_as_divisor) {
80:               			f1_as_dividend -= f2_as_divisor;
81:               			f3_as_quot |= 1;
82:               		}
83:               		f1_as_dividend <<= 1;
84:               	} while(--cntr != 0);
85:               	return __ftpack(f3_as_quot, exp, sign);
86:               }
87:               #endif	
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\fttol.c ----------------------------------------------------------------------
1:                /*	Floating point routines.
2:                
3:                	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:                */
5:                
6:                // this is bigendian code right now. Need to parameterise it.
7:                
8:                #include	"ftarith.h"
9:                
10:               #define	f1_as_mant1	(*(unsigned short long *)&f1)
11:               
12:               // Convert float to long
13:               
14:               #ifdef _OLDLIB
15:               long
16:               __fttol(float f1)
17:               {
18:               	unsigned char	sign1, exp1;
19:               	unsigned long	lval;
20:               
21:               	sign1 = __ftunpack(&f1_as_mant1, &exp1);
22:               	lval = f1_as_mant1;
23:               	exp1 -= 127+15;
24:               	if((signed char)exp1 < 0) {
25:               		if((signed char)exp1 < -15)
26:               			return 0;
27:               		do
28:               			lval >>= 1;
29:               		while(++exp1 != 0);
30:               	} else {
31:               		if(exp1 >= 32)
32:               			return 00;
33:               		while(exp1 != 0) {
34:               			lval <<= 1;
35:               			exp1--;
36:               		}
37:               	}
38:               	if(sign1)
39:               		lval = -lval;
40:               	return lval;
41:               }
42:               #else
43:               long
44:               __fttol(float f1)
  058A    27B8    CALL	0x7B8
  058B    118A    CLRB	0xA,3
  058C    1003    CLRB	0x3,0
  058D    0D64    RLCA	0x64
  058E    0D65    RLCA	0x65
  058F    00EB    LD	0x6B,A
  0590    086B    LD	A,0x6B
  0591    1D03    SNZB	0x3,2
  0592    2D98    JP	0x598
  0593    01DF    CLR	0x5F
  0594    01E0    CLR	0x60
  0595    01E1    CLR	0x61
  0596    01E2    CLR	0x62
  0597    0008    RET
  0598    27B8    CALL	0x7B8
  0599    118A    CLRB	0xA,3
  059A    3017    LDIA	0x17
  059B    1003    CLRB	0x3,0
  059C    0CE5    RRCR	0x65
  059D    0CE4    RRCR	0x64
  059E    0CE3    RRCR	0x63
  059F    3EFF    ADDIA	0xFF
  05A0    1D03    SNZB	0x3,2
  05A1    2D9B    JP	0x59B
  05A2    0863    LD	A,0x63
  05A3    00E6    LD	0x66,A
  05A4    17E0    SETB	0x60,7
  05A5    01E1    CLR	0x61
  05A6    085F    LD	A,0x5F
  05A7    00E7    LD	0x67,A
  05A8    0860    LD	A,0x60
  05A9    00E8    LD	0x68,A
  05AA    0861    LD	A,0x61
  05AB    00E9    LD	0x69,A
  05AC    308E    LDIA	0x8E
  05AD    01EA    CLR	0x6A
  05AE    02EB    SUBR	0x6B
  05AF    1FEB    SNZB	0x6B,7
  05B0    2DBE    JP	0x5BE
  05B1    086B    LD	A,0x6B
  05B2    3A80    XORIA	0x80
  05B3    3E8F    ADDIA	0x8F
  05B4    1C03    SNZB	0x3,0
  05B5    2D93    JP	0x593
  05B6    1003    CLRB	0x3,0
  05B7    0CEA    RRCR	0x6A
  05B8    0CE9    RRCR	0x69
  05B9    0CE8    RRCR	0x68
  05BA    0CE7    RRCR	0x67
  05BB    0FEB    SZINCR	0x6B
  05BC    2DB6    JP	0x5B6
  05BD    2DCC    JP	0x5CC
  05BE    3018    LDIA	0x18
  05BF    026B    SUBA	0x6B
  05C0    1803    SZB	0x3,0
  05C1    2D93    JP	0x593
  05C2    086B    LD	A,0x6B
  05C3    1903    SZB	0x3,2
  05C4    2DCC    JP	0x5CC
  05C5    1003    CLRB	0x3,0
  05C6    0DE7    RLCR	0x67
  05C7    0DE8    RLCR	0x68
  05C8    0DE9    RLCR	0x69
  05C9    0DEA    RLCR	0x6A
  05CA    03EB    DECR	0x6B
  05CB    2DC2    JP	0x5C2
  05CC    0866    LD	A,0x66
  05CD    1903    SZB	0x3,2
  05CE    2DDA    JP	0x5DA
  05CF    09E7    COMR	0x67
  05D0    09E8    COMR	0x68
  05D1    09E9    COMR	0x69
  05D2    09EA    COMR	0x6A
  05D3    0AE7    INCR	0x67
  05D4    1903    SZB	0x3,2
  05D5    0AE8    INCR	0x68
  05D6    1903    SZB	0x3,2
  05D7    0AE9    INCR	0x69
  05D8    1903    SZB	0x3,2
  05D9    0AEA    INCR	0x6A
  05DA    086A    LD	A,0x6A
  05DB    00E2    LD	0x62,A
  05DC    0869    LD	A,0x69
  05DD    00E1    LD	0x61,A
  05DE    0868    LD	A,0x68
  05DF    00E0    LD	0x60,A
  05E0    0867    LD	A,0x67
  05E1    00DF    LD	0x5F,A
  05E2    0008    RET
45:               {
46:               	unsigned char	sign1, exp1;
47:               	unsigned long	lval;
48:               
49:               	if((exp1 = f1_as_mant1 >> 15) == 0)
50:               		return 0;
51:               	sign1 = f1_as_mant1 >> 23;
52:               	f1_as_mant1 |= 0x8000UL;
53:               	f1_as_mant1 &= 0xFFFFUL;
54:               	lval = f1_as_mant1;
55:               	exp1 -= 127+15;
56:               	if((signed char)exp1 < 0) {
57:               		if((signed char)exp1 < -15)
58:               			return 0;
59:               		do
60:               			lval >>= 1;
61:               		while(++exp1 != 0);
62:               	} else {
63:               		if(exp1 >= 24)
64:               			return 0;
65:               		while(exp1 != 0) {
66:               			lval <<= 1;
67:               			exp1--;
68:               		}
69:               	}
70:               	if(sign1)
71:               		lval = -lval;
72:               	return lval;
73:               }
74:               #endif
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\lwtoft.c ----------------------------------------------------------------------
1:                /*	Floating point routines.
2:                
3:                	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:                */
5:                
6:                // this is bigendian code right now. Need to parameterise it.
7:                
8:                #include	"ftarith.h"
9:                
10:               
11:               // Convert unsigned int to float
12:               
13:               #ifdef _OLDLIB
14:               #define	f1_as_mant1	(*(unsigned short long *)&f1)
15:               float
16:               __lwtoft(unsigned int c)
17:               {
18:               	float	f1;
19:               	
20:               	if(c == 0)
21:               		return 0.0;
22:               	f1_as_mant1 = c;
23:               	__ftpack(&f1_as_mant1, 127+15);
24:               	return f1;
25:               }
26:               #else
27:               float
28:               __lwtoft(unsigned int c)
  05E3    084D    LD	A,0x4D
  05E4    00F3    LD	0x73,A
  05E5    084E    LD	A,0x4E
  05E6    00F4    LD	0x74,A
  05E7    308E    LDIA	0x8E
  05E8    01F5    CLR	0x75
  05E9    00F6    LD	0x76,A
  05EA    01F7    CLR	0x77
  05EB    25F3    CALL	0x5F3
  05EC    0873    LD	A,0x73
  05ED    00CD    LD	0x4D,A
  05EE    0874    LD	A,0x74
  05EF    00CE    LD	0x4E,A
  05F0    0875    LD	A,0x75
  05F1    00CF    LD	0x4F,A
  05F2    0008    RET
29:               {
30:               	return __ftpack(c, 127+15, 0);
31:               }
32:               #endif
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\float.c ----------------------------------------------------------------------
1:                /*	Floating point routines.
2:                
3:                	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:                */
5:                
6:                #include	"ftarith.h"
7:                
8:                
9:                //	unpack the operand pointed to. Store the exponent into the location pointed to by exp,
10:               //	and return the sign (zero is positive)
11:               
12:               #ifdef _OLDLIB
13:               
14:               unsigned char
15:               __ftunpack(unsigned short long * arg, unsigned char * exp)
16:               {
17:               	unsigned char	sign;
18:               
19:               	*exp = sign = *arg >> 15;
20:               	if(sign == 0) {
21:               		*arg = 0;
22:               		return 0;
23:               	}
24:               	sign = 0;
25:               	*arg |= 0x8000;
26:               	if(*arg & 0x800000)
27:               		sign++;
28:               	*arg &= 0xFFFF;
29:               	return sign;
30:               }
31:               
32:               // normalize and pack the supplied argument into floating point format
33:               
34:               void
35:               __ftpack(unsigned short long * arg, unsigned char exp)
36:               {
37:               	if(exp == 0 || *arg == 0) {
38:               		*arg = 0;
39:               		return;
40:               	}
41:               	while(*arg & 0xFE0000UL) {
42:               		exp++;
43:               		*arg >>= 1;
44:               	}
45:               	while(*arg & 0xFF0000UL) {
46:               		exp++;
47:               		(*arg)++;
48:               		*arg >>= 1;
49:               	}
50:               	while(!(*arg & 0x8000UL)) {
51:               		exp--;
52:               		*arg <<= 1;
53:               	}
54:               	if(!(exp & 1))
55:               		*arg &= ~0x8000L;
56:               	exp >>= 1;
57:               	*arg |= (unsigned short long)exp << 16;
58:               }
59:               
60:               #else
61:               float
62:               __ftpack(unsigned short long arg, unsigned char exp, unsigned char sign)
  05F3    0876    LD	A,0x76
  05F4    1903    SZB	0x3,2
  05F5    2DFB    JP	0x5FB
  05F6    0875    LD	A,0x75
  05F7    0474    ORA	0x74
  05F8    0473    ORA	0x73
  05F9    1D03    SNZB	0x3,2
  05FA    2E02    JP	0x602
  05FB    01F3    CLR	0x73
  05FC    01F4    CLR	0x74
  05FD    01F5    CLR	0x75
  05FE    0008    RET
  05FF    0AF6    INCR	0x76
  0600    27BF    CALL	0x7BF
  0601    118A    CLRB	0xA,3
  0602    30FE    LDIA	0xFE
  0603    0575    ANDA	0x75
  0604    1903    SZB	0x3,2
  0605    2E0F    JP	0x60F
  0606    2DFF    JP	0x5FF
  0607    0AF6    INCR	0x76
  0608    0AF3    INCR	0x73
  0609    1903    SZB	0x3,2
  060A    0AF4    INCR	0x74
  060B    1903    SZB	0x3,2
  060C    0AF5    INCR	0x75
  060D    27BF    CALL	0x7BF
  060E    118A    CLRB	0xA,3
  060F    30FF    LDIA	0xFF
  0610    0575    ANDA	0x75
  0611    1903    SZB	0x3,2
  0612    2E1D    JP	0x61D
  0613    2E07    JP	0x607
  0614    3002    LDIA	0x2
  0615    0276    SUBA	0x76
  0616    1C03    SNZB	0x3,0
  0617    2E1F    JP	0x61F
  0618    03F6    DECR	0x76
  0619    1003    CLRB	0x3,0
  061A    0DF3    RLCR	0x73
  061B    0DF4    RLCR	0x74
  061C    0DF5    RLCR	0x75
  061D    1FF4    SNZB	0x74,7
  061E    2E14    JP	0x614
  061F    1C76    SNZB	0x76,0
  0620    13F4    CLRB	0x74,7
  0621    1003    CLRB	0x3,0
  0622    0CF6    RRCR	0x76
  0623    0876    LD	A,0x76
  0624    00CC    LD	0x4C,A
  0625    01CB    CLR	0x4B
  0626    01CA    CLR	0x4A
  0627    084A    LD	A,0x4A
  0628    04F3    ORR	0x73
  0629    084B    LD	A,0x4B
  062A    04F4    ORR	0x74
  062B    084C    LD	A,0x4C
  062C    04F5    ORR	0x75
  062D    0877    LD	A,0x77
  062E    1D03    SNZB	0x3,2
  062F    17F5    SETB	0x75,7
  0630    0008    RET
63:               {
64:               	if(exp == 0 || arg == 0)
65:               		return 0.0;
66:               	while(arg & 0xFE0000UL) {
67:               		exp++;
68:               		arg >>= 1;
69:               	}
70:               	while(arg & 0xFF0000UL) {
71:               		exp++;
72:               		(arg)++;
73:               		arg >>= 1;
74:               	}
75:               	while(!(arg & 0x8000UL) && exp > 1) {
76:               		exp--;
77:               		arg <<= 1;
78:               	}
79:               	if(!(exp & 1))
80:               		arg &= ~0x8000L;
81:               	exp >>= 1;
82:               	arg |= (unsigned short long)exp << 16;
83:               	if (sign)
84:               		arg |= 0x800000UL;
85:                  return *(float*)&arg;	
86:               }
87:               
88:               #endif
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\lwmod.c ----------------------------------------------------------------------
1:                // word unsigned modulus
2:                
3:                unsigned int
4:                #ifdef __PICC__
5:                #warning TODO: update cgpic and this file to use the other prototype
6:                __lwmod(unsigned int divisor, unsigned int dividend)
  0745    0873    LD	A,0x73
  0746    0474    ORA	0x74
  0747    1903    SZB	0x3,2
  0748    2F64    JP	0x764
  0749    01F7    CLR	0x77
  074A    0AF7    INCR	0x77
  074B    1BF4    SZB	0x74,7
  074C    2F51    JP	0x751
  074D    1003    CLRB	0x3,0
  074E    0DF3    RLCR	0x73
  074F    0DF4    RLCR	0x74
  0750    2F4A    JP	0x74A
  0751    0874    LD	A,0x74
  0752    0276    SUBA	0x76
  0753    1D03    SNZB	0x3,2
  0754    2F57    JP	0x757
  0755    0873    LD	A,0x73
  0756    0275    SUBA	0x75
  0757    1C03    SNZB	0x3,0
  0758    2F60    JP	0x760
  0759    0873    LD	A,0x73
  075A    02F5    SUBR	0x75
  075B    0874    LD	A,0x74
  075C    1C03    SNZB	0x3,0
  075D    03F6    DECR	0x76
  075E    02F6    SUBR	0x76
  075F    1003    CLRB	0x3,0
  0760    0CF4    RRCR	0x74
  0761    0CF3    RRCR	0x73
  0762    0BF7    SZDECR	0x77
  0763    2F51    JP	0x751
  0764    0876    LD	A,0x76
  0765    00F4    LD	0x74,A
  0766    0875    LD	A,0x75
  0767    00F3    LD	0x73,A
  0768    0008    RET
7:                #else
8:                __lwmod(unsigned int dividend, unsigned int divisor)
9:                #endif
10:               {
11:               	unsigned char	counter;
12:               
13:               	if(divisor != 0) {
14:               		counter = 1;
15:               		while((divisor & 0x8000) == 0) {
16:               			divisor <<= 1;
17:               			counter++;
18:               		}
19:               		do {
20:               			if(divisor <= dividend)
21:               				dividend -= divisor;
22:               			divisor >>= 1;
23:               		} while(--counter != 0);
24:               	}
25:               	return dividend;
26:               }
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\lwdiv.c ----------------------------------------------------------------------
1:                // word unsigned division
2:                
3:                unsigned int
4:                #ifdef __PICC__
5:                #warning TODO: update cgpic and this file to use the other prototype
6:                __lwdiv(unsigned int divisor, unsigned int dividend)
  0FD6    01CB    CLR	0x4B
  0FD7    01CC    CLR	0x4C
  0FD8    0873    LD	A,0x73
  0FD9    0474    ORA	0x74
  0FDA    1903    SZB	0x3,2
  0FDB    2FFB    JP	0x7FB
  0FDC    01CA    CLR	0x4A
  0FDD    0ACA    INCR	0x4A
  0FDE    1BF4    SZB	0x74,7
  0FDF    2FE4    JP	0x7E4
  0FE0    1003    CLRB	0x3,0
  0FE1    0DF3    RLCR	0x73
  0FE2    0DF4    RLCR	0x74
  0FE3    2FDD    JP	0x7DD
  0FE4    1003    CLRB	0x3,0
  0FE5    0DCB    RLCR	0x4B
  0FE6    0DCC    RLCR	0x4C
  0FE7    0874    LD	A,0x74
  0FE8    0276    SUBA	0x76
  0FE9    1D03    SNZB	0x3,2
  0FEA    2FED    JP	0x7ED
  0FEB    0873    LD	A,0x73
  0FEC    0275    SUBA	0x75
  0FED    1C03    SNZB	0x3,0
  0FEE    2FF7    JP	0x7F7
  0FEF    0873    LD	A,0x73
  0FF0    02F5    SUBR	0x75
  0FF1    0874    LD	A,0x74
  0FF2    1C03    SNZB	0x3,0
  0FF3    03F6    DECR	0x76
  0FF4    02F6    SUBR	0x76
  0FF5    144B    SETB	0x4B,0
  0FF6    1003    CLRB	0x3,0
  0FF7    0CF4    RRCR	0x74
  0FF8    0CF3    RRCR	0x73
  0FF9    0BCA    SZDECR	0x4A
  0FFA    2FE4    JP	0x7E4
  0FFB    084C    LD	A,0x4C
  0FFC    00F4    LD	0x74,A
  0FFD    084B    LD	A,0x4B
  0FFE    00F3    LD	0x73,A
7:                #else
8:                __lwdiv(unsigned int dividend, unsigned int divisor)
9:                #endif
10:               {
11:               	unsigned int	quotient;
12:               	unsigned char	counter;
13:               
14:               	quotient = 0;
15:               	if(divisor != 0) {
16:               		counter = 1;
17:               		while((divisor & 0x8000) == 0) {
18:               			divisor <<= 1;
19:               			counter++;
20:               		}
21:               		do {
22:               			quotient <<= 1;
23:               			if(divisor <= dividend) {
24:               				dividend -= divisor;
25:               				quotient |= 1;
26:               			}
27:               			divisor >>= 1;
28:               		} while(--counter != 0);
29:               	}
30:               	return quotient;
31:               }
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\lbdiv.c ----------------------------------------------------------------------
1:                // byte unsigned division
2:                
3:                unsigned char
4:                __lbdiv(unsigned char dividend, unsigned char divisor)
  0E1E    00F4    LD	0x74,A
  0E1F    01F6    CLR	0x76
  0E20    0873    LD	A,0x73
  0E21    1903    SZB	0x3,2
  0E22    2E37    JP	0x637
  0E23    01F5    CLR	0x75
  0E24    0AF5    INCR	0x75
  0E25    1BF3    SZB	0x73,7
  0E26    2E2A    JP	0x62A
  0E27    1003    CLRB	0x3,0
  0E28    0DF3    RLCR	0x73
  0E29    2E24    JP	0x624
  0E2A    1003    CLRB	0x3,0
  0E2B    0DF6    RLCR	0x76
  0E2C    0873    LD	A,0x73
  0E2D    0274    SUBA	0x74
  0E2E    1C03    SNZB	0x3,0
  0E2F    2E34    JP	0x634
  0E30    0873    LD	A,0x73
  0E31    02F4    SUBR	0x74
  0E32    1476    SETB	0x76,0
  0E33    1003    CLRB	0x3,0
  0E34    0CF3    RRCR	0x73
  0E35    0BF5    SZDECR	0x75
  0E36    2E2A    JP	0x62A
  0E37    0876    LD	A,0x76
  0E38    0008    RET
5:                {
6:                	unsigned char	quotient;
7:                	unsigned char	counter;
8:                
9:                	quotient = 0;
10:               	if(divisor != 0) {
11:               		counter = 1;
12:               		while((divisor & 0x80) == 0) {
13:               			divisor <<= 1;
14:               			counter++;
15:               		}
16:               		do {
17:               			quotient <<= 1;
18:               			if(divisor <= dividend) {
19:               				dividend -= divisor;
20:               				quotient |= 1;
21:               			}
22:               			divisor >>= 1;
23:               		} while(--counter != 0);
24:               	}
25:               	return quotient;
26:               }
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\lbmod.c ----------------------------------------------------------------------
1:                // byte unsigned modulus
2:                
3:                unsigned char
4:                __lbmod(unsigned char dividend, unsigned char divisor)
  0E39    00F5    LD	0x75,A
  0E3A    3008    LDIA	0x8
  0E3B    00F6    LD	0x76,A
  0E3C    01F7    CLR	0x77
  0E3D    0875    LD	A,0x75
  0E3E    00F4    LD	0x74,A
  0E3F    3007    LDIA	0x7
  0E40    1003    CLRB	0x3,0
  0E41    0CF4    RRCR	0x74
  0E42    3EFF    ADDIA	0xFF
  0E43    1003    CLRB	0x3,0
  0E44    1D03    SNZB	0x3,2
  0E45    2E41    JP	0x641
  0E46    0D77    RLCA	0x77
  0E47    0474    ORA	0x74
  0E48    00F7    LD	0x77,A
  0E49    1003    CLRB	0x3,0
  0E4A    0DF5    RLCR	0x75
  0E4B    0873    LD	A,0x73
  0E4C    0277    SUBA	0x77
  0E4D    1C03    SNZB	0x3,0
  0E4E    2E51    JP	0x651
  0E4F    0873    LD	A,0x73
  0E50    02F7    SUBR	0x77
  0E51    0BF6    SZDECR	0x76
  0E52    2E3D    JP	0x63D
  0E53    0877    LD	A,0x77
  0E54    0008    RET
5:                {
6:                	unsigned char	rem;
7:                	unsigned char	counter;
8:                
9:                	counter = 8;
10:               	rem = 0;
11:               	do {
12:               		rem = (rem << 1) | (dividend >> 7);
13:               		dividend <<= 1;
14:               		if(divisor <= rem)
15:               			rem -= divisor;
16:               	} while(--counter != 0);
17:               	return rem;
18:               }
---- library_code ------------------------------------------------------------------
  007C    1A78    SZB	0x78,4
  007D    288A    JP	0x8A
  007E    2139    CALL	0x139
  007F    118A    CLRB	0xA,3
  0080    3008    LDIA	0x8
  0081    1283    CLRB	0x3,5
  0082    1303    CLRB	0x3,6
  0083    0AB4    INCR	0x34
  0084    0234    SUBA	0x34
  0085    1C03    SNZB	0x3,0
  0086    28A8    JP	0xA8
  0087    01B4    CLR	0x34
  0088    1678    SETB	0x78,4
  0089    28A8    JP	0xA8
  008A    19F8    SZB	0x78,3
  008B    28A2    JP	0xA2
  008C    21B0    CALL	0x1B0
  008D    118A    CLRB	0xA,3
  008E    2342    CALL	0x342
  008F    118A    CLRB	0xA,3
  0090    15F8    SETB	0x78,3
  0091    18F8    SZB	0x78,1
  0092    2899    JP	0x99
  0093    3003    LDIA	0x3
  0094    1283    CLRB	0x3,5
  0095    1303    CLRB	0x3,6
  0096    0234    SUBA	0x34
  0097    1C03    SNZB	0x3,0
  0098    289E    JP	0x9E
  0099    232C    CALL	0x32C
  009A    118A    CLRB	0xA,3
  009B    10F8    CLRB	0x78,1
  009C    1278    CLRB	0x78,4
  009D    11F8    CLRB	0x78,3
  009E    1283    CLRB	0x3,5
  009F    1303    CLRB	0x3,6
  00A0    01B4    CLR	0x34
  00A1    28A8    JP	0xA8
  00A2    22C8    CALL	0x2C8
  00A3    118A    CLRB	0xA,3
  00A4    21A1    CALL	0x1A1
  00A5    118A    CLRB	0xA,3
  00A6    1278    CLRB	0x78,4
  00A7    11F8    CLRB	0x78,3
  00A8    2B75    JP	0x375
  00A9    0064    CLRWDT
  00AA    1683    SETB	0x3,5
  00AB    1303    CLRB	0x3,6
  00AC    0181    CLR	0x1
  00AD    3007    LDIA	0x7
  00AE    1283    CLRB	0x3,5
  00AF    0481    ORR	0x1
  00B0    1581    SETB	0x1,3
  00B1    0064    CLRWDT
  00B2    300A    LDIA	0xA
  00B3    1283    CLRB	0x3,5
  00B4    1303    CLRB	0x3,6
  00B5    0081    LD	0x1,A
  00B6    0064    CLRWDT
  00B7    1283    CLRB	0x3,5
  00B8    1703    SETB	0x3,6
  00B9    0191    CLR	0x11
  00BA    0193    CLR	0x13
  00BB    3002    LDIA	0x2
  00BC    1303    CLRB	0x3,6
  00BD    0094    LD	0x14,A
  00BE    0063    STOP
  00BF    0000    NOP
  00C0    0064    CLRWDT
  00C1    3072    LDIA	0x72
  00C2    1283    CLRB	0x3,5
  00C3    1303    CLRB	0x3,6
  00C4    0094    LD	0x14,A
  00C5    3079    LDIA	0x79
  00C6    1703    SETB	0x3,6
  00C7    0093    LD	0x13,A
  00C8    21A1    CALL	0x1A1
  00C9    118A    CLRB	0xA,3
  00CA    1478    SETB	0x78,0
  00CB    2139    CALL	0x139
  00CC    118A    CLRB	0xA,3
  00CD    1283    CLRB	0x3,5
  00CE    1303    CLRB	0x3,6
  00CF    23F9    CALL	0x3F9
  00D0    118A    CLRB	0xA,3
  00D1    1C0B    SNZB	0xB,0
  00D2    188B    SZB	0xB,1
  00D3    28D6    JP	0xD6
  00D4    1D8D    SNZB	0xD,3
  00D5    28DD    JP	0xDD
  00D6    21A1    CALL	0x1A1
  00D7    1283    CLRB	0x3,5
  00D8    1303    CLRB	0x3,6
  00D9    01B4    CLR	0x34
  00DA    1278    CLRB	0x78,4
  00DB    11F8    CLRB	0x78,3
  00DC    0008    RET
  00DD    0853    LD	A,0x53
  00DE    3903    ANDIA	0x3
  00DF    1003    CLRB	0x3,0
  00E0    1903    SZB	0x3,2
  00E1    2933    JP	0x133
  00E2    0D55    RLCA	0x55
  00E3    3EAC    ADDIA	0xAC
  00E4    0084    LD	0x4,A
  00E5    1383    CLRB	0x3,7
  00E6    0800    LD	A,0x0
  00E7    00D1    LD	0x51,A
  00E8    0A84    INCR	0x4
  00E9    0800    LD	A,0x0
  00EA    00D2    LD	0x52,A
  00EB    00D0    LD	0x50,A
  00EC    0851    LD	A,0x51
  00ED    00CF    LD	0x4F,A
  00EE    0851    LD	A,0x51
  00EF    0452    ORA	0x52
  00F0    1903    SZB	0x3,2
  00F1    2932    JP	0x132
  00F2    0855    LD	A,0x55
  00F3    3E16    ADDIA	0x16
  00F4    0084    LD	0x4,A
  00F5    158A    SETB	0xA,3
  00F6    2000    CALL	0x0
  00F7    118A    CLRB	0xA,3
  00F8    07CF    ADDR	0x4F
  00F9    1803    SZB	0x3,0
  00FA    0AD0    INCR	0x50
  00FB    1003    CLRB	0x3,0
  00FC    0D55    RLCA	0x55
  00FD    3EA4    ADDIA	0xA4
  00FE    23D8    CALL	0x3D8
  00FF    118A    CLRB	0xA,3
  0100    0850    LD	A,0x50
  0101    0275    SUBA	0x75
  0102    1D03    SNZB	0x3,2
  0103    2906    JP	0x106
  0104    084F    LD	A,0x4F
  0105    0274    SUBA	0x74
  0106    1C03    SNZB	0x3,0
  0107    291A    JP	0x11A
  0108    23F9    CALL	0x3F9
  0109    118A    CLRB	0xA,3
  010A    0853    LD	A,0x53
  010B    3903    ANDIA	0x3
  010C    1D03    SNZB	0x3,2
  010D    2911    JP	0x111
  010E    0855    LD	A,0x55
  010F    22A5    CALL	0x2A5
  0110    118A    CLRB	0xA,3
  0111    1283    CLRB	0x3,5
  0112    3002    LDIA	0x2
  0113    1303    CLRB	0x3,6
  0114    1003    CLRB	0x3,0
  0115    23FE    CALL	0x3FE
  0116    118A    CLRB	0xA,3
  0117    1803    SZB	0x3,0
  0118    28D6    JP	0xD6
  0119    290A    JP	0x10A
  011A    0D55    RLCA	0x55
  011B    3E20    ADDIA	0x20
  011C    23D8    CALL	0x3D8
  011D    118A    CLRB	0xA,3
  011E    1003    CLRB	0x3,0
  011F    0D55    RLCA	0x55
  0120    3EA4    ADDIA	0xA4
  0121    23C2    CALL	0x3C2
  0122    118A    CLRB	0xA,3
  0123    0800    LD	A,0x0
  0124    00F4    LD	0x74,A
  0125    0A84    INCR	0x4
  0126    0800    LD	A,0x0
  0127    00F5    LD	0x75,A
  0128    1003    CLRB	0x3,0
  0129    0D55    RLCA	0x55
  012A    3E20    ADDIA	0x20
  012B    23C2    CALL	0x3C2
  012C    118A    CLRB	0xA,3
  012D    0851    LD	A,0x51
  012E    0080    LD	0x0,A
  012F    0A84    INCR	0x4
  0130    0852    LD	A,0x52
  0131    0080    LD	0x0,A
  0132    1003    CLRB	0x3,0
  0133    3002    LDIA	0x2
  0134    23FE    CALL	0x3FE
  0135    118A    CLRB	0xA,3
  0136    1803    SZB	0x3,0
  0137    28A9    JP	0xA9
  0138    28DD    JP	0xDD
  0139    1283    CLRB	0x3,5
  013A    1303    CLRB	0x3,6
  013B    01CE    CLR	0x4E
  013C    01CC    CLR	0x4C
  013D    0ACC    INCR	0x4C
  013E    01CD    CLR	0x4D
  013F    1C78    SNZB	0x78,0
  0140    2945    JP	0x145
  0141    084C    LD	A,0x4C
  0142    3903    ANDIA	0x3
  0143    1903    SZB	0x3,2
  0144    2996    JP	0x196
  0145    1703    SETB	0x3,6
  0146    0191    CLR	0x11
  0147    0192    CLR	0x12
  0148    3079    LDIA	0x79
  0149    0093    LD	0x13,A
  014A    1303    CLRB	0x3,6
  014B    1305    CLRB	0x5,6
  014C    1306    CLRB	0x6,6
  014D    0000    NOP
  014E    0000    NOP
  014F    0000    NOP
  0150    0000    NOP
  0151    0000    NOP
  0152    0000    NOP
  0153    0000    NOP
  0154    0000    NOP
  0155    1283    CLRB	0x3,5
  0156    1303    CLRB	0x3,6
  0157    1705    SETB	0x5,6
  0158    084E    LD	A,0x4E
  0159    3E18    ADDIA	0x18
  015A    0084    LD	0x4,A
  015B    158A    SETB	0xA,3
  015C    2000    CALL	0x0
  015D    118A    CLRB	0xA,3
  015E    1703    SETB	0x3,6
  015F    0091    LD	0x11,A
  0160    1303    CLRB	0x3,6
  0161    084E    LD	A,0x4E
  0162    3E1A    ADDIA	0x1A
  0163    0084    LD	0x4,A
  0164    158A    SETB	0xA,3
  0165    2000    CALL	0x0
  0166    118A    CLRB	0xA,3
  0167    1703    SETB	0x3,6
  0168    0092    LD	0x12,A
  0169    0000    NOP
  016A    0000    NOP
  016B    0000    NOP
  016C    0000    NOP
  016D    1283    CLRB	0x3,5
  016E    1703    SETB	0x3,6
  016F    1411    SETB	0x11,0
  0170    30D0    LDIA	0xD0
  0171    1303    CLRB	0x3,6
  0172    00CA    LD	0x4A,A
  0173    3007    LDIA	0x7
  0174    00CB    LD	0x4B,A
  0175    1703    SETB	0x3,6
  0176    1B91    SZB	0x11,7
  0177    2984    JP	0x184
  0178    3001    LDIA	0x1
  0179    1303    CLRB	0x3,6
  017A    02CA    SUBR	0x4A
  017B    1C03    SNZB	0x3,0
  017C    03CB    DECR	0x4B
  017D    084A    LD	A,0x4A
  017E    044B    ORA	0x4B
  017F    1D03    SNZB	0x3,2
  0180    2975    JP	0x175
  0181    30FF    LDIA	0xFF
  0182    00B4    LD	0x34,A
  0183    29A1    JP	0x1A1
  0184    1303    CLRB	0x3,6
  0185    1003    CLRB	0x3,0
  0186    0D4E    RLCA	0x4E
  0187    3EAC    ADDIA	0xAC
  0188    0084    LD	0x4,A
  0189    1703    SETB	0x3,6
  018A    0816    LD	A,0x16
  018B    1383    CLRB	0x3,7
  018C    0780    ADDR	0x0
  018D    0F84    SZINCR	0x4
  018E    0800    LD	A,0x0
  018F    1803    SZB	0x3,0
  0190    0A00    INCA	0x0
  0191    00FF    LD	0x7F,A
  0192    0817    LD	A,0x17
  0193    077F    ADDA	0x7F
  0194    0080    LD	0x0,A
  0195    0384    DECR	0x4
  0196    3002    LDIA	0x2
  0197    1303    CLRB	0x3,6
  0198    1003    CLRB	0x3,0
  0199    0DCC    RLCR	0x4C
  019A    0DCD    RLCR	0x4D
  019B    0ACE    INCR	0x4E
  019C    024E    SUBA	0x4E
  019D    1C03    SNZB	0x3,0
  019E    293F    JP	0x13F
  019F    1078    CLRB	0x78,0
  01A0    0008    RET
  01A1    01F3    CLR	0x73
  01A2    1003    CLRB	0x3,0
  01A3    0D73    RLCA	0x73
  01A4    3EAC    ADDIA	0xAC
  01A5    0084    LD	0x4,A
  01A6    3002    LDIA	0x2
  01A7    1383    CLRB	0x3,7
  01A8    0180    CLR	0x0
  01A9    0A84    INCR	0x4
  01AA    0180    CLR	0x0
  01AB    0AF3    INCR	0x73
  01AC    0273    SUBA	0x73
  01AD    1803    SZB	0x3,0
  01AE    0008    RET
  01AF    29A2    JP	0x1A2
  01B0    1283    CLRB	0x3,5
  01B1    1303    CLRB	0x3,6
  01B2    01D6    CLR	0x56
  01B3    01F9    CLR	0x79
  01B4    01FA    CLR	0x7A
  01B5    01B3    CLR	0x33
  01B6    0856    LD	A,0x56
  01B7    3907    ANDIA	0x7
  01B8    3E0E    ADDIA	0xE
  01B9    0084    LD	0x4,A
  01BA    158A    SETB	0xA,3
  01BB    2000    CALL	0x0
  01BC    118A    CLRB	0xA,3
  01BD    00D0    LD	0x50,A
  01BE    1003    CLRB	0x3,0
  01BF    0D56    RLCA	0x56
  01C0    3EAC    ADDIA	0xAC
  01C1    0084    LD	0x4,A
  01C2    3003    LDIA	0x3
  01C3    0A84    INCR	0x4
  01C4    1003    CLRB	0x3,0
  01C5    1383    CLRB	0x3,7
  01C6    0C80    RRCR	0x0
  01C7    0384    DECR	0x4
  01C8    0C80    RRCR	0x0
  01C9    3EFF    ADDIA	0xFF
  01CA    1D03    SNZB	0x3,2
  01CB    29C3    JP	0x1C3
  01CC    1003    CLRB	0x3,0
  01CD    0D56    RLCA	0x56
  01CE    3EAC    ADDIA	0xAC
  01CF    0084    LD	0x4,A
  01D0    0800    LD	A,0x0
  01D1    00D4    LD	0x54,A
  01D2    0A84    INCR	0x4
  01D3    0800    LD	A,0x0
  01D4    00D5    LD	0x55,A
  01D5    0856    LD	A,0x56
  01D6    3E16    ADDIA	0x16
  01D7    0084    LD	0x4,A
  01D8    158A    SETB	0xA,3
  01D9    2000    CALL	0x0
  01DA    118A    CLRB	0xA,3
  01DB    00D3    LD	0x53,A
  01DC    00D1    LD	0x51,A
  01DD    01D2    CLR	0x52
  01DE    0854    LD	A,0x54
  01DF    07D1    ADDR	0x51
  01E0    1803    SZB	0x3,0
  01E1    0AD2    INCR	0x52
  01E2    0855    LD	A,0x55
  01E3    07D2    ADDR	0x52
  01E4    0856    LD	A,0x56
  01E5    2291    CALL	0x291
  01E6    118A    CLRB	0xA,3
  01E7    3A00    XORIA	0x0
  01E8    1003    CLRB	0x3,0
  01E9    1D03    SNZB	0x3,2
  01EA    2A45    JP	0x245
  01EB    0D56    RLCA	0x56
  01EC    3EA4    ADDIA	0xA4
  01ED    0084    LD	0x4,A
  01EE    1383    CLRB	0x3,7
  01EF    0800    LD	A,0x0
  01F0    00CE    LD	0x4E,A
  01F1    0A84    INCR	0x4
  01F2    0800    LD	A,0x0
  01F3    00CF    LD	0x4F,A
  01F4    1003    CLRB	0x3,0
  01F5    0D56    RLCA	0x56
  01F6    3EA0    ADDIA	0xA0
  01F7    23BB    CALL	0x3BB
  01F8    118A    CLRB	0xA,3
  01F9    0252    SUBA	0x52
  01FA    1D03    SNZB	0x3,2
  01FB    29FE    JP	0x1FE
  01FC    084A    LD	A,0x4A
  01FD    0251    SUBA	0x51
  01FE    1803    SZB	0x3,0
  01FF    2A0D    JP	0x20D
  0200    1003    CLRB	0x3,0
  0201    0D56    RLCA	0x56
  0202    3EA0    ADDIA	0xA0
  0203    23BB    CALL	0x3BB
  0204    118A    CLRB	0xA,3
  0205    0854    LD	A,0x54
  0206    024A    SUBA	0x4A
  0207    00D4    LD	0x54,A
  0208    0855    LD	A,0x55
  0209    1C03    SNZB	0x3,0
  020A    0A55    INCA	0x55
  020B    024B    SUBA	0x4B
  020C    2A31    JP	0x231
  020D    084F    LD	A,0x4F
  020E    0252    SUBA	0x52
  020F    1D03    SNZB	0x3,2
  0210    2A13    JP	0x213
  0211    084E    LD	A,0x4E
  0212    0251    SUBA	0x51
  0213    1803    SZB	0x3,0
  0214    2A89    JP	0x289
  0215    1003    CLRB	0x3,0
  0216    0D56    RLCA	0x56
  0217    3E20    ADDIA	0x20
  0218    23BB    CALL	0x3BB
  0219    118A    CLRB	0xA,3
  021A    0252    SUBA	0x52
  021B    1D03    SNZB	0x3,2
  021C    2A1F    JP	0x21F
  021D    084A    LD	A,0x4A
  021E    0251    SUBA	0x51
  021F    1803    SZB	0x3,0
  0220    2A89    JP	0x289
  0221    1003    CLRB	0x3,0
  0222    0D56    RLCA	0x56
  0223    3EA0    ADDIA	0xA0
  0224    0084    LD	0x4,A
  0225    084E    LD	A,0x4E
  0226    0080    LD	0x0,A
  0227    0A84    INCR	0x4
  0228    084F    LD	A,0x4F
  0229    0080    LD	0x0,A
  022A    0854    LD	A,0x54
  022B    024E    SUBA	0x4E
  022C    00D4    LD	0x54,A
  022D    0855    LD	A,0x55
  022E    1C03    SNZB	0x3,0
  022F    0A55    INCA	0x55
  0230    024F    SUBA	0x4F
  0231    00D5    LD	0x55,A
  0232    0856    LD	A,0x56
  0233    3EBC    ADDIA	0xBC
  0234    0084    LD	0x4,A
  0235    0180    CLR	0x0
  0236    0855    LD	A,0x55
  0237    1903    SZB	0x3,2
  0238    2A3B    JP	0x23B
  0239    30FF    LDIA	0xFF
  023A    2A3C    JP	0x23C
  023B    0854    LD	A,0x54
  023C    00D3    LD	0x53,A
  023D    0233    SUBA	0x33
  023E    1803    SZB	0x3,0
  023F    2A43    JP	0x243
  0240    0853    LD	A,0x53
  0241    00B3    LD	0x33,A
  0242    2A83    JP	0x283
  0243    0AB4    INCR	0x34
  0244    2A89    JP	0x289
  0245    0D56    RLCA	0x56
  0246    3EA0    ADDIA	0xA0
  0247    0084    LD	0x4,A
  0248    1383    CLRB	0x3,7
  0249    0800    LD	A,0x0
  024A    00CA    LD	0x4A,A
  024B    0A84    INCR	0x4
  024C    0800    LD	A,0x0
  024D    00CB    LD	0x4B,A
  024E    084A    LD	A,0x4A
  024F    3E01    ADDIA	0x1
  0250    00CC    LD	0x4C,A
  0251    084B    LD	A,0x4B
  0252    1803    SZB	0x3,0
  0253    3E01    ADDIA	0x1
  0254    00CD    LD	0x4D,A
  0255    0852    LD	A,0x52
  0256    024D    SUBA	0x4D
  0257    1D03    SNZB	0x3,2
  0258    2A5B    JP	0x25B
  0259    0851    LD	A,0x51
  025A    024C    SUBA	0x4C
  025B    1C03    SNZB	0x3,0
  025C    2A89    JP	0x289
  025D    1003    CLRB	0x3,0
  025E    0D56    RLCA	0x56
  025F    3EA4    ADDIA	0xA4
  0260    0084    LD	0x4,A
  0261    0800    LD	A,0x0
  0262    23A9    CALL	0x3A9
  0263    118A    CLRB	0xA,3
  0264    1C03    SNZB	0x3,0
  0265    2A6F    JP	0x26F
  0266    1003    CLRB	0x3,0
  0267    0D56    RLCA	0x56
  0268    3E20    ADDIA	0x20
  0269    0084    LD	0x4,A
  026A    0800    LD	A,0x0
  026B    23A9    CALL	0x3A9
  026C    118A    CLRB	0xA,3
  026D    1803    SZB	0x3,0
  026E    2A7B    JP	0x27B
  026F    0856    LD	A,0x56
  0270    3EBC    ADDIA	0xBC
  0271    0084    LD	0x4,A
  0272    3009    LDIA	0x9
  0273    0A80    INCR	0x0
  0274    0200    SUBA	0x0
  0275    1C03    SNZB	0x3,0
  0276    2A7F    JP	0x27F
  0277    0856    LD	A,0x56
  0278    22A5    CALL	0x2A5
  0279    118A    CLRB	0xA,3
  027A    2A89    JP	0x289
  027B    0856    LD	A,0x56
  027C    3EBC    ADDIA	0xBC
  027D    0084    LD	0x4,A
  027E    0180    CLR	0x0
  027F    087A    LD	A,0x7A
  0280    0479    ORA	0x79
  0281    1D03    SNZB	0x3,2
  0282    2A89    JP	0x289
  0283    0850    LD	A,0x50
  0284    00F3    LD	0x73,A
  0285    01F4    CLR	0x74
  0286    0856    LD	A,0x56
  0287    22BA    CALL	0x2BA
  0288    118A    CLRB	0xA,3
  0289    3002    LDIA	0x2
  028A    1283    CLRB	0x3,5
  028B    1303    CLRB	0x3,6
  028C    0AD6    INCR	0x56
  028D    0256    SUBA	0x56
  028E    1803    SZB	0x3,0
  028F    0008    RET
  0290    29B6    JP	0x1B6
  0291    00F4    LD	0x74,A
  0292    3907    ANDIA	0x7
  0293    3E0E    ADDIA	0xE
  0294    0084    LD	0x4,A
  0295    158A    SETB	0xA,3
  0296    2000    CALL	0x0
  0297    118A    CLRB	0xA,3
  0298    00F3    LD	0x73,A
  0299    1DF4    SNZB	0x74,3
  029A    2A9F    JP	0x29F
  029B    1283    CLRB	0x3,5
  029C    1303    CLRB	0x3,6
  029D    082F    LD	A,0x2F
  029E    2AA2    JP	0x2A2
  029F    1283    CLRB	0x3,5
  02A0    1303    CLRB	0x3,6
  02A1    082E    LD	A,0x2E
  02A2    05F3    ANDR	0x73
  02A3    0873    LD	A,0x73
  02A4    0008    RET
  02A5    00F3    LD	0x73,A
  02A6    1003    CLRB	0x3,0
  02A7    0D73    RLCA	0x73
  02A8    3EA8    ADDIA	0xA8
  02A9    0084    LD	0x4,A
  02AA    1383    CLRB	0x3,7
  02AB    23E7    CALL	0x3E7
  02AC    118A    CLRB	0xA,3
  02AD    3E20    ADDIA	0x20
  02AE    0084    LD	0x4,A
  02AF    23E7    CALL	0x3E7
  02B0    118A    CLRB	0xA,3
  02B1    3EA4    ADDIA	0xA4
  02B2    0084    LD	0x4,A
  02B3    23E7    CALL	0x3E7
  02B4    3EA0    ADDIA	0xA0
  02B5    0084    LD	0x4,A
  02B6    0180    CLR	0x0
  02B7    0A84    INCR	0x4
  02B8    0180    CLR	0x0
  02B9    0008    RET
  02BA    00F5    LD	0x75,A
  02BB    1283    CLRB	0x3,5
  02BC    1303    CLRB	0x3,6
  02BD    0AB4    INCR	0x34
  02BE    01F9    CLR	0x79
  02BF    01FA    CLR	0x7A
  02C0    1DF5    SNZB	0x75,3
  02C1    2AC5    JP	0x2C5
  02C2    0873    LD	A,0x73
  02C3    00FA    LD	0x7A,A
  02C4    0008    RET
  02C5    0873    LD	A,0x73
  02C6    00F9    LD	0x79,A
  02C7    0008    RET
  02C8    1283    CLRB	0x3,5
  02C9    3004    LDIA	0x4
  02CA    1303    CLRB	0x3,6
  02CB    01CE    CLR	0x4E
  02CC    0AB2    INCR	0x32
  02CD    0232    SUBA	0x32
  02CE    1C03    SNZB	0x3,0
  02CF    0008    RET
  02D0    01B2    CLR	0x32
  02D1    1003    CLRB	0x3,0
  02D2    0D4E    RLCA	0x4E
  02D3    3EAC    ADDIA	0xAC
  02D4    0084    LD	0x4,A
  02D5    1383    CLRB	0x3,7
  02D6    0800    LD	A,0x0
  02D7    00CA    LD	0x4A,A
  02D8    0A84    INCR	0x4
  02D9    0800    LD	A,0x0
  02DA    00CB    LD	0x4B,A
  02DB    084E    LD	A,0x4E
  02DC    2291    CALL	0x291
  02DD    118A    CLRB	0xA,3
  02DE    3A00    XORIA	0x0
  02DF    1003    CLRB	0x3,0
  02E0    1D03    SNZB	0x3,2
  02E1    2B16    JP	0x316
  02E2    0D4E    RLCA	0x4E
  02E3    3EA8    ADDIA	0xA8
  02E4    0084    LD	0x4,A
  02E5    1383    CLRB	0x3,7
  02E6    239B    CALL	0x39B
  02E7    118A    CLRB	0xA,3
  02E8    1903    SZB	0x3,2
  02E9    024C    SUBA	0x4C
  02EA    1C03    SNZB	0x3,0
  02EB    2AF2    JP	0x2F2
  02EC    0F4C    SZINCA	0x4C
  02ED    2B15    JP	0x315
  02EE    0A4D    INCA	0x4D
  02EF    1003    CLRB	0x3,0
  02F0    1D03    SNZB	0x3,2
  02F1    2B16    JP	0x316
  02F2    0D4E    RLCA	0x4E
  02F3    3E20    ADDIA	0x20
  02F4    0084    LD	0x4,A
  02F5    239B    CALL	0x39B
  02F6    118A    CLRB	0xA,3
  02F7    1903    SZB	0x3,2
  02F8    024C    SUBA	0x4C
  02F9    1C03    SNZB	0x3,0
  02FA    2B01    JP	0x301
  02FB    0F4C    SZINCA	0x4C
  02FC    2B15    JP	0x315
  02FD    0A4D    INCA	0x4D
  02FE    1003    CLRB	0x3,0
  02FF    1D03    SNZB	0x3,2
  0300    2B16    JP	0x316
  0301    0D4E    RLCA	0x4E
  0302    3EA4    ADDIA	0xA4
  0303    0084    LD	0x4,A
  0304    239B    CALL	0x39B
  0305    118A    CLRB	0xA,3
  0306    1903    SZB	0x3,2
  0307    024C    SUBA	0x4C
  0308    1C03    SNZB	0x3,0
  0309    2B10    JP	0x310
  030A    0F4C    SZINCA	0x4C
  030B    2B15    JP	0x315
  030C    0A4D    INCA	0x4D
  030D    1003    CLRB	0x3,0
  030E    1D03    SNZB	0x3,2
  030F    2B16    JP	0x316
  0310    0D4E    RLCA	0x4E
  0311    3EA0    ADDIA	0xA0
  0312    0084    LD	0x4,A
  0313    23F3    CALL	0x3F3
  0314    118A    CLRB	0xA,3
  0315    1003    CLRB	0x3,0
  0316    0D4E    RLCA	0x4E
  0317    3E20    ADDIA	0x20
  0318    0084    LD	0x4,A
  0319    1383    CLRB	0x3,7
  031A    23DF    CALL	0x3DF
  031B    118A    CLRB	0xA,3
  031C    3EA4    ADDIA	0xA4
  031D    23CD    CALL	0x3CD
  031E    118A    CLRB	0xA,3
  031F    23DF    CALL	0x3DF
  0320    118A    CLRB	0xA,3
  0321    3E20    ADDIA	0x20
  0322    23CD    CALL	0x3CD
  0323    118A    CLRB	0xA,3
  0324    23F3    CALL	0x3F3
  0325    118A    CLRB	0xA,3
  0326    3002    LDIA	0x2
  0327    0ACE    INCR	0x4E
  0328    024E    SUBA	0x4E
  0329    1803    SZB	0x3,0
  032A    0008    RET
  032B    2AD1    JP	0x2D1
  032C    1283    CLRB	0x3,5
  032D    1303    CLRB	0x3,6
  032E    01AE    CLR	0x2E
  032F    01AF    CLR	0x2F
  0330    01F4    CLR	0x74
  0331    1003    CLRB	0x3,0
  0332    0D74    RLCA	0x74
  0333    3EAC    ADDIA	0xAC
  0334    0084    LD	0x4,A
  0335    1383    CLRB	0x3,7
  0336    0180    CLR	0x0
  0337    0A84    INCR	0x4
  0338    0180    CLR	0x0
  0339    0874    LD	A,0x74
  033A    22A5    CALL	0x2A5
  033B    118A    CLRB	0xA,3
  033C    3002    LDIA	0x2
  033D    0AF4    INCR	0x74
  033E    0274    SUBA	0x74
  033F    1803    SZB	0x3,0
  0340    0008    RET
  0341    2B31    JP	0x331
  0342    087A    LD	A,0x7A
  0343    0479    ORA	0x79
  0344    1903    SZB	0x3,2
  0345    2B66    JP	0x366
  0346    1283    CLRB	0x3,5
  0347    1303    CLRB	0x3,6
  0348    01B0    CLR	0x30
  0349    0879    LD	A,0x79
  034A    0624    XORA	0x24
  034B    1D03    SNZB	0x3,2
  034C    2B5F    JP	0x35F
  034D    087A    LD	A,0x7A
  034E    0625    XORA	0x25
  034F    1D03    SNZB	0x3,2
  0350    2B5F    JP	0x35F
  0351    3002    LDIA	0x2
  0352    0AB1    INCR	0x31
  0353    0231    SUBA	0x31
  0354    1C03    SNZB	0x3,0
  0355    0008    RET
  0356    01B1    CLR	0x31
  0357    0879    LD	A,0x79
  0358    00AE    LD	0x2E,A
  0359    087A    LD	A,0x7A
  035A    00AF    LD	0x2F,A
  035B    1978    SZB	0x78,2
  035C    0008    RET
  035D    1578    SETB	0x78,2
  035E    2B8B    JP	0x38B
  035F    1178    CLRB	0x78,2
  0360    0879    LD	A,0x79
  0361    00A4    LD	0x24,A
  0362    087A    LD	A,0x7A
  0363    00A5    LD	0x25,A
  0364    01B1    CLR	0x31
  0365    0008    RET
  0366    1283    CLRB	0x3,5
  0367    1303    CLRB	0x3,6
  0368    01B1    CLR	0x31
  0369    01A4    CLR	0x24
  036A    01A5    CLR	0x25
  036B    3002    LDIA	0x2
  036C    0AB0    INCR	0x30
  036D    0230    SUBA	0x30
  036E    1C03    SNZB	0x3,0
  036F    0008    RET
  0370    01B0    CLR	0x30
  0371    01AE    CLR	0x2E
  0372    01AF    CLR	0x2F
  0373    1178    CLRB	0x78,2
  0374    0008    RET
  0375    1283    CLRB	0x3,5
  0376    1303    CLRB	0x3,6
  0377    082F    LD	A,0x2F
  0378    042E    ORA	0x2E
  0379    1903    SZB	0x3,2
  037A    2B87    JP	0x387
  037B    1683    SETB	0x3,5
  037C    0AB0    INCR	0x30
  037D    1903    SZB	0x3,2
  037E    0AB1    INCR	0x31
  037F    303A    LDIA	0x3A
  0380    0231    SUBA	0x31
  0381    3098    LDIA	0x98
  0382    1903    SZB	0x3,2
  0383    0230    SUBA	0x30
  0384    1C03    SNZB	0x3,0
  0385    0008    RET
  0386    14F8    SETB	0x78,1
  0387    1683    SETB	0x3,5
  0388    01B0    CLR	0x30
  0389    01B1    CLR	0x31
  038A    0008    RET
  038B    01F5    CLR	0x75
  038C    0875    LD	A,0x75
  038D    2291    CALL	0x291
  038E    118A    CLRB	0xA,3
  038F    3A00    XORIA	0x0
  0390    1D03    SNZB	0x3,2
  0391    2B95    JP	0x395
  0392    0875    LD	A,0x75
  0393    22A5    CALL	0x2A5
  0394    118A    CLRB	0xA,3
  0395    3002    LDIA	0x2
  0396    0AF5    INCR	0x75
  0397    0275    SUBA	0x75
  0398    1803    SZB	0x3,0
  0399    0008    RET
  039A    2B8C    JP	0x38C
---- stringtab ------------------------------------------------------------------
  0800    3008    LDIA	0x8
  0801    008A    LD	0xA,A
  0802    0804    LD	A,0x4
  0803    0A84    INCR	0x4
  0804    0782    ADDR	0x2
  0805    3400    RET	0x0
---- reset_enter ------------------------------------------------------------------
  0000    118A    CLRB	0xA,3
  0001    280D    JP	0xD
  000D    118A    CLRB	0xA,3
  000E    280F    JP	0xF
---- start_initialization ------------------------------------------------------------------
  000F    307F    LDIA	0x7F
  0010    00EC    LD	0x6C,A
  0011    00ED    LD	0x6D,A
  0012    30A0    LDIA	0xA0
  0013    1383    CLRB	0x3,7
  0014    0084    LD	0x4,A
  0015    30BE    LDIA	0xBE
  0016    118A    CLRB	0xA,3
  0017    27F5    CALL	0x7F5
  0018    118A    CLRB	0xA,3
  0019    3020    LDIA	0x20
  001A    0084    LD	0x4,A
  001B    304A    LDIA	0x4A
  001C    118A    CLRB	0xA,3
  001D    27F5    CALL	0x7F5
  001E    01F9    CLR	0x79
  001F    01FA    CLR	0x7A
  0020    01F8    CLR	0x78
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F0    LD	0x70,A
  0007    0804    LD	A,0x4
  0008    00F1    LD	0x71,A
  0009    080A    LD	A,0xA
  000A    00F2    LD	0x72,A
  000B    158A    SETB	0xA,3
  000C    2E55    JP	0x655
  07CD    158A    SETB	0xA,3
  07CE    2F24    JP	0x724
  07CF    158A    SETB	0xA,3
  07D0    2E89    JP	0x689
  07D1    158A    SETB	0xA,3
  07D2    2E90    JP	0x690
  07D3    158A    SETB	0xA,3
  07D4    2E97    JP	0x697
  07D5    158A    SETB	0xA,3
  07D6    2E9E    JP	0x69E
  07D7    158A    SETB	0xA,3
  07D8    2EA3    JP	0x6A3
  07D9    158A    SETB	0xA,3
  07DA    2EAA    JP	0x6AA
  07DB    158A    SETB	0xA,3
  07DC    2EB1    JP	0x6B1
  07DD    158A    SETB	0xA,3
  07DE    2EB8    JP	0x6B8
  07DF    158A    SETB	0xA,3
  07E0    2EBD    JP	0x6BD
  07E1    158A    SETB	0xA,3
  07E2    2EC4    JP	0x6C4
  07E3    158A    SETB	0xA,3
  07E4    2ECB    JP	0x6CB
  07E5    158A    SETB	0xA,3
  07E6    2ED2    JP	0x6D2
  07E7    158A    SETB	0xA,3
  07E8    2ED7    JP	0x6D7
  07E9    158A    SETB	0xA,3
  07EA    2EDE    JP	0x6DE
  07EB    158A    SETB	0xA,3
  07EC    2EE5    JP	0x6E5
  07ED    158A    SETB	0xA,3
  07EE    2EF2    JP	0x6F2
  07EF    158A    SETB	0xA,3
  07F0    2EFA    JP	0x6FA
  07F1    158A    SETB	0xA,3
  07F2    2F04    JP	0x704
  07F3    158A    SETB	0xA,3
  07F4    2F0E    JP	0x70E
---- common_function ------------------------------------------------------------------
  0021    0183    CLR	0x3
  0022    158A    SETB	0xA,3
  0023    2D43    JP	0x543
  039B    0800    LD	A,0x0
  039C    00CC    LD	0x4C,A
  039D    0A84    INCR	0x4
  039E    0800    LD	A,0x0
  039F    00CD    LD	0x4D,A
  03A0    084A    LD	A,0x4A
  03A1    02CC    SUBR	0x4C
  03A2    084B    LD	A,0x4B
  03A3    1C03    SNZB	0x3,0
  03A4    03CD    DECR	0x4D
  03A5    02CD    SUBR	0x4D
  03A6    3000    LDIA	0x0
  03A7    024D    SUBA	0x4D
  03A8    3402    RET	0x2
  03A9    00CA    LD	0x4A,A
  03AA    0A84    INCR	0x4
  03AB    0800    LD	A,0x0
  03AC    00CB    LD	0x4B,A
  03AD    0853    LD	A,0x53
  03AE    074A    ADDA	0x4A
  03AF    00CC    LD	0x4C,A
  03B0    084B    LD	A,0x4B
  03B1    1803    SZB	0x3,0
  03B2    0A4B    INCA	0x4B
  03B3    00CD    LD	0x4D,A
  03B4    0855    LD	A,0x55
  03B5    024D    SUBA	0x4D
  03B6    1D03    SNZB	0x3,2
  03B7    0008    RET
  03B8    0854    LD	A,0x54
  03B9    024C    SUBA	0x4C
  03BA    0008    RET
  03BB    0084    LD	0x4,A
  03BC    0800    LD	A,0x0
  03BD    00CA    LD	0x4A,A
  03BE    0A84    INCR	0x4
  03BF    0800    LD	A,0x0
  03C0    00CB    LD	0x4B,A
  03C1    0008    RET
  03C2    0084    LD	0x4,A
  03C3    0874    LD	A,0x74
  03C4    0080    LD	0x0,A
  03C5    0A84    INCR	0x4
  03C6    0875    LD	A,0x75
  03C7    0080    LD	0x0,A
  03C8    1003    CLRB	0x3,0
  03C9    0D55    RLCA	0x55
  03CA    3EA8    ADDIA	0xA8
  03CB    0084    LD	0x4,A
  03CC    0008    RET
  03CD    0084    LD	0x4,A
  03CE    0875    LD	A,0x75
  03CF    0080    LD	0x0,A
  03D0    0A84    INCR	0x4
  03D1    0876    LD	A,0x76
  03D2    0080    LD	0x0,A
  03D3    1003    CLRB	0x3,0
  03D4    0D4E    RLCA	0x4E
  03D5    3EA8    ADDIA	0xA8
  03D6    0084    LD	0x4,A
  03D7    0008    RET
  03D8    0084    LD	0x4,A
  03D9    0800    LD	A,0x0
  03DA    00F4    LD	0x74,A
  03DB    0A84    INCR	0x4
  03DC    0800    LD	A,0x0
  03DD    00F5    LD	0x75,A
  03DE    0008    RET
  03DF    0800    LD	A,0x0
  03E0    00F5    LD	0x75,A
  03E1    0A84    INCR	0x4
  03E2    0800    LD	A,0x0
  03E3    00F6    LD	0x76,A
  03E4    1003    CLRB	0x3,0
  03E5    0D4E    RLCA	0x4E
  03E6    0008    RET
  03E7    0180    CLR	0x0
  03E8    0A84    INCR	0x4
  03E9    0180    CLR	0x0
  03EA    1003    CLRB	0x3,0
  03EB    0D73    RLCA	0x73
  03EC    0008    RET
  03ED    3041    LDIA	0x41
  03EE    1683    SETB	0x3,5
  03EF    0095    LD	0x15,A
  03F0    1415    SETB	0x15,0
  03F1    0196    CLR	0x16
  03F2    0008    RET
  03F3    084A    LD	A,0x4A
  03F4    0080    LD	0x0,A
  03F5    0A84    INCR	0x4
  03F6    084B    LD	A,0x4B
  03F7    0080    LD	0x0,A
  03F8    0008    RET
  03F9    01D5    CLR	0x55
  03FA    01D3    CLR	0x53
  03FB    0AD3    INCR	0x53
  03FC    01D4    CLR	0x54
  03FD    0008    RET
  03FE    0DD3    RLCR	0x53
  03FF    0DD4    RLCR	0x54
  0400    0AD5    INCR	0x55
  0401    0255    SUBA	0x55
  0402    0008    RET
  07A0    00F5    LD	0x75,A
  07A1    01F6    CLR	0x76
  07A2    01F7    CLR	0x77
  07A3    0874    LD	A,0x74
  07A4    02CD    SUBR	0x4D
  07A5    0875    LD	A,0x75
  07A6    1C03    SNZB	0x3,0
  07A7    0F75    SZINCA	0x75
  07A8    02CE    SUBR	0x4E
  07A9    0876    LD	A,0x76
  07AA    1C03    SNZB	0x3,0
  07AB    0F76    SZINCA	0x76
  07AC    02CF    SUBR	0x4F
  07AD    0877    LD	A,0x77
  07AE    0008    RET
  07AF    01CD    CLR	0x4D
  07B0    01CE    CLR	0x4E
  07B1    01CF    CLR	0x4F
  07B2    01D0    CLR	0x50
  07B3    01D1    CLR	0x51
  07B4    01D2    CLR	0x52
  07B5    01D3    CLR	0x53
  07B6    01D4    CLR	0x54
  07B7    0008    RET
  07B8    085F    LD	A,0x5F
  07B9    00E3    LD	0x63,A
  07BA    0860    LD	A,0x60
  07BB    00E4    LD	0x64,A
  07BC    0861    LD	A,0x61
  07BD    00E5    LD	0x65,A
  07BE    0008    RET
  07BF    1003    CLRB	0x3,0
  07C0    0CF5    RRCR	0x75
  07C1    0CF4    RRCR	0x74
  07C2    0CF3    RRCR	0x73
  07C3    0008    RET
  07C4    0856    LD	A,0x56
  07C5    00D4    LD	0x54,A
  07C6    0855    LD	A,0x55
  07C7    00D3    LD	0x53,A
  07C8    0008    RET
  07C9    01D0    CLR	0x50
  07CA    01D1    CLR	0x51
  07CB    01D2    CLR	0x52
  07CC    0008    RET
  07F5    0064    CLRWDT
  07F6    0180    CLR	0x0
  07F7    0A84    INCR	0x4
  07F8    0604    XORA	0x4
  07F9    1903    SZB	0x3,2
  07FA    3400    RET	0x0
  07FB    0604    XORA	0x4
  07FC    2FF6    JP	0x7F6
  0806    343F    RET	0x3F
  0807    3406    RET	0x6
  0808    345B    RET	0x5B
  0809    344F    RET	0x4F
  080A    3466    RET	0x66
  080B    346D    RET	0x6D
  080C    347D    RET	0x7D
  080D    3407    RET	0x7
  080E    347F    RET	0x7F
  080F    346F    RET	0x6F
  0810    3471    RET	0x71
  0811    3479    RET	0x79
  0812    3450    RET	0x50
  0813    3401    RET	0x1
  0814    3402    RET	0x2
  0815    3404    RET	0x4
  0816    3408    RET	0x8
  0817    3410    RET	0x10
  0818    3420    RET	0x20
  0819    3440    RET	0x40
  081A    3480    RET	0x80
  081B    340A    RET	0xA
  081C    340A    RET	0xA
  081D    3402    RET	0x2
  081E    3402    RET	0x2
  081F    3442    RET	0x42
  0820    3443    RET	0x43
  0D7E    30E4    LDIA	0xE4
  0D7F    1683    SETB	0x3,5
  0D80    0586    ANDR	0x6
  0D81    1283    CLRB	0x3,5
  0D82    1206    CLRB	0x6,4
  0D83    301B    LDIA	0x1B
  0D84    1683    SETB	0x3,5
  0D85    0485    ORR	0x5
  0D86    1283    CLRB	0x3,5
  0D87    1605    SETB	0x5,4
  0D88    0008    RET
  0F25    1283    CLRB	0x3,5
  0F26    1205    CLRB	0x5,4
  0F27    1606    SETB	0x6,4
  0F28    0008    RET
