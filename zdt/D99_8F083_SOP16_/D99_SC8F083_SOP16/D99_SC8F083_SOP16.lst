---- C:\mcuproject\scm\zdt\D99_8F083_SOP16_\D99_SC8F083_SOP16\main.c ----------------------------------------------------------------------
1:                #include <sc.h>
2:                #include "Touch_Kscan_Library.h"
3:                
4:                #ifndef _XTAL_FREQ
5:                #define _XTAL_FREQ 8000000			//8MHz,使用内置延时函数必须定义主频，
6:                									//如用16M需改此参数为16000000
7:                #endif
8:                #define     POWER_RATIO  	(4096UL*1.2*1000)
9:                
10:               #define		uchar		unsigned char
11:               #define		u8t		unsigned char
12:               #define		uint			unsigned int
13:               #define		u16t			unsigned int
14:               #define		ulong		unsigned long
15:               
16:               
17:               
18:               #define		LED5						 RB4
19:               #define		LED4						 RA1
20:               #define		LED3						 RA3
21:               #define		LED2						 RA4
22:               #define		LED1						 RA0
23:               
24:               
25:               #define		LED5_OUT					 TRISB	&= 0xEF
26:               #define		LED4_OUT					 TRISA	&= 0xFD
27:               #define		LED3_OUT					 TRISA	&= 0xF7
28:               #define		LED2_OUT					 TRISA	&= 0xEF
29:               #define		LED1_OUT					 TRISA	&= 0xFE
30:               
31:               
32:               
33:               
34:               
35:               const static unsigned char numArray[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x71,0x79,0x50};
36:               volatile unsigned char MainTime;
37:               static unsigned int time;
38:               volatile bit	B_MainLoop,B_OnOff;
39:               u8t	count1s = 0;
40:               u8t	workStep = 0;
41:               u8t	wuhuaFlag = 0;
42:               u16t		shanshuoTime = 0;
43:               u16t		shanshuoTime2 = 0;
44:               u16t		fanValue = 0;
45:               u16t		wuhuaValue = 0;
46:               u8t	fanDuty = 0;
47:               u8t	count10s = 0;
48:               u8t	fanOverTime = 0;
49:               u8t	firstTime = 0;
50:               u16t	checkTime = 0;
51:               u16t	lowWaterTime = 0;
52:               u8t		chrgFlag = 0;
53:               u8t		chrgFullFlag = 0;
54:               u8t		chrgFullTime = 0;
55:               u8t		firstLock = 0;
56:               u8t		lowBatLock = 0;
57:               u16t		lowBatTime = 0;	
58:               u8t		lowFanTime = 0;//风扇降低为1档的时间
59:               u8t		ledCnt = 0;	
60:               u8t		showNumShi = 0x7F;
61:               u8t		showNumGe = 0x7F;
62:               u8t		fanKeyFlag = 0;
63:               u8t		wuhuaKeyFlag = 0;
64:               u8t		showBatStep = 0;
65:               u8t		curBatStep = 0;
66:               u16t	count30s = 0;
67:               u16t	count15s = 0;
68:               
69:               volatile unsigned int adresult;
70:               volatile unsigned int result;
71:               volatile unsigned char test_adc;
72:               volatile unsigned int power_ad;
73:               
74:               void chrgCtr();
75:               unsigned char ADC_Sample(unsigned char adch, unsigned char adldo);
76:               void ledShow();
77:               
78:               
79:               //系统初始化
80:               void Init_System()
  0024    0000    NOP
  0025    0064    CLRWDT
81:               {
82:               	asm("nop");
83:               	asm("clrwdt");
84:               	INTCON = 0;				//禁止中断
  0026    018B    CLR	0xB
85:               	OSCCON = 0X72;			//配置振荡为8M
  0027    3072    LDIA	0x72
  0028    1283    CLRB	0x3,5
  0029    1303    CLRB	0x3,6
  002A    0094    LD	0x14,A
86:               	OPTION_REG = 0;
  002B    0181    CLR	0x1
87:               	
88:               	
89:               	//延时等待电源电压稳定
90:               	//DelayXms(200);
91:               	TRISA = 0x00;
  002C    1683    SETB	0x3,5
  002D    0185    CLR	0x5
92:               	PORTA = 0;
  002E    0186    CLR	0x6
93:               	TRISB = 0x23;
  002F    3023    LDIA	0x23
  0030    1283    CLRB	0x3,5
  0031    0085    LD	0x5,A
94:               	PORTB = 0;
  0032    0186    CLR	0x6
95:               	WPUB = 0x02;
  0033    3002    LDIA	0x2
  0034    0088    LD	0x8,A
96:               	TRISC = 0;
  0035    1703    SETB	0x3,6
  0036    0185    CLR	0x5
97:               	PORTC = 0;
  0037    0186    CLR	0x6
98:               
99:               	PIE1 = 2;
  0038    1303    CLRB	0x3,6
  0039    008E    LD	0xE,A
100:              	PR2 = 250;				//8M下将TMR2设置为125us中断
  003A    30FA    LDIA	0xFA
  003B    0091    LD	0x11,A
101:              	T2CON = 4;				//使能定时器2
  003C    3004    LDIA	0x4
  003D    0093    LD	0x13,A
102:              
103:              	INTCON = 0XC0;			//使能中断
  003E    30C0    LDIA	0xC0
  003F    008B    LD	0xB,A
104:              	ADCON0 = 0X41;
105:              	ADON = 1;
106:              	ADCON1 = 0x00;
  0040    2BED    JP	0x3ED
107:              }
108:              
109:              
110:              /**********************************************************
111:              函数名称：Refurbish_Sfr
112:              函数功能：刷新一些特殊功能寄存器
113:              入口参数：无
114:              出口参数：无
115:              备    注：每隔一定时间刷新一次SFR可增强抗干扰能力
116:              **********************************************************/
117:              void Refurbish_Sfr() 
118:              {
119:              	//刷新中断相关控制寄存器
120:              	PIE1 = 2;
  0403    3002    LDIA	0x2
  0404    1283    CLRB	0x3,5
  0405    008E    LD	0xE,A
121:              	PR2 = 250;
  0406    30FA    LDIA	0xFA
  0407    0091    LD	0x11,A
122:              	INTCON = 0XC0;
  0408    30C0    LDIA	0xC0
  0409    008B    LD	0xB,A
123:              	if (4 != T2CON)
  040A    3004    LDIA	0x4
  040B    0613    XORA	0x13
  040C    1903    SZB	0x3,2
  040D    0008    RET
124:              		T2CON = 4;
  040E    3004    LDIA	0x4
  040F    0093    LD	0x13,A
  0410    0008    RET
125:              }
126:              
127:              
128:              /***********************************************************
129:              键处理函数
130:              ***********************************************************/
131:              void KeyServer() 
132:              {
133:              	static unsigned char KeyOldFlag = 0;
134:              	if (KeyFlag[0]) 
  0D86    082E    LD	A,0x2E
  0D87    1903    SZB	0x3,2
  0D88    2DD7    JP	0x5D7
135:              	{
136:              		time = 0;
  0D89    1683    SETB	0x3,5
  0D8A    01BA    CLR	0x3A
  0D8B    01BB    CLR	0x3B
137:              		if (KeyFlag[0] != KeyOldFlag) 
  0D8C    1283    CLRB	0x3,5
  0D8D    082E    LD	A,0x2E
  0D8E    0635    XORA	0x35
  0D8F    1903    SZB	0x3,2
  0D90    0008    RET
138:              		{
139:              			//确定状态改变的按键
140:              			KeyOldFlag ^= KeyFlag[0];
  0D91    082E    LD	A,0x2E
  0D92    06B5    XORR	0x35
141:              			if ((KeyOldFlag & 0x1) && (KeyFlag[0] & 0x1) && firstLock == 0) 
  0D93    1835    SZB	0x35,0
  0D94    1C2E    SNZB	0x2E,0
  0D95    2DB8    JP	0x5B8
  0D96    086B    LD	A,0x6B
  0D97    1D03    SNZB	0x3,2
  0D98    2DB8    JP	0x5B8
142:              			{
143:              				//KEY1被按下
144:              				if(lowBatLock == 1)
  0D99    0B3C    SZDECA	0x3C
  0D9A    2D9F    JP	0x59F
145:              				{
146:              					shanshuoTime = 225;
  0D9B    30E1    LDIA	0xE1
  0D9C    00AC    LD	0x2C,A
  0D9D    01AD    CLR	0x2D
147:              				}
  0D9E    2DA4    JP	0x5A4
148:              				else if(++workStep > 2)
  0D9F    3003    LDIA	0x3
  0DA0    0AC4    INCR	0x44
  0DA1    0244    SUBA	0x44
  0DA2    1803    SZB	0x3,0
149:              				{
150:              					workStep = 0;
  0DA3    01C4    CLR	0x44
151:              				}
152:              				if(power_ad < 3200 && workStep == 2)
  0DA4    300C    LDIA	0xC
  0DA5    0227    SUBA	0x27
  0DA6    3080    LDIA	0x80
  0DA7    1903    SZB	0x3,2
  0DA8    0226    SUBA	0x26
  0DA9    3002    LDIA	0x2
  0DAA    0644    XORA	0x44
  0DAB    1803    SZB	0x3,0
  0DAC    2DB1    JP	0x5B1
  0DAD    1903    SZB	0x3,2
153:              				{
154:              					workStep = 0;
  0DAE    01C4    CLR	0x44
155:              				}
156:              				if(workStep == 2)
  0DAF    3002    LDIA	0x2
  0DB0    0644    XORA	0x44
  0DB1    1D03    SNZB	0x3,2
  0DB2    2DB6    JP	0x5B6
157:              				{
158:              					shanshuoTime = 225;
  0DB3    30E1    LDIA	0xE1
  0DB4    00AC    LD	0x2C,A
  0DB5    2DB7    JP	0x5B7
159:              				}
160:              				else
161:              				{
162:              					shanshuoTime = 0;
  0DB6    01AC    CLR	0x2C
  0DB7    01AD    CLR	0x2D
163:              				}
164:              			}
165:              			if ((KeyOldFlag & 0x2) && (KeyFlag[0] & 0x2) && firstLock == 0) 
  0DB8    18B5    SZB	0x35,1
  0DB9    1CAE    SNZB	0x2E,1
  0DBA    2DD4    JP	0x5D4
  0DBB    086B    LD	A,0x6B
  0DBC    1D03    SNZB	0x3,2
  0DBD    2DD4    JP	0x5D4
166:              			{
167:              				//KEY2被按下
168:              				if(lowBatLock == 1)
  0DBE    0B3C    SZDECA	0x3C
  0DBF    2DC4    JP	0x5C4
169:              				{
170:              					shanshuoTime2 = 225;
  0DC0    30E1    LDIA	0xE1
  0DC1    00AA    LD	0x2A,A
  0DC2    01AB    CLR	0x2B
171:              				}
  0DC3    2DC9    JP	0x5C9
172:              				else if(++wuhuaFlag > 2)
  0DC4    3003    LDIA	0x3
  0DC5    0AC3    INCR	0x43
  0DC6    0243    SUBA	0x43
  0DC7    1803    SZB	0x3,0
173:              				{
174:              					wuhuaFlag = 0;
  0DC8    01C3    CLR	0x43
175:              				}
176:              				if(wuhuaFlag == 2)
  0DC9    3002    LDIA	0x2
  0DCA    0643    XORA	0x43
  0DCB    1D03    SNZB	0x3,2
  0DCC    2DD2    JP	0x5D2
177:              				{
178:              					shanshuoTime2 = 225;
  0DCD    30E1    LDIA	0xE1
  0DCE    00AA    LD	0x2A,A
  0DCF    01AB    CLR	0x2B
179:              					count10s = 0;
  0DD0    01C1    CLR	0x41
180:              				}
  0DD1    2DD4    JP	0x5D4
181:              				else
182:              				{
183:              					shanshuoTime2 = 0;
  0DD2    01AA    CLR	0x2A
  0DD3    01AB    CLR	0x2B
184:              				}
185:              			}
186:              			
187:              
188:              			KeyOldFlag = KeyFlag[0];
  0DD4    082E    LD	A,0x2E
  0DD5    00B5    LD	0x35,A
  0DD6    0008    RET
189:              		}
190:              	} 
191:              	else 
192:              	{
193:              		KeyOldFlag = 0;
  0DD7    01B5    CLR	0x35
  0DD8    0008    RET
194:              	}
195:              }
196:              
197:              
198:              /***********************************************************
199:              中断服务函数
200:              ***********************************************************/
201:              void interrupt Isr_Timer()
202:              {
203:              	if(TMR2IF)				//若只使能了一个中断源,可以略去判断
  0E55    1283    CLRB	0x3,5
  0E56    1303    CLRB	0x3,6
  0E57    1C8D    SNZB	0xD,1
  0E58    2E76    JP	0x676
204:              	{
205:              		TMR2IF = 0;
  0E59    108D    CLRB	0xD,1
206:              		if(firstTime > 0 || workStep > 0 || wuhuaFlag > 0 || chrgFlag > 0)
  0E5A    086C    LD	A,0x6C
  0E5B    1D03    SNZB	0x3,2
  0E5C    2E65    JP	0x665
  0E5D    0844    LD	A,0x44
  0E5E    1D03    SNZB	0x3,2
  0E5F    2E65    JP	0x665
  0E60    0843    LD	A,0x43
  0E61    1903    SZB	0x3,2
  0E62    083F    LD	A,0x3F
  0E63    1903    SZB	0x3,2
  0E64    2E67    JP	0x667
207:              		{
208:              			ledShow();
  0E65    2680    CALL	0x680
  0E66    158A    SETB	0xA,3
209:              		}
210:              		if(++MainTime >= 64)	//需根据你选择的触摸路数和触摸电容选择扫描一次按键的时间
  0E67    3040    LDIA	0x40
  0E68    1283    CLRB	0x3,5
  0E69    0AC6    INCR	0x46
  0E6A    0246    SUBA	0x46
  0E6B    1C03    SNZB	0x3,0
  0E6C    2E77    JP	0x677
211:              		{						//一般103电容，8路触摸，8M主频检测时间约4ms，故扫描一次的时间可选5ms
212:              			MainTime = 0;
  0E6D    01C6    CLR	0x46
213:              			B_MainLoop = 1;
  0E6E    1778    SETB	0x78,6
214:              			if(++count1s >= 250)
  0E6F    30FA    LDIA	0xFA
  0E70    0AC5    INCR	0x45
  0E71    0245    SUBA	0x45
  0E72    1C03    SNZB	0x3,0
  0E73    2E77    JP	0x677
215:              			{
216:              				count1s = 0;
  0E74    01C5    CLR	0x45
  0E75    2E77    JP	0x677
217:              			}
218:              		}
219:              	}
220:              	else
221:              	{
222:              		PIR1 = 0;
  0E76    018D    CLR	0xD
  0E77    0872    LD	A,0x72
  0E78    008A    LD	0xA,A
  0E79    0871    LD	A,0x71
  0E7A    0084    LD	0x4,A
  0E7B    0E70    SWAPA	0x70
  0E7C    0083    LD	0x3,A
  0E7D    0EFE    SWAPR	0x7E
  0E7E    0E7E    SWAPA	0x7E
  0E7F    0009    RETI
223:              	}
224:              	
225:              }
226:              
227:              void WorkSleep()
228:              {
229:              #if (0 != C_KEY_WAKEUP)
230:              	
231:              	
232:              	if(B_OnOff)time = 0;
  0041    1EF8    SNZB	0x78,5
  0042    2846    JP	0x46
  0043    1683    SETB	0x3,5
  0044    01BA    CLR	0x3A
  0045    01BB    CLR	0x3B
233:              	
234:              	if(++time >= 1000)
  0046    1683    SETB	0x3,5
  0047    0ABA    INCR	0x3A
  0048    1903    SZB	0x3,2
  0049    0ABB    INCR	0x3B
  004A    3003    LDIA	0x3
  004B    023B    SUBA	0x3B
  004C    30E8    LDIA	0xE8
  004D    1903    SZB	0x3,2
  004E    023A    SUBA	0x3A
  004F    1C03    SNZB	0x3,0
  0050    0008    RET
235:              	{
236:              		time = 0;
  0051    01BA    CLR	0x3A
  0052    01BB    CLR	0x3B
237:              		INTCON = 0;			//;关断ADC模块及中断使能；
  0053    018B    CLR	0xB
238:              		PIE1 = 0;
  0054    1283    CLRB	0x3,5
  0055    018E    CLR	0xE
239:              		PIE2 = 0;
  0056    1703    SETB	0x3,6
  0057    0190    CLR	0x10
240:              		PIR1 = 0;
  0058    1303    CLRB	0x3,6
  0059    018D    CLR	0xD
241:              		PIR2 = 0;
  005A    1703    SETB	0x3,6
  005B    018F    CLR	0xF
242:              		T2CON = 0;
  005C    1303    CLRB	0x3,6
  005D    0193    CLR	0x13
243:              		ADCON1 = 0;
  005E    1683    SETB	0x3,5
  005F    0196    CLR	0x16
244:              
245:              		//进入休眠前关掉所有功能模块,以降低休眠电流
246:              		ADCON0 = 0;
  0060    0195    CLR	0x15
247:              	
248:              		//进入休眠前,必须固定口线电平,这儿全部输出低电平,并关闭所有上拉电阻
249:              		TRISA &= 0xE4;
  0061    30E4    LDIA	0xE4
  0062    0585    ANDR	0x5
250:              		TRISB &= 0xEF;
  0063    1283    CLRB	0x3,5
  0064    1205    CLRB	0x5,4
251:              		PORTA = 0x00;
  0065    1683    SETB	0x3,5
  0066    0186    CLR	0x6
252:              		PORTB = 0x00;
  0067    1283    CLRB	0x3,5
  0068    0186    CLR	0x6
253:              		TRISC = 0;
  0069    1703    SETB	0x3,6
  006A    0185    CLR	0x5
254:              		PORTC = 0;
  006B    0186    CLR	0x6
255:              
256:              		TRISB0 =1;//输入
  006C    1303    CLRB	0x3,6
  006D    1405    SETB	0x5,0
257:              		//WPUB7 = 1;//上拉			
258:              		RBIF = 0;//清标志
  006E    100B    CLRB	0xB,0
259:              		RBIE = 1; //允许PB口电平变化中断
  006F    158B    SETB	0xB,3
260:              		IOCB0= 1;//允许PB0电平变化中断
  0070    1409    SETB	0x9,0
261:              		PORTB;//读一次PB口	
  0071    0806    LD	A,0x6
262:              /****如需要PA口中断唤醒，使能下列程序并按需修改****
263:              			TRISA0 =1;	//输入
264:              			WPUA0 = 1;	//上拉			
265:              			RAIF = 0;	//清标志
266:              			RAIE = 1;	//允许PA口电平变化中断
267:              			IOCA0 = 1;	//允许PA0电平变化中断
268:              			PEIE = 1;	//允许外设中断
269:              			PORTA;		//读一次PA口			
270:              ************************************/	
271:              
272:              		//进入休眠模式,触摸允许唤醒的按键后恢复正常工作
273:              		SystemEnterSleep();
  0072    20A9    CALL	0xA9
  0073    118A    CLRB	0xA,3
274:              		if(RAIF) 
  0074    1D8D    SNZB	0xD,3
  0075    2879    JP	0x79
275:              		{
276:              			RAIF = 0;
  0076    118D    CLRB	0xD,3
277:              			PORTA;
  0077    1683    SETB	0x3,5
  0078    0806    LD	A,0x6
278:              		}
279:              		//休眠被唤醒,重新配置中断等SFR,使系统进入正常工作
280:              		Refurbish_Sfr();
  0079    2403    CALL	0x403
  007A    118A    CLRB	0xA,3
281:              		ADCON0 = 0X41;
282:              		ADON = 1;
283:              		ADCON1 = 0x00;
  007B    2BED    JP	0x3ED
284:              	}
285:              #endif
286:              }
287:              
288:              
289:              /**********************************************************
290:              函数名称：AD_Sample
291:              函数功能：AD检测
292:              入口参数：adch - 检测通道
293:              出口参数：无
294:              备    注：采样通道需自行设置为输入口
295:              	      采样10次,取中间八次的平均值为采样结果存于adresult中
296:              
297:              	      adch 为输入AD通道 0-15，31
298:                           31  检测内部1.2V
299:              	
300:               		  adldo =5,开启内部LDO 2V 作为ADC 参考
301:               		  adldo =6,开启内部LDO 2.4V 作为ADC 参考
302:              		  adldo =7,开启内部LDO 3V 作为ADC 参考
303:               		  adldo =0,VDD 作为ADC 参考
304:               		  AD转换结果左对齐
305:               		  ADC参考电压从VDD切换到LDO时需要延时100us以上，才能进行AD转换
306:              **********************************************************/
307:              unsigned char ADC_Sample(unsigned char adch, unsigned char adldo) 
  04E0    00CA    LD	0x4A,A
308:              {
309:              	volatile unsigned long adsum = 0;
310:              	volatile unsigned int admin = 0, admax = 0;
  04E1    279A    CALL	0x79A
  04E2    118A    CLRB	0xA,3
311:              	volatile unsigned int ad_temp = 0;
  04E3    01D4    CLR	0x54
  04E4    01D5    CLR	0x55
312:              
313:              	if ((!LDO_EN) && (adldo & 0x04) ) 
  04E5    1683    SETB	0x3,5
  04E6    1D16    SNZB	0x16,2
  04E7    1D73    SNZB	0x73,2
  04E8    2CF1    JP	0x4F1
314:              	{
315:              								//如果AD参考从VDD换到内部LDO，需要延时100US以上
316:              		ADCON1 = adldo;			//左对齐,AD值取12位
  04E9    0873    LD	A,0x73
  04EA    0096    LD	0x16,A
317:              		__delay_us(100);		//IDE内置延时函数，延时100us
  04EB    3042    LDIA	0x42
  04EC    00F4    LD	0x74,A
  04ED    0BF4    SZDECR	0x74
  04EE    2CED    JP	0x4ED
  04EF    0000    NOP
318:              	} 
  04F0    2CF3    JP	0x4F3
319:              	else
320:              		ADCON1 = adldo;			//如果ADCON1.7(ADFM)=1为右对齐，,AD值取10位
  04F1    0873    LD	A,0x73
  04F2    0096    LD	0x16,A
321:              
322:              	if(adch & 0x10) 
  04F3    1283    CLRB	0x3,5
  04F4    1303    CLRB	0x3,6
  04F5    1E4A    SNZB	0x4A,4
  04F6    2CFC    JP	0x4FC
323:              	{
324:              		CHS4 = 1;
  04F7    1683    SETB	0x3,5
  04F8    1716    SETB	0x16,6
325:              		adch &= 0x0f;
  04F9    300F    LDIA	0xF
  04FA    1283    CLRB	0x3,5
  04FB    05CA    ANDR	0x4A
326:              	}
327:              	unsigned char i = 0;
328:              	for (i = 0; i < 10; i++) 
  04FC    01CB    CLR	0x4B
329:              	{
330:              		ADCON0 = (unsigned char)(0X41 | (adch << 2));	//16分频，如果主频为16M，则必须选16分频或以上
  04FD    084A    LD	A,0x4A
  04FE    00F4    LD	0x74,A
  04FF    3001    LDIA	0x1
  0500    1003    CLRB	0x3,0
  0501    0DF4    RLCR	0x74
  0502    3EFF    ADDIA	0xFF
  0503    1003    CLRB	0x3,0
  0504    1D03    SNZB	0x3,2
  0505    2D01    JP	0x501
  0506    0D74    RLCA	0x74
  0507    3841    ORIA	0x41
  0508    1683    SETB	0x3,5
  0509    0095    LD	0x15,A
  050A    0000    NOP
  050B    0000    NOP
  050C    0000    NOP
  050D    0000    NOP
331:              		asm("nop");
332:              		asm("nop");
333:              		asm("nop");
334:              		asm("nop");				//选择通道后需延时1uS以上
335:              		GODONE = 1;				//开始转换
  050E    1683    SETB	0x3,5
  050F    1303    CLRB	0x3,6
  0510    1495    SETB	0x15,1
336:              
337:              		unsigned char j = 0;
  0511    1283    CLRB	0x3,5
  0512    01C9    CLR	0x49
338:              		while (GODONE) 
  0513    1683    SETB	0x3,5
  0514    1C95    SNZB	0x15,1
  0515    2D1D    JP	0x51D
339:              		{
340:              			__delay_us(2);		//延时2us(编译器内置函数)
  0516    2D17    JP	0x517
  0517    2D18    JP	0x518
341:              
342:              			if (0 == (--j))		//延时0.5ms仍没有AD转换结束，跳出程序
  0518    1283    CLRB	0x3,5
  0519    1303    CLRB	0x3,6
  051A    0BC9    SZDECR	0x49
  051B    2D13    JP	0x513
343:              			return 0;
  051C    3400    RET	0x0
344:              		}
345:              
346:              		ad_temp = (unsigned int)((ADRESH << 4) + (ADRESL >> 4));	//计算12位AD值
  051D    0819    LD	A,0x19
  051E    1283    CLRB	0x3,5
  051F    00D4    LD	0x54,A
  0520    01D5    CLR	0x55
  0521    0ED4    SWAPR	0x54
  0522    0ED5    SWAPR	0x55
  0523    30F0    LDIA	0xF0
  0524    05D5    ANDR	0x55
  0525    0854    LD	A,0x54
  0526    390F    ANDIA	0xF
  0527    04D5    ORR	0x55
  0528    30F0    LDIA	0xF0
  0529    05D4    ANDR	0x54
  052A    1683    SETB	0x3,5
  052B    0E18    SWAPA	0x18
  052C    390F    ANDIA	0xF
  052D    1283    CLRB	0x3,5
  052E    07D4    ADDR	0x54
  052F    1803    SZB	0x3,0
  0530    0AD5    INCR	0x55
347:              
348:              		if (0 == admax) 
  0531    0852    LD	A,0x52
  0532    0453    ORA	0x53
  0533    1D03    SNZB	0x3,2
  0534    2D38    JP	0x538
349:              		{
350:              			admax = ad_temp;
  0535    27B3    CALL	0x7B3
  0536    118A    CLRB	0xA,3
  0537    2D4B    JP	0x54B
351:              			admin = ad_temp;
352:              		} 
353:              		else if (ad_temp > admax)
  0538    0855    LD	A,0x55
  0539    0253    SUBA	0x53
  053A    1D03    SNZB	0x3,2
  053B    2D3E    JP	0x53E
  053C    0854    LD	A,0x54
  053D    0252    SUBA	0x52
  053E    1803    SZB	0x3,0
  053F    2D43    JP	0x543
354:              			admax = ad_temp;				//AD采样最大值
  0540    27B3    CALL	0x7B3
  0541    118A    CLRB	0xA,3
  0542    2D4F    JP	0x54F
355:              		else if (ad_temp < admin)
  0543    0851    LD	A,0x51
  0544    0255    SUBA	0x55
  0545    1D03    SNZB	0x3,2
  0546    2D49    JP	0x549
  0547    0850    LD	A,0x50
  0548    0254    SUBA	0x54
  0549    1803    SZB	0x3,0
  054A    2D4F    JP	0x54F
356:              			admin = ad_temp;				//AD采样最小值
  054B    0855    LD	A,0x55
  054C    00D1    LD	0x51,A
  054D    0854    LD	A,0x54
  054E    00D0    LD	0x50,A
357:              
358:              		adsum += ad_temp;
  054F    0854    LD	A,0x54
  0550    00F4    LD	0x74,A
  0551    0855    LD	A,0x55
  0552    00F5    LD	0x75,A
  0553    01F6    CLR	0x76
  0554    01F7    CLR	0x77
  0555    0874    LD	A,0x74
  0556    07CC    ADDR	0x4C
  0557    0875    LD	A,0x75
  0558    1103    CLRB	0x3,2
  0559    1803    SZB	0x3,0
  055A    3E01    ADDIA	0x1
  055B    1D03    SNZB	0x3,2
  055C    07CD    ADDR	0x4D
  055D    0876    LD	A,0x76
  055E    1103    CLRB	0x3,2
  055F    1803    SZB	0x3,0
  0560    3E01    ADDIA	0x1
  0561    1D03    SNZB	0x3,2
  0562    07CE    ADDR	0x4E
  0563    0877    LD	A,0x77
  0564    1103    CLRB	0x3,2
  0565    1803    SZB	0x3,0
  0566    3E01    ADDIA	0x1
  0567    1D03    SNZB	0x3,2
  0568    07CF    ADDR	0x4F
  0569    300A    LDIA	0xA
  056A    0ACB    INCR	0x4B
  056B    024B    SUBA	0x4B
  056C    1C03    SNZB	0x3,0
  056D    2CFD    JP	0x4FD
359:              	}
360:              		adsum -= admax;
  056E    0852    LD	A,0x52
  056F    00F4    LD	0x74,A
  0570    0853    LD	A,0x53
  0571    278B    CALL	0x78B
  0572    118A    CLRB	0xA,3
  0573    1C03    SNZB	0x3,0
  0574    0F77    SZINCA	0x77
  0575    02CF    SUBR	0x4F
361:              		if (adsum >= admin)
  0576    0850    LD	A,0x50
  0577    00F4    LD	0x74,A
  0578    0851    LD	A,0x51
  0579    00F5    LD	0x75,A
  057A    01F6    CLR	0x76
  057B    01F7    CLR	0x77
  057C    0877    LD	A,0x77
  057D    024F    SUBA	0x4F
  057E    1D03    SNZB	0x3,2
  057F    2D8A    JP	0x58A
  0580    0876    LD	A,0x76
  0581    024E    SUBA	0x4E
  0582    1D03    SNZB	0x3,2
  0583    2D8A    JP	0x58A
  0584    0875    LD	A,0x75
  0585    024D    SUBA	0x4D
  0586    1D03    SNZB	0x3,2
  0587    2D8A    JP	0x58A
  0588    0874    LD	A,0x74
  0589    024C    SUBA	0x4C
  058A    1C03    SNZB	0x3,0
  058B    2D95    JP	0x595
362:              			adsum -= admin;
  058C    0850    LD	A,0x50
  058D    00F4    LD	0x74,A
  058E    0851    LD	A,0x51
  058F    278B    CALL	0x78B
  0590    118A    CLRB	0xA,3
  0591    1C03    SNZB	0x3,0
  0592    0F77    SZINCA	0x77
  0593    02CF    SUBR	0x4F
  0594    2D99    JP	0x599
363:              		else
364:              			adsum = 0;
  0595    01CC    CLR	0x4C
  0596    01CD    CLR	0x4D
  0597    01CE    CLR	0x4E
  0598    01CF    CLR	0x4F
365:              
366:              		adresult = adsum >> 3;		//8次平均值作为最终结果
  0599    084C    LD	A,0x4C
  059A    00F4    LD	0x74,A
  059B    084D    LD	A,0x4D
  059C    00F5    LD	0x75,A
  059D    084E    LD	A,0x4E
  059E    00F6    LD	0x76,A
  059F    084F    LD	A,0x4F
  05A0    00F7    LD	0x77,A
  05A1    3003    LDIA	0x3
  05A2    1003    CLRB	0x3,0
  05A3    0CF7    RRCR	0x77
  05A4    0CF6    RRCR	0x76
  05A5    0CF5    RRCR	0x75
  05A6    0CF4    RRCR	0x74
  05A7    3EFF    ADDIA	0xFF
  05A8    1D03    SNZB	0x3,2
  05A9    2DA2    JP	0x5A2
  05AA    0875    LD	A,0x75
  05AB    00C8    LD	0x48,A
  05AC    0874    LD	A,0x74
  05AD    00C7    LD	0x47,A
367:              
368:              		adsum = 0;
369:              		admin = 0;
370:              		admax = 0;
  05AE    279A    CALL	0x79A
371:              		return 0xA5;
  05AF    34A5    RET	0xA5
372:              		
373:              }
374:              
375:              void ledShow()
376:              {
377:              
378:              	if(++ledCnt > 19)
  0E80    3014    LDIA	0x14
  0E81    0ABB    INCR	0x3B
  0E82    023B    SUBA	0x3B
  0E83    1803    SZB	0x3,0
379:              	{
380:              		ledCnt = 0;
  0E84    01BB    CLR	0x3B
381:              	
382:              	}
383:              	PORTA &= 0xE4;
384:              	PORTB &= 0xEF;
385:              	TRISA |= 0x1B;
386:              	TRISB |= 0x10;
  0E85    118A    CLRB	0xA,3
  0E86    27F3    CALL	0x7F3
  0E87    158A    SETB	0xA,3
387:              	switch(ledCnt)
  0E88    2F18    JP	0x718
388:              	{
389:              		case 0:
390:              		break;
391:              		case 1:
392:              		if(showNumShi & 0x01)
  0E89    1C6E    SNZB	0x6E,0
  0E8A    0008    RET
393:              		{
394:              			LED1_OUT;
  0E8B    1683    SETB	0x3,5
  0E8C    1005    CLRB	0x5,0
395:              			LED2_OUT;
  0E8D    1205    CLRB	0x5,4
396:              			LED2 = 1;
  0E8E    1606    SETB	0x6,4
  0E8F    0008    RET
397:              		}
398:              		break;
399:              		case 2:
400:              		if(showNumShi & 0x02)
  0E90    1CEE    SNZB	0x6E,1
  0E91    0008    RET
401:              		{
402:              			LED1_OUT;
  0E92    1683    SETB	0x3,5
  0E93    1005    CLRB	0x5,0
403:              			LED3_OUT;
  0E94    1185    CLRB	0x5,3
404:              			LED3 = 1;
  0E95    1586    SETB	0x6,3
  0E96    0008    RET
405:              		}
406:              		break;
407:              		case 3:
408:              		if(showNumShi & 0x04)
  0E97    1D6E    SNZB	0x6E,2
  0E98    0008    RET
409:              		{
410:              			LED1_OUT;
  0E99    1683    SETB	0x3,5
  0E9A    1005    CLRB	0x5,0
411:              			LED4_OUT;
  0E9B    1085    CLRB	0x5,1
412:              			LED4 = 1;
  0E9C    1486    SETB	0x6,1
  0E9D    0008    RET
413:              		}
414:              		break;
415:              		case 4:
416:              		if(showNumShi & 0x08)
  0E9E    1DEE    SNZB	0x6E,3
  0E9F    0008    RET
417:              		{
418:              			LED1_OUT;
  0EA0    1683    SETB	0x3,5
  0EA1    1005    CLRB	0x5,0
419:              			LED5_OUT;
420:              			LED5 = 1;
  0EA2    2F25    JP	0x725
421:              		}
422:              		break;
423:              		case 5:
424:              		if(showNumShi & 0x10)
  0EA3    1E6E    SNZB	0x6E,4
  0EA4    0008    RET
425:              		{
426:              			LED2_OUT;
  0EA5    1683    SETB	0x3,5
  0EA6    1205    CLRB	0x5,4
427:              			LED1_OUT;
  0EA7    1005    CLRB	0x5,0
428:              			LED1 = 1;
  0EA8    1406    SETB	0x6,0
  0EA9    0008    RET
429:              		}
430:              		break;
431:              		case 6:
432:              		if(showNumShi & 0x20)
  0EAA    1EEE    SNZB	0x6E,5
  0EAB    0008    RET
433:              		{
434:              			LED2_OUT;
  0EAC    1683    SETB	0x3,5
  0EAD    1205    CLRB	0x5,4
435:              			LED3_OUT;
  0EAE    1185    CLRB	0x5,3
436:              			LED3 = 1;
  0EAF    1586    SETB	0x6,3
  0EB0    0008    RET
437:              		}
438:              		break;
439:              		case 7:
440:              		if(showNumShi & 0x40)
  0EB1    1F6E    SNZB	0x6E,6
  0EB2    0008    RET
441:              		{
442:              			LED2_OUT;
  0EB3    1683    SETB	0x3,5
  0EB4    1205    CLRB	0x5,4
443:              			LED4_OUT;
  0EB5    1085    CLRB	0x5,1
444:              			LED4 = 1;
  0EB6    1486    SETB	0x6,1
  0EB7    0008    RET
445:              		}
446:              		break;
447:              		case 8:
448:              		if(showNumGe & 0x01)
  0EB8    1C6D    SNZB	0x6D,0
  0EB9    0008    RET
449:              		{
450:              			LED2_OUT;
  0EBA    1683    SETB	0x3,5
  0EBB    1205    CLRB	0x5,4
451:              			LED5_OUT;
452:              			LED5 = 1;
  0EBC    2F25    JP	0x725
453:              		}
454:              		break;
455:              		case 9:
456:              		if(showNumGe & 0x02)
  0EBD    1CED    SNZB	0x6D,1
  0EBE    0008    RET
457:              		{
458:              			LED3_OUT;
  0EBF    1683    SETB	0x3,5
  0EC0    1185    CLRB	0x5,3
459:              			LED1_OUT;
  0EC1    1005    CLRB	0x5,0
460:              			LED1 = 1;
  0EC2    1406    SETB	0x6,0
  0EC3    0008    RET
461:              		}
462:              		break;
463:              		case 10:
464:              		if(showNumGe & 0x04)
  0EC4    1D6D    SNZB	0x6D,2
  0EC5    0008    RET
465:              		{
466:              			LED3_OUT;
  0EC6    1683    SETB	0x3,5
  0EC7    1185    CLRB	0x5,3
467:              			LED2_OUT;
  0EC8    1205    CLRB	0x5,4
468:              			LED2 = 1;
  0EC9    1606    SETB	0x6,4
  0ECA    0008    RET
469:              		}
470:              		break;
471:              		case 11:
472:              		if(showNumGe & 0x08)
  0ECB    1DED    SNZB	0x6D,3
  0ECC    0008    RET
473:              		{
474:              			LED3_OUT;
  0ECD    1683    SETB	0x3,5
  0ECE    1185    CLRB	0x5,3
475:              			LED4_OUT;
  0ECF    1085    CLRB	0x5,1
476:              			LED4 = 1;
  0ED0    1486    SETB	0x6,1
  0ED1    0008    RET
477:              		}
478:              		break;
479:              		case 12:
480:              		if(showNumGe & 0x10)
  0ED2    1E6D    SNZB	0x6D,4
  0ED3    0008    RET
481:              		{
482:              			LED3_OUT;
  0ED4    1683    SETB	0x3,5
  0ED5    1185    CLRB	0x5,3
483:              			LED5_OUT;
484:              			LED5 = 1;
  0ED6    2F25    JP	0x725
485:              		}
486:              		break;
487:              		case 13:
488:              		if(showNumGe & 0x20)
  0ED7    1EED    SNZB	0x6D,5
  0ED8    0008    RET
489:              		{
490:              			LED4_OUT;
  0ED9    1683    SETB	0x3,5
  0EDA    1085    CLRB	0x5,1
491:              			LED1_OUT;
  0EDB    1005    CLRB	0x5,0
492:              			LED1 = 1;
  0EDC    1406    SETB	0x6,0
  0EDD    0008    RET
493:              		}
494:              		break;
495:              		case 14:
496:              		if(showNumGe & 0x40)
  0EDE    1F6D    SNZB	0x6D,6
  0EDF    0008    RET
497:              		{
498:              			LED4_OUT;
  0EE0    1683    SETB	0x3,5
  0EE1    1085    CLRB	0x5,1
499:              			LED2_OUT;
  0EE2    1205    CLRB	0x5,4
500:              			LED2 = 1;
  0EE3    1606    SETB	0x6,4
  0EE4    0008    RET
501:              		}
502:              		break;
503:              		case 15:
504:              		if(firstTime || showNumGe || showNumShi)
  0EE5    086C    LD	A,0x6C
  0EE6    1D03    SNZB	0x3,2
  0EE7    2EED    JP	0x6ED
  0EE8    086D    LD	A,0x6D
  0EE9    1903    SZB	0x3,2
  0EEA    086E    LD	A,0x6E
  0EEB    1903    SZB	0x3,2
  0EEC    0008    RET
505:              		{
506:              			LED4_OUT;
  0EED    1683    SETB	0x3,5
  0EEE    1085    CLRB	0x5,1
507:              			LED3_OUT;
  0EEF    1185    CLRB	0x5,3
508:              			LED3 = 1;
  0EF0    1586    SETB	0x6,3
  0EF1    0008    RET
509:              		}
510:              		break;
511:              		case 16:
512:              		if(firstTime > 0 || wuhuaFlag > 0)
  0EF2    086C    LD	A,0x6C
  0EF3    1903    SZB	0x3,2
  0EF4    0843    LD	A,0x43
  0EF5    1903    SZB	0x3,2
  0EF6    0008    RET
513:              		{
514:              			LED4_OUT;
  0EF7    1683    SETB	0x3,5
  0EF8    1085    CLRB	0x5,1
515:              			LED5_OUT;
516:              			LED5 = 1;
  0EF9    2F25    JP	0x725
517:              		}
518:              		break;
519:              		case 17:
520:              		if(firstTime > 0 ||workStep > 0)
  0EFA    086C    LD	A,0x6C
  0EFB    1903    SZB	0x3,2
  0EFC    0844    LD	A,0x44
  0EFD    1903    SZB	0x3,2
  0EFE    0008    RET
521:              		{
522:              			LED5_OUT;
  0EFF    1205    CLRB	0x5,4
523:              			LED1_OUT;
  0F00    1683    SETB	0x3,5
  0F01    1005    CLRB	0x5,0
524:              			LED1 = 1;
  0F02    1406    SETB	0x6,0
  0F03    0008    RET
525:              		}
526:              		break;
527:              		case 18:
528:              		if(firstTime > 0 ||fanKeyFlag > 0)
  0F04    086C    LD	A,0x6C
  0F05    1903    SZB	0x3,2
  0F06    083A    LD	A,0x3A
  0F07    1903    SZB	0x3,2
  0F08    0008    RET
529:              		{
530:              			LED5_OUT;
  0F09    1205    CLRB	0x5,4
531:              			LED2_OUT;
  0F0A    1683    SETB	0x3,5
  0F0B    1205    CLRB	0x5,4
532:              			LED2 = 1;
  0F0C    1606    SETB	0x6,4
  0F0D    0008    RET
533:              		}
534:              		break;
535:              		case 19:
536:              		if(firstTime > 0 ||wuhuaKeyFlag > 0)
  0F0E    086C    LD	A,0x6C
  0F0F    1903    SZB	0x3,2
  0F10    0839    LD	A,0x39
  0F11    1903    SZB	0x3,2
  0F12    0008    RET
537:              		{
538:              			LED5_OUT;
  0F13    1205    CLRB	0x5,4
539:              			LED4_OUT;
  0F14    1683    SETB	0x3,5
  0F15    1085    CLRB	0x5,1
540:              			LED4 = 1;
  0F16    1486    SETB	0x6,1
  0F17    0008    RET
  0F18    083B    LD	A,0x3B
  0F19    0084    LD	0x4,A
  0F1A    3014    LDIA	0x14
  0F1B    0204    SUBA	0x4
  0F1C    1803    SZB	0x3,0
  0F1D    0008    RET
  0F1E    3008    LDIA	0x8
  0F1F    008A    LD	0xA,A
  0F20    1003    CLRB	0x3,0
  0F21    0D04    RLCA	0x4
  0F22    3E00    ADDIA	0x0
  0F23    0082    LD	0x2,A
  0F24    0008    RET
541:              		}
542:              		break;
543:              		default:
544:              		break;
545:              	}
546:              
547:              }
548:              
549:              void showBatLed()
550:              {
551:              	showNumShi = numArray[showBatStep/10];
  0E0A    300A    LDIA	0xA
  0E0B    00F3    LD	0x73,A
  0E0C    0838    LD	A,0x38
  0E0D    261E    CALL	0x61E
  0E0E    3E01    ADDIA	0x1
  0E0F    0084    LD	0x4,A
  0E10    158A    SETB	0xA,3
  0E11    2028    CALL	0x28
  0E12    158A    SETB	0xA,3
  0E13    00EE    LD	0x6E,A
552:              	showNumGe = numArray[showBatStep%10];
  0E14    300A    LDIA	0xA
  0E15    00F3    LD	0x73,A
  0E16    0838    LD	A,0x38
  0E17    2639    CALL	0x639
  0E18    3E01    ADDIA	0x1
  0E19    0084    LD	0x4,A
  0E1A    158A    SETB	0xA,3
  0E1B    2028    CALL	0x28
  0E1C    00ED    LD	0x6D,A
  0E1D    0008    RET
553:              }
554:              
555:              void setBatStep()
556:              {
557:              	if(lowBatLock == 1)
  0F29    1283    CLRB	0x3,5
  0F2A    0B3C    SZDECA	0x3C
  0F2B    2F2F    JP	0x72F
558:              	{
559:              		showBatStep = 0;
  0F2C    01B8    CLR	0x38
560:              		curBatStep = 0;
  0F2D    01B7    CLR	0x37
561:              	}
  0F2E    0008    RET
562:              	else if(power_ad < 2800)
  0F2F    300A    LDIA	0xA
  0F30    0227    SUBA	0x27
  0F31    30F0    LDIA	0xF0
  0F32    1903    SZB	0x3,2
  0F33    0226    SUBA	0x26
  0F34    1803    SZB	0x3,0
  0F35    2F4C    JP	0x74C
563:              	{
564:              		if(count10s == 0 && count1s == 0)
  0F36    0841    LD	A,0x41
  0F37    1D03    SNZB	0x3,2
  0F38    2F49    JP	0x749
  0F39    0845    LD	A,0x45
  0F3A    1D03    SNZB	0x3,2
  0F3B    2F49    JP	0x749
565:              		{
566:              			if(showBatStep > 1)
  0F3C    3002    LDIA	0x2
  0F3D    0238    SUBA	0x38
  0F3E    1C03    SNZB	0x3,0
  0F3F    2F45    JP	0x745
567:              			{
568:              				if(chrgFlag == 0)
  0F40    083F    LD	A,0x3F
  0F41    1D03    SNZB	0x3,2
  0F42    2F47    JP	0x747
569:              					showBatStep--;
  0F43    03B8    DECR	0x38
  0F44    2F47    JP	0x747
570:              			}
571:              			else
572:              			{
573:              				showBatStep = 1;
  0F45    01B8    CLR	0x38
  0F46    0AB8    INCR	0x38
574:              			}
575:              			curBatStep = 1;
  0F47    01B7    CLR	0x37
  0F48    0AB7    INCR	0x37
576:              		}
577:              		curBatStep = 1;
  0F49    01B7    CLR	0x37
  0F4A    0AB7    INCR	0x37
578:              	}
  0F4B    0008    RET
579:              	else
580:              	{
581:              		if(power_ad < 3600)
  0F4C    300E    LDIA	0xE
  0F4D    0227    SUBA	0x27
  0F4E    3010    LDIA	0x10
  0F4F    1903    SZB	0x3,2
  0F50    0226    SUBA	0x26
  0F51    1803    SZB	0x3,0
  0F52    2F62    JP	0x762
582:              		{
583:              			curBatStep = (power_ad - 2800)/80;
  0F53    3050    LDIA	0x50
  0F54    00F3    LD	0x73,A
  0F55    01F4    CLR	0x74
  0F56    0826    LD	A,0x26
  0F57    3E10    ADDIA	0x10
  0F58    00F5    LD	0x75,A
  0F59    0827    LD	A,0x27
  0F5A    1803    SZB	0x3,0
  0F5B    3E01    ADDIA	0x1
  0F5C    3EF5    ADDIA	0xF5
  0F5D    00F6    LD	0x76,A
  0F5E    27D6    CALL	0x7D6
  0F5F    158A    SETB	0xA,3
  0F60    0873    LD	A,0x73
  0F61    2F71    JP	0x771
584:              		}
585:              		else
586:              		{
587:              			curBatStep = 20 + ((power_ad - 3600)/5);
  0F62    3005    LDIA	0x5
  0F63    00F3    LD	0x73,A
  0F64    01F4    CLR	0x74
  0F65    0826    LD	A,0x26
  0F66    3EF0    ADDIA	0xF0
  0F67    00F5    LD	0x75,A
  0F68    0827    LD	A,0x27
  0F69    1803    SZB	0x3,0
  0F6A    3E01    ADDIA	0x1
  0F6B    3EF1    ADDIA	0xF1
  0F6C    00F6    LD	0x76,A
  0F6D    27D6    CALL	0x7D6
  0F6E    158A    SETB	0xA,3
  0F6F    0873    LD	A,0x73
  0F70    3E14    ADDIA	0x14
  0F71    00B7    LD	0x37,A
588:              		}
589:              		if(curBatStep > 99)
  0F72    3064    LDIA	0x64
  0F73    0237    SUBA	0x37
  0F74    1C03    SNZB	0x3,0
  0F75    2F78    JP	0x778
590:              		{
591:              			curBatStep = 99;
  0F76    3063    LDIA	0x63
  0F77    00B7    LD	0x37,A
592:              		}
593:              
594:              		if(chrgFlag)
  0F78    083F    LD	A,0x3F
  0F79    1903    SZB	0x3,2
  0F7A    2FAF    JP	0x7AF
595:              		{
596:              			if(chrgFullFlag && showBatStep < 99)
  0F7B    083E    LD	A,0x3E
  0F7C    1903    SZB	0x3,2
  0F7D    2F92    JP	0x792
  0F7E    3063    LDIA	0x63
  0F7F    0238    SUBA	0x38
  0F80    1803    SZB	0x3,0
  0F81    2F92    JP	0x792
597:              			{
598:              				if(++count15s >= 7500)
  0F82    1683    SETB	0x3,5
  0F83    0AB4    INCR	0x34
  0F84    1903    SZB	0x3,2
  0F85    0AB5    INCR	0x35
  0F86    301D    LDIA	0x1D
  0F87    0235    SUBA	0x35
  0F88    304C    LDIA	0x4C
  0F89    1903    SZB	0x3,2
  0F8A    0234    SUBA	0x34
  0F8B    1C03    SNZB	0x3,0
  0F8C    2F95    JP	0x795
599:              				{
600:              					count15s = 0;
  0F8D    01B4    CLR	0x34
  0F8E    01B5    CLR	0x35
601:              					showBatStep++;
  0F8F    1283    CLRB	0x3,5
  0F90    0AB8    INCR	0x38
  0F91    2F95    JP	0x795
602:              				}
603:              			}
604:              			else
605:              			{
606:              				count15s = 0;
  0F92    1683    SETB	0x3,5
  0F93    01B4    CLR	0x34
  0F94    01B5    CLR	0x35
607:              			}
608:              			if(curBatStep > showBatStep)
  0F95    1283    CLRB	0x3,5
  0F96    0837    LD	A,0x37
  0F97    0238    SUBA	0x38
  0F98    1803    SZB	0x3,0
  0F99    2FAC    JP	0x7AC
609:              			{
610:              				if(++count30s >= 15000 && showBatStep < 99)	//60s
  0F9A    0AA8    INCR	0x28
  0F9B    1903    SZB	0x3,2
  0F9C    0AA9    INCR	0x29
  0F9D    303A    LDIA	0x3A
  0F9E    0229    SUBA	0x29
  0F9F    3098    LDIA	0x98
  0FA0    1903    SZB	0x3,2
  0FA1    0228    SUBA	0x28
  0FA2    1C03    SNZB	0x3,0
  0FA3    0008    RET
  0FA4    3063    LDIA	0x63
  0FA5    0238    SUBA	0x38
  0FA6    1803    SZB	0x3,0
  0FA7    0008    RET
611:              				{	
612:              					count30s = 0;
  0FA8    01A8    CLR	0x28
  0FA9    01A9    CLR	0x29
613:              					showBatStep++;
  0FAA    0AB8    INCR	0x38
  0FAB    0008    RET
614:              				}
615:              				
616:              			}
617:              			else
618:              			{
619:              				count30s = 0;
  0FAC    01A8    CLR	0x28
  0FAD    01A9    CLR	0x29
  0FAE    0008    RET
620:              			}
621:              		}
622:              		else
623:              		{
624:              			u16t tempSubBatTime = 15000;
  0FAF    3098    LDIA	0x98
  0FB0    00CC    LD	0x4C,A
  0FB1    303A    LDIA	0x3A
  0FB2    00CD    LD	0x4D,A
625:              			if(showBatStep < 40)
  0FB3    3028    LDIA	0x28
  0FB4    0238    SUBA	0x38
  0FB5    1803    SZB	0x3,0
  0FB6    2FBB    JP	0x7BB
626:              			{
627:              				tempSubBatTime = 8000;
  0FB7    3040    LDIA	0x40
  0FB8    00CC    LD	0x4C,A
  0FB9    301F    LDIA	0x1F
  0FBA    00CD    LD	0x4D,A
628:              			}
629:              			if(curBatStep < showBatStep && showBatStep > 1)
  0FBB    0838    LD	A,0x38
  0FBC    0237    SUBA	0x37
  0FBD    1803    SZB	0x3,0
  0FBE    2FAC    JP	0x7AC
  0FBF    3002    LDIA	0x2
  0FC0    0238    SUBA	0x38
  0FC1    1C03    SNZB	0x3,0
  0FC2    2FAC    JP	0x7AC
630:              			{
631:              				if(++count30s >= tempSubBatTime && showBatStep > 1)	//60s
  0FC3    0AA8    INCR	0x28
  0FC4    1903    SZB	0x3,2
  0FC5    0AA9    INCR	0x29
  0FC6    084D    LD	A,0x4D
  0FC7    0229    SUBA	0x29
  0FC8    1D03    SNZB	0x3,2
  0FC9    2FCC    JP	0x7CC
  0FCA    084C    LD	A,0x4C
  0FCB    0228    SUBA	0x28
  0FCC    1C03    SNZB	0x3,0
  0FCD    0008    RET
  0FCE    3002    LDIA	0x2
  0FCF    0238    SUBA	0x38
  0FD0    1C03    SNZB	0x3,0
  0FD1    0008    RET
632:              				{	
633:              					count30s = 0;
  0FD2    01A8    CLR	0x28
  0FD3    01A9    CLR	0x29
634:              					showBatStep--;
  0FD4    03B8    DECR	0x38
  0FD5    0008    RET
635:              				}
636:              			}
637:              			else
638:              			{
639:              				count30s = 0;
640:              			}
641:              		}
642:              		
643:              	}
644:              }
645:              
646:              void chrgCtr()
647:              {
648:              	if(PORTB & 0x01)
  0DD9    1283    CLRB	0x3,5
  0DDA    1303    CLRB	0x3,6
  0DDB    1C06    SNZB	0x6,0
  0DDC    2DF0    JP	0x5F0
649:              	{
650:              		chrgFlag = 1;
  0DDD    01BF    CLR	0x3F
  0DDE    0ABF    INCR	0x3F
651:              		firstLock = 0;
  0DDF    01EB    CLR	0x6B
652:              		lowBatLock = 0;
  0DE0    01BC    CLR	0x3C
653:              		showBatLed();
  0DE1    260A    CALL	0x60A
  0DE2    158A    SETB	0xA,3
654:              		if(PORTB & 0x02)
  0DE3    1C86    SNZB	0x6,1
  0DE4    2DEE    JP	0x5EE
655:              		{
656:              			if(++chrgFullTime > 200)
  0DE5    30C9    LDIA	0xC9
  0DE6    0ABD    INCR	0x3D
  0DE7    023D    SUBA	0x3D
  0DE8    1C03    SNZB	0x3,0
  0DE9    0008    RET
657:              			{
658:              				chrgFullTime = 0;
  0DEA    01BD    CLR	0x3D
659:              				chrgFullFlag = 1;
  0DEB    01BE    CLR	0x3E
  0DEC    0ABE    INCR	0x3E
  0DED    0008    RET
660:              			}
661:              		}
662:              		else
663:              		{
664:              			chrgFullTime = 0;
  0DEE    01BD    CLR	0x3D
  0DEF    0008    RET
665:              		}
666:              
667:              	}
668:              	else
669:              	{
670:              		chrgFlag = 0;
  0DF0    01BF    CLR	0x3F
671:              		chrgFullTime = 0;
  0DF1    01BD    CLR	0x3D
672:              		chrgFullFlag = 0;
  0DF2    01BE    CLR	0x3E
673:              		
674:              		if(firstTime == 0)
  0DF3    086C    LD	A,0x6C
  0DF4    1D03    SNZB	0x3,2
  0DF5    2E00    JP	0x600
675:              		{
676:              			if(workStep == 0 && wuhuaFlag == 0)
  0DF6    0844    LD	A,0x44
  0DF7    1D03    SNZB	0x3,2
  0DF8    2DFF    JP	0x5FF
  0DF9    0843    LD	A,0x43
  0DFA    1D03    SNZB	0x3,2
  0DFB    2DFF    JP	0x5FF
677:              			{
678:              				showNumShi = 0;
  0DFC    01EE    CLR	0x6E
679:              				showNumGe = 0;
  0DFD    01ED    CLR	0x6D
680:              			}
  0DFE    0008    RET
681:              			else
682:              			{
683:              				showBatLed();
  0DFF    2E0A    JP	0x60A
684:              			}
685:              		}
686:              		else
687:              		{
688:              			if(showBatStep < curBatStep)
  0E00    0837    LD	A,0x37
  0E01    0238    SUBA	0x38
  0E02    1803    SZB	0x3,0
  0E03    2E06    JP	0x606
689:              			{
690:              				showBatStep = curBatStep;
  0E04    0837    LD	A,0x37
  0E05    00B8    LD	0x38,A
691:              			}
692:              			showNumShi = 0x7F;
  0E06    307F    LDIA	0x7F
  0E07    00EE    LD	0x6E,A
693:              			showNumGe = 0x7F;
  0E08    00ED    LD	0x6D,A
  0E09    0008    RET
694:              		}
695:              	}
696:              }
697:              
698:              void keyLedCtr()
699:              {
700:              	if(shanshuoTime > 0)
  06EC    082C    LD	A,0x2C
  06ED    042D    ORA	0x2D
  06EE    1903    SZB	0x3,2
  06EF    2F08    JP	0x708
701:              	{
702:              		shanshuoTime--;
  06F0    3001    LDIA	0x1
  06F1    02AC    SUBR	0x2C
  06F2    3000    LDIA	0x0
  06F3    1C03    SNZB	0x3,0
  06F4    03AD    DECR	0x2D
  06F5    02AD    SUBR	0x2D
703:              		if((shanshuoTime % 75) < 37)
  06F6    304B    LDIA	0x4B
  06F7    00F3    LD	0x73,A
  06F8    01F4    CLR	0x74
  06F9    082D    LD	A,0x2D
  06FA    00F6    LD	0x76,A
  06FB    082C    LD	A,0x2C
  06FC    00F5    LD	0x75,A
  06FD    2730    CALL	0x730
  06FE    118A    CLRB	0xA,3
  06FF    3000    LDIA	0x0
  0700    0274    SUBA	0x74
  0701    3025    LDIA	0x25
  0702    1903    SZB	0x3,2
  0703    0273    SUBA	0x73
  0704    1803    SZB	0x3,0
  0705    2F0B    JP	0x70B
704:              		{
705:              			fanKeyFlag = 0;
  0706    01BA    CLR	0x3A
706:              		}
  0707    2F0D    JP	0x70D
707:              		else
708:              		{
709:              			fanKeyFlag = 1;
  070B    01BA    CLR	0x3A
  070C    0ABA    INCR	0x3A
710:              		}
711:              	}
712:              	else if(workStep > 0)
  0708    0844    LD	A,0x44
  0709    1903    SZB	0x3,2
  070A    2F06    JP	0x706
713:              	{
714:              		fanKeyFlag = 1;
715:              	}
716:              	else
717:              	{
718:              		fanKeyFlag = 0;
719:              	}
720:              	
721:              	if(shanshuoTime2 > 0)
  070D    082A    LD	A,0x2A
  070E    042B    ORA	0x2B
  070F    1903    SZB	0x3,2
  0710    2F2C    JP	0x72C
722:              	{
723:              		shanshuoTime2--;
  0711    3001    LDIA	0x1
  0712    02AA    SUBR	0x2A
  0713    3000    LDIA	0x0
  0714    1C03    SNZB	0x3,0
  0715    03AB    DECR	0x2B
  0716    02AB    SUBR	0x2B
724:              		if((shanshuoTime2 % 75) < 37)
  0717    304B    LDIA	0x4B
  0718    00F3    LD	0x73,A
  0719    01F4    CLR	0x74
  071A    082B    LD	A,0x2B
  071B    00F6    LD	0x76,A
  071C    082A    LD	A,0x2A
  071D    00F5    LD	0x75,A
  071E    2730    CALL	0x730
  071F    118A    CLRB	0xA,3
  0720    3000    LDIA	0x0
  0721    0274    SUBA	0x74
  0722    3025    LDIA	0x25
  0723    1903    SZB	0x3,2
  0724    0273    SUBA	0x73
  0725    1803    SZB	0x3,0
  0726    2F29    JP	0x729
725:              		{
726:              			wuhuaKeyFlag = 0;
  0727    01B9    CLR	0x39
727:              		}
  0728    0008    RET
728:              		else
729:              		{
730:              			wuhuaKeyFlag = 1;
  0729    01B9    CLR	0x39
  072A    0AB9    INCR	0x39
  072B    0008    RET
731:              		}
732:              	}
733:              	else if(wuhuaFlag > 0)
  072C    0843    LD	A,0x43
  072D    1D03    SNZB	0x3,2
  072E    2F29    JP	0x729
  072F    2F27    JP	0x727
734:              	{
735:              		wuhuaKeyFlag = 1;
736:              	}
737:              	else
738:              	{
739:              		wuhuaKeyFlag = 0;
740:              	}
741:              	
742:              }
743:              
744:              void pwmInit()
745:              {
746:              
747:              	PWMTH = 0x00;
  077A    0198    CLR	0x18
748:              	PWMTL = 73;
  077B    3049    LDIA	0x49
  077C    0097    LD	0x17,A
749:              	PWMD01H = 0x00;
  077D    019E    CLR	0x1E
750:              	PWMD0L = 32;
  077E    3020    LDIA	0x20
  077F    0099    LD	0x19,A
751:              	PWMCON1 = 0x40;
  0780    3040    LDIA	0x40
  0781    0096    LD	0x16,A
752:              	PWMCON2 = 0x00;
  0782    019D    CLR	0x1D
753:              	PWMCON0 |= 0x21;
  0783    3021    LDIA	0x21
  0784    0495    ORR	0x15
  0785    0008    RET
754:              }
755:              
756:              void pwmStop()
757:              {
758:              	PWMD0L = 0;
  0786    0199    CLR	0x19
759:              	PWMCON0 &= 0xFE;
  0787    1015    CLRB	0x15,0
760:              	PORTA &= 0xDF;
  0788    1683    SETB	0x3,5
  0789    1286    CLRB	0x6,5
  078A    0008    RET
761:              }
762:              
763:              void fanInit()
764:              {
765:              
766:              	PWMTH = 0x00;
  0754    0198    CLR	0x18
767:              	PWMTL = 73;
  0755    3049    LDIA	0x49
  0756    0097    LD	0x17,A
768:              	PWMD01H = 0x00;
  0757    019E    CLR	0x1E
769:              	PWMD1L = fanDuty;
  0758    0842    LD	A,0x42
  0759    009A    LD	0x1A,A
770:              	PWMCON1 = 0x40;
  075A    3040    LDIA	0x40
  075B    0096    LD	0x16,A
771:              	PWMCON2 = 0x00;
  075C    019D    CLR	0x1D
772:              	PWMCON0 |= 0x22;
  075D    3022    LDIA	0x22
  075E    0495    ORR	0x15
  075F    0008    RET
773:              }
774:              
775:              void fanStop()
776:              {
777:              	PWMD1L = 0;
  0760    019A    CLR	0x1A
778:              	PWMCON0 &= 0xFD;
  0761    1095    CLRB	0x15,1
779:              	PORTB &= 0x7F;
  0762    1386    CLRB	0x6,7
  0763    0008    RET
780:              }
781:              
782:              void fanCtr()
783:              {
784:              	if(workStep > 0)
  0473    0844    LD	A,0x44
  0474    1903    SZB	0x3,2
  0475    2CDB    JP	0x4DB
785:              	{
786:              		PORTA |= 0x04;
  0476    1683    SETB	0x3,5
  0477    1506    SETB	0x6,2
787:              		u8t maxFanValue = 52;
  0478    3034    LDIA	0x34
  0479    1283    CLRB	0x3,5
  047A    00D6    LD	0x56,A
788:              		if(workStep == 1 || power_ad < 3150)
  047B    0344    DECA	0x44
  047C    1903    SZB	0x3,2
  047D    2C85    JP	0x485
  047E    300C    LDIA	0xC
  047F    0227    SUBA	0x27
  0480    304E    LDIA	0x4E
  0481    1903    SZB	0x3,2
  0482    0226    SUBA	0x26
  0483    1803    SZB	0x3,0
  0484    2C87    JP	0x487
789:              		{	
790:              			maxFanValue = 38;
  0485    3026    LDIA	0x26
  0486    00D6    LD	0x56,A
  0487    300D    LDIA	0xD
791:              		}
792:              		test_adc = ADC_Sample(13, 0);
  0488    01F3    CLR	0x73
  0489    24E0    CALL	0x4E0
  048A    118A    CLRB	0xA,3
  048B    00B6    LD	0x36,A
793:              		if (0xA5 == test_adc)
  048C    30A5    LDIA	0xA5
  048D    0636    XORA	0x36
  048E    1D03    SNZB	0x3,2
  048F    2CBA    JP	0x4BA
794:              		{
795:              			volatile unsigned long fan_temp;
796:              			if(power_ad > 0)
  0490    0826    LD	A,0x26
  0491    0427    ORA	0x27
  0492    1903    SZB	0x3,2
  0493    2CBA    JP	0x4BA
797:              			{
798:              				fan_temp = ((unsigned long)1UL*adresult * power_ad)/4096;
  0494    0847    LD	A,0x47
  0495    00C9    LD	0x49,A
  0496    0848    LD	A,0x48
  0497    00CA    LD	0x4A,A
  0498    01CB    CLR	0x4B
  0499    01CC    CLR	0x4C
  049A    0826    LD	A,0x26
  049B    00CD    LD	0x4D,A
  049C    0827    LD	A,0x27
  049D    00CE    LD	0x4E,A
  049E    01CF    CLR	0x4F
  049F    01D0    CLR	0x50
  04A0    26B9    CALL	0x6B9
  04A1    118A    CLRB	0xA,3
  04A2    084C    LD	A,0x4C
  04A3    00DA    LD	0x5A,A
  04A4    084B    LD	A,0x4B
  04A5    00D9    LD	0x59,A
  04A6    084A    LD	A,0x4A
  04A7    00D8    LD	0x58,A
  04A8    0849    LD	A,0x49
  04A9    00D7    LD	0x57,A
  04AA    300C    LDIA	0xC
  04AB    1003    CLRB	0x3,0
  04AC    0CDA    RRCR	0x5A
  04AD    0CD9    RRCR	0x59
  04AE    0CD8    RRCR	0x58
  04AF    0CD7    RRCR	0x57
  04B0    3EFF    ADDIA	0xFF
  04B1    1D03    SNZB	0x3,2
  04B2    2CAB    JP	0x4AB
799:              				fanValue = (unsigned int)(fan_temp);
  04B3    0858    LD	A,0x58
  04B4    1683    SETB	0x3,5
  04B5    00B9    LD	0x39,A
  04B6    1283    CLRB	0x3,5
  04B7    0857    LD	A,0x57
  04B8    1683    SETB	0x3,5
  04B9    00B8    LD	0x38,A
800:              			}
801:              		}
802:              		if(fanValue > 1300)		//原来的值是1.3V
  04BA    3005    LDIA	0x5
  04BB    1683    SETB	0x3,5
  04BC    0239    SUBA	0x39
  04BD    3015    LDIA	0x15
  04BE    1903    SZB	0x3,2
  04BF    0238    SUBA	0x38
  04C0    1C03    SNZB	0x3,0
  04C1    2CCE    JP	0x4CE
803:              		{
804:              			if(++fanOverTime > 25)
  04C2    301A    LDIA	0x1A
  04C3    1283    CLRB	0x3,5
  04C4    0AC0    INCR	0x40
  04C5    0240    SUBA	0x40
  04C6    1C03    SNZB	0x3,0
  04C7    2CD0    JP	0x4D0
  04C8    30E1    LDIA	0xE1
805:              			{
806:              				fanOverTime = 0;
  04C9    01C0    CLR	0x40
807:              				workStep = 0;
  04CA    01C4    CLR	0x44
808:              				shanshuoTime = 225;
  04CB    00AC    LD	0x2C,A
  04CC    01AD    CLR	0x2D
  04CD    2CD0    JP	0x4D0
809:              			}
810:              		}
811:              		else
812:              		{
813:              			fanOverTime = 0;
  04CE    1283    CLRB	0x3,5
  04CF    01C0    CLR	0x40
814:              		}
815:              		if(fanDuty < maxFanValue)
  04D0    0856    LD	A,0x56
  04D1    0242    SUBA	0x42
  04D2    1803    SZB	0x3,0
  04D3    2CD6    JP	0x4D6
816:              		{
817:              			fanDuty++;
  04D4    0AC2    INCR	0x42
818:              		}
  04D5    2CDA    JP	0x4DA
819:              		else if(fanDuty > maxFanValue)
  04D6    0842    LD	A,0x42
  04D7    0256    SUBA	0x56
  04D8    1C03    SNZB	0x3,0
820:              		{
821:              			fanDuty--;
  04D9    03C2    DECR	0x42
822:              		}
823:              		fanInit();
  04DA    2F54    JP	0x754
824:              	}
825:              	else
826:              	{
827:              		fanStop();
  04DB    2760    CALL	0x760
828:              		fanDuty = 0;
  04DC    01C2    CLR	0x42
829:              		PORTA &= 0xFB;
  04DD    1683    SETB	0x3,5
  04DE    1106    CLRB	0x6,2
  04DF    0008    RET
830:              	}
831:              }
832:              
833:              void wuhuaCtr()
834:              {
835:              	if(count1s == 0)
  0764    1283    CLRB	0x3,5
  0765    0845    LD	A,0x45
  0766    1D03    SNZB	0x3,2
  0767    2F6D    JP	0x76D
836:              	{
837:              		if(++count10s >= 10)
  0768    300A    LDIA	0xA
  0769    0AC1    INCR	0x41
  076A    0241    SUBA	0x41
  076B    1803    SZB	0x3,0
838:              		{
839:              			count10s = 0;
  076C    01C1    CLR	0x41
840:              		}
841:              	}
842:              	if(wuhuaFlag == 1 || (wuhuaFlag == 2 && count10s < 5))
  076D    0343    DECA	0x43
  076E    1903    SZB	0x3,2
  076F    2F78    JP	0x778
  0770    3002    LDIA	0x2
  0771    0643    XORA	0x43
  0772    1D03    SNZB	0x3,2
  0773    2F79    JP	0x779
  0774    3005    LDIA	0x5
  0775    0241    SUBA	0x41
  0776    1803    SZB	0x3,0
  0777    2F79    JP	0x779
843:              	{
844:              		pwmInit();
  0778    2F7A    JP	0x77A
845:              		/*
846:              		if(++checkTime > 200)
847:              		{
848:              			if(lowWaterTime > 110)
849:              			{
850:              				//干烧状态
851:              				wuhuaFlag = 0;
852:              				shanshuoTime2 = 450;
853:              			}
854:              			checkTime = 0;
855:              			lowWaterTime = 0;
856:              		}
857:              		*/
858:              		
859:              	}
860:              	else
861:              	{
862:              		pwmStop();
  0779    2F86    JP	0x786
863:              	}
864:              }
865:              
866:              
867:              void workCtr()
  0411    301F    LDIA	0x1F
868:              {
869:              	test_adc = ADC_Sample(31, 0);		//测试内部基准1.2V相对电源的AD值
  0412    01F3    CLR	0x73
  0413    24E0    CALL	0x4E0
  0414    118A    CLRB	0xA,3
  0415    00B6    LD	0x36,A
870:              	if (0xA5 == test_adc)
  0416    30A5    LDIA	0xA5
  0417    0636    XORA	0x36
  0418    1D03    SNZB	0x3,2
  0419    2C4B    JP	0x44B
871:              	{
872:              		volatile unsigned long power_temp;
873:              			
874:              		power_temp = (unsigned long)((POWER_RATIO)/adresult);		//1.2*4096/AD=VDD，参数放大1000倍 
  041A    3096    LDIA	0x96
  041B    01D2    CLR	0x52
  041C    00D3    LD	0x53,A
  041D    304A    LDIA	0x4A
  041E    00D4    LD	0x54,A
  041F    0848    LD	A,0x48
  0420    00CD    LD	0x4D,A
  0421    0847    LD	A,0x47
  0422    00CC    LD	0x4C,A
  0423    266B    CALL	0x66B
  0424    118A    CLRB	0xA,3
  0425    084C    LD	A,0x4C
  0426    00CF    LD	0x4F,A
  0427    084D    LD	A,0x4D
  0428    00D0    LD	0x50,A
  0429    084E    LD	A,0x4E
  042A    00D1    LD	0x51,A
  042B    25B0    CALL	0x5B0
  042C    118A    CLRB	0xA,3
  042D    084F    LD	A,0x4F
  042E    00DE    LD	0x5E,A
  042F    0850    LD	A,0x50
  0430    00DF    LD	0x5F,A
  0431    0851    LD	A,0x51
  0432    00E0    LD	0x60,A
  0433    2612    CALL	0x612
  0434    118A    CLRB	0xA,3
  0435    0861    LD	A,0x61
  0436    1683    SETB	0x3,5
  0437    00C1    LD	0x41,A
  0438    1283    CLRB	0x3,5
  0439    0860    LD	A,0x60
  043A    1683    SETB	0x3,5
  043B    00C0    LD	0x40,A
  043C    1283    CLRB	0x3,5
  043D    085F    LD	A,0x5F
  043E    1683    SETB	0x3,5
  043F    00BF    LD	0x3F,A
  0440    1283    CLRB	0x3,5
  0441    085E    LD	A,0x5E
  0442    1683    SETB	0x3,5
  0443    00BE    LD	0x3E,A
875:              		power_ad = (unsigned int)(power_temp);		//通过内部基准电压推出芯片VDD电压
  0444    083F    LD	A,0x3F
  0445    1283    CLRB	0x3,5
  0446    00A7    LD	0x27,A
  0447    1683    SETB	0x3,5
  0448    083E    LD	A,0x3E
  0449    1283    CLRB	0x3,5
  044A    00A6    LD	0x26,A
876:              	}
877:              	if(workStep == 2 && power_ad < 3300)
878:              	{
879:              		if(++lowFanTime > 2000)
880:              		{
881:              			lowFanTime = 0;
882:              			workStep = 1;
883:              		}
884:              	}
885:              	else
886:              	{
887:              		lowFanTime = 0;
888:              	}	
889:              	if(power_ad < 2900)
  044B    300B    LDIA	0xB
  044C    0227    SUBA	0x27
  044D    3054    LDIA	0x54
  044E    1903    SZB	0x3,2
  044F    0226    SUBA	0x26
  0450    1803    SZB	0x3,0
  0451    2C65    JP	0x465
890:              	{
891:              		if(++lowBatTime > 1000)
  0452    1683    SETB	0x3,5
  0453    0AB6    INCR	0x36
  0454    1903    SZB	0x3,2
  0455    0AB7    INCR	0x37
  0456    3003    LDIA	0x3
  0457    0237    SUBA	0x37
  0458    30E9    LDIA	0xE9
  0459    1903    SZB	0x3,2
  045A    0236    SUBA	0x36
  045B    1C03    SNZB	0x3,0
  045C    2C68    JP	0x468
892:              		{
893:              			lowBatTime = 0;
  045D    01B6    CLR	0x36
  045E    01B7    CLR	0x37
894:              			lowBatLock = 1;
  045F    1283    CLRB	0x3,5
  0460    01BC    CLR	0x3C
  0461    0ABC    INCR	0x3C
895:              			workStep = 0;
  0462    01C4    CLR	0x44
896:              			wuhuaFlag = 0;
  0463    01C3    CLR	0x43
  0464    2C68    JP	0x468
897:              		}
898:              	}
899:              	else
900:              	{
901:              		lowBatTime = 0;
  0465    1683    SETB	0x3,5
  0466    01B6    CLR	0x36
  0467    01B7    CLR	0x37
902:              	}
903:              	if(firstTime > 0)
  0468    1283    CLRB	0x3,5
  0469    086C    LD	A,0x6C
  046A    1903    SZB	0x3,2
  046B    2C6E    JP	0x46E
904:              	{
905:              		firstTime--;
  046C    03EC    DECR	0x6C
906:              	}
  046D    0008    RET
907:              	else
908:              	{
909:              		keyLedCtr();
  046E    26EC    CALL	0x6EC
  046F    118A    CLRB	0xA,3
910:              		fanCtr();
  0470    2473    CALL	0x473
  0471    118A    CLRB	0xA,3
911:              		wuhuaCtr();
  0472    2F64    JP	0x764
912:              	}
913:              	
914:              }
915:              
916:              /***********************************************************
917:              主循环
918:              ***********************************************************/
919:              void main()
920:              {
921:              	Init_System();
  07B8    118A    CLRB	0xA,3
  07B9    2024    CALL	0x24
  07BA    118A    CLRB	0xA,3
922:              	firstLock = 1;
  07BB    1283    CLRB	0x3,5
  07BC    30FA    LDIA	0xFA
  07BD    01EB    CLR	0x6B
  07BE    0AEB    INCR	0x6B
923:              	firstTime = 250;
  07BF    00EC    LD	0x6C,A
924:              	while(1)
925:              	{
926:              
927:              		if(B_MainLoop)
  07C0    1F78    SNZB	0x78,6
  07C1    2FC0    JP	0x7C0
928:              		{
929:              			B_MainLoop = 0;
  07C2    1378    CLRB	0x78,6
  07C3    0064    CLRWDT
930:              			CLRWDT();
931:              			CheckTouchKey();
  07C4    118A    CLRB	0xA,3
  07C5    207C    CALL	0x7C
  07C6    118A    CLRB	0xA,3
932:              			chrgCtr();
  07C7    158A    SETB	0xA,3
  07C8    25D9    CALL	0x5D9
  07C9    118A    CLRB	0xA,3
933:              			Refurbish_Sfr();
  07CA    118A    CLRB	0xA,3
  07CB    2403    CALL	0x403
  07CC    118A    CLRB	0xA,3
934:              			KeyServer();
  07CD    158A    SETB	0xA,3
  07CE    2586    CALL	0x586
  07CF    118A    CLRB	0xA,3
935:              			workCtr();
  07D0    118A    CLRB	0xA,3
  07D1    2411    CALL	0x411
  07D2    118A    CLRB	0xA,3
936:              			setBatStep();
  07D3    158A    SETB	0xA,3
  07D4    2729    CALL	0x729
  07D5    118A    CLRB	0xA,3
937:              			if(firstTime == 0 && chrgFlag == 0 && workStep == 0 && wuhuaFlag == 0 && shanshuoTime == 0 && shanshuoTime2 == 0)
  07D6    086C    LD	A,0x6C
  07D7    1D03    SNZB	0x3,2
  07D8    2FEF    JP	0x7EF
  07D9    083F    LD	A,0x3F
  07DA    1D03    SNZB	0x3,2
  07DB    2FEF    JP	0x7EF
  07DC    0844    LD	A,0x44
  07DD    1D03    SNZB	0x3,2
  07DE    2FEF    JP	0x7EF
  07DF    0843    LD	A,0x43
  07E0    1D03    SNZB	0x3,2
  07E1    2FEF    JP	0x7EF
  07E2    082C    LD	A,0x2C
  07E3    042D    ORA	0x2D
  07E4    1D03    SNZB	0x3,2
  07E5    2FEF    JP	0x7EF
  07E6    082A    LD	A,0x2A
  07E7    042B    ORA	0x2B
  07E8    1D03    SNZB	0x3,2
  07E9    2FEF    JP	0x7EF
938:              			{
939:              				PORTA &= 0xE4;
940:              				PORTB &= 0xEF;
941:              				TRISA |= 0x1B;
942:              				TRISB |= 0x10;
  07EA    27F3    CALL	0x7F3
943:              				WorkSleep();
  07EB    118A    CLRB	0xA,3
  07EC    2041    CALL	0x41
  07ED    118A    CLRB	0xA,3
944:              			}
  07EE    2FC0    JP	0x7C0
945:              			else
946:              			{
947:              				time = 0;
  07EF    1683    SETB	0x3,5
  07F0    01BA    CLR	0x3A
  07F1    01BB    CLR	0x3B
  07F2    2FC0    JP	0x7C0
948:              			}
949:              		}
950:              	}
951:              }
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\ftdiv.c ----------------------------------------------------------------------
1:                /*	Floating point routines.
2:                
3:                	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:                */
5:                
6:                // this is bigendian code right now. Need to parameterise it.
7:                
8:                #include	"ftarith.h"
9:                
10:               #define	f1_as_dividend	(*(unsigned short long *)&f1)
11:               #define	f2_as_divisor	(*(unsigned short long *)&f2)
12:               #define	f3_as_quot	(*(unsigned short long *)&f3)
13:               
14:               // floating addition
15:               #ifdef _OLDLIB
16:               #define	cntr		sign2
17:               float
18:               #ifdef _PIC18
19:               __ftdiv(float f1, float f2)
20:               #else
21:               __ftdiv(float f2, float f1)
22:               #endif
23:               {
24:               	unsigned char	exp1, exp2, sign1, sign2;
25:               	float	f3;
26:               	
27:               	f3_as_quot = 0;
28:               	sign1 = __ftunpack(&f1_as_dividend, &exp1);
29:               	if(exp1 == 0)
30:               		return f3;
31:               	sign2 = __ftunpack(&f2_as_divisor, &exp2);
32:               	if(exp2 == 0)
33:               		return f3;
34:               	exp1 -= exp2-127+8;	// compute new exponent
35:               	sign1 ^= sign2;
36:               	cntr = 16+8;
37:               	do {
38:               		f3_as_quot <<= 1;
39:               		if(f1_as_dividend >= f2_as_divisor) {
40:               			f1_as_dividend -= f2_as_divisor;
41:               			f3_as_quot |= 1;
42:               		}
43:               		f1_as_dividend <<= 1;
44:               	} while(--cntr != 0);
45:               	__ftpack(&f3_as_quot, exp1);
46:               	if(sign1)
47:               		f3_as_quot |= 0x800000;
48:               	return f3;
49:               }
50:               #else
51:               #define	exp2	sign
52:               float
53:               #ifdef _PIC18
54:               __ftdiv(float f1, float f2)
55:               #else
56:               __ftdiv(float f2, float f1)
  05B0    0852    LD	A,0x52
  05B1    00D5    LD	0x55,A
  05B2    0853    LD	A,0x53
  05B3    00D6    LD	0x56,A
  05B4    0854    LD	A,0x54
  05B5    00D7    LD	0x57,A
  05B6    1003    CLRB	0x3,0
  05B7    0D56    RLCA	0x56
  05B8    0D57    RLCA	0x57
  05B9    00DC    LD	0x5C,A
  05BA    085C    LD	A,0x5C
  05BB    1D03    SNZB	0x3,2
  05BC    2DBE    JP	0x5BE
  05BD    2FAA    JP	0x7AA
  05BE    084F    LD	A,0x4F
  05BF    00D5    LD	0x55,A
  05C0    0850    LD	A,0x50
  05C1    00D6    LD	0x56,A
  05C2    0851    LD	A,0x51
  05C3    00D7    LD	0x57,A
  05C4    1003    CLRB	0x3,0
  05C5    0D56    RLCA	0x56
  05C6    0D57    RLCA	0x57
  05C7    00DD    LD	0x5D,A
  05C8    085D    LD	A,0x5D
  05C9    1D03    SNZB	0x3,2
  05CA    2DCC    JP	0x5CC
  05CB    2FAA    JP	0x7AA
  05CC    3089    LDIA	0x89
  05CD    01D9    CLR	0x59
  05CE    01DA    CLR	0x5A
  05CF    01DB    CLR	0x5B
  05D0    075D    ADDA	0x5D
  05D1    00D5    LD	0x55,A
  05D2    02DC    SUBR	0x5C
  05D3    0854    LD	A,0x54
  05D4    00DD    LD	0x5D,A
  05D5    0851    LD	A,0x51
  05D6    06DD    XORR	0x5D
  05D7    3080    LDIA	0x80
  05D8    05DD    ANDR	0x5D
  05D9    3018    LDIA	0x18
  05DA    17D3    SETB	0x53,7
  05DB    01D4    CLR	0x54
  05DC    17D0    SETB	0x50,7
  05DD    01D1    CLR	0x51
  05DE    00D8    LD	0x58,A
  05DF    1003    CLRB	0x3,0
  05E0    0DD9    RLCR	0x59
  05E1    0DDA    RLCR	0x5A
  05E2    0DDB    RLCR	0x5B
  05E3    0851    LD	A,0x51
  05E4    0254    SUBA	0x54
  05E5    1D03    SNZB	0x3,2
  05E6    2DED    JP	0x5ED
  05E7    0850    LD	A,0x50
  05E8    0253    SUBA	0x53
  05E9    1D03    SNZB	0x3,2
  05EA    2DED    JP	0x5ED
  05EB    084F    LD	A,0x4F
  05EC    0252    SUBA	0x52
  05ED    1C03    SNZB	0x3,0
  05EE    2DFB    JP	0x5FB
  05EF    084F    LD	A,0x4F
  05F0    02D2    SUBR	0x52
  05F1    0850    LD	A,0x50
  05F2    1C03    SNZB	0x3,0
  05F3    0F50    SZINCA	0x50
  05F4    02D3    SUBR	0x53
  05F5    0851    LD	A,0x51
  05F6    1C03    SNZB	0x3,0
  05F7    0A51    INCA	0x51
  05F8    02D4    SUBR	0x54
  05F9    1459    SETB	0x59,0
  05FA    1003    CLRB	0x3,0
  05FB    0DD2    RLCR	0x52
  05FC    0DD3    RLCR	0x53
  05FD    0DD4    RLCR	0x54
  05FE    0BD8    SZDECR	0x58
  05FF    2DDF    JP	0x5DF
  0600    0859    LD	A,0x59
  0601    00F3    LD	0x73,A
  0602    085A    LD	A,0x5A
  0603    00F4    LD	0x74,A
  0604    085B    LD	A,0x5B
  0605    00F5    LD	0x75,A
  0606    085C    LD	A,0x5C
  0607    00F6    LD	0x76,A
  0608    085D    LD	A,0x5D
  0609    00F7    LD	0x77,A
  060A    267B    CALL	0x67B
  060B    0873    LD	A,0x73
  060C    00CF    LD	0x4F,A
  060D    0874    LD	A,0x74
  060E    00D0    LD	0x50,A
  060F    0875    LD	A,0x75
  0610    00D1    LD	0x51,A
  0611    0008    RET
57:               #endif
58:               {
59:               	unsigned char	exp, sign, cntr;
60:               	float	f3;
61:               	
62:               	// unpack the operands
63:               	if((exp = f1_as_dividend >> 15) == 0)
64:               		return 0.0;
65:               	if((exp2 = f2_as_divisor >> 15) == 0)
66:               		return 0.0;
67:               	f3_as_quot = 0;
68:               	exp -= exp2-127+8;	// compute new exponent
69:               	sign = f1_as_dividend >> 16;
70:               	sign ^= (unsigned char)(f2_as_divisor >> 16);
71:               	sign &= 0x80;
72:               	f1_as_dividend |= 0x8000UL;
73:               	f1_as_dividend &= 0xFFFFUL;
74:               	f2_as_divisor |= 0x8000UL;
75:               	f2_as_divisor &= 0xFFFFUL;
76:               	cntr = 16+8;
77:               	do {
78:               		f3_as_quot <<= 1;
79:               		if(f1_as_dividend >= f2_as_divisor) {
80:               			f1_as_dividend -= f2_as_divisor;
81:               			f3_as_quot |= 1;
82:               		}
83:               		f1_as_dividend <<= 1;
84:               	} while(--cntr != 0);
85:               	return __ftpack(f3_as_quot, exp, sign);
86:               }
87:               #endif	
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\fttol.c ----------------------------------------------------------------------
1:                /*	Floating point routines.
2:                
3:                	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:                */
5:                
6:                // this is bigendian code right now. Need to parameterise it.
7:                
8:                #include	"ftarith.h"
9:                
10:               #define	f1_as_mant1	(*(unsigned short long *)&f1)
11:               
12:               // Convert float to long
13:               
14:               #ifdef _OLDLIB
15:               long
16:               __fttol(float f1)
17:               {
18:               	unsigned char	sign1, exp1;
19:               	unsigned long	lval;
20:               
21:               	sign1 = __ftunpack(&f1_as_mant1, &exp1);
22:               	lval = f1_as_mant1;
23:               	exp1 -= 127+15;
24:               	if((signed char)exp1 < 0) {
25:               		if((signed char)exp1 < -15)
26:               			return 0;
27:               		do
28:               			lval >>= 1;
29:               		while(++exp1 != 0);
30:               	} else {
31:               		if(exp1 >= 32)
32:               			return 00;
33:               		while(exp1 != 0) {
34:               			lval <<= 1;
35:               			exp1--;
36:               		}
37:               	}
38:               	if(sign1)
39:               		lval = -lval;
40:               	return lval;
41:               }
42:               #else
43:               long
44:               __fttol(float f1)
  0612    27A3    CALL	0x7A3
  0613    118A    CLRB	0xA,3
  0614    1003    CLRB	0x3,0
  0615    0D63    RLCA	0x63
  0616    0D64    RLCA	0x64
  0617    00EA    LD	0x6A,A
  0618    086A    LD	A,0x6A
  0619    1D03    SNZB	0x3,2
  061A    2E20    JP	0x620
  061B    01DE    CLR	0x5E
  061C    01DF    CLR	0x5F
  061D    01E0    CLR	0x60
  061E    01E1    CLR	0x61
  061F    0008    RET
  0620    27A3    CALL	0x7A3
  0621    118A    CLRB	0xA,3
  0622    3017    LDIA	0x17
  0623    1003    CLRB	0x3,0
  0624    0CE4    RRCR	0x64
  0625    0CE3    RRCR	0x63
  0626    0CE2    RRCR	0x62
  0627    3EFF    ADDIA	0xFF
  0628    1D03    SNZB	0x3,2
  0629    2E23    JP	0x623
  062A    0862    LD	A,0x62
  062B    00E5    LD	0x65,A
  062C    17DF    SETB	0x5F,7
  062D    01E0    CLR	0x60
  062E    085E    LD	A,0x5E
  062F    00E6    LD	0x66,A
  0630    085F    LD	A,0x5F
  0631    00E7    LD	0x67,A
  0632    0860    LD	A,0x60
  0633    00E8    LD	0x68,A
  0634    308E    LDIA	0x8E
  0635    01E9    CLR	0x69
  0636    02EA    SUBR	0x6A
  0637    1FEA    SNZB	0x6A,7
  0638    2E46    JP	0x646
  0639    086A    LD	A,0x6A
  063A    3A80    XORIA	0x80
  063B    3E8F    ADDIA	0x8F
  063C    1C03    SNZB	0x3,0
  063D    2E1B    JP	0x61B
  063E    1003    CLRB	0x3,0
  063F    0CE9    RRCR	0x69
  0640    0CE8    RRCR	0x68
  0641    0CE7    RRCR	0x67
  0642    0CE6    RRCR	0x66
  0643    0FEA    SZINCR	0x6A
  0644    2E3E    JP	0x63E
  0645    2E54    JP	0x654
  0646    3018    LDIA	0x18
  0647    026A    SUBA	0x6A
  0648    1803    SZB	0x3,0
  0649    2E1B    JP	0x61B
  064A    086A    LD	A,0x6A
  064B    1903    SZB	0x3,2
  064C    2E54    JP	0x654
  064D    1003    CLRB	0x3,0
  064E    0DE6    RLCR	0x66
  064F    0DE7    RLCR	0x67
  0650    0DE8    RLCR	0x68
  0651    0DE9    RLCR	0x69
  0652    03EA    DECR	0x6A
  0653    2E4A    JP	0x64A
  0654    0865    LD	A,0x65
  0655    1903    SZB	0x3,2
  0656    2E62    JP	0x662
  0657    09E6    COMR	0x66
  0658    09E7    COMR	0x67
  0659    09E8    COMR	0x68
  065A    09E9    COMR	0x69
  065B    0AE6    INCR	0x66
  065C    1903    SZB	0x3,2
  065D    0AE7    INCR	0x67
  065E    1903    SZB	0x3,2
  065F    0AE8    INCR	0x68
  0660    1903    SZB	0x3,2
  0661    0AE9    INCR	0x69
  0662    0869    LD	A,0x69
  0663    00E1    LD	0x61,A
  0664    0868    LD	A,0x68
  0665    00E0    LD	0x60,A
  0666    0867    LD	A,0x67
  0667    00DF    LD	0x5F,A
  0668    0866    LD	A,0x66
  0669    00DE    LD	0x5E,A
  066A    0008    RET
45:               {
46:               	unsigned char	sign1, exp1;
47:               	unsigned long	lval;
48:               
49:               	if((exp1 = f1_as_mant1 >> 15) == 0)
50:               		return 0;
51:               	sign1 = f1_as_mant1 >> 23;
52:               	f1_as_mant1 |= 0x8000UL;
53:               	f1_as_mant1 &= 0xFFFFUL;
54:               	lval = f1_as_mant1;
55:               	exp1 -= 127+15;
56:               	if((signed char)exp1 < 0) {
57:               		if((signed char)exp1 < -15)
58:               			return 0;
59:               		do
60:               			lval >>= 1;
61:               		while(++exp1 != 0);
62:               	} else {
63:               		if(exp1 >= 24)
64:               			return 0;
65:               		while(exp1 != 0) {
66:               			lval <<= 1;
67:               			exp1--;
68:               		}
69:               	}
70:               	if(sign1)
71:               		lval = -lval;
72:               	return lval;
73:               }
74:               #endif
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\lwtoft.c ----------------------------------------------------------------------
1:                /*	Floating point routines.
2:                
3:                	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:                */
5:                
6:                // this is bigendian code right now. Need to parameterise it.
7:                
8:                #include	"ftarith.h"
9:                
10:               
11:               // Convert unsigned int to float
12:               
13:               #ifdef _OLDLIB
14:               #define	f1_as_mant1	(*(unsigned short long *)&f1)
15:               float
16:               __lwtoft(unsigned int c)
17:               {
18:               	float	f1;
19:               	
20:               	if(c == 0)
21:               		return 0.0;
22:               	f1_as_mant1 = c;
23:               	__ftpack(&f1_as_mant1, 127+15);
24:               	return f1;
25:               }
26:               #else
27:               float
28:               __lwtoft(unsigned int c)
  066B    084C    LD	A,0x4C
  066C    00F3    LD	0x73,A
  066D    084D    LD	A,0x4D
  066E    00F4    LD	0x74,A
  066F    308E    LDIA	0x8E
  0670    01F5    CLR	0x75
  0671    00F6    LD	0x76,A
  0672    01F7    CLR	0x77
  0673    267B    CALL	0x67B
  0674    0873    LD	A,0x73
  0675    00CC    LD	0x4C,A
  0676    0874    LD	A,0x74
  0677    00CD    LD	0x4D,A
  0678    0875    LD	A,0x75
  0679    00CE    LD	0x4E,A
  067A    0008    RET
29:               {
30:               	return __ftpack(c, 127+15, 0);
31:               }
32:               #endif
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\float.c ----------------------------------------------------------------------
1:                /*	Floating point routines.
2:                
3:                	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:                */
5:                
6:                #include	"ftarith.h"
7:                
8:                
9:                //	unpack the operand pointed to. Store the exponent into the location pointed to by exp,
10:               //	and return the sign (zero is positive)
11:               
12:               #ifdef _OLDLIB
13:               
14:               unsigned char
15:               __ftunpack(unsigned short long * arg, unsigned char * exp)
16:               {
17:               	unsigned char	sign;
18:               
19:               	*exp = sign = *arg >> 15;
20:               	if(sign == 0) {
21:               		*arg = 0;
22:               		return 0;
23:               	}
24:               	sign = 0;
25:               	*arg |= 0x8000;
26:               	if(*arg & 0x800000)
27:               		sign++;
28:               	*arg &= 0xFFFF;
29:               	return sign;
30:               }
31:               
32:               // normalize and pack the supplied argument into floating point format
33:               
34:               void
35:               __ftpack(unsigned short long * arg, unsigned char exp)
36:               {
37:               	if(exp == 0 || *arg == 0) {
38:               		*arg = 0;
39:               		return;
40:               	}
41:               	while(*arg & 0xFE0000UL) {
42:               		exp++;
43:               		*arg >>= 1;
44:               	}
45:               	while(*arg & 0xFF0000UL) {
46:               		exp++;
47:               		(*arg)++;
48:               		*arg >>= 1;
49:               	}
50:               	while(!(*arg & 0x8000UL)) {
51:               		exp--;
52:               		*arg <<= 1;
53:               	}
54:               	if(!(exp & 1))
55:               		*arg &= ~0x8000L;
56:               	exp >>= 1;
57:               	*arg |= (unsigned short long)exp << 16;
58:               }
59:               
60:               #else
61:               float
62:               __ftpack(unsigned short long arg, unsigned char exp, unsigned char sign)
  067B    0876    LD	A,0x76
  067C    1903    SZB	0x3,2
  067D    2E83    JP	0x683
  067E    0875    LD	A,0x75
  067F    0474    ORA	0x74
  0680    0473    ORA	0x73
  0681    1D03    SNZB	0x3,2
  0682    2E8A    JP	0x68A
  0683    01F3    CLR	0x73
  0684    01F4    CLR	0x74
  0685    01F5    CLR	0x75
  0686    0008    RET
  0687    0AF6    INCR	0x76
  0688    27AE    CALL	0x7AE
  0689    118A    CLRB	0xA,3
  068A    30FE    LDIA	0xFE
  068B    0575    ANDA	0x75
  068C    1903    SZB	0x3,2
  068D    2E97    JP	0x697
  068E    2E87    JP	0x687
  068F    0AF6    INCR	0x76
  0690    0AF3    INCR	0x73
  0691    1903    SZB	0x3,2
  0692    0AF4    INCR	0x74
  0693    1903    SZB	0x3,2
  0694    0AF5    INCR	0x75
  0695    27AE    CALL	0x7AE
  0696    118A    CLRB	0xA,3
  0697    30FF    LDIA	0xFF
  0698    0575    ANDA	0x75
  0699    1903    SZB	0x3,2
  069A    2EA5    JP	0x6A5
  069B    2E8F    JP	0x68F
  069C    3002    LDIA	0x2
  069D    0276    SUBA	0x76
  069E    1C03    SNZB	0x3,0
  069F    2EA7    JP	0x6A7
  06A0    03F6    DECR	0x76
  06A1    1003    CLRB	0x3,0
  06A2    0DF3    RLCR	0x73
  06A3    0DF4    RLCR	0x74
  06A4    0DF5    RLCR	0x75
  06A5    1FF4    SNZB	0x74,7
  06A6    2E9C    JP	0x69C
  06A7    1C76    SNZB	0x76,0
  06A8    13F4    CLRB	0x74,7
  06A9    1003    CLRB	0x3,0
  06AA    0CF6    RRCR	0x76
  06AB    0876    LD	A,0x76
  06AC    00CB    LD	0x4B,A
  06AD    01CA    CLR	0x4A
  06AE    01C9    CLR	0x49
  06AF    0849    LD	A,0x49
  06B0    04F3    ORR	0x73
  06B1    084A    LD	A,0x4A
  06B2    04F4    ORR	0x74
  06B3    084B    LD	A,0x4B
  06B4    04F5    ORR	0x75
  06B5    0877    LD	A,0x77
  06B6    1D03    SNZB	0x3,2
  06B7    17F5    SETB	0x75,7
  06B8    0008    RET
63:               {
64:               	if(exp == 0 || arg == 0)
65:               		return 0.0;
66:               	while(arg & 0xFE0000UL) {
67:               		exp++;
68:               		arg >>= 1;
69:               	}
70:               	while(arg & 0xFF0000UL) {
71:               		exp++;
72:               		(arg)++;
73:               		arg >>= 1;
74:               	}
75:               	while(!(arg & 0x8000UL) && exp > 1) {
76:               		exp--;
77:               		arg <<= 1;
78:               	}
79:               	if(!(exp & 1))
80:               		arg &= ~0x8000L;
81:               	exp >>= 1;
82:               	arg |= (unsigned short long)exp << 16;
83:               	if (sign)
84:               		arg |= 0x800000UL;
85:                  return *(float*)&arg;	
86:               }
87:               
88:               #endif
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\Umul32.c ----------------------------------------------------------------------
1:                // 32 x 32 bit multiplication with 32 bit result
2:                #ifdef _PIC18
3:                #define _Has_hardware_multiply 1
4:                #else
5:                #define _Has_hardware_multiply 0
6:                #endif
7:                
8:                #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:                #define _Has_large_call_stack 1
10:               #else
11:               #define _Has_large_call_stack 0
12:               #endif
13:               
14:               unsigned long
15:               __lmul(unsigned long multiplier, unsigned long multiplicand)
  06B9    01F3    CLR	0x73
  06BA    01F4    CLR	0x74
  06BB    01F5    CLR	0x75
  06BC    01F6    CLR	0x76
  06BD    1C49    SNZB	0x49,0
  06BE    2ED3    JP	0x6D3
  06BF    084D    LD	A,0x4D
  06C0    07F3    ADDR	0x73
  06C1    084E    LD	A,0x4E
  06C2    1103    CLRB	0x3,2
  06C3    1803    SZB	0x3,0
  06C4    3E01    ADDIA	0x1
  06C5    1D03    SNZB	0x3,2
  06C6    07F4    ADDR	0x74
  06C7    084F    LD	A,0x4F
  06C8    1103    CLRB	0x3,2
  06C9    1803    SZB	0x3,0
  06CA    3E01    ADDIA	0x1
  06CB    1D03    SNZB	0x3,2
  06CC    07F5    ADDR	0x75
  06CD    0850    LD	A,0x50
  06CE    1103    CLRB	0x3,2
  06CF    1803    SZB	0x3,0
  06D0    3E01    ADDIA	0x1
  06D1    1D03    SNZB	0x3,2
  06D2    07F6    ADDR	0x76
  06D3    1003    CLRB	0x3,0
  06D4    0DCD    RLCR	0x4D
  06D5    0DCE    RLCR	0x4E
  06D6    0DCF    RLCR	0x4F
  06D7    0DD0    RLCR	0x50
  06D8    1003    CLRB	0x3,0
  06D9    0CCC    RRCR	0x4C
  06DA    0CCB    RRCR	0x4B
  06DB    0CCA    RRCR	0x4A
  06DC    0CC9    RRCR	0x49
  06DD    084C    LD	A,0x4C
  06DE    044B    ORA	0x4B
  06DF    044A    ORA	0x4A
  06E0    0449    ORA	0x49
  06E1    1D03    SNZB	0x3,2
  06E2    2EBD    JP	0x6BD
  06E3    0876    LD	A,0x76
  06E4    00CC    LD	0x4C,A
  06E5    0875    LD	A,0x75
  06E6    00CB    LD	0x4B,A
  06E7    0874    LD	A,0x74
  06E8    00CA    LD	0x4A,A
  06E9    0873    LD	A,0x73
  06EA    00C9    LD	0x49,A
  06EB    0008    RET
16:               {
17:               	unsigned long product;
18:               
19:               #define LOWBYTE(x)  (*(unsigned char *)(&x))
20:               #define LMIDBYTE(x) (*(((unsigned char *)(&x))+1))
21:               #define HMIDBYTE(x) (*(((unsigned char *)(&x))+2))
22:               #define HIGHBYTE(x) (*(((unsigned char *)(&x))+3))
23:               
24:               #if (_Has_hardware_multiply || _Has_large_call_stack) && defined(__OPTIMIZE_SPEED__)
25:               	{
26:               
27:               #define USE_SHRINK
28:               
29:               /*
30:               a 32-bit multiply can be decomposed into the sum of ten 8-bit multiplies
31:                            a  b  c  d
32:               *            e  f  g  h
33:               -----------------------
34:                          |         dh
35:                          |      ch  0
36:                          |   bh  0  0
37:                          |ah  0  0  0
38:                          |      dg  0
39:                          |   cg  0  0
40:                          |bg  0  0  0
41:                        ag| 0  0  0  0 (we ignore this intermediate product
42:                                        because it does not affect the low 32 bits of the result)
43:                          |   df  0  0
44:                          |cf  0  0  0
45:                        bf| 0  0  0  0 (ignore)
46:                     af  0| 0  0  0  0 (ignore)
47:                          |de  0  0  0
48:                        ce| 0  0  0  0 (ignore)
49:                     be  0| 0  0  0  0 (ignore)
50:               +  ae  0  0| 0  0  0  0 (ignore)
51:               =======================
52:                */
53:               		product =  (unsigned int)LOWBYTE(multiplier) * LOWBYTE(multiplicand);
54:               
55:               #if defined(USE_MASKS)
56:               		product += ((unsigned long)
57:               			     ((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand))
58:               			     +
59:               			     ((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
60:               			<< 8;
61:               
62:               		product += ((unsigned long)
63:               			    ((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand))
64:               			    +
65:               			    ((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
66:               			    +
67:               			    ((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
68:               			<< 16;
69:               
70:               		/* cast to smaller type to avoid adding high bits just to discard */
71:               		product += ((unsigned long)
72:               			    (unsigned char)
73:               			    ((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand))
74:               			    +
75:               			    (unsigned char)
76:               			    ((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand))
77:               			    +
78:               			    (unsigned char)
79:               			    ((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
80:               			    +
81:               			    (unsigned char)
82:               			    ((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand)))
83:               			<< 24;
84:               
85:               #elif defined(USE_SHRINK)
86:               		/* add direct to upper bytes, rather than shift and add all bytes */
87:               		*((unsigned short long*)(((unsigned char*)&product)+1)) +=
88:               			((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand));
89:               		*((unsigned short long*)(((unsigned char*)&product)+1)) +=
90:               			((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand));
91:               
92:               
93:               		*((unsigned int*)(((unsigned char*)&product)+2)) +=
94:               			((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand));
95:               		*((unsigned int*)(((unsigned char*)&product)+2)) +=
96:               			((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
97:               		*((unsigned int*)(((unsigned char*)&product)+2)) +=
98:               			((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand));
99:               
100:              		*(((unsigned char*)&product)+3) +=
101:              			(unsigned char)
102:              			((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand));
103:              		*(((unsigned char*)&product)+3) +=
104:              			(unsigned char)
105:              			((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand));
106:              		*(((unsigned char*)&product)+3) +=
107:              			(unsigned char)
108:              			((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
109:              		*(((unsigned char*)&product)+3) +=
110:              			(unsigned char)
111:              			((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand));
112:              
113:              #else
114:              #error No method chosen
115:              #endif
116:              	}
117:              #else
118:              
119:              	product = 0;
120:              	do {
121:              		if(multiplier & 1)
122:              			product += multiplicand;
123:              		multiplicand <<= 1;
124:              		multiplier >>= 1;
125:              	} while(multiplier != 0);
126:              
127:              #endif
128:              	return product;
129:              }
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\lwmod.c ----------------------------------------------------------------------
1:                // word unsigned modulus
2:                
3:                unsigned int
4:                #ifdef __PICC__
5:                #warning TODO: update cgpic and this file to use the other prototype
6:                __lwmod(unsigned int divisor, unsigned int dividend)
  0730    0873    LD	A,0x73
  0731    0474    ORA	0x74
  0732    1903    SZB	0x3,2
  0733    2F4F    JP	0x74F
  0734    01F7    CLR	0x77
  0735    0AF7    INCR	0x77
  0736    1BF4    SZB	0x74,7
  0737    2F3C    JP	0x73C
  0738    1003    CLRB	0x3,0
  0739    0DF3    RLCR	0x73
  073A    0DF4    RLCR	0x74
  073B    2F35    JP	0x735
  073C    0874    LD	A,0x74
  073D    0276    SUBA	0x76
  073E    1D03    SNZB	0x3,2
  073F    2F42    JP	0x742
  0740    0873    LD	A,0x73
  0741    0275    SUBA	0x75
  0742    1C03    SNZB	0x3,0
  0743    2F4B    JP	0x74B
  0744    0873    LD	A,0x73
  0745    02F5    SUBR	0x75
  0746    0874    LD	A,0x74
  0747    1C03    SNZB	0x3,0
  0748    03F6    DECR	0x76
  0749    02F6    SUBR	0x76
  074A    1003    CLRB	0x3,0
  074B    0CF4    RRCR	0x74
  074C    0CF3    RRCR	0x73
  074D    0BF7    SZDECR	0x77
  074E    2F3C    JP	0x73C
  074F    0876    LD	A,0x76
  0750    00F4    LD	0x74,A
  0751    0875    LD	A,0x75
  0752    00F3    LD	0x73,A
  0753    0008    RET
7:                #else
8:                __lwmod(unsigned int dividend, unsigned int divisor)
9:                #endif
10:               {
11:               	unsigned char	counter;
12:               
13:               	if(divisor != 0) {
14:               		counter = 1;
15:               		while((divisor & 0x8000) == 0) {
16:               			divisor <<= 1;
17:               			counter++;
18:               		}
19:               		do {
20:               			if(divisor <= dividend)
21:               				dividend -= divisor;
22:               			divisor >>= 1;
23:               		} while(--counter != 0);
24:               	}
25:               	return dividend;
26:               }
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\lwdiv.c ----------------------------------------------------------------------
1:                // word unsigned division
2:                
3:                unsigned int
4:                #ifdef __PICC__
5:                #warning TODO: update cgpic and this file to use the other prototype
6:                __lwdiv(unsigned int divisor, unsigned int dividend)
  0FD6    01CA    CLR	0x4A
  0FD7    01CB    CLR	0x4B
  0FD8    0873    LD	A,0x73
  0FD9    0474    ORA	0x74
  0FDA    1903    SZB	0x3,2
  0FDB    2FFB    JP	0x7FB
  0FDC    01C9    CLR	0x49
  0FDD    0AC9    INCR	0x49
  0FDE    1BF4    SZB	0x74,7
  0FDF    2FE4    JP	0x7E4
  0FE0    1003    CLRB	0x3,0
  0FE1    0DF3    RLCR	0x73
  0FE2    0DF4    RLCR	0x74
  0FE3    2FDD    JP	0x7DD
  0FE4    1003    CLRB	0x3,0
  0FE5    0DCA    RLCR	0x4A
  0FE6    0DCB    RLCR	0x4B
  0FE7    0874    LD	A,0x74
  0FE8    0276    SUBA	0x76
  0FE9    1D03    SNZB	0x3,2
  0FEA    2FED    JP	0x7ED
  0FEB    0873    LD	A,0x73
  0FEC    0275    SUBA	0x75
  0FED    1C03    SNZB	0x3,0
  0FEE    2FF7    JP	0x7F7
  0FEF    0873    LD	A,0x73
  0FF0    02F5    SUBR	0x75
  0FF1    0874    LD	A,0x74
  0FF2    1C03    SNZB	0x3,0
  0FF3    03F6    DECR	0x76
  0FF4    02F6    SUBR	0x76
  0FF5    144A    SETB	0x4A,0
  0FF6    1003    CLRB	0x3,0
  0FF7    0CF4    RRCR	0x74
  0FF8    0CF3    RRCR	0x73
  0FF9    0BC9    SZDECR	0x49
  0FFA    2FE4    JP	0x7E4
  0FFB    084B    LD	A,0x4B
  0FFC    00F4    LD	0x74,A
  0FFD    084A    LD	A,0x4A
  0FFE    00F3    LD	0x73,A
7:                #else
8:                __lwdiv(unsigned int dividend, unsigned int divisor)
9:                #endif
10:               {
11:               	unsigned int	quotient;
12:               	unsigned char	counter;
13:               
14:               	quotient = 0;
15:               	if(divisor != 0) {
16:               		counter = 1;
17:               		while((divisor & 0x8000) == 0) {
18:               			divisor <<= 1;
19:               			counter++;
20:               		}
21:               		do {
22:               			quotient <<= 1;
23:               			if(divisor <= dividend) {
24:               				dividend -= divisor;
25:               				quotient |= 1;
26:               			}
27:               			divisor >>= 1;
28:               		} while(--counter != 0);
29:               	}
30:               	return quotient;
31:               }
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\lbdiv.c ----------------------------------------------------------------------
1:                // byte unsigned division
2:                
3:                unsigned char
4:                __lbdiv(unsigned char dividend, unsigned char divisor)
  0E1E    00F4    LD	0x74,A
  0E1F    01F6    CLR	0x76
  0E20    0873    LD	A,0x73
  0E21    1903    SZB	0x3,2
  0E22    2E37    JP	0x637
  0E23    01F5    CLR	0x75
  0E24    0AF5    INCR	0x75
  0E25    1BF3    SZB	0x73,7
  0E26    2E2A    JP	0x62A
  0E27    1003    CLRB	0x3,0
  0E28    0DF3    RLCR	0x73
  0E29    2E24    JP	0x624
  0E2A    1003    CLRB	0x3,0
  0E2B    0DF6    RLCR	0x76
  0E2C    0873    LD	A,0x73
  0E2D    0274    SUBA	0x74
  0E2E    1C03    SNZB	0x3,0
  0E2F    2E34    JP	0x634
  0E30    0873    LD	A,0x73
  0E31    02F4    SUBR	0x74
  0E32    1476    SETB	0x76,0
  0E33    1003    CLRB	0x3,0
  0E34    0CF3    RRCR	0x73
  0E35    0BF5    SZDECR	0x75
  0E36    2E2A    JP	0x62A
  0E37    0876    LD	A,0x76
  0E38    0008    RET
5:                {
6:                	unsigned char	quotient;
7:                	unsigned char	counter;
8:                
9:                	quotient = 0;
10:               	if(divisor != 0) {
11:               		counter = 1;
12:               		while((divisor & 0x80) == 0) {
13:               			divisor <<= 1;
14:               			counter++;
15:               		}
16:               		do {
17:               			quotient <<= 1;
18:               			if(divisor <= dividend) {
19:               				dividend -= divisor;
20:               				quotient |= 1;
21:               			}
22:               			divisor >>= 1;
23:               		} while(--counter != 0);
24:               	}
25:               	return quotient;
26:               }
---- C:\mcuproject\scm\SCMCU_IDE_V2.00.16_Beta5\SCMCU_IDE_V2.00.16_Beta5\data\sources\common\lbmod.c ----------------------------------------------------------------------
1:                // byte unsigned modulus
2:                
3:                unsigned char
4:                __lbmod(unsigned char dividend, unsigned char divisor)
  0E39    00F5    LD	0x75,A
  0E3A    3008    LDIA	0x8
  0E3B    00F6    LD	0x76,A
  0E3C    01F7    CLR	0x77
  0E3D    0875    LD	A,0x75
  0E3E    00F4    LD	0x74,A
  0E3F    3007    LDIA	0x7
  0E40    1003    CLRB	0x3,0
  0E41    0CF4    RRCR	0x74
  0E42    3EFF    ADDIA	0xFF
  0E43    1003    CLRB	0x3,0
  0E44    1D03    SNZB	0x3,2
  0E45    2E41    JP	0x641
  0E46    0D77    RLCA	0x77
  0E47    0474    ORA	0x74
  0E48    00F7    LD	0x77,A
  0E49    1003    CLRB	0x3,0
  0E4A    0DF5    RLCR	0x75
  0E4B    0873    LD	A,0x73
  0E4C    0277    SUBA	0x77
  0E4D    1C03    SNZB	0x3,0
  0E4E    2E51    JP	0x651
  0E4F    0873    LD	A,0x73
  0E50    02F7    SUBR	0x77
  0E51    0BF6    SZDECR	0x76
  0E52    2E3D    JP	0x63D
  0E53    0877    LD	A,0x77
  0E54    0008    RET
5:                {
6:                	unsigned char	rem;
7:                	unsigned char	counter;
8:                
9:                	counter = 8;
10:               	rem = 0;
11:               	do {
12:               		rem = (rem << 1) | (dividend >> 7);
13:               		dividend <<= 1;
14:               		if(divisor <= rem)
15:               			rem -= divisor;
16:               	} while(--counter != 0);
17:               	return rem;
18:               }
---- library_code ------------------------------------------------------------------
  007C    1A78    SZB	0x78,4
  007D    288A    JP	0x8A
  007E    2139    CALL	0x139
  007F    118A    CLRB	0xA,3
  0080    3008    LDIA	0x8
  0081    1283    CLRB	0x3,5
  0082    1303    CLRB	0x3,6
  0083    0AB4    INCR	0x34
  0084    0234    SUBA	0x34
  0085    1C03    SNZB	0x3,0
  0086    28A8    JP	0xA8
  0087    01B4    CLR	0x34
  0088    1678    SETB	0x78,4
  0089    28A8    JP	0xA8
  008A    19F8    SZB	0x78,3
  008B    28A2    JP	0xA2
  008C    21B0    CALL	0x1B0
  008D    118A    CLRB	0xA,3
  008E    2342    CALL	0x342
  008F    118A    CLRB	0xA,3
  0090    15F8    SETB	0x78,3
  0091    18F8    SZB	0x78,1
  0092    2899    JP	0x99
  0093    3003    LDIA	0x3
  0094    1283    CLRB	0x3,5
  0095    1303    CLRB	0x3,6
  0096    0234    SUBA	0x34
  0097    1C03    SNZB	0x3,0
  0098    289E    JP	0x9E
  0099    232C    CALL	0x32C
  009A    118A    CLRB	0xA,3
  009B    10F8    CLRB	0x78,1
  009C    1278    CLRB	0x78,4
  009D    11F8    CLRB	0x78,3
  009E    1283    CLRB	0x3,5
  009F    1303    CLRB	0x3,6
  00A0    01B4    CLR	0x34
  00A1    28A8    JP	0xA8
  00A2    22C8    CALL	0x2C8
  00A3    118A    CLRB	0xA,3
  00A4    21A1    CALL	0x1A1
  00A5    118A    CLRB	0xA,3
  00A6    1278    CLRB	0x78,4
  00A7    11F8    CLRB	0x78,3
  00A8    2B75    JP	0x375
  00A9    0064    CLRWDT
  00AA    1683    SETB	0x3,5
  00AB    1303    CLRB	0x3,6
  00AC    0181    CLR	0x1
  00AD    3007    LDIA	0x7
  00AE    1283    CLRB	0x3,5
  00AF    0481    ORR	0x1
  00B0    1581    SETB	0x1,3
  00B1    0064    CLRWDT
  00B2    300A    LDIA	0xA
  00B3    1283    CLRB	0x3,5
  00B4    1303    CLRB	0x3,6
  00B5    0081    LD	0x1,A
  00B6    0064    CLRWDT
  00B7    1283    CLRB	0x3,5
  00B8    1703    SETB	0x3,6
  00B9    0191    CLR	0x11
  00BA    0193    CLR	0x13
  00BB    3002    LDIA	0x2
  00BC    1303    CLRB	0x3,6
  00BD    0094    LD	0x14,A
  00BE    0063    STOP
  00BF    0000    NOP
  00C0    0064    CLRWDT
  00C1    3072    LDIA	0x72
  00C2    1283    CLRB	0x3,5
  00C3    1303    CLRB	0x3,6
  00C4    0094    LD	0x14,A
  00C5    3079    LDIA	0x79
  00C6    1703    SETB	0x3,6
  00C7    0093    LD	0x13,A
  00C8    21A1    CALL	0x1A1
  00C9    118A    CLRB	0xA,3
  00CA    1478    SETB	0x78,0
  00CB    2139    CALL	0x139
  00CC    118A    CLRB	0xA,3
  00CD    1283    CLRB	0x3,5
  00CE    1303    CLRB	0x3,6
  00CF    23F9    CALL	0x3F9
  00D0    118A    CLRB	0xA,3
  00D1    1C0B    SNZB	0xB,0
  00D2    188B    SZB	0xB,1
  00D3    28D6    JP	0xD6
  00D4    1D8D    SNZB	0xD,3
  00D5    28DD    JP	0xDD
  00D6    21A1    CALL	0x1A1
  00D7    1283    CLRB	0x3,5
  00D8    1303    CLRB	0x3,6
  00D9    01B4    CLR	0x34
  00DA    1278    CLRB	0x78,4
  00DB    11F8    CLRB	0x78,3
  00DC    0008    RET
  00DD    0852    LD	A,0x52
  00DE    3903    ANDIA	0x3
  00DF    1003    CLRB	0x3,0
  00E0    1903    SZB	0x3,2
  00E1    2933    JP	0x133
  00E2    0D54    RLCA	0x54
  00E3    3EAC    ADDIA	0xAC
  00E4    0084    LD	0x4,A
  00E5    1383    CLRB	0x3,7
  00E6    0800    LD	A,0x0
  00E7    00D0    LD	0x50,A
  00E8    0A84    INCR	0x4
  00E9    0800    LD	A,0x0
  00EA    00D1    LD	0x51,A
  00EB    00CF    LD	0x4F,A
  00EC    0850    LD	A,0x50
  00ED    00CE    LD	0x4E,A
  00EE    0850    LD	A,0x50
  00EF    0451    ORA	0x51
  00F0    1903    SZB	0x3,2
  00F1    2932    JP	0x132
  00F2    0854    LD	A,0x54
  00F3    3E16    ADDIA	0x16
  00F4    0084    LD	0x4,A
  00F5    158A    SETB	0xA,3
  00F6    2028    CALL	0x28
  00F7    118A    CLRB	0xA,3
  00F8    07CE    ADDR	0x4E
  00F9    1803    SZB	0x3,0
  00FA    0ACF    INCR	0x4F
  00FB    1003    CLRB	0x3,0
  00FC    0D54    RLCA	0x54
  00FD    3EA4    ADDIA	0xA4
  00FE    23D8    CALL	0x3D8
  00FF    118A    CLRB	0xA,3
  0100    084F    LD	A,0x4F
  0101    0275    SUBA	0x75
  0102    1D03    SNZB	0x3,2
  0103    2906    JP	0x106
  0104    084E    LD	A,0x4E
  0105    0274    SUBA	0x74
  0106    1C03    SNZB	0x3,0
  0107    291A    JP	0x11A
  0108    23F9    CALL	0x3F9
  0109    118A    CLRB	0xA,3
  010A    0852    LD	A,0x52
  010B    3903    ANDIA	0x3
  010C    1D03    SNZB	0x3,2
  010D    2911    JP	0x111
  010E    0854    LD	A,0x54
  010F    22A5    CALL	0x2A5
  0110    118A    CLRB	0xA,3
  0111    1283    CLRB	0x3,5
  0112    3002    LDIA	0x2
  0113    1303    CLRB	0x3,6
  0114    1003    CLRB	0x3,0
  0115    23FE    CALL	0x3FE
  0116    118A    CLRB	0xA,3
  0117    1803    SZB	0x3,0
  0118    28D6    JP	0xD6
  0119    290A    JP	0x10A
  011A    0D54    RLCA	0x54
  011B    3E20    ADDIA	0x20
  011C    23D8    CALL	0x3D8
  011D    118A    CLRB	0xA,3
  011E    1003    CLRB	0x3,0
  011F    0D54    RLCA	0x54
  0120    3EA4    ADDIA	0xA4
  0121    23C2    CALL	0x3C2
  0122    118A    CLRB	0xA,3
  0123    0800    LD	A,0x0
  0124    00F4    LD	0x74,A
  0125    0A84    INCR	0x4
  0126    0800    LD	A,0x0
  0127    00F5    LD	0x75,A
  0128    1003    CLRB	0x3,0
  0129    0D54    RLCA	0x54
  012A    3E20    ADDIA	0x20
  012B    23C2    CALL	0x3C2
  012C    118A    CLRB	0xA,3
  012D    0850    LD	A,0x50
  012E    0080    LD	0x0,A
  012F    0A84    INCR	0x4
  0130    0851    LD	A,0x51
  0131    0080    LD	0x0,A
  0132    1003    CLRB	0x3,0
  0133    3002    LDIA	0x2
  0134    23FE    CALL	0x3FE
  0135    118A    CLRB	0xA,3
  0136    1803    SZB	0x3,0
  0137    28A9    JP	0xA9
  0138    28DD    JP	0xDD
  0139    1283    CLRB	0x3,5
  013A    1303    CLRB	0x3,6
  013B    01CD    CLR	0x4D
  013C    01CB    CLR	0x4B
  013D    0ACB    INCR	0x4B
  013E    01CC    CLR	0x4C
  013F    1C78    SNZB	0x78,0
  0140    2945    JP	0x145
  0141    084B    LD	A,0x4B
  0142    3903    ANDIA	0x3
  0143    1903    SZB	0x3,2
  0144    2996    JP	0x196
  0145    1703    SETB	0x3,6
  0146    0191    CLR	0x11
  0147    0192    CLR	0x12
  0148    3079    LDIA	0x79
  0149    0093    LD	0x13,A
  014A    1303    CLRB	0x3,6
  014B    1305    CLRB	0x5,6
  014C    1306    CLRB	0x6,6
  014D    0000    NOP
  014E    0000    NOP
  014F    0000    NOP
  0150    0000    NOP
  0151    0000    NOP
  0152    0000    NOP
  0153    0000    NOP
  0154    0000    NOP
  0155    1283    CLRB	0x3,5
  0156    1303    CLRB	0x3,6
  0157    1705    SETB	0x5,6
  0158    084D    LD	A,0x4D
  0159    3E18    ADDIA	0x18
  015A    0084    LD	0x4,A
  015B    158A    SETB	0xA,3
  015C    2028    CALL	0x28
  015D    118A    CLRB	0xA,3
  015E    1703    SETB	0x3,6
  015F    0091    LD	0x11,A
  0160    1303    CLRB	0x3,6
  0161    084D    LD	A,0x4D
  0162    3E1A    ADDIA	0x1A
  0163    0084    LD	0x4,A
  0164    158A    SETB	0xA,3
  0165    2028    CALL	0x28
  0166    118A    CLRB	0xA,3
  0167    1703    SETB	0x3,6
  0168    0092    LD	0x12,A
  0169    0000    NOP
  016A    0000    NOP
  016B    0000    NOP
  016C    0000    NOP
  016D    1283    CLRB	0x3,5
  016E    1703    SETB	0x3,6
  016F    1411    SETB	0x11,0
  0170    30D0    LDIA	0xD0
  0171    1303    CLRB	0x3,6
  0172    00C9    LD	0x49,A
  0173    3007    LDIA	0x7
  0174    00CA    LD	0x4A,A
  0175    1703    SETB	0x3,6
  0176    1B91    SZB	0x11,7
  0177    2984    JP	0x184
  0178    3001    LDIA	0x1
  0179    1303    CLRB	0x3,6
  017A    02C9    SUBR	0x49
  017B    1C03    SNZB	0x3,0
  017C    03CA    DECR	0x4A
  017D    0849    LD	A,0x49
  017E    044A    ORA	0x4A
  017F    1D03    SNZB	0x3,2
  0180    2975    JP	0x175
  0181    30FF    LDIA	0xFF
  0182    00B4    LD	0x34,A
  0183    29A1    JP	0x1A1
  0184    1303    CLRB	0x3,6
  0185    1003    CLRB	0x3,0
  0186    0D4D    RLCA	0x4D
  0187    3EAC    ADDIA	0xAC
  0188    0084    LD	0x4,A
  0189    1703    SETB	0x3,6
  018A    0816    LD	A,0x16
  018B    1383    CLRB	0x3,7
  018C    0780    ADDR	0x0
  018D    0F84    SZINCR	0x4
  018E    0800    LD	A,0x0
  018F    1803    SZB	0x3,0
  0190    0A00    INCA	0x0
  0191    00FF    LD	0x7F,A
  0192    0817    LD	A,0x17
  0193    077F    ADDA	0x7F
  0194    0080    LD	0x0,A
  0195    0384    DECR	0x4
  0196    3002    LDIA	0x2
  0197    1303    CLRB	0x3,6
  0198    1003    CLRB	0x3,0
  0199    0DCB    RLCR	0x4B
  019A    0DCC    RLCR	0x4C
  019B    0ACD    INCR	0x4D
  019C    024D    SUBA	0x4D
  019D    1C03    SNZB	0x3,0
  019E    293F    JP	0x13F
  019F    1078    CLRB	0x78,0
  01A0    0008    RET
  01A1    01F3    CLR	0x73
  01A2    1003    CLRB	0x3,0
  01A3    0D73    RLCA	0x73
  01A4    3EAC    ADDIA	0xAC
  01A5    0084    LD	0x4,A
  01A6    3002    LDIA	0x2
  01A7    1383    CLRB	0x3,7
  01A8    0180    CLR	0x0
  01A9    0A84    INCR	0x4
  01AA    0180    CLR	0x0
  01AB    0AF3    INCR	0x73
  01AC    0273    SUBA	0x73
  01AD    1803    SZB	0x3,0
  01AE    0008    RET
  01AF    29A2    JP	0x1A2
  01B0    1283    CLRB	0x3,5
  01B1    1303    CLRB	0x3,6
  01B2    01D5    CLR	0x55
  01B3    01F9    CLR	0x79
  01B4    01FA    CLR	0x7A
  01B5    01B3    CLR	0x33
  01B6    0855    LD	A,0x55
  01B7    3907    ANDIA	0x7
  01B8    3E0E    ADDIA	0xE
  01B9    0084    LD	0x4,A
  01BA    158A    SETB	0xA,3
  01BB    2028    CALL	0x28
  01BC    118A    CLRB	0xA,3
  01BD    00CF    LD	0x4F,A
  01BE    1003    CLRB	0x3,0
  01BF    0D55    RLCA	0x55
  01C0    3EAC    ADDIA	0xAC
  01C1    0084    LD	0x4,A
  01C2    3003    LDIA	0x3
  01C3    0A84    INCR	0x4
  01C4    1003    CLRB	0x3,0
  01C5    1383    CLRB	0x3,7
  01C6    0C80    RRCR	0x0
  01C7    0384    DECR	0x4
  01C8    0C80    RRCR	0x0
  01C9    3EFF    ADDIA	0xFF
  01CA    1D03    SNZB	0x3,2
  01CB    29C3    JP	0x1C3
  01CC    1003    CLRB	0x3,0
  01CD    0D55    RLCA	0x55
  01CE    3EAC    ADDIA	0xAC
  01CF    0084    LD	0x4,A
  01D0    0800    LD	A,0x0
  01D1    00D3    LD	0x53,A
  01D2    0A84    INCR	0x4
  01D3    0800    LD	A,0x0
  01D4    00D4    LD	0x54,A
  01D5    0855    LD	A,0x55
  01D6    3E16    ADDIA	0x16
  01D7    0084    LD	0x4,A
  01D8    158A    SETB	0xA,3
  01D9    2028    CALL	0x28
  01DA    118A    CLRB	0xA,3
  01DB    00D2    LD	0x52,A
  01DC    00D0    LD	0x50,A
  01DD    01D1    CLR	0x51
  01DE    0853    LD	A,0x53
  01DF    07D0    ADDR	0x50
  01E0    1803    SZB	0x3,0
  01E1    0AD1    INCR	0x51
  01E2    0854    LD	A,0x54
  01E3    07D1    ADDR	0x51
  01E4    0855    LD	A,0x55
  01E5    2291    CALL	0x291
  01E6    118A    CLRB	0xA,3
  01E7    3A00    XORIA	0x0
  01E8    1003    CLRB	0x3,0
  01E9    1D03    SNZB	0x3,2
  01EA    2A45    JP	0x245
  01EB    0D55    RLCA	0x55
  01EC    3EA4    ADDIA	0xA4
  01ED    0084    LD	0x4,A
  01EE    1383    CLRB	0x3,7
  01EF    0800    LD	A,0x0
  01F0    00CD    LD	0x4D,A
  01F1    0A84    INCR	0x4
  01F2    0800    LD	A,0x0
  01F3    00CE    LD	0x4E,A
  01F4    1003    CLRB	0x3,0
  01F5    0D55    RLCA	0x55
  01F6    3EA0    ADDIA	0xA0
  01F7    23BB    CALL	0x3BB
  01F8    118A    CLRB	0xA,3
  01F9    0251    SUBA	0x51
  01FA    1D03    SNZB	0x3,2
  01FB    29FE    JP	0x1FE
  01FC    0849    LD	A,0x49
  01FD    0250    SUBA	0x50
  01FE    1803    SZB	0x3,0
  01FF    2A0D    JP	0x20D
  0200    1003    CLRB	0x3,0
  0201    0D55    RLCA	0x55
  0202    3EA0    ADDIA	0xA0
  0203    23BB    CALL	0x3BB
  0204    118A    CLRB	0xA,3
  0205    0853    LD	A,0x53
  0206    0249    SUBA	0x49
  0207    00D3    LD	0x53,A
  0208    0854    LD	A,0x54
  0209    1C03    SNZB	0x3,0
  020A    0A54    INCA	0x54
  020B    024A    SUBA	0x4A
  020C    2A31    JP	0x231
  020D    084E    LD	A,0x4E
  020E    0251    SUBA	0x51
  020F    1D03    SNZB	0x3,2
  0210    2A13    JP	0x213
  0211    084D    LD	A,0x4D
  0212    0250    SUBA	0x50
  0213    1803    SZB	0x3,0
  0214    2A89    JP	0x289
  0215    1003    CLRB	0x3,0
  0216    0D55    RLCA	0x55
  0217    3E20    ADDIA	0x20
  0218    23BB    CALL	0x3BB
  0219    118A    CLRB	0xA,3
  021A    0251    SUBA	0x51
  021B    1D03    SNZB	0x3,2
  021C    2A1F    JP	0x21F
  021D    0849    LD	A,0x49
  021E    0250    SUBA	0x50
  021F    1803    SZB	0x3,0
  0220    2A89    JP	0x289
  0221    1003    CLRB	0x3,0
  0222    0D55    RLCA	0x55
  0223    3EA0    ADDIA	0xA0
  0224    0084    LD	0x4,A
  0225    084D    LD	A,0x4D
  0226    0080    LD	0x0,A
  0227    0A84    INCR	0x4
  0228    084E    LD	A,0x4E
  0229    0080    LD	0x0,A
  022A    0853    LD	A,0x53
  022B    024D    SUBA	0x4D
  022C    00D3    LD	0x53,A
  022D    0854    LD	A,0x54
  022E    1C03    SNZB	0x3,0
  022F    0A54    INCA	0x54
  0230    024E    SUBA	0x4E
  0231    00D4    LD	0x54,A
  0232    0855    LD	A,0x55
  0233    3EBC    ADDIA	0xBC
  0234    0084    LD	0x4,A
  0235    0180    CLR	0x0
  0236    0854    LD	A,0x54
  0237    1903    SZB	0x3,2
  0238    2A3B    JP	0x23B
  0239    30FF    LDIA	0xFF
  023A    2A3C    JP	0x23C
  023B    0853    LD	A,0x53
  023C    00D2    LD	0x52,A
  023D    0233    SUBA	0x33
  023E    1803    SZB	0x3,0
  023F    2A43    JP	0x243
  0240    0852    LD	A,0x52
  0241    00B3    LD	0x33,A
  0242    2A83    JP	0x283
  0243    0AB4    INCR	0x34
  0244    2A89    JP	0x289
  0245    0D55    RLCA	0x55
  0246    3EA0    ADDIA	0xA0
  0247    0084    LD	0x4,A
  0248    1383    CLRB	0x3,7
  0249    0800    LD	A,0x0
  024A    00C9    LD	0x49,A
  024B    0A84    INCR	0x4
  024C    0800    LD	A,0x0
  024D    00CA    LD	0x4A,A
  024E    0849    LD	A,0x49
  024F    3E01    ADDIA	0x1
  0250    00CB    LD	0x4B,A
  0251    084A    LD	A,0x4A
  0252    1803    SZB	0x3,0
  0253    3E01    ADDIA	0x1
  0254    00CC    LD	0x4C,A
  0255    0851    LD	A,0x51
  0256    024C    SUBA	0x4C
  0257    1D03    SNZB	0x3,2
  0258    2A5B    JP	0x25B
  0259    0850    LD	A,0x50
  025A    024B    SUBA	0x4B
  025B    1C03    SNZB	0x3,0
  025C    2A89    JP	0x289
  025D    1003    CLRB	0x3,0
  025E    0D55    RLCA	0x55
  025F    3EA4    ADDIA	0xA4
  0260    0084    LD	0x4,A
  0261    0800    LD	A,0x0
  0262    23A9    CALL	0x3A9
  0263    118A    CLRB	0xA,3
  0264    1C03    SNZB	0x3,0
  0265    2A6F    JP	0x26F
  0266    1003    CLRB	0x3,0
  0267    0D55    RLCA	0x55
  0268    3E20    ADDIA	0x20
  0269    0084    LD	0x4,A
  026A    0800    LD	A,0x0
  026B    23A9    CALL	0x3A9
  026C    118A    CLRB	0xA,3
  026D    1803    SZB	0x3,0
  026E    2A7B    JP	0x27B
  026F    0855    LD	A,0x55
  0270    3EBC    ADDIA	0xBC
  0271    0084    LD	0x4,A
  0272    3009    LDIA	0x9
  0273    0A80    INCR	0x0
  0274    0200    SUBA	0x0
  0275    1C03    SNZB	0x3,0
  0276    2A7F    JP	0x27F
  0277    0855    LD	A,0x55
  0278    22A5    CALL	0x2A5
  0279    118A    CLRB	0xA,3
  027A    2A89    JP	0x289
  027B    0855    LD	A,0x55
  027C    3EBC    ADDIA	0xBC
  027D    0084    LD	0x4,A
  027E    0180    CLR	0x0
  027F    087A    LD	A,0x7A
  0280    0479    ORA	0x79
  0281    1D03    SNZB	0x3,2
  0282    2A89    JP	0x289
  0283    084F    LD	A,0x4F
  0284    00F3    LD	0x73,A
  0285    01F4    CLR	0x74
  0286    0855    LD	A,0x55
  0287    22BA    CALL	0x2BA
  0288    118A    CLRB	0xA,3
  0289    3002    LDIA	0x2
  028A    1283    CLRB	0x3,5
  028B    1303    CLRB	0x3,6
  028C    0AD5    INCR	0x55
  028D    0255    SUBA	0x55
  028E    1803    SZB	0x3,0
  028F    0008    RET
  0290    29B6    JP	0x1B6
  0291    00F4    LD	0x74,A
  0292    3907    ANDIA	0x7
  0293    3E0E    ADDIA	0xE
  0294    0084    LD	0x4,A
  0295    158A    SETB	0xA,3
  0296    2028    CALL	0x28
  0297    118A    CLRB	0xA,3
  0298    00F3    LD	0x73,A
  0299    1DF4    SNZB	0x74,3
  029A    2A9F    JP	0x29F
  029B    1283    CLRB	0x3,5
  029C    1303    CLRB	0x3,6
  029D    082F    LD	A,0x2F
  029E    2AA2    JP	0x2A2
  029F    1283    CLRB	0x3,5
  02A0    1303    CLRB	0x3,6
  02A1    082E    LD	A,0x2E
  02A2    05F3    ANDR	0x73
  02A3    0873    LD	A,0x73
  02A4    0008    RET
  02A5    00F3    LD	0x73,A
  02A6    1003    CLRB	0x3,0
  02A7    0D73    RLCA	0x73
  02A8    3EA8    ADDIA	0xA8
  02A9    0084    LD	0x4,A
  02AA    1383    CLRB	0x3,7
  02AB    23E7    CALL	0x3E7
  02AC    118A    CLRB	0xA,3
  02AD    3E20    ADDIA	0x20
  02AE    0084    LD	0x4,A
  02AF    23E7    CALL	0x3E7
  02B0    118A    CLRB	0xA,3
  02B1    3EA4    ADDIA	0xA4
  02B2    0084    LD	0x4,A
  02B3    23E7    CALL	0x3E7
  02B4    3EA0    ADDIA	0xA0
  02B5    0084    LD	0x4,A
  02B6    0180    CLR	0x0
  02B7    0A84    INCR	0x4
  02B8    0180    CLR	0x0
  02B9    0008    RET
  02BA    00F5    LD	0x75,A
  02BB    1283    CLRB	0x3,5
  02BC    1303    CLRB	0x3,6
  02BD    0AB4    INCR	0x34
  02BE    01F9    CLR	0x79
  02BF    01FA    CLR	0x7A
  02C0    1DF5    SNZB	0x75,3
  02C1    2AC5    JP	0x2C5
  02C2    0873    LD	A,0x73
  02C3    00FA    LD	0x7A,A
  02C4    0008    RET
  02C5    0873    LD	A,0x73
  02C6    00F9    LD	0x79,A
  02C7    0008    RET
  02C8    1283    CLRB	0x3,5
  02C9    3004    LDIA	0x4
  02CA    1303    CLRB	0x3,6
  02CB    01CD    CLR	0x4D
  02CC    0AB2    INCR	0x32
  02CD    0232    SUBA	0x32
  02CE    1C03    SNZB	0x3,0
  02CF    0008    RET
  02D0    01B2    CLR	0x32
  02D1    1003    CLRB	0x3,0
  02D2    0D4D    RLCA	0x4D
  02D3    3EAC    ADDIA	0xAC
  02D4    0084    LD	0x4,A
  02D5    1383    CLRB	0x3,7
  02D6    0800    LD	A,0x0
  02D7    00C9    LD	0x49,A
  02D8    0A84    INCR	0x4
  02D9    0800    LD	A,0x0
  02DA    00CA    LD	0x4A,A
  02DB    084D    LD	A,0x4D
  02DC    2291    CALL	0x291
  02DD    118A    CLRB	0xA,3
  02DE    3A00    XORIA	0x0
  02DF    1003    CLRB	0x3,0
  02E0    1D03    SNZB	0x3,2
  02E1    2B16    JP	0x316
  02E2    0D4D    RLCA	0x4D
  02E3    3EA8    ADDIA	0xA8
  02E4    0084    LD	0x4,A
  02E5    1383    CLRB	0x3,7
  02E6    239B    CALL	0x39B
  02E7    118A    CLRB	0xA,3
  02E8    1903    SZB	0x3,2
  02E9    024B    SUBA	0x4B
  02EA    1C03    SNZB	0x3,0
  02EB    2AF2    JP	0x2F2
  02EC    0F4B    SZINCA	0x4B
  02ED    2B15    JP	0x315
  02EE    0A4C    INCA	0x4C
  02EF    1003    CLRB	0x3,0
  02F0    1D03    SNZB	0x3,2
  02F1    2B16    JP	0x316
  02F2    0D4D    RLCA	0x4D
  02F3    3E20    ADDIA	0x20
  02F4    0084    LD	0x4,A
  02F5    239B    CALL	0x39B
  02F6    118A    CLRB	0xA,3
  02F7    1903    SZB	0x3,2
  02F8    024B    SUBA	0x4B
  02F9    1C03    SNZB	0x3,0
  02FA    2B01    JP	0x301
  02FB    0F4B    SZINCA	0x4B
  02FC    2B15    JP	0x315
  02FD    0A4C    INCA	0x4C
  02FE    1003    CLRB	0x3,0
  02FF    1D03    SNZB	0x3,2
  0300    2B16    JP	0x316
  0301    0D4D    RLCA	0x4D
  0302    3EA4    ADDIA	0xA4
  0303    0084    LD	0x4,A
  0304    239B    CALL	0x39B
  0305    118A    CLRB	0xA,3
  0306    1903    SZB	0x3,2
  0307    024B    SUBA	0x4B
  0308    1C03    SNZB	0x3,0
  0309    2B10    JP	0x310
  030A    0F4B    SZINCA	0x4B
  030B    2B15    JP	0x315
  030C    0A4C    INCA	0x4C
  030D    1003    CLRB	0x3,0
  030E    1D03    SNZB	0x3,2
  030F    2B16    JP	0x316
  0310    0D4D    RLCA	0x4D
  0311    3EA0    ADDIA	0xA0
  0312    0084    LD	0x4,A
  0313    23F3    CALL	0x3F3
  0314    118A    CLRB	0xA,3
  0315    1003    CLRB	0x3,0
  0316    0D4D    RLCA	0x4D
  0317    3E20    ADDIA	0x20
  0318    0084    LD	0x4,A
  0319    1383    CLRB	0x3,7
  031A    23DF    CALL	0x3DF
  031B    118A    CLRB	0xA,3
  031C    3EA4    ADDIA	0xA4
  031D    23CD    CALL	0x3CD
  031E    118A    CLRB	0xA,3
  031F    23DF    CALL	0x3DF
  0320    118A    CLRB	0xA,3
  0321    3E20    ADDIA	0x20
  0322    23CD    CALL	0x3CD
  0323    118A    CLRB	0xA,3
  0324    23F3    CALL	0x3F3
  0325    118A    CLRB	0xA,3
  0326    3002    LDIA	0x2
  0327    0ACD    INCR	0x4D
  0328    024D    SUBA	0x4D
  0329    1803    SZB	0x3,0
  032A    0008    RET
  032B    2AD1    JP	0x2D1
  032C    1283    CLRB	0x3,5
  032D    1303    CLRB	0x3,6
  032E    01AE    CLR	0x2E
  032F    01AF    CLR	0x2F
  0330    01F4    CLR	0x74
  0331    1003    CLRB	0x3,0
  0332    0D74    RLCA	0x74
  0333    3EAC    ADDIA	0xAC
  0334    0084    LD	0x4,A
  0335    1383    CLRB	0x3,7
  0336    0180    CLR	0x0
  0337    0A84    INCR	0x4
  0338    0180    CLR	0x0
  0339    0874    LD	A,0x74
  033A    22A5    CALL	0x2A5
  033B    118A    CLRB	0xA,3
  033C    3002    LDIA	0x2
  033D    0AF4    INCR	0x74
  033E    0274    SUBA	0x74
  033F    1803    SZB	0x3,0
  0340    0008    RET
  0341    2B31    JP	0x331
  0342    087A    LD	A,0x7A
  0343    0479    ORA	0x79
  0344    1903    SZB	0x3,2
  0345    2B66    JP	0x366
  0346    1283    CLRB	0x3,5
  0347    1303    CLRB	0x3,6
  0348    01B0    CLR	0x30
  0349    0879    LD	A,0x79
  034A    0624    XORA	0x24
  034B    1D03    SNZB	0x3,2
  034C    2B5F    JP	0x35F
  034D    087A    LD	A,0x7A
  034E    0625    XORA	0x25
  034F    1D03    SNZB	0x3,2
  0350    2B5F    JP	0x35F
  0351    3002    LDIA	0x2
  0352    0AB1    INCR	0x31
  0353    0231    SUBA	0x31
  0354    1C03    SNZB	0x3,0
  0355    0008    RET
  0356    01B1    CLR	0x31
  0357    0879    LD	A,0x79
  0358    00AE    LD	0x2E,A
  0359    087A    LD	A,0x7A
  035A    00AF    LD	0x2F,A
  035B    1978    SZB	0x78,2
  035C    0008    RET
  035D    1578    SETB	0x78,2
  035E    2B8B    JP	0x38B
  035F    1178    CLRB	0x78,2
  0360    0879    LD	A,0x79
  0361    00A4    LD	0x24,A
  0362    087A    LD	A,0x7A
  0363    00A5    LD	0x25,A
  0364    01B1    CLR	0x31
  0365    0008    RET
  0366    1283    CLRB	0x3,5
  0367    1303    CLRB	0x3,6
  0368    01B1    CLR	0x31
  0369    01A4    CLR	0x24
  036A    01A5    CLR	0x25
  036B    3002    LDIA	0x2
  036C    0AB0    INCR	0x30
  036D    0230    SUBA	0x30
  036E    1C03    SNZB	0x3,0
  036F    0008    RET
  0370    01B0    CLR	0x30
  0371    01AE    CLR	0x2E
  0372    01AF    CLR	0x2F
  0373    1178    CLRB	0x78,2
  0374    0008    RET
  0375    1283    CLRB	0x3,5
  0376    1303    CLRB	0x3,6
  0377    082F    LD	A,0x2F
  0378    042E    ORA	0x2E
  0379    1903    SZB	0x3,2
  037A    2B87    JP	0x387
  037B    1683    SETB	0x3,5
  037C    0AB0    INCR	0x30
  037D    1903    SZB	0x3,2
  037E    0AB1    INCR	0x31
  037F    303A    LDIA	0x3A
  0380    0231    SUBA	0x31
  0381    3098    LDIA	0x98
  0382    1903    SZB	0x3,2
  0383    0230    SUBA	0x30
  0384    1C03    SNZB	0x3,0
  0385    0008    RET
  0386    14F8    SETB	0x78,1
  0387    1683    SETB	0x3,5
  0388    01B0    CLR	0x30
  0389    01B1    CLR	0x31
  038A    0008    RET
  038B    01F5    CLR	0x75
  038C    0875    LD	A,0x75
  038D    2291    CALL	0x291
  038E    118A    CLRB	0xA,3
  038F    3A00    XORIA	0x0
  0390    1D03    SNZB	0x3,2
  0391    2B95    JP	0x395
  0392    0875    LD	A,0x75
  0393    22A5    CALL	0x2A5
  0394    118A    CLRB	0xA,3
  0395    3002    LDIA	0x2
  0396    0AF5    INCR	0x75
  0397    0275    SUBA	0x75
  0398    1803    SZB	0x3,0
  0399    0008    RET
  039A    2B8C    JP	0x38C
---- stringtab ------------------------------------------------------------------
  0828    3008    LDIA	0x8
  0829    008A    LD	0xA,A
  082A    0804    LD	A,0x4
  082B    0A84    INCR	0x4
  082C    0782    ADDR	0x2
  082D    3400    RET	0x0
---- reset_enter ------------------------------------------------------------------
  0000    118A    CLRB	0xA,3
  0001    280D    JP	0xD
  000D    118A    CLRB	0xA,3
  000E    280F    JP	0xF
---- start_initialization ------------------------------------------------------------------
  000F    307F    LDIA	0x7F
  0010    00ED    LD	0x6D,A
  0011    00EE    LD	0x6E,A
  0012    30A0    LDIA	0xA0
  0013    1383    CLRB	0x3,7
  0014    0084    LD	0x4,A
  0015    30BE    LDIA	0xBE
  0016    158A    SETB	0xA,3
  0017    257E    CALL	0x57E
  0018    118A    CLRB	0xA,3
  0019    3020    LDIA	0x20
  001A    0084    LD	0x4,A
  001B    3049    LDIA	0x49
  001C    158A    SETB	0xA,3
  001D    257E    CALL	0x57E
  001E    01F9    CLR	0x79
  001F    01FA    CLR	0x7A
  0020    01F8    CLR	0x78
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F0    LD	0x70,A
  0007    0804    LD	A,0x4
  0008    00F1    LD	0x71,A
  0009    080A    LD	A,0xA
  000A    00F2    LD	0x72,A
  000B    158A    SETB	0xA,3
  000C    2E55    JP	0x655
  0800    158A    SETB	0xA,3
  0801    2F24    JP	0x724
  0802    158A    SETB	0xA,3
  0803    2E89    JP	0x689
  0804    158A    SETB	0xA,3
  0805    2E90    JP	0x690
  0806    158A    SETB	0xA,3
  0807    2E97    JP	0x697
  0808    158A    SETB	0xA,3
  0809    2E9E    JP	0x69E
  080A    158A    SETB	0xA,3
  080B    2EA3    JP	0x6A3
  080C    158A    SETB	0xA,3
  080D    2EAA    JP	0x6AA
  080E    158A    SETB	0xA,3
  080F    2EB1    JP	0x6B1
  0810    158A    SETB	0xA,3
  0811    2EB8    JP	0x6B8
  0812    158A    SETB	0xA,3
  0813    2EBD    JP	0x6BD
  0814    158A    SETB	0xA,3
  0815    2EC4    JP	0x6C4
  0816    158A    SETB	0xA,3
  0817    2ECB    JP	0x6CB
  0818    158A    SETB	0xA,3
  0819    2ED2    JP	0x6D2
  081A    158A    SETB	0xA,3
  081B    2ED7    JP	0x6D7
  081C    158A    SETB	0xA,3
  081D    2EDE    JP	0x6DE
  081E    158A    SETB	0xA,3
  081F    2EE5    JP	0x6E5
  0820    158A    SETB	0xA,3
  0821    2EF2    JP	0x6F2
  0822    158A    SETB	0xA,3
  0823    2EFA    JP	0x6FA
  0824    158A    SETB	0xA,3
  0825    2F04    JP	0x704
  0826    158A    SETB	0xA,3
  0827    2F0E    JP	0x70E
---- common_function ------------------------------------------------------------------
  0021    0183    CLR	0x3
  0022    118A    CLRB	0xA,3
  0023    2FB8    JP	0x7B8
  039B    0800    LD	A,0x0
  039C    00CB    LD	0x4B,A
  039D    0A84    INCR	0x4
  039E    0800    LD	A,0x0
  039F    00CC    LD	0x4C,A
  03A0    0849    LD	A,0x49
  03A1    02CB    SUBR	0x4B
  03A2    084A    LD	A,0x4A
  03A3    1C03    SNZB	0x3,0
  03A4    03CC    DECR	0x4C
  03A5    02CC    SUBR	0x4C
  03A6    3000    LDIA	0x0
  03A7    024C    SUBA	0x4C
  03A8    3402    RET	0x2
  03A9    00C9    LD	0x49,A
  03AA    0A84    INCR	0x4
  03AB    0800    LD	A,0x0
  03AC    00CA    LD	0x4A,A
  03AD    0852    LD	A,0x52
  03AE    0749    ADDA	0x49
  03AF    00CB    LD	0x4B,A
  03B0    084A    LD	A,0x4A
  03B1    1803    SZB	0x3,0
  03B2    0A4A    INCA	0x4A
  03B3    00CC    LD	0x4C,A
  03B4    0854    LD	A,0x54
  03B5    024C    SUBA	0x4C
  03B6    1D03    SNZB	0x3,2
  03B7    0008    RET
  03B8    0853    LD	A,0x53
  03B9    024B    SUBA	0x4B
  03BA    0008    RET
  03BB    0084    LD	0x4,A
  03BC    0800    LD	A,0x0
  03BD    00C9    LD	0x49,A
  03BE    0A84    INCR	0x4
  03BF    0800    LD	A,0x0
  03C0    00CA    LD	0x4A,A
  03C1    0008    RET
  03C2    0084    LD	0x4,A
  03C3    0874    LD	A,0x74
  03C4    0080    LD	0x0,A
  03C5    0A84    INCR	0x4
  03C6    0875    LD	A,0x75
  03C7    0080    LD	0x0,A
  03C8    1003    CLRB	0x3,0
  03C9    0D54    RLCA	0x54
  03CA    3EA8    ADDIA	0xA8
  03CB    0084    LD	0x4,A
  03CC    0008    RET
  03CD    0084    LD	0x4,A
  03CE    0875    LD	A,0x75
  03CF    0080    LD	0x0,A
  03D0    0A84    INCR	0x4
  03D1    0876    LD	A,0x76
  03D2    0080    LD	0x0,A
  03D3    1003    CLRB	0x3,0
  03D4    0D4D    RLCA	0x4D
  03D5    3EA8    ADDIA	0xA8
  03D6    0084    LD	0x4,A
  03D7    0008    RET
  03D8    0084    LD	0x4,A
  03D9    0800    LD	A,0x0
  03DA    00F4    LD	0x74,A
  03DB    0A84    INCR	0x4
  03DC    0800    LD	A,0x0
  03DD    00F5    LD	0x75,A
  03DE    0008    RET
  03DF    0800    LD	A,0x0
  03E0    00F5    LD	0x75,A
  03E1    0A84    INCR	0x4
  03E2    0800    LD	A,0x0
  03E3    00F6    LD	0x76,A
  03E4    1003    CLRB	0x3,0
  03E5    0D4D    RLCA	0x4D
  03E6    0008    RET
  03E7    0180    CLR	0x0
  03E8    0A84    INCR	0x4
  03E9    0180    CLR	0x0
  03EA    1003    CLRB	0x3,0
  03EB    0D73    RLCA	0x73
  03EC    0008    RET
  03ED    3041    LDIA	0x41
  03EE    1683    SETB	0x3,5
  03EF    0095    LD	0x15,A
  03F0    1415    SETB	0x15,0
  03F1    0196    CLR	0x16
  03F2    0008    RET
  03F3    0849    LD	A,0x49
  03F4    0080    LD	0x0,A
  03F5    0A84    INCR	0x4
  03F6    084A    LD	A,0x4A
  03F7    0080    LD	0x0,A
  03F8    0008    RET
  03F9    01D4    CLR	0x54
  03FA    01D2    CLR	0x52
  03FB    0AD2    INCR	0x52
  03FC    01D3    CLR	0x53
  03FD    0008    RET
  03FE    0DD2    RLCR	0x52
  03FF    0DD3    RLCR	0x53
  0400    0AD4    INCR	0x54
  0401    0254    SUBA	0x54
  0402    0008    RET
  078B    00F5    LD	0x75,A
  078C    01F6    CLR	0x76
  078D    01F7    CLR	0x77
  078E    0874    LD	A,0x74
  078F    02CC    SUBR	0x4C
  0790    0875    LD	A,0x75
  0791    1C03    SNZB	0x3,0
  0792    0F75    SZINCA	0x75
  0793    02CD    SUBR	0x4D
  0794    0876    LD	A,0x76
  0795    1C03    SNZB	0x3,0
  0796    0F76    SZINCA	0x76
  0797    02CE    SUBR	0x4E
  0798    0877    LD	A,0x77
  0799    0008    RET
  079A    01CC    CLR	0x4C
  079B    01CD    CLR	0x4D
  079C    01CE    CLR	0x4E
  079D    01CF    CLR	0x4F
  079E    01D0    CLR	0x50
  079F    01D1    CLR	0x51
  07A0    01D2    CLR	0x52
  07A1    01D3    CLR	0x53
  07A2    0008    RET
  07A3    085E    LD	A,0x5E
  07A4    00E2    LD	0x62,A
  07A5    085F    LD	A,0x5F
  07A6    00E3    LD	0x63,A
  07A7    0860    LD	A,0x60
  07A8    00E4    LD	0x64,A
  07A9    0008    RET
  07AA    01CF    CLR	0x4F
  07AB    01D0    CLR	0x50
  07AC    01D1    CLR	0x51
  07AD    0008    RET
  07AE    1003    CLRB	0x3,0
  07AF    0CF5    RRCR	0x75
  07B0    0CF4    RRCR	0x74
  07B1    0CF3    RRCR	0x73
  07B2    0008    RET
  07B3    0855    LD	A,0x55
  07B4    00D3    LD	0x53,A
  07B5    0854    LD	A,0x54
  07B6    00D2    LD	0x52,A
  07B7    0008    RET
  07F3    30E4    LDIA	0xE4
  07F4    1683    SETB	0x3,5
  07F5    0586    ANDR	0x6
  07F6    1283    CLRB	0x3,5
  07F7    1206    CLRB	0x6,4
  07F8    301B    LDIA	0x1B
  07F9    1683    SETB	0x3,5
  07FA    0485    ORR	0x5
  07FB    1283    CLRB	0x3,5
  07FC    1605    SETB	0x5,4
  07FD    0008    RET
  082E    343F    RET	0x3F
  082F    3406    RET	0x6
  0830    345B    RET	0x5B
  0831    344F    RET	0x4F
  0832    3466    RET	0x66
  0833    346D    RET	0x6D
  0834    347D    RET	0x7D
  0835    3407    RET	0x7
  0836    347F    RET	0x7F
  0837    346F    RET	0x6F
  0838    3471    RET	0x71
  0839    3479    RET	0x79
  083A    3450    RET	0x50
  083B    3401    RET	0x1
  083C    3402    RET	0x2
  083D    3404    RET	0x4
  083E    3408    RET	0x8
  083F    3410    RET	0x10
  0840    3420    RET	0x20
  0841    3440    RET	0x40
  0842    3480    RET	0x80
  0843    340A    RET	0xA
  0844    340A    RET	0xA
  0845    3402    RET	0x2
  0846    3402    RET	0x2
  0847    3442    RET	0x42
  0848    3443    RET	0x43
  0D7E    0064    CLRWDT
  0D7F    0180    CLR	0x0
  0D80    0A84    INCR	0x4
  0D81    0604    XORA	0x4
  0D82    1903    SZB	0x3,2
  0D83    3400    RET	0x0
  0D84    0604    XORA	0x4
  0D85    2D7F    JP	0x57F
  0F25    1283    CLRB	0x3,5
  0F26    1205    CLRB	0x5,4
  0F27    1606    SETB	0x6,4
  0F28    0008    RET
