---- E:\project\project0508\scm\uf166fan\main.c ----------------------------------------------------------------------
1:                #include "scankey.h"
2:                #include "init.h"
3:                #include "adc.h"
4:                
5:                #define MAX_FAN_LEVEL 4
6:                #define MIN_FAN_LEVEL 1
7:                
8:                #define FAN_STATUS_OFF  0
9:                #define FAN_STATUS_ON  1
10:               #define FAN_STATUS_NONE 2
11:               
12:               #define PBPORTB PORTA
13:               #define PBTRISB TRISA
14:               
15:               #define LED_1  1
16:               #define LED_2  2
17:               #define LED_3  3
18:               #define LED_4  4
19:               //1毫秒中断标志
20:               static unsigned char time0Flag = 0;
21:               static unsigned int countTime = 0;
22:               static unsigned int count10Ms = 0;
23:               unsigned char currentLevel = 3;
24:               //风扇状态
25:               unsigned char FAN_STATUS = FAN_STATUS_NONE;
26:               //检测风扇次数
27:               unsigned int fan_check_time = 0;
28:               //按键结构体
29:               struct Keys key1, key2, key3;
30:               //显示风扇挡位
31:               void setLedOn(unsigned char ledIndex);
32:               //初始化配置
33:               void Init_Config();
34:               //睡眠模式
35:               void Sleep_Mode();
36:               
37:               void checkUsbStatus() {
38:                   if (getbit(PORTB, 2) == 1) {
  02A8    0806    LD	A,0x6
  02A9    00F4    LD	0x74,A
  02AA    1003    CLRB	0x3,0
  02AB    0CF4    RRCR	0x74
  02AC    1003    CLRB	0x3,0
  02AD    0CF4    RRCR	0x74
  02AE    1C74    SNZB	0x74,0
  02AF    2AC2    JP	0x2C2
39:                       if (getbit(PORTB, 1) == 1) {
  02B0    0806    LD	A,0x6
  02B1    00F4    LD	0x74,A
  02B2    1003    CLRB	0x3,0
  02B3    0CF4    RRCR	0x74
  02B4    1C74    SNZB	0x74,0
  02B5    2AB8    JP	0x2B8
40:                           //充满了，Led常亮
41:                           resetbit(PORTA, 0);
  02B6    1005    CLRB	0x5,0
42:                       } else if (countTime == 1000) {
  02B7    0008    RET
  02B8    30E8    LDIA	0xE8
  02B9    062C    XORA	0x2C
  02BA    3003    LDIA	0x3
  02BB    1903    SZB	0x3,2
  02BC    062D    XORA	0x2D
  02BD    1D03    SNZB	0x3,2
  02BE    0008    RET
43:                           //充电中，一直闪		
44:                           reversebit(PORTA, 0);
  02BF    3001    LDIA	0x1
  02C0    0685    XORR	0x5
  02C1    0008    RET
45:                       }
46:                   } else {
47:                       //usb断开充电灯熄灭,PA0 = 1
48:                       setbit(PORTA, 0);
  02C2    1405    SETB	0x5,0
  02C3    0008    RET
49:                   }
50:               }
51:               
52:               void Init_PWM() {
53:                   CCP1CON = 0x0F;//设置PC2为PWM模式，4,5位为占空比的低2位
  030F    300F    LDIA	0xF
  0310    1283    CLRB	0x3,5
  0311    1303    CLRB	0x3,6
  037E    300F    LDIA	0xF
54:                   T2CON = 0; //时钟分频 1:1 PWM周期为（PR2+1）*4/8,000,000
55:                   PR2 = 7;
56:               
57:                   CCPR1L = 0;//占空比高8位，低2位设置为0，结果就是 占空比 = CCPR1L*4/4*(PR2+1)
58:                   TMR2IF = 0;
59:                   T2CON = 0;
60:                   //PC2设置为输出脚
61:                   resetbit(TRISC, 2);
  0312    2B13    JP	0x313
  037F    2B13    JP	0x313
62:                   //T2CON = 0X04 //启动定时器2，溢出后启动PWM
63:               }
64:               
65:               //设置风扇转速
66:               void setFanLevel(char level) {
  014A    00F5    LD	0x75,A
67:               	if(level == 0)
  014B    0875    LD	A,0x75
  014C    1D03    SNZB	0x3,2
  014D    2950    JP	0x150
68:               	{
69:               		currentLevel = 3;
  014E    3003    LDIA	0x3
  014F    00F8    LD	0x78,A
70:               	}
71:                   unsigned int levelWidth = (PR2 + 1) / MAX_FAN_LEVEL;
  0150    1683    SETB	0x3,5
  0151    0812    LD	A,0x12
  0152    1283    CLRB	0x3,5
  0153    00C8    LD	0x48,A
  0154    01C9    CLR	0x49
  0155    0AC8    INCR	0x48
  0156    1903    SZB	0x3,2
  0157    0AC9    INCR	0x49
  0158    3004    LDIA	0x4
  0159    00C6    LD	0x46,A
  015A    01C7    CLR	0x47
  015B    20C3    CALL	0xC3
72:                   char tempLevel = currentLevel + level;
  015C    0875    LD	A,0x75
  015D    0778    ADDA	0x78
  015E    00F6    LD	0x76,A
73:                   if (tempLevel > MAX_FAN_LEVEL) {
  015F    3005    LDIA	0x5
  0160    0276    SUBA	0x76
  0161    1C03    SNZB	0x3,0
  0162    2965    JP	0x165
74:                       tempLevel = MAX_FAN_LEVEL;
  0163    3004    LDIA	0x4
  0164    00F6    LD	0x76,A
75:                   }
76:               
77:                   if (tempLevel < MIN_FAN_LEVEL) {
  0165    0876    LD	A,0x76
  0166    1D03    SNZB	0x3,2
  0167    296A    JP	0x16A
78:                       tempLevel = MIN_FAN_LEVEL;
  0168    01F6    CLR	0x76
  0169    0AF6    INCR	0x76
79:                   }
80:               	
81:                   
82:                   if (FAN_STATUS == FAN_STATUS_ON) {
  016A    0B77    SZDECA	0x77
  016B    0008    RET
83:               		currentLevel = tempLevel;
  016C    0876    LD	A,0x76
  016D    00F8    LD	0x78,A
84:               		switch(currentLevel)
  016E    2978    JP	0x178
85:               		{
86:               			case 1:
87:               			CCPR1L = 1;
  016F    3001    LDIA	0x1
  0170    2976    JP	0x176
88:               			break;
89:               			case 2:
90:               			CCPR1L = 2;
  0171    3002    LDIA	0x2
  0172    2976    JP	0x176
91:               			break;
92:               			case 3:
93:               			CCPR1L = 3;
  0173    3003    LDIA	0x3
  0174    2976    JP	0x176
94:               			break;
95:               			case 4:
96:               			CCPR1L = 5;
  0175    3005    LDIA	0x5
  0176    0095    LD	0x15,A
97:               			break;
  0177    2986    JP	0x186
  0178    0878    LD	A,0x78
  0179    3A01    XORIA	0x1
  017A    1903    SZB	0x3,2
  017B    296F    JP	0x16F
  017C    3A03    XORIA	0x3
  017D    1903    SZB	0x3,2
  017E    2971    JP	0x171
  017F    3A01    XORIA	0x1
  0180    1903    SZB	0x3,2
  0181    2973    JP	0x173
  0182    3A07    XORIA	0x7
  0183    1903    SZB	0x3,2
  0184    2975    JP	0x175
  0185    2986    JP	0x186
98:               		}
99:                   //设置占宽比
100:              		//CCPR1L = levelWidth * currentLevel;
101:                      setLedOn(currentLevel);
  0186    0878    LD	A,0x78
  0187    2988    JP	0x188
102:                  }
103:              
104:              }
105:              
106:              //关闭风扇
107:              void closeFan() {
108:                  Init_PWM();
  032F    230F    CALL	0x30F
109:                  currentLevel = 2;
  0330    3002    LDIA	0x2
  0331    00F8    LD	0x78,A
110:                  setLedOn(5);
  0332    3005    LDIA	0x5
  0333    2188    CALL	0x188
111:                  setbit(PORTA, 0);
  0334    1283    CLRB	0x3,5
  0335    1405    SETB	0x5,0
112:                  //PWM输出脚设置为输入，关闭PWM
113:                  setbit(TRISC, 2);
  0336    1683    SETB	0x3,5
  0337    1507    SETB	0x7,2
114:                  fan_check_time = 0;
  0338    1283    CLRB	0x3,5
  0339    01A8    CLR	0x28
  033A    01A9    CLR	0x29
115:                  FAN_STATUS = FAN_STATUS_OFF;
  033B    01F7    CLR	0x77
  033C    0008    RET
116:                  //Sleep_Mode();
117:              }
118:              
119:              
120:              //检测风扇是否连接
121:              void checkFan() {
122:              	resetbit(TRISA, 1);
  01C1    1683    SETB	0x3,5
  01C2    1303    CLRB	0x3,6
  01C3    1085    CLRB	0x5,1
123:                  setbit(PORTA, 1);
  01C4    1283    CLRB	0x3,5
  01C5    1485    SETB	0x5,1
124:                  //PC2设置为输出脚
125:                  resetbit(TRISC, 2);
  01C6    1683    SETB	0x3,5
  01C7    1107    CLRB	0x7,2
126:              	setbit(PORTA, 2);
  01C8    1283    CLRB	0x3,5
  01C9    1505    SETB	0x5,2
127:                  T2CON = 0X04; //启动定时器2，溢出后启动PWM
  01CA    3004    LDIA	0x4
  01CB    0092    LD	0x12,A
128:              
129:                  //EN IN输出高电位，D1点亮，检测FAN DET，FAN DET为低电位则风扇正常工作，高电位则未连接
130:                  if (getbit(PORTB, 6) == 0) {
  01CC    0806    LD	A,0x6
  01CD    00CE    LD	0x4E,A
  01CE    3006    LDIA	0x6
  01CF    1003    CLRB	0x3,0
  01D0    0CCE    RRCR	0x4E
  01D1    3EFF    ADDIA	0xFF
  01D2    1D03    SNZB	0x3,2
  01D3    29CF    JP	0x1CF
  01D4    184E    SZB	0x4E,0
  01D5    29D9    JP	0x1D9
131:                      FAN_STATUS = FAN_STATUS_ON;
  01D6    01F7    CLR	0x77
  01D7    0AF7    INCR	0x77
132:                  } else {
  01D8    29DB    JP	0x1DB
133:                      FAN_STATUS = FAN_STATUS_NONE;
  01D9    3002    LDIA	0x2
  01DA    00F7    LD	0x77,A
134:                  }
135:              	
136:              	setFanLevel(0);
  01DB    3000    LDIA	0x0
  01DC    214A    CALL	0x14A
137:              
138:                  //没有检测到风扇
139:                  if (FAN_STATUS == FAN_STATUS_NONE) {
  01DD    3002    LDIA	0x2
  01DE    0677    XORA	0x77
  01DF    1D03    SNZB	0x3,2
  01E0    0008    RET
140:                      fan_check_time++;
  01E1    1283    CLRB	0x3,5
  01E2    0AA8    INCR	0x28
  01E3    1903    SZB	0x3,2
  01E4    0AA9    INCR	0x29
141:                      if (fan_check_time == 3000) {
  01E5    30B8    LDIA	0xB8
  01E6    0628    XORA	0x28
  01E7    300B    LDIA	0xB
  01E8    1903    SZB	0x3,2
  01E9    0629    XORA	0x29
  01EA    1D03    SNZB	0x3,2
  01EB    0008    RET
142:                          closeFan();
  01EC    2B2F    JP	0x32F
143:                          return;
144:                      }
145:                  }
146:              
147:              
148:              }
149:              
150:              
151:              //设置Led灯亮
152:              void setLedOn(unsigned char ledIndex) {
  0188    00F4    LD	0x74,A
153:                  switch(ledIndex) {
  0189    29A5    JP	0x1A5
154:                      case 1:
155:                          //PB7设置为输入脚,PC1和PC0设置为输出
156:              			resetbit(TRISC, 1);
157:              			setbit(PBTRISB, 7);
158:                          resetbit(TRISC, 0);
159:                          resetbit(PBPORTB, 7);
  018A    21B4    CALL	0x1B4
160:                          setbit(PORTC, 0);
  018B    1407    SETB	0x7,0
161:                          resetbit(PORTC, 1);            
  018C    1087    CLRB	0x7,1
162:                          break;
  018D    0008    RET
163:                      case 2:
164:              			resetbit(TRISC, 1);
165:              			setbit(PBTRISB, 7);
166:                          resetbit(TRISC, 0);
167:              			resetbit(PBPORTB, 7);
  018E    21B4    CALL	0x1B4
168:                          resetbit(PORTC, 0);
  018F    1007    CLRB	0x7,0
169:                          setbit(PORTC, 1);
  0190    1487    SETB	0x7,1
170:                          break;
  0191    0008    RET
171:                      case 3:
172:                          //PC0设置为输入脚，PB7和PC1设置为输出
173:              			setbit(TRISC, 0);
174:              			resetbit(PBTRISB, 7);
175:                          resetbit(TRISC, 1);
176:                          setbit(PBPORTB, 7);
  0192    21BB    CALL	0x1BB
  0193    1785    SETB	0x5,7
177:                          resetbit(PORTC, 0);
  0194    1007    CLRB	0x7,0
178:                          resetbit(PORTC, 1);
  0195    1087    CLRB	0x7,1
179:                          break;
  0196    0008    RET
180:                      case 4:
181:              			setbit(TRISC, 0);
182:              			resetbit(PBTRISB, 7);
183:                          resetbit(TRISC, 1);
184:                          resetbit(PBPORTB, 7);
  0197    21BB    CALL	0x1BB
  0198    1385    CLRB	0x5,7
185:                          setbit(PORTC, 0);
  0199    1407    SETB	0x7,0
186:                          setbit(PORTC, 1);
  019A    1487    SETB	0x7,1
187:                          break;
  019B    0008    RET
188:                      case 5:
189:                          //全部设置为输入脚
190:              			setbit(TRISC, 0);
  019C    1683    SETB	0x3,5
  019D    1407    SETB	0x7,0
191:              			setbit(PBTRISB, 7);
  019E    1785    SETB	0x5,7
192:                          setbit(TRISC, 1);
  019F    1487    SETB	0x7,1
193:              			resetbit(PORTC, 0);
  01A0    1283    CLRB	0x3,5
  01A1    1007    CLRB	0x7,0
194:              			resetbit(PBPORTB, 7);
  01A2    1385    CLRB	0x5,7
195:                          resetbit(PORTC, 1);
  01A3    1087    CLRB	0x7,1
196:                          break;
  01A4    0008    RET
  01A5    0874    LD	A,0x74
  01A6    3EFF    ADDIA	0xFF
  01A7    1C03    SNZB	0x3,0
  01A8    0008    RET
  01A9    0084    LD	0x4,A
  01AA    3005    LDIA	0x5
  01AB    0204    SUBA	0x4
  01AC    1803    SZB	0x3,0
  01AD    0008    RET
  01AE    3003    LDIA	0x3
  01AF    008A    LD	0xA,A
  01B0    3072    LDIA	0x72
  01B1    0704    ADDA	0x4
  01B2    0082    LD	0x2,A
  01B3    0008    RET
197:                  }
198:              }
199:              
200:              
201:              //扫描按键
202:              void scanKeys() {
203:                  key1.key_addr_result = key2.key_addr_result = key3.key_addr_result = PORTB;
  02ED    1283    CLRB	0x3,5
  02EE    1303    CLRB	0x3,6
  02EF    0806    LD	A,0x6
  02F0    00B6    LD	0x36,A
  02F1    00BD    LD	0x3D,A
  02F2    00C4    LD	0x44,A
204:                  sacnKeyInput(&key1);
  02F3    303F    LDIA	0x3F
  02F4    226E    CALL	0x26E
205:                  sacnKeyInput(&key2);
  02F5    3038    LDIA	0x38
  02F6    226E    CALL	0x26E
206:                  sacnKeyInput(&key3);
  02F7    3031    LDIA	0x31
  02F8    226E    CALL	0x26E
207:                  countTime++;
  02F9    1283    CLRB	0x3,5
  02FA    1303    CLRB	0x3,6
  02FB    0AAC    INCR	0x2C
  02FC    1903    SZB	0x3,2
  02FD    0AAD    INCR	0x2D
  02FE    0008    RET
208:                 
209:              }
210:              
211:              //检测按键状态并处理
212:              void checkKeys() {
213:                  if (key_driver(&key1) == key_click) {
  01ED    303F    LDIA	0x3F
  01EE    2108    CALL	0x108
  01EF    3A01    XORIA	0x1
  01F0    1D03    SNZB	0x3,2
  01F1    29F8    JP	0x1F8
214:                      //检测到按键了，检测风扇是否存在
215:              
216:                      if (FAN_STATUS == FAN_STATUS_ON) {
  01F2    0B77    SZDECA	0x77
  01F3    29F5    JP	0x1F5
217:                          //关闭风扇
218:                          closeFan();
  01F4    2B2F    JP	0x32F
219:                      } else {
220:                          FAN_STATUS = FAN_STATUS_NONE;
  01F5    3002    LDIA	0x2
  01F6    00F7    LD	0x77,A
221:                          checkFan();
  01F7    29C1    JP	0x1C1
  01F8    3002    LDIA	0x2
  01F9    0677    XORA	0x77
  01FA    1D03    SNZB	0x3,2
  01FB    29FD    JP	0x1FD
222:                      }
223:                      return;
224:                  } else if (FAN_STATUS == FAN_STATUS_NONE) {
225:                      checkFan();
  01FC    21C1    CALL	0x1C1
226:                  }
227:              
228:              	unsigned char key2Status = key_driver(&key2);
  01FD    3038    LDIA	0x38
  01FE    2108    CALL	0x108
  01FF    1283    CLRB	0x3,5
  0200    1303    CLRB	0x3,6
  0201    00CF    LD	0x4F,A
229:                  if (key2Status == key_click) {
  0202    0B4F    SZDECA	0x4F
  0203    2A06    JP	0x206
230:                      //加档
231:                      setFanLevel(1);
  0204    3001    LDIA	0x1
  0205    294A    JP	0x14A
232:                      return;
233:                  }
234:              	unsigned char key3Status = key_driver(&key3);
  0206    3031    LDIA	0x31
  0207    2108    CALL	0x108
  0208    1283    CLRB	0x3,5
  0209    1303    CLRB	0x3,6
  020A    00D0    LD	0x50,A
235:                  if (key3Status == key_click) {
  020B    0B50    SZDECA	0x50
  020C    0008    RET
236:                      //减档
237:                      setFanLevel(-1);
  020D    30FF    LDIA	0xFF
  020E    294A    JP	0x14A
238:                      return;
239:                  }
240:              
241:              }
242:              
243:              
244:              void main(void) {
245:              	Sleep_Mode();
  020F    2230    CALL	0x230
246:                  Init_Config();
  0210    2348    CALL	0x348
247:                  while (1) {
248:                      //0.1毫秒检测一次
249:                      if (time0Flag) {
  0211    0879    LD	A,0x79
  0212    1903    SZB	0x3,2
  0213    2A1A    JP	0x21A
  0214    0064    CLRWDT
250:                          asm("clrwdt");
251:                          time0Flag = 0;
  0215    01F9    CLR	0x79
252:              			scanKeys();
  0216    22ED    CALL	0x2ED
253:                          count10Ms++;
  0217    0AAA    INCR	0x2A
  0218    1903    SZB	0x3,2
  0219    0AAB    INCR	0x2B
254:                      }
255:              
256:                      //10毫秒检测一次
257:                      if (count10Ms == 100) {		
  021A    3064    LDIA	0x64
  021B    1283    CLRB	0x3,5
  021C    062A    XORA	0x2A
  021D    042B    ORA	0x2B
  021E    1D03    SNZB	0x3,2
  021F    2A26    JP	0x226
258:                          checkKeys();
  0220    21ED    CALL	0x1ED
259:                          count10Ms = 0;
  0221    1283    CLRB	0x3,5
  0222    01AA    CLR	0x2A
  0223    01AB    CLR	0x2B
260:                          //检测USB状态
261:                          checkUsbStatus();
  0224    22A8    CALL	0x2A8
262:              			//检测内部电压
263:              			readVrefADC();
  0225    236C    CALL	0x36C
264:                      }
265:              
266:                      if (countTime == 1000) {
  0226    30E8    LDIA	0xE8
  0227    062C    XORA	0x2C
  0228    3003    LDIA	0x3
  0229    1903    SZB	0x3,2
  022A    062D    XORA	0x2D
  022B    1D03    SNZB	0x3,2
  022C    2A11    JP	0x211
267:                          countTime = 0;
  022D    01AC    CLR	0x2C
  022E    01AD    CLR	0x2D
  022F    2A11    JP	0x211
268:                      }
269:              		
270:                  }
271:              
272:              }
273:              
274:              void Init_Config() {
275:              
276:                  Init_System();
  024F    2353    CALL	0x353
  0348    237B    CALL	0x37B
277:                  Init_GPIO();
  0250    2381    CALL	0x381
  0349    22DA    CALL	0x2DA
278:                  Init_Interupt();
  0251    2380    CALL	0x380
  034A    2365    CALL	0x365
279:                  Init_PWM();
  0252    237E    CALL	0x37E
  034B    230F    CALL	0x30F
280:                  //设置唤醒
281:                  IOCB = 0x04;
282:                  TMR0 = 155;
283:                  TO = 0;
284:              
285:                  //K1开关
286:                  key1.key_index = 5;
287:                  //K2加档
288:                  key2.key_index = 4;
289:                  //K3减档
290:                  key3.key_index = 3;
291:                  resetKey(&key1);
  0253    225A    CALL	0x25A
  0254    231F    CALL	0x31F
  034C    225A    CALL	0x25A
  034D    22FF    CALL	0x2FF
292:                  resetKey(&key2);
  0255    3038    LDIA	0x38
  0256    231F    CALL	0x31F
  034E    3038    LDIA	0x38
  034F    22FF    CALL	0x2FF
293:                  resetKey(&key3);
  0257    3031    LDIA	0x31
  0258    231F    CALL	0x31F
  0350    3031    LDIA	0x31
  0351    22FF    CALL	0x2FF
294:                  //设置IO方向
295:                  TRISA = 0;
296:                  TRISB = 0x7E;//1-6脚输入
297:                  TRISC = 0;
  0259    2A67    JP	0x267
  0352    2A67    JP	0x267
298:              }
299:              
300:              
301:              void Sleep_Mode() {
302:                  INTCON = 0;
  0230    018B    CLR	0xB
303:              
304:                  OPTION_REG = 0;
  0231    1683    SETB	0x3,5
  0232    0181    CLR	0x1
305:              
306:                  TRISA = 0B00000000;        //关闭所有输出
  0233    0185    CLR	0x5
307:                  PORTA = 0B00000000;
  0234    1283    CLRB	0x3,5
  0235    0185    CLR	0x5
308:                  WPUA = 0B00000000;
  0236    1683    SETB	0x3,5
  0237    1703    SETB	0x3,6
  0238    018E    CLR	0xE
309:              
310:                  TRISB = 0B00100000;
  0239    3020    LDIA	0x20
  023A    1303    CLRB	0x3,6
  023B    0086    LD	0x6,A
311:                  PORTB = 0B00000000;
  023C    1283    CLRB	0x3,5
  023D    0186    CLR	0x6
312:              
313:                  PORTB = 0;
  023E    0186    CLR	0x6
314:                  WPUB = 0B00100000;         //RB3 上拉
  023F    1683    SETB	0x3,5
  0240    0095    LD	0x15,A
315:              
316:                  IOCB = 0B00100000;            //允许RB3的IO口电平变化中断
  0241    0096    LD	0x16,A
317:                  RBIE = 1;                    //允许PORTB电平变化中断
  0242    158B    SETB	0xB,3
318:                  GIE = 1;                    //GIE = 0时，唤醒后执行SLEEP后程序;GIE = 1时，唤醒后跳至中断服务
  0243    178B    SETB	0xB,7
319:              
320:                  ADCON0 = 0;                    //关闭所有模块
  0244    1283    CLRB	0x3,5
  0245    019F    CLR	0x1F
321:              
322:                  OSCCON = 0X70;                //配置振荡为16M,关闭WDT
  0246    3070    LDIA	0x70
  0247    1683    SETB	0x3,5
  0248    008F    LD	0xF,A
323:              
324:                  PORTB;                        //读PORTB值并锁存			
  0249    1283    CLRB	0x3,5
  024A    0806    LD	A,0x6
  024B    0064    CLRWDT
  024C    0063    STOP
  024D    0000    NOP
  024E    0008    RET
325:                  asm("clrwdt");
326:              
327:                  asm("sleep");                //进入休眠模式
328:              
329:                  asm("nop");
330:              
331:              
332:              }
333:              
334:              
335:              /***********************************************
336:              函数名称：Timer0_Isr
337:              函数功能：中断服务
338:              入口参数：无
339:              出口参数：无
340:              备注：
341:              ***********************************************/
342:              void interrupt
343:              
344:              Timer0_Isr() {
345:                  if (T0IF) {
  02C4    1D0B    SNZB	0xB,2
  02C5    2ACD    JP	0x2CD
346:                      //---------------------------------------
347:                      TMR0 += 155;        //重新赋初值，在赋值前Timer0已有计数，故在该基础上加初值
  02C6    309B    LDIA	0x9B
  02C7    1283    CLRB	0x3,5
  02C8    1303    CLRB	0x3,6
  02C9    0781    ADDR	0x1
348:                      //---------------------------------------
349:              
350:                      T0IF = 0;            //清中断标志位	
  02CA    110B    CLRB	0xB,2
351:                      time0Flag = 1;
  02CB    01F9    CLR	0x79
  02CC    0AF9    INCR	0x79
352:              
353:                  }
354:              
355:                  if (RBIF) {
  02CD    1C0B    SNZB	0xB,0
  02CE    2AD1    JP	0x2D1
356:                      RBIF = 0;            //清中断标志
  02CF    100B    CLRB	0xB,0
357:                      Init_Config();
  02D0    224F    CALL	0x24F
  02D1    0873    LD	A,0x73
  02D2    008A    LD	0xA,A
  02D3    0872    LD	A,0x72
  02D4    0084    LD	0x4,A
  02D5    0E71    SWAPA	0x71
  02D6    0083    LD	0x3,A
  02D7    0EFE    SWAPR	0x7E
  02D8    0E7E    SWAPA	0x7E
  02D9    0009    RETI
358:                  }
359:              }
360:              
361:              
362:              
---- E:\project\project0508\scm\uf166fan\scankey.c ----------------------------------------------------------------------
1:                #include "scankey.h"
2:                
3:                void sacnKeyInput(struct Keys *key) {
  026E    00F6    LD	0x76,A
4:                    key->key_input = getbit(key->key_addr_result, key->key_index);
  026F    3E05    ADDIA	0x5
  0270    0084    LD	0x4,A
  0271    1383    CLRB	0x3,7
  0272    0800    LD	A,0x0
  0273    00F4    LD	0x74,A
  0274    0876    LD	A,0x76
  0275    3E06    ADDIA	0x6
  0276    0084    LD	0x4,A
  0277    0A00    INCA	0x0
  0278    2A7B    JP	0x27B
  0279    1003    CLRB	0x3,0
  027A    0CF4    RRCR	0x74
  027B    3EFF    ADDIA	0xFF
  027C    1D03    SNZB	0x3,2
  027D    2A79    JP	0x279
  027E    0874    LD	A,0x74
  027F    00F5    LD	0x75,A
  0280    0876    LD	A,0x76
  0281    3E04    ADDIA	0x4
  0282    0084    LD	0x4,A
  0283    0875    LD	A,0x75
  0284    0080    LD	0x0,A
  0285    0876    LD	A,0x76
  0286    3E04    ADDIA	0x4
  0287    0084    LD	0x4,A
  0288    3001    LDIA	0x1
  0289    0580    ANDR	0x0
  028A    0008    RET
5:                
6:                }
7:                
8:                
9:                unsigned char key_driver(struct Keys *key) {
  0108    00F6    LD	0x76,A
10:               
11:               
12:                   unsigned char key_return = key_no;
  0109    01F4    CLR	0x74
13:                   unsigned char key_read = key->key_input;  //read the I/O states
  010A    3E04    ADDIA	0x4
  010B    0084    LD	0x4,A
  010C    1383    CLRB	0x3,7
  010D    0800    LD	A,0x0
  010E    00F5    LD	0x75,A
14:               
15:                   switch (key->key_state_buffer1) {
  010F    293B    JP	0x13B
16:                       case key_state_0:
17:                           if (key_read == 0) {
  0110    0875    LD	A,0x75
  0111    1D03    SNZB	0x3,2
  0112    2948    JP	0x148
18:                               key->key_state_buffer1 = key_state_1;
  0113    0A76    INCA	0x76
  0114    0084    LD	0x4,A
  0115    0180    CLR	0x0
  0116    0A80    INCR	0x0
  0117    2948    JP	0x148
19:                           }
20:               
21:                           //按键被按下，状态转换到按键消抖和确认状态//
22:                           break;
23:               
24:                       case key_state_1:
25:                           if (key_read == 0) {
  0118    0875    LD	A,0x75
  0119    1D03    SNZB	0x3,2
  011A    2937    JP	0x137
26:                               key->key_timer_cnt1 = 0;
  011B    0876    LD	A,0x76
  011C    0084    LD	0x4,A
  011D    0180    CLR	0x0
27:                               key->key_state_buffer1 = key_state_2;
  011E    0A76    INCA	0x76
  011F    0084    LD	0x4,A
  0120    3002    LDIA	0x2
  0121    2933    JP	0x133
28:                               //按键仍然处于按下状态
29:                               //消抖完成，key_timer开始准备计时
30:                               //状态切换到按下时间计时状态
31:                           } else {
32:                               key->key_state_buffer1 = key_state_0;
33:                           }
34:               
35:                           //按键已经抬起，回到按键初始状态
36:                           break;  //完成软件消抖
37:               
38:                       case key_state_2:
39:                           if (key_read == 1) {
  0122    0B75    SZDECA	0x75
  0123    2927    JP	0x127
40:                               key_return = key_click;  //按键抬起，产生一次click操作
  0124    01F4    CLR	0x74
  0125    0AF4    INCR	0x74
  0126    2937    JP	0x137
41:                               key->key_state_buffer1 = key_state_0;  //转换到按键初始状态
  0127    0876    LD	A,0x76
  0128    0084    LD	0x4,A
  0129    3064    LDIA	0x64
  012A    0A80    INCR	0x0
  012B    0200    SUBA	0x0
  012C    1C03    SNZB	0x3,0
  012D    2948    JP	0x148
42:                           } else if (++(key->key_timer_cnt1) >= 100)  //按键继续按下，计时超过1000ms
43:                           {
44:                               key_return = key_long;  //送回长按事件
  012E    3003    LDIA	0x3
  012F    00F4    LD	0x74,A
45:                               key->key_state_buffer1 = key_state_3;  //转换到等待按键释放状态
  0130    0A76    INCA	0x76
  0131    0084    LD	0x4,A
  0132    3003    LDIA	0x3
  0133    0080    LD	0x0,A
  0134    2948    JP	0x148
46:               
47:                           }
48:                           break;
49:               
50:                       case key_state_3:  //等待按键释放
51:                           if (key_read == 1)  //按键释放
  0135    0B75    SZDECA	0x75
  0136    2948    JP	0x148
52:                           {
53:                               key->key_state_buffer1 = key_state_0;  //切回按键初始状态
  0137    0A76    INCA	0x76
  0138    0084    LD	0x4,A
  0139    0180    CLR	0x0
  013A    2948    JP	0x148
  013B    0A76    INCA	0x76
  013C    0084    LD	0x4,A
  013D    0800    LD	A,0x0
  013E    0084    LD	0x4,A
  013F    3004    LDIA	0x4
  0140    0204    SUBA	0x4
  0141    1803    SZB	0x3,0
  0142    2948    JP	0x148
  0143    3003    LDIA	0x3
  0144    008A    LD	0xA,A
  0145    3077    LDIA	0x77
  0146    0704    ADDA	0x4
  0147    0082    LD	0x2,A
54:                           }
55:               
56:                           break;
57:                   }
58:                   return key_return;
  0148    0874    LD	A,0x74
  0149    0008    RET
59:               }
60:               
61:               /***************************************************************************
62:               函数功能：中层按键处理函数，调用底层函数一次，处理双击事件的判断，
63:                                                       返回上层正确的无键、单击、双击、长按四种状态
64:               本函数由上层循环调用，间隔10ms
65:               ***************************************************************************/
66:               unsigned char key_read(struct Keys *key) {
67:               
68:                   unsigned char key_return = key_no;
69:                   unsigned char key_read = key_driver(key);
70:               //    printf("IO:%d  key status: %d\n",getSimpleKeyInput(key_input),key);
71:                   switch (key->key_state_buffer2) {
72:                       case key_state_0:
73:                           if (key_read == key_click) {
74:                               key->key_timer_cnt2 = 0;  //第一次单击，不返回，到下个状态判断是否会出现双击
75:                               key->key_state_buffer2 = key_state_1;
76:                           } else
77:                               key_return = key_read;  //对于无键、长按，返回原事件
78:                           break;
79:               
80:                       case key_state_1:
81:                           if (key_read == key_click)  //又一次单击，时间间隔小于500ms
82:                           {
83:                               key_return = key_double;  //返回双击事件，回到初始状态
84:                               key->key_state_buffer2 = key_state_0;
85:                           } else if (++(key->key_timer_cnt2) >= 50) {
86:                               //这里500ms内肯定读到的都是无键事件，因为长按大于1000ms
87:                               //在1s前底层返回的都是无键
88:               
89:                               key_return = key_click;  //500ms内没有再次出现单击事件，返回单击事件
90:                               key->key_state_buffer2 = key_state_0;  //返回初始状态
91:               
92:                           }
93:                           break;
94:                   }
95:               
96:                   return key_return;
97:               }
98:               
99:               
100:              void resetKey(struct Keys *key) {
  02FF    00F4    LD	0x74,A
  031F    00F0    LD	0x70,A
101:                  key->key_timer_cnt1 = key->key_timer_cnt2 = key->key_state_buffer1 = key->key_state_buffer2 = 0;
  0300    3E03    ADDIA	0x3
  0301    0084    LD	0x4,A
  0302    1383    CLRB	0x3,7
  0303    0180    CLR	0x0
  0304    0A74    INCA	0x74
  0305    0084    LD	0x4,A
  0306    0180    CLR	0x0
  0307    0874    LD	A,0x74
  0308    3E02    ADDIA	0x2
  0309    0084    LD	0x4,A
  030A    0180    CLR	0x0
  030B    0874    LD	A,0x74
  030C    0084    LD	0x4,A
  030D    0180    CLR	0x0
  030E    0008    RET
  0320    3E03    ADDIA	0x3
  0321    0084    LD	0x4,A
  0322    1383    CLRB	0x3,7
  0323    0180    CLR	0x0
  0324    0A70    INCA	0x70
  0325    0084    LD	0x4,A
  0326    0180    CLR	0x0
  0327    0870    LD	A,0x70
  0328    3E02    ADDIA	0x2
  0329    0084    LD	0x4,A
  032A    0180    CLR	0x0
  032B    0870    LD	A,0x70
  032C    0084    LD	0x4,A
  032D    0180    CLR	0x0
  032E    0008    RET
102:              }
---- E:\project\project0508\scm\uf166fan\adc.c ----------------------------------------------------------------------
1:                #include "adc.h"
2:                
3:                /**********************************************************
4:                函数名称：AD_Sample
5:                函数功能：AD检测
6:                入口参数：adch - 检测通道
7:                出口参数：无 
8:                备    注：采样通道需自行设置为模拟口
9:                	      采样10次,取中间八次的平均值为采样结果存于adresult中
10:               **********************************************************/
11:               void ADC_Sample(unsigned char adch)
  0019    00CA    LD	0x4A,A
12:               {
13:               	static unsigned long adsum = 0;
14:               	static unsigned int admin = 0,admax = 0;
15:               	static unsigned char adtimes = 0;
16:               	volatile unsigned int ad_temp;
17:               	ADCON1 = 0;						//左对齐
  001A    1683    SETB	0x3,5
  001B    019F    CLR	0x1F
18:               	ADCON0 = 0X41 | (adch << 2);	//16分频
  001C    1283    CLRB	0x3,5
  001D    084A    LD	A,0x4A
  001E    00C6    LD	0x46,A
  001F    3001    LDIA	0x1
  0020    1003    CLRB	0x3,0
  0021    0DC6    RLCR	0x46
  0022    3EFF    ADDIA	0xFF
  0023    1003    CLRB	0x3,0
  0024    1D03    SNZB	0x3,2
  0025    2821    JP	0x21
  0026    0D46    RLCA	0x46
  0027    3841    ORIA	0x41
  0028    009F    LD	0x1F,A
  0029    0000    NOP
  002A    0000    NOP
19:               	asm("nop");
20:               	asm("nop");
21:               	GODONE = 1;						//开始转换
  002B    1283    CLRB	0x3,5
  002C    1303    CLRB	0x3,6
  002D    149F    SETB	0x1F,1
22:               
23:               	unsigned char i = 0;
  002E    01CB    CLR	0x4B
24:               	while(GODONE)
  002F    1C9F    SNZB	0x1F,1
  0030    2834    JP	0x34
25:               	{
26:               		if(0 == (--i))
  0031    0BCB    SZDECR	0x4B
  0032    282F    JP	0x2F
  0033    0008    RET
27:               			return;
28:               	}
29:               	
30:               	ad_temp=(ADRESH<<4)+(ADRESL>>4);	//计算12位AD值
  0034    081E    LD	A,0x1E
  0035    00CC    LD	0x4C,A
  0036    01CD    CLR	0x4D
  0037    0ECC    SWAPR	0x4C
  0038    0ECD    SWAPR	0x4D
  0039    30F0    LDIA	0xF0
  003A    05CD    ANDR	0x4D
  003B    084C    LD	A,0x4C
  003C    390F    ANDIA	0xF
  003D    04CD    ORR	0x4D
  003E    30F0    LDIA	0xF0
  003F    05CC    ANDR	0x4C
  0040    1683    SETB	0x3,5
  0041    0E1E    SWAPA	0x1E
  0042    390F    ANDIA	0xF
  0043    1283    CLRB	0x3,5
  0044    07CC    ADDR	0x4C
  0045    1803    SZB	0x3,0
  0046    0ACD    INCR	0x4D
31:               	
32:               	if(0 == admax)
  0047    0824    LD	A,0x24
  0048    0425    ORA	0x25
  0049    1D03    SNZB	0x3,2
  004A    284D    JP	0x4D
33:               	{
34:               		admax = ad_temp;
  004B    20BE    CALL	0xBE
  004C    285F    JP	0x5F
35:               		admin = ad_temp;
36:               	}
37:               	else if(ad_temp > admax)
  004D    084D    LD	A,0x4D
  004E    0225    SUBA	0x25
  004F    1D03    SNZB	0x3,2
  0050    2853    JP	0x53
  0051    084C    LD	A,0x4C
  0052    0224    SUBA	0x24
  0053    1803    SZB	0x3,0
  0054    2857    JP	0x57
38:               		admax = ad_temp;				//AD采样最大值
  0055    20BE    CALL	0xBE
  0056    2863    JP	0x63
39:               	else if(ad_temp < admin)
  0057    0827    LD	A,0x27
  0058    024D    SUBA	0x4D
  0059    1D03    SNZB	0x3,2
  005A    285D    JP	0x5D
  005B    0826    LD	A,0x26
  005C    024C    SUBA	0x4C
  005D    1803    SZB	0x3,0
  005E    2863    JP	0x63
40:               		admin = ad_temp;				//AD采样最小值
  005F    084D    LD	A,0x4D
  0060    00A7    LD	0x27,A
  0061    084C    LD	A,0x4C
  0062    00A6    LD	0x26,A
41:               	
42:               	adsum += ad_temp;
  0063    084C    LD	A,0x4C
  0064    00C6    LD	0x46,A
  0065    084D    LD	A,0x4D
  0066    00C7    LD	0x47,A
  0067    01C8    CLR	0x48
  0068    01C9    CLR	0x49
  0069    0846    LD	A,0x46
  006A    07A0    ADDR	0x20
  006B    0847    LD	A,0x47
  006C    1103    CLRB	0x3,2
  006D    1803    SZB	0x3,0
  006E    3E01    ADDIA	0x1
  006F    1D03    SNZB	0x3,2
  0070    07A1    ADDR	0x21
  0071    0848    LD	A,0x48
  0072    1103    CLRB	0x3,2
  0073    1803    SZB	0x3,0
  0074    3E01    ADDIA	0x1
  0075    1D03    SNZB	0x3,2
  0076    07A2    ADDR	0x22
  0077    0849    LD	A,0x49
  0078    1103    CLRB	0x3,2
  0079    1803    SZB	0x3,0
  007A    3E01    ADDIA	0x1
  007B    1D03    SNZB	0x3,2
  007C    07A3    ADDR	0x23
43:               	if(++adtimes >= 10)
  007D    300A    LDIA	0xA
  007E    0AB0    INCR	0x30
  007F    0230    SUBA	0x30
  0080    1C03    SNZB	0x3,0
  0081    0008    RET
44:               	{
45:               		adsum -= admax;
  0082    0824    LD	A,0x24
  0083    00C6    LD	0x46,A
  0084    0825    LD	A,0x25
  0085    20AF    CALL	0xAF
  0086    1C03    SNZB	0x3,0
  0087    0F49    SZINCA	0x49
  0088    02A3    SUBR	0x23
46:               		adsum -= admin;
  0089    0826    LD	A,0x26
  008A    00C6    LD	0x46,A
  008B    0827    LD	A,0x27
  008C    20AF    CALL	0xAF
  008D    1C03    SNZB	0x3,0
  008E    0F49    SZINCA	0x49
  008F    02A3    SUBR	0x23
47:               		
48:               		adresult = adsum >> 3;		//8次平均值作为最终结果
  0090    0820    LD	A,0x20
  0091    00C6    LD	0x46,A
  0092    0821    LD	A,0x21
  0093    00C7    LD	0x47,A
  0094    0822    LD	A,0x22
  0095    00C8    LD	0x48,A
  0096    0823    LD	A,0x23
  0097    00C9    LD	0x49,A
  0098    3003    LDIA	0x3
  0099    1003    CLRB	0x3,0
  009A    0CC9    RRCR	0x49
  009B    0CC8    RRCR	0x48
  009C    0CC7    RRCR	0x47
  009D    0CC6    RRCR	0x46
  009E    3EFF    ADDIA	0xFF
  009F    1D03    SNZB	0x3,2
  00A0    2899    JP	0x99
  00A1    0847    LD	A,0x47
  00A2    00AF    LD	0x2F,A
  00A3    0846    LD	A,0x46
  00A4    00AE    LD	0x2E,A
49:               		
50:               		adsum = 0;
  00A5    01A0    CLR	0x20
  00A6    01A1    CLR	0x21
  00A7    01A2    CLR	0x22
  00A8    01A3    CLR	0x23
51:               		admin = 0;
  00A9    01A6    CLR	0x26
  00AA    01A7    CLR	0x27
52:               		admax = 0;
  00AB    01A4    CLR	0x24
  00AC    01A5    CLR	0x25
53:               		adtimes = 0;
  00AD    01B0    CLR	0x30
  00AE    0008    RET
54:               	}
55:               }
56:               
57:               
58:               //ADC单次采样
59:               unsigned char ADC_Result(unsigned char adch)
  028B    00F5    LD	0x75,A
60:               {
61:               	ADCON1 = 0;						//左对齐
  028C    1683    SETB	0x3,5
  028D    019F    CLR	0x1F
62:               	ADCON0 = 0X41 | (adch << 2);	//16分频
  028E    0875    LD	A,0x75
  028F    00F4    LD	0x74,A
  0290    3001    LDIA	0x1
  0291    1003    CLRB	0x3,0
  0292    0DF4    RLCR	0x74
  0293    3EFF    ADDIA	0xFF
  0294    1003    CLRB	0x3,0
  0295    1D03    SNZB	0x3,2
  0296    2A92    JP	0x292
  0297    0D74    RLCA	0x74
  0298    3841    ORIA	0x41
  0299    1283    CLRB	0x3,5
  029A    009F    LD	0x1F,A
  029B    0000    NOP
  029C    0000    NOP
63:               	asm("nop");
64:               	asm("nop");
65:               	GODONE = 1;						//开始转换
  029D    1283    CLRB	0x3,5
  029E    1303    CLRB	0x3,6
  029F    149F    SETB	0x1F,1
66:               
67:               	unsigned char i = 0;
  02A0    01F6    CLR	0x76
68:               	while(GODONE)
  02A1    1C9F    SNZB	0x1F,1
  02A2    2AA6    JP	0x2A6
69:               	{
70:               		if(0 == (--i))
  02A3    0BF6    SZDECR	0x76
  02A4    2AA1    JP	0x2A1
71:               			return 0;				//转换超时
  02A5    3400    RET	0x0
72:               	}
73:               	return ADRESH;
  02A6    081E    LD	A,0x1E
  02A7    0008    RET
74:               }
75:               /***********************************************************
76:               函数名称：DelayXms
77:               函数功能：毫秒级非精准延时
78:               入口参数：x - 延时时间
79:               出口参数：
80:               备    注：
81:               ***********************************************************/
82:               void DelayXms(unsigned char x)
  033D    00F4    LD	0x74,A
83:               {
84:               	unsigned char i,j;
85:               	for(i=x;i>0;i--)
  033E    00F5    LD	0x75,A
  033F    0875    LD	A,0x75
  0340    1903    SZB	0x3,2
  0341    0008    RET
86:               		for(j=153;j>0;j--);
  0342    3099    LDIA	0x99
  0343    00F6    LD	0x76,A
  0344    0BF6    SZDECR	0x76
  0345    2B44    JP	0x344
  0346    03F5    DECR	0x75
  0347    2B3F    JP	0x33F
87:               }
88:               
89:               //读取内部电压
90:               unsigned char readVrefADC()
91:               {
92:               	DelayXms(1);
  036C    3001    LDIA	0x1
  036D    233D    CALL	0x33D
93:               	ADC_Sample(15);
  036E    300F    LDIA	0xF
  036F    2019    CALL	0x19
  0370    300F    LDIA	0xF
  0371    2A8B    JP	0x28B
94:               	unsigned char result;
95:               		
96:               	result = ADC_Result(15);
97:               	return result;
98:               }
---- E:\cms\SCMCU_IDE_V2.00.07\data\sources\common\awdiv.c ----------------------------------------------------------------------
1:                // integer signed division
2:                
3:                signed int
4:                #ifdef __PICC__
5:                #warning TODO: update cgpic and this file to use the other prototype
6:                __awdiv(signed int divisor, signed int dividend)
  00C3    01CB    CLR	0x4B
  00C4    1FC7    SNZB	0x47,7
  00C5    28CD    JP	0xCD
  00C6    09C6    COMR	0x46
  00C7    09C7    COMR	0x47
  00C8    0AC6    INCR	0x46
  00C9    1903    SZB	0x3,2
  00CA    0AC7    INCR	0x47
  00CB    01CB    CLR	0x4B
  00CC    0ACB    INCR	0x4B
  00CD    1FC9    SNZB	0x49,7
  00CE    28D6    JP	0xD6
  00CF    09C8    COMR	0x48
  00D0    09C9    COMR	0x49
  00D1    0AC8    INCR	0x48
  00D2    1903    SZB	0x3,2
  00D3    0AC9    INCR	0x49
  00D4    3001    LDIA	0x1
  00D5    06CB    XORR	0x4B
  00D6    01CC    CLR	0x4C
  00D7    01CD    CLR	0x4D
  00D8    0846    LD	A,0x46
  00D9    0447    ORA	0x47
  00DA    1903    SZB	0x3,2
  00DB    28FB    JP	0xFB
  00DC    01CA    CLR	0x4A
  00DD    0ACA    INCR	0x4A
  00DE    1BC7    SZB	0x47,7
  00DF    28E4    JP	0xE4
  00E0    1003    CLRB	0x3,0
  00E1    0DC6    RLCR	0x46
  00E2    0DC7    RLCR	0x47
  00E3    28DD    JP	0xDD
  00E4    1003    CLRB	0x3,0
  00E5    0DCC    RLCR	0x4C
  00E6    0DCD    RLCR	0x4D
  00E7    0847    LD	A,0x47
  00E8    0249    SUBA	0x49
  00E9    1D03    SNZB	0x3,2
  00EA    28ED    JP	0xED
  00EB    0846    LD	A,0x46
  00EC    0248    SUBA	0x48
  00ED    1C03    SNZB	0x3,0
  00EE    28F7    JP	0xF7
  00EF    0846    LD	A,0x46
  00F0    02C8    SUBR	0x48
  00F1    0847    LD	A,0x47
  00F2    1C03    SNZB	0x3,0
  00F3    03C9    DECR	0x49
  00F4    02C9    SUBR	0x49
  00F5    144C    SETB	0x4C,0
  00F6    1003    CLRB	0x3,0
  00F7    0CC7    RRCR	0x47
  00F8    0CC6    RRCR	0x46
  00F9    0BCA    SZDECR	0x4A
  00FA    28E4    JP	0xE4
  00FB    084B    LD	A,0x4B
  00FC    1903    SZB	0x3,2
  00FD    2903    JP	0x103
  00FE    09CC    COMR	0x4C
  00FF    09CD    COMR	0x4D
  0100    0ACC    INCR	0x4C
  0101    1903    SZB	0x3,2
  0102    0ACD    INCR	0x4D
  0103    084D    LD	A,0x4D
  0104    00C7    LD	0x47,A
  0105    084C    LD	A,0x4C
  0106    00C6    LD	0x46,A
  0107    0008    RET
7:                #else
8:                __awdiv(signed int dividend, signed int divisor)
9:                #endif
10:               {
11:               	signed int	quotient;
12:               	unsigned char	counter, sign;
13:               
14:               	sign = 0;
15:               	if(divisor < 0) {
16:               		divisor = -divisor;
17:               		sign = 1;
18:               	}
19:               	if(dividend < 0) {
20:               		dividend = -dividend;
21:               		sign ^= 1;
22:               	}
23:               	quotient = 0;
24:               	if(divisor != 0) {
25:               		counter = 1;
26:               		while((divisor & 0x8000U) == 0) {
27:               			divisor <<= 1;
28:               			counter++;
29:               		}
30:               		do {
31:               			quotient <<= 1;
32:               			if((unsigned int)divisor <= (unsigned int)dividend) {
33:               				dividend -= divisor;
34:               				quotient |= 1;
35:               			}
36:               			*(unsigned int *)&divisor >>= 1;
37:               		} while(--counter != 0);
38:               	}
39:               	if(sign)
40:               		quotient = -quotient;
41:               	return quotient;
42:               }
---- E:\project\project0508\scm\uf166fan\init.c ----------------------------------------------------------------------
1:                #include "init.h"
2:                
3:                void Init_System() {
  0353    0000    NOP
  0354    0064    CLRWDT
  037B    0000    NOP
  037C    0064    CLRWDT
4:                    asm("nop");
5:                    asm("clrwdt");
6:                    INTCON = 0;                    //系统初始化
7:                    OSCCON = 0X71;                //配置振荡为8M,开 WDT
8:                    OPTION_REG = 0x00;        //Timer0使用内部时钟Focs/4，预分频比为1:2
  0355    2B56    JP	0x356
  037D    2B56    JP	0x356
9:                
10:               }
11:               
12:               
13:               void Init_GPIO() {
14:                   TRISA = 0;
15:                   TRISB = 0;
16:                   TRISC = 0;
17:                   WPUA = 0xFF;
18:                   WPUB = 0xFF;
19:                   WPUC = 0xFF;
20:                   PORTA = 0xFF;
21:                   PORTB = 0xFF;
22:                   PORTC = 0xFF;
23:                   IOCB = 0x00;
  02DA    2ADB    JP	0x2DB
  0381    2ADB    JP	0x2DB
24:               
25:               }
26:               
27:               void Init_Interupt() {
28:                   OPTION_REG = 0x00;        //Timer0使用内部时钟Focs/4，预分频比为1:2
29:                   TMR0 = 0;                //赋予初始值
30:                   INTCON = 0xE0;            //允许所有未被屏蔽的中断、禁止外设中断，使能Timer0
  0365    2B66    JP	0x366
  0380    2B66    JP	0x366
31:               
32:               }
---- stringtab ------------------------------------------------------------------
---- reset_enter ------------------------------------------------------------------
  0000    280C    JP	0xC
  000C    280D    JP	0xD
---- start_initialization ------------------------------------------------------------------
  000D    3002    LDIA	0x2
  000E    00F7    LD	0x77,A
  000F    3003    LDIA	0x3
  0010    00F8    LD	0x78,A
  0011    3020    LDIA	0x20
  0012    1383    CLRB	0x3,7
  0013    0084    LD	0x4,A
  0014    3046    LDIA	0x46
  0015    235D    CALL	0x35D
  0016    01F9    CLR	0x79
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F1    LD	0x71,A
  0007    0804    LD	A,0x4
  0008    00F2    LD	0x72,A
  0009    080A    LD	A,0xA
  000A    00F3    LD	0x73,A
  000B    2AC4    JP	0x2C4
---- common_function ------------------------------------------------------------------
  0017    0183    CLR	0x3
  0018    2A0F    JP	0x20F
  00AF    00C7    LD	0x47,A
  00B0    01C8    CLR	0x48
  00B1    01C9    CLR	0x49
  00B2    0846    LD	A,0x46
  00B3    02A0    SUBR	0x20
  00B4    0847    LD	A,0x47
  00B5    1C03    SNZB	0x3,0
  00B6    0F47    SZINCA	0x47
  00B7    02A1    SUBR	0x21
  00B8    0848    LD	A,0x48
  00B9    1C03    SNZB	0x3,0
  00BA    0F48    SZINCA	0x48
  00BB    02A2    SUBR	0x22
  00BC    0849    LD	A,0x49
  00BD    0008    RET
  00BE    084D    LD	A,0x4D
  00BF    00A5    LD	0x25,A
  00C0    084C    LD	A,0x4C
  00C1    00A4    LD	0x24,A
  00C2    0008    RET
  01B4    1683    SETB	0x3,5
  01B5    1087    CLRB	0x7,1
  01B6    1785    SETB	0x5,7
  01B7    1007    CLRB	0x7,0
  01B8    1283    CLRB	0x3,5
  01B9    1385    CLRB	0x5,7
  01BA    0008    RET
  01BB    1683    SETB	0x3,5
  01BC    1407    SETB	0x7,0
  01BD    1385    CLRB	0x5,7
  01BE    1087    CLRB	0x7,1
  01BF    1283    CLRB	0x3,5
  01C0    0008    RET
  025A    3004    LDIA	0x4
  025B    0096    LD	0x16,A
  025C    309B    LDIA	0x9B
  025D    1283    CLRB	0x3,5
  025E    0081    LD	0x1,A
  025F    1203    CLRB	0x3,4
  0260    3005    LDIA	0x5
  0261    00C5    LD	0x45,A
  0262    3004    LDIA	0x4
  0263    00BE    LD	0x3E,A
  0264    3003    LDIA	0x3
  0265    00B7    LD	0x37,A
  0266    343F    RET	0x3F
  0267    1683    SETB	0x3,5
  0268    1303    CLRB	0x3,6
  0269    0185    CLR	0x5
  026A    307E    LDIA	0x7E
  026B    0086    LD	0x6,A
  026C    0187    CLR	0x7
  026D    0008    RET
  02DB    0185    CLR	0x5
  02DC    0186    CLR	0x6
  02DD    0187    CLR	0x7
  02DE    30FF    LDIA	0xFF
  02DF    1703    SETB	0x3,6
  02E0    008E    LD	0xE,A
  02E1    1303    CLRB	0x3,6
  02E2    0095    LD	0x15,A
  02E3    1703    SETB	0x3,6
  02E4    008F    LD	0xF,A
  02E5    1283    CLRB	0x3,5
  02E6    1303    CLRB	0x3,6
  02E7    0085    LD	0x5,A
  02E8    0086    LD	0x6,A
  02E9    0087    LD	0x7,A
  02EA    1683    SETB	0x3,5
  02EB    0196    CLR	0x16
  02EC    0008    RET
  0313    0097    LD	0x17,A
  0314    0192    CLR	0x12
  0315    3007    LDIA	0x7
  0316    1683    SETB	0x3,5
  0317    0092    LD	0x12,A
  0318    1283    CLRB	0x3,5
  0319    0195    CLR	0x15
  031A    108C    CLRB	0xC,1
  031B    0192    CLR	0x12
  031C    1683    SETB	0x3,5
  031D    1107    CLRB	0x7,2
  031E    0008    RET
  0356    018B    CLR	0xB
  0357    3071    LDIA	0x71
  0358    1683    SETB	0x3,5
  0359    1303    CLRB	0x3,6
  035A    008F    LD	0xF,A
  035B    0181    CLR	0x1
  035C    0008    RET
  035D    0064    CLRWDT
  035E    0180    CLR	0x0
  035F    0A84    INCR	0x4
  0360    0604    XORA	0x4
  0361    1903    SZB	0x3,2
  0362    3400    RET	0x0
  0363    0604    XORA	0x4
  0364    2B5E    JP	0x35E
  0366    0181    CLR	0x1
  0367    1283    CLRB	0x3,5
  0368    0181    CLR	0x1
  0369    30E0    LDIA	0xE0
  036A    008B    LD	0xB,A
  036B    0008    RET
  0372    298A    JP	0x18A
  0373    298E    JP	0x18E
  0374    2992    JP	0x192
  0375    2997    JP	0x197
  0376    299C    JP	0x19C
  0377    2910    JP	0x110
  0378    2918    JP	0x118
  0379    2922    JP	0x122
  037A    2935    JP	0x135
