---- E:\project\project0508\scm\uf166fan\main.c ----------------------------------------------------------------------
1:                #include "scankey.h"
2:                #include "init.h"
3:                #include "adc.h"
4:                
5:                #define MAX_FAN_LEVEL 4
6:                #define MIN_FAN_LEVEL 1
7:                
8:                #define FAN_STATUS_OFF  0
9:                #define FAN_STATUS_ON  1
10:               #define FAN_STATUS_NONE 2
11:               
12:               #define PBPORTB PORTA
13:               #define PBTRISB TRISA
14:               
15:               #define LED_1  1
16:               #define LED_2  2
17:               #define LED_3  3
18:               #define LED_4  4
19:               //1毫秒中断标志
20:               static unsigned char time0Flag = 0;
21:               static unsigned int countTime = 0;
22:               static unsigned int count10Ms = 0;
23:               unsigned char currentLevel = 3;
24:               //风扇状态
25:               unsigned char FAN_STATUS = FAN_STATUS_NONE;
26:               //检测风扇次数
27:               unsigned int fan_check_time = 0;
28:               //低电压检测次数
29:               unsigned char lowVTime = 0;
30:               unsigned char count300ms = 0;
31:               //按键结构体
32:               struct Keys key1, key2, key3;
33:               //显示风扇挡位
34:               void setLedOn(unsigned char ledIndex);
35:               //初始化配置
36:               void Init_Config();
37:               //睡眠模式
38:               void Sleep_Mode();
39:               //关闭风扇
40:               void closeFan();
41:               
42:               void checkUsbStatus() {
43:                   if (getbit(PORTB, 2) == 1) {
  014D    0806    LD	A,0x6
  014E    00C7    LD	0x47,A
  014F    1003    CLRB	0x3,0
  0150    0CC7    RRCR	0x47
  0151    1003    CLRB	0x3,0
  0152    0CC7    RRCR	0x47
  0153    1C47    SNZB	0x47,0
  0154    2964    JP	0x164
44:                       if (getbit(PORTB, 1) == 1) {
  0155    0806    LD	A,0x6
  0156    00C7    LD	0x47,A
  0157    1003    CLRB	0x3,0
  0158    0CC7    RRCR	0x47
  0159    1C47    SNZB	0x47,0
  015A    295D    JP	0x15D
45:                           //充满了，Led常亮
46:                           resetbit(PORTA, 0);
  015B    1005    CLRB	0x5,0
47:                       } else if (countTime == 0) {
  015C    0008    RET
  015D    082C    LD	A,0x2C
  015E    042D    ORA	0x2D
  015F    1D03    SNZB	0x3,2
  0160    0008    RET
48:                           //充电中，一直闪		
49:                           reversebit(PORTA, 0);
  0161    3001    LDIA	0x1
  0162    0685    XORR	0x5
  0163    0008    RET
50:                       }
51:                   } else {
52:                       //usb断开充电灯熄灭,PA0 = 1
53:                       setbit(PORTA, 0);
  0164    1405    SETB	0x5,0
54:               		if((adresult/8) > 0x63 && count300ms == 0)
  0165    2180    CALL	0x180
  0166    3064    LDIA	0x64
  0167    1903    SZB	0x3,2
  0168    0247    SUBA	0x47
  0169    1C03    SNZB	0x3,0
  016A    2977    JP	0x177
  016B    0876    LD	A,0x76
  016C    1D03    SNZB	0x3,2
  016D    2977    JP	0x177
55:               		{
56:               			if(lowVTime < 20)
  016E    3014    LDIA	0x14
  016F    0231    SUBA	0x31
  0170    1803    SZB	0x3,0
  0171    2976    JP	0x176
  0172    3001    LDIA	0x1
57:               			{
58:               				lowVTime++;
  0173    0AB1    INCR	0x31
59:               				//闪红灯，
60:               				reversebit(PORTA, 0);
  0174    0685    XORR	0x5
61:               			}else
  0175    2977    JP	0x177
62:               			{
63:               				//关闭风扇
64:               				closeFan();
  0176    2349    CALL	0x349
65:               			}
66:               		}
67:               		if((adresult/8) < 0x63)
  0177    1283    CLRB	0x3,5
  0178    1303    CLRB	0x3,6
  0179    2180    CALL	0x180
  017A    3063    LDIA	0x63
  017B    1903    SZB	0x3,2
  017C    0247    SUBA	0x47
  017D    1C03    SNZB	0x3,0
68:               		{
69:               			lowVTime = 0;
  017E    01B1    CLR	0x31
  017F    0008    RET
70:               		}
71:                   }
72:               }
73:               
74:               void Init_PWM() {
75:                   CCP1CON = 0x0F;//设置PC2为PWM模式，4,5位为占空比的低2位
76:                   T2CON = 0; //时钟分频 1:1 PWM周期为（PR2+1）*4/8,000,000
77:                   PR2 = 7;
78:               
79:                   CCPR1L = 0;//占空比高8位，低2位设置为0，结果就是 占空比 = CCPR1L*4/4*(PR2+1)
80:                   TMR2IF = 0;
81:                   T2CON = 0;
82:                   //PC2设置为输出脚
83:                   resetbit(TRISC, 2);
  0357    2B58    JP	0x358
  03A6    2B58    JP	0x358
84:                   //T2CON = 0X04 //启动定时器2，溢出后启动PWM
85:               }
86:               
87:               //设置风扇转速
88:               void setFanLevel(char level) {
  0190    00CF    LD	0x4F,A
89:               	if(level == 0)
  0191    084F    LD	A,0x4F
  0192    1D03    SNZB	0x3,2
  0193    2996    JP	0x196
90:               	{
91:               		currentLevel = 3;
  0194    3003    LDIA	0x3
  0195    00F9    LD	0x79,A
92:               	}
93:                   unsigned int levelWidth = (PR2 + 1) / MAX_FAN_LEVEL;
  0196    1683    SETB	0x3,5
  0197    0812    LD	A,0x12
  0198    1283    CLRB	0x3,5
  0199    00C9    LD	0x49,A
  019A    01CA    CLR	0x4A
  019B    0AC9    INCR	0x49
  019C    1903    SZB	0x3,2
  019D    0ACA    INCR	0x4A
  019E    3004    LDIA	0x4
  019F    00C7    LD	0x47,A
  01A0    01C8    CLR	0x48
  01A1    20C4    CALL	0xC4
94:                   char tempLevel = currentLevel + level;
  01A2    084F    LD	A,0x4F
  01A3    0779    ADDA	0x79
  01A4    00D0    LD	0x50,A
95:                   if (tempLevel > MAX_FAN_LEVEL) {
  01A5    3005    LDIA	0x5
  01A6    0250    SUBA	0x50
  01A7    1C03    SNZB	0x3,0
  01A8    29AB    JP	0x1AB
96:                       tempLevel = MAX_FAN_LEVEL;
  01A9    3004    LDIA	0x4
  01AA    00D0    LD	0x50,A
97:                   }
98:               
99:                   if (tempLevel < MIN_FAN_LEVEL) {
  01AB    0850    LD	A,0x50
  01AC    1D03    SNZB	0x3,2
  01AD    29B0    JP	0x1B0
100:                      tempLevel = MIN_FAN_LEVEL;
  01AE    01D0    CLR	0x50
  01AF    0AD0    INCR	0x50
101:                  }
102:              	
103:                  
104:                  if (FAN_STATUS == FAN_STATUS_ON) {
  01B0    0B78    SZDECA	0x78
  01B1    0008    RET
105:              		currentLevel = tempLevel;
  01B2    0850    LD	A,0x50
  01B3    00F9    LD	0x79,A
106:              		switch(currentLevel)
  01B4    29BE    JP	0x1BE
107:              		{
108:              			case 1:
109:              			CCPR1L = 1;
  01B5    3001    LDIA	0x1
  01B6    29BC    JP	0x1BC
110:              			break;
111:              			case 2:
112:              			CCPR1L = 2;
  01B7    3002    LDIA	0x2
  01B8    29BC    JP	0x1BC
113:              			break;
114:              			case 3:
115:              			CCPR1L = 3;
  01B9    3003    LDIA	0x3
  01BA    29BC    JP	0x1BC
116:              			break;
117:              			case 4:
118:              			CCPR1L = 5;
  01BB    3005    LDIA	0x5
  01BC    0095    LD	0x15,A
119:              			break;
  01BD    29CC    JP	0x1CC
  01BE    0879    LD	A,0x79
  01BF    3A01    XORIA	0x1
  01C0    1903    SZB	0x3,2
  01C1    29B5    JP	0x1B5
  01C2    3A03    XORIA	0x3
  01C3    1903    SZB	0x3,2
  01C4    29B7    JP	0x1B7
  01C5    3A01    XORIA	0x1
  01C6    1903    SZB	0x3,2
  01C7    29B9    JP	0x1B9
  01C8    3A07    XORIA	0x7
  01C9    1903    SZB	0x3,2
  01CA    29BB    JP	0x1BB
  01CB    29CC    JP	0x1CC
120:              		}
121:                  //设置占宽比
122:              		//CCPR1L = levelWidth * currentLevel;
123:                      setLedOn(currentLevel);
  01CC    0879    LD	A,0x79
  01CD    29CE    JP	0x1CE
124:                  }
125:              
126:              }
127:              
128:              //关闭风扇
129:              void closeFan() {
130:                  Init_PWM();
  0349    2357    CALL	0x357
131:                  currentLevel = 2;
  034A    3002    LDIA	0x2
  034B    00F9    LD	0x79,A
132:                  setLedOn(5);
  034C    3005    LDIA	0x5
  034D    21CE    CALL	0x1CE
133:                  setbit(PORTA, 0);
  034E    1283    CLRB	0x3,5
  034F    1405    SETB	0x5,0
134:                  //PWM输出脚设置为输入，关闭PWM
135:                  setbit(TRISC, 2);
  0350    1683    SETB	0x3,5
  0351    1507    SETB	0x7,2
136:                  fan_check_time = 0;
  0352    1283    CLRB	0x3,5
  0353    01A8    CLR	0x28
  0354    01A9    CLR	0x29
137:                  FAN_STATUS = FAN_STATUS_OFF;
  0355    01F8    CLR	0x78
138:                  Sleep_Mode();
  0356    2A56    JP	0x256
139:              }
140:              
141:              
142:              //检测风扇是否连接
143:              void checkFan() {
144:              	resetbit(TRISA, 1);
  0207    1683    SETB	0x3,5
  0208    1085    CLRB	0x5,1
145:                  setbit(PORTA, 1);
  0209    1283    CLRB	0x3,5
  020A    1485    SETB	0x5,1
146:                  //PC2设置为输出脚
147:                  resetbit(TRISC, 2);
  020B    1683    SETB	0x3,5
  020C    1107    CLRB	0x7,2
148:              	setbit(PORTA, 2);
  020D    1283    CLRB	0x3,5
  020E    1505    SETB	0x5,2
149:                  T2CON = 0X04; //启动定时器2，溢出后启动PWM
  020F    3004    LDIA	0x4
  0210    0092    LD	0x12,A
150:              
151:                  //EN IN输出高电位，D1点亮，检测FAN DET，FAN DET为低电位则风扇正常工作，高电位则未连接
152:                  if (getbit(PORTB, 6) == 0) {
  0211    0806    LD	A,0x6
  0212    00F5    LD	0x75,A
  0213    3006    LDIA	0x6
  0214    1003    CLRB	0x3,0
  0215    0CF5    RRCR	0x75
  0216    3EFF    ADDIA	0xFF
  0217    1D03    SNZB	0x3,2
  0218    2A14    JP	0x214
  0219    1875    SZB	0x75,0
  021A    2A1E    JP	0x21E
153:                      FAN_STATUS = FAN_STATUS_ON;
  021B    01F8    CLR	0x78
  021C    0AF8    INCR	0x78
154:                  } else {
  021D    2A20    JP	0x220
155:                      FAN_STATUS = FAN_STATUS_NONE;
  021E    3002    LDIA	0x2
  021F    00F8    LD	0x78,A
156:                  }
157:              	
158:              	setFanLevel(0);
  0220    3000    LDIA	0x0
  0221    2190    CALL	0x190
159:              
160:                  //没有检测到风扇
161:                  if (FAN_STATUS == FAN_STATUS_NONE) {
  0222    3002    LDIA	0x2
  0223    0678    XORA	0x78
  0224    1D03    SNZB	0x3,2
  0225    0008    RET
162:                      fan_check_time++;
  0226    1283    CLRB	0x3,5
  0227    0AA8    INCR	0x28
  0228    1903    SZB	0x3,2
  0229    0AA9    INCR	0x29
163:                      if (fan_check_time == 3000) {
  022A    30B8    LDIA	0xB8
  022B    0628    XORA	0x28
  022C    300B    LDIA	0xB
  022D    1903    SZB	0x3,2
  022E    0629    XORA	0x29
  022F    1D03    SNZB	0x3,2
  0230    0008    RET
164:                          closeFan();
  0231    2B49    JP	0x349
165:                          return;
166:                      }
167:                  }
168:              
169:              
170:              }
171:              
172:              
173:              //设置Led灯亮
174:              void setLedOn(unsigned char ledIndex) {
  01CE    00F4    LD	0x74,A
175:                  switch(ledIndex) {
  01CF    29EB    JP	0x1EB
176:                      case 1:
177:                          //PB7设置为输入脚,PC1和PC0设置为输出
178:              			resetbit(TRISC, 1);
179:              			setbit(PBTRISB, 7);
180:                          resetbit(TRISC, 0);
181:                          resetbit(PBPORTB, 7);
  01D0    21FA    CALL	0x1FA
182:                          setbit(PORTC, 0);
  01D1    1407    SETB	0x7,0
183:                          resetbit(PORTC, 1);            
  01D2    1087    CLRB	0x7,1
184:                          break;
  01D3    0008    RET
185:                      case 2:
186:              			resetbit(TRISC, 1);
187:              			setbit(PBTRISB, 7);
188:                          resetbit(TRISC, 0);
189:              			resetbit(PBPORTB, 7);
  01D4    21FA    CALL	0x1FA
190:                          resetbit(PORTC, 0);
  01D5    1007    CLRB	0x7,0
191:                          setbit(PORTC, 1);
  01D6    1487    SETB	0x7,1
192:                          break;
  01D7    0008    RET
193:                      case 3:
194:                          //PC0设置为输入脚，PB7和PC1设置为输出
195:              			setbit(TRISC, 0);
196:              			resetbit(PBTRISB, 7);
197:                          resetbit(TRISC, 1);
198:                          setbit(PBPORTB, 7);
  01D8    2201    CALL	0x201
  01D9    1785    SETB	0x5,7
199:                          resetbit(PORTC, 0);
  01DA    1007    CLRB	0x7,0
200:                          resetbit(PORTC, 1);
  01DB    1087    CLRB	0x7,1
201:                          break;
  01DC    0008    RET
202:                      case 4:
203:              			setbit(TRISC, 0);
204:              			resetbit(PBTRISB, 7);
205:                          resetbit(TRISC, 1);
206:                          resetbit(PBPORTB, 7);
  01DD    2201    CALL	0x201
  01DE    1385    CLRB	0x5,7
207:                          setbit(PORTC, 0);
  01DF    1407    SETB	0x7,0
208:                          setbit(PORTC, 1);
  01E0    1487    SETB	0x7,1
209:                          break;
  01E1    0008    RET
210:                      case 5:
211:                          //全部设置为输入脚
212:              			setbit(TRISC, 0);
  01E2    1683    SETB	0x3,5
  01E3    1407    SETB	0x7,0
213:              			setbit(PBTRISB, 7);
  01E4    1785    SETB	0x5,7
214:                          setbit(TRISC, 1);
  01E5    1487    SETB	0x7,1
215:              			resetbit(PORTC, 0);
  01E6    1283    CLRB	0x3,5
  01E7    1007    CLRB	0x7,0
216:              			resetbit(PBPORTB, 7);
  01E8    1385    CLRB	0x5,7
217:                          resetbit(PORTC, 1);
  01E9    1087    CLRB	0x7,1
218:                          break;
  01EA    0008    RET
  01EB    0874    LD	A,0x74
  01EC    3EFF    ADDIA	0xFF
  01ED    1C03    SNZB	0x3,0
  01EE    0008    RET
  01EF    0084    LD	0x4,A
  01F0    3005    LDIA	0x5
  01F1    0204    SUBA	0x4
  01F2    1803    SZB	0x3,0
  01F3    0008    RET
  01F4    3003    LDIA	0x3
  01F5    008A    LD	0xA,A
  01F6    309A    LDIA	0x9A
  01F7    0704    ADDA	0x4
  01F8    0082    LD	0x2,A
  01F9    0008    RET
219:                  }
220:              }
221:              
222:              
223:              //扫描按键
224:              void scanKeys() {
225:                  key1.key_addr_result = key2.key_addr_result = key3.key_addr_result = PORTB;
  0319    1283    CLRB	0x3,5
  031A    1303    CLRB	0x3,6
  031B    0806    LD	A,0x6
  031C    00B7    LD	0x37,A
  031D    00BE    LD	0x3E,A
  031E    00C5    LD	0x45,A
226:                  sacnKeyInput(&key1);
  031F    3040    LDIA	0x40
  0320    22B6    CALL	0x2B6
227:                  sacnKeyInput(&key2);
  0321    3039    LDIA	0x39
  0322    22B6    CALL	0x2B6
228:                  sacnKeyInput(&key3);
  0323    3032    LDIA	0x32
  0324    22B6    CALL	0x2B6
229:                  countTime++;
  0325    0AAC    INCR	0x2C
  0326    1903    SZB	0x3,2
  0327    0AAD    INCR	0x2D
  0328    0008    RET
230:                 
231:              }
232:              
233:              //检测按键状态并处理
234:              void checkKeys() {
235:                  if (key_driver(&key1) == key_click) {
  0298    3040    LDIA	0x40
  0299    2109    CALL	0x109
  029A    3A01    XORIA	0x1
  029B    1D03    SNZB	0x3,2
  029C    2AA3    JP	0x2A3
236:                      //检测到按键了，检测风扇是否存在
237:              
238:                      if (FAN_STATUS == FAN_STATUS_ON) {
  029D    0B78    SZDECA	0x78
  029E    2AA0    JP	0x2A0
239:                          //关闭风扇
240:                          closeFan();
  029F    2B49    JP	0x349
241:                      } else {
242:                          FAN_STATUS = FAN_STATUS_NONE;
  02A0    3002    LDIA	0x2
  02A1    00F8    LD	0x78,A
243:                          checkFan();
  02A2    2A07    JP	0x207
  02A3    3002    LDIA	0x2
  02A4    0678    XORA	0x78
  02A5    1D03    SNZB	0x3,2
  02A6    2AA8    JP	0x2A8
244:                      }
245:                      return;
246:                  } else if (FAN_STATUS == FAN_STATUS_NONE) {
247:                      checkFan();
  02A7    2207    CALL	0x207
248:                  }
249:              
250:              	unsigned char key2Status = key_driver(&key2);
  02A8    3039    LDIA	0x39
  02A9    2109    CALL	0x109
  02AA    00D1    LD	0x51,A
251:                  if (key2Status == key_click) {
  02AB    0B51    SZDECA	0x51
  02AC    2AAF    JP	0x2AF
252:                      //加档
253:                      setFanLevel(1);
  02AD    3001    LDIA	0x1
  02AE    2990    JP	0x190
254:                      return;
255:                  }
256:              	unsigned char key3Status = key_driver(&key3);
  02AF    3032    LDIA	0x32
  02B0    2109    CALL	0x109
  02B1    00D2    LD	0x52,A
257:                  if (key3Status == key_click) {
  02B2    0B52    SZDECA	0x52
  02B3    0008    RET
258:                      //减档
259:                      setFanLevel(-1);
  02B4    30FF    LDIA	0xFF
  02B5    2990    JP	0x190
260:                      return;
261:                  }
262:              
263:              }
264:              
265:              
266:              void main(void) {
267:              	Sleep_Mode();
  0232    2256    CALL	0x256
268:                  Init_Config();
  0233    2370    CALL	0x370
269:                  while (1) {
270:                      //0.1毫秒检测一次
271:                      if (time0Flag) {
  0234    0877    LD	A,0x77
  0235    1903    SZB	0x3,2
  0236    2A3D    JP	0x23D
  0237    0064    CLRWDT
272:                          asm("clrwdt");
273:                          time0Flag = 0;
  0238    01F7    CLR	0x77
274:              			scanKeys();
  0239    2319    CALL	0x319
275:                          count10Ms++;
  023A    0AAA    INCR	0x2A
  023B    1903    SZB	0x3,2
  023C    0AAB    INCR	0x2B
276:                      }
277:              
278:                      //10毫秒检测一次
279:                      if (count10Ms == 100) {	
  023D    3064    LDIA	0x64
  023E    062A    XORA	0x2A
  023F    042B    ORA	0x2B
  0240    1D03    SNZB	0x3,2
  0241    2A4A    JP	0x24A
280:              			count300ms++;	
  0242    0AF6    INCR	0x76
281:                          checkKeys();
  0243    2298    CALL	0x298
282:                          count10Ms = 0;
  0244    1283    CLRB	0x3,5
  0245    1303    CLRB	0x3,6
  0246    01AA    CLR	0x2A
  0247    01AB    CLR	0x2B
283:                          //检测USB状态
284:                          checkUsbStatus();
  0248    214D    CALL	0x14D
285:              			//检测内部电压
286:              			readVrefADC();
  0249    2394    CALL	0x394
287:                      }
288:              		//300ms
289:              		if(count300ms == 30)
  024A    301E    LDIA	0x1E
  024B    0676    XORA	0x76
  024C    1903    SZB	0x3,2
290:              		{
291:              			count300ms = 0;
  024D    01F6    CLR	0x76
292:              		}
293:              		//1s钟
294:                      if (countTime == 100) {
  024E    3064    LDIA	0x64
  024F    062C    XORA	0x2C
  0250    042D    ORA	0x2D
  0251    1D03    SNZB	0x3,2
  0252    2A34    JP	0x234
295:                          countTime = 0;
  0253    01AC    CLR	0x2C
  0254    01AD    CLR	0x2D
  0255    2A34    JP	0x234
296:                      }
297:              		
298:                  }
299:              
300:              }
301:              
302:              void Init_Config() {
303:              
304:                  Init_System();
  0277    237B    CALL	0x37B
  0370    23A3    CALL	0x3A3
305:                  Init_GPIO();
  0278    23A8    CALL	0x3A8
  0371    2306    CALL	0x306
306:                  Init_Interupt();
  0279    23A7    CALL	0x3A7
  0372    238D    CALL	0x38D
307:                  Init_PWM();
  027A    23A6    CALL	0x3A6
  0373    2357    CALL	0x357
308:                  //设置唤醒
309:                  IOCB = 0x04;
310:                  TMR0 = 155;
311:                  TO = 0;
312:              
313:                  //K1开关
314:                  key1.key_index = 5;
315:                  //K2加档
316:                  key2.key_index = 4;
317:                  //K3减档
318:                  key3.key_index = 3;
319:                  resetKey(&key1);
  027B    2282    CALL	0x282
  027C    2339    CALL	0x339
  0374    2282    CALL	0x282
  0375    2329    CALL	0x329
320:                  resetKey(&key2);
  027D    3039    LDIA	0x39
  027E    2339    CALL	0x339
  0376    3039    LDIA	0x39
  0377    2329    CALL	0x329
321:                  resetKey(&key3);
  027F    3032    LDIA	0x32
  0280    2339    CALL	0x339
  0378    3032    LDIA	0x32
  0379    2329    CALL	0x329
322:                  //设置IO方向
323:                  TRISA = 0;
324:                  TRISB = 0x7E;//1-6脚输入
325:                  TRISC = 0;
326:              	lowVTime = 0;
  0281    2A8F    JP	0x28F
  037A    2A8F    JP	0x28F
327:              }
328:              
329:              
330:              void Sleep_Mode() {
331:                  INTCON = 0;
  0256    018B    CLR	0xB
332:              
333:                  OPTION_REG = 0;
  0257    1683    SETB	0x3,5
  0258    0181    CLR	0x1
334:              
335:                  TRISA = 0B00000000;        //关闭所有输出
  0259    0185    CLR	0x5
336:                  PORTA = 0B00000000;
  025A    1283    CLRB	0x3,5
  025B    0185    CLR	0x5
337:                  WPUA = 0B00000000;
  025C    1683    SETB	0x3,5
  025D    1703    SETB	0x3,6
  025E    018E    CLR	0xE
338:              
339:                  TRISB = 0B00100100;
  025F    3024    LDIA	0x24
  0260    1303    CLRB	0x3,6
  0261    0086    LD	0x6,A
340:                  PORTB = 0B00000000;
  0262    1283    CLRB	0x3,5
  0263    0186    CLR	0x6
341:              
342:                  PORTB = 0;
  0264    0186    CLR	0x6
343:                  WPUB = 0B00100000;         //RB3 上拉
  0265    3020    LDIA	0x20
  0266    1683    SETB	0x3,5
  0267    0095    LD	0x15,A
344:              
345:                  IOCB = 0B00100100;            //允许RB3的IO口电平变化中断
  0268    3024    LDIA	0x24
  0269    0096    LD	0x16,A
346:                  RBIE = 1;                    //允许PORTB电平变化中断
  026A    158B    SETB	0xB,3
347:                  GIE = 1;                    //GIE = 0时，唤醒后执行SLEEP后程序;GIE = 1时，唤醒后跳至中断服务
  026B    178B    SETB	0xB,7
348:              
349:                  ADCON0 = 0;                    //关闭所有模块
  026C    1283    CLRB	0x3,5
  026D    019F    CLR	0x1F
350:              
351:                  OSCCON = 0X70;                //配置振荡为16M,关闭WDT
  026E    3070    LDIA	0x70
  026F    1683    SETB	0x3,5
  0270    008F    LD	0xF,A
352:              
353:                  PORTB;                        //读PORTB值并锁存			
  0271    1283    CLRB	0x3,5
  0272    0806    LD	A,0x6
  0273    0064    CLRWDT
  0274    0063    STOP
  0275    0000    NOP
  0276    0008    RET
354:                  asm("clrwdt");
355:              
356:                  asm("sleep");                //进入休眠模式
357:              
358:                  asm("nop");
359:              
360:              
361:              }
362:              
363:              
364:              /***********************************************
365:              函数名称：Timer0_Isr
366:              函数功能：中断服务
367:              入口参数：无
368:              出口参数：无
369:              备注：
370:              ***********************************************/
371:              void interrupt
372:              
373:              Timer0_Isr() {
374:                  if (T0IF) {
  02F0    1D0B    SNZB	0xB,2
  02F1    2AF9    JP	0x2F9
375:                      //---------------------------------------
376:                      TMR0 += 155;        //重新赋初值，在赋值前Timer0已有计数，故在该基础上加初值
  02F2    309B    LDIA	0x9B
  02F3    1283    CLRB	0x3,5
  02F4    1303    CLRB	0x3,6
  02F5    0781    ADDR	0x1
377:                      //---------------------------------------
378:              
379:                      T0IF = 0;            //清中断标志位	
  02F6    110B    CLRB	0xB,2
380:                      time0Flag = 1;
  02F7    01F7    CLR	0x77
  02F8    0AF7    INCR	0x77
381:              
382:                  }
383:              
384:                  if (RBIF) {
  02F9    1C0B    SNZB	0xB,0
  02FA    2AFD    JP	0x2FD
385:                      RBIF = 0;            //清中断标志
  02FB    100B    CLRB	0xB,0
386:                      Init_Config();
  02FC    2277    CALL	0x277
  02FD    0873    LD	A,0x73
  02FE    008A    LD	0xA,A
  02FF    0872    LD	A,0x72
  0300    0084    LD	0x4,A
  0301    0E71    SWAPA	0x71
  0302    0083    LD	0x3,A
  0303    0EFE    SWAPR	0x7E
  0304    0E7E    SWAPA	0x7E
  0305    0009    RETI
387:                  }
388:              }
389:              
390:              
391:              
---- E:\project\project0508\scm\uf166fan\scankey.c ----------------------------------------------------------------------
1:                #include "scankey.h"
2:                
3:                void sacnKeyInput(struct Keys *key) {
  02B6    00C7    LD	0x47,A
4:                    key->key_input = getbit(key->key_addr_result, key->key_index);
  02B7    3E05    ADDIA	0x5
  02B8    0084    LD	0x4,A
  02B9    1383    CLRB	0x3,7
  02BA    0800    LD	A,0x0
  02BB    00F4    LD	0x74,A
  02BC    0847    LD	A,0x47
  02BD    3E06    ADDIA	0x6
  02BE    0084    LD	0x4,A
  02BF    0A00    INCA	0x0
  02C0    2AC3    JP	0x2C3
  02C1    1003    CLRB	0x3,0
  02C2    0CF4    RRCR	0x74
  02C3    3EFF    ADDIA	0xFF
  02C4    1D03    SNZB	0x3,2
  02C5    2AC1    JP	0x2C1
  02C6    0874    LD	A,0x74
  02C7    00F5    LD	0x75,A
  02C8    0847    LD	A,0x47
  02C9    3E04    ADDIA	0x4
  02CA    0084    LD	0x4,A
  02CB    0875    LD	A,0x75
  02CC    0080    LD	0x0,A
  02CD    0847    LD	A,0x47
  02CE    3E04    ADDIA	0x4
  02CF    0084    LD	0x4,A
  02D0    3001    LDIA	0x1
  02D1    0580    ANDR	0x0
  02D2    0008    RET
5:                
6:                }
7:                
8:                
9:                unsigned char key_driver(struct Keys *key) {
  0109    1283    CLRB	0x3,5
  010A    1303    CLRB	0x3,6
  010B    00C9    LD	0x49,A
10:               
11:               
12:                   unsigned char key_return = key_no;
  010C    01C7    CLR	0x47
13:                   unsigned char key_read = key->key_input;  //read the I/O states
  010D    3E04    ADDIA	0x4
  010E    0084    LD	0x4,A
  010F    1383    CLRB	0x3,7
  0110    0800    LD	A,0x0
  0111    00C8    LD	0x48,A
14:               
15:                   switch (key->key_state_buffer1) {
  0112    293E    JP	0x13E
16:                       case key_state_0:
17:                           if (key_read == 0) {
  0113    0848    LD	A,0x48
  0114    1D03    SNZB	0x3,2
  0115    294B    JP	0x14B
18:                               key->key_state_buffer1 = key_state_1;
  0116    0A49    INCA	0x49
  0117    0084    LD	0x4,A
  0118    0180    CLR	0x0
  0119    0A80    INCR	0x0
  011A    294B    JP	0x14B
19:                           }
20:               
21:                           //按键被按下，状态转换到按键消抖和确认状态//
22:                           break;
23:               
24:                       case key_state_1:
25:                           if (key_read == 0) {
  011B    0848    LD	A,0x48
  011C    1D03    SNZB	0x3,2
  011D    293A    JP	0x13A
26:                               key->key_timer_cnt1 = 0;
  011E    0849    LD	A,0x49
  011F    0084    LD	0x4,A
  0120    0180    CLR	0x0
27:                               key->key_state_buffer1 = key_state_2;
  0121    0A49    INCA	0x49
  0122    0084    LD	0x4,A
  0123    3002    LDIA	0x2
  0124    2936    JP	0x136
28:                               //按键仍然处于按下状态
29:                               //消抖完成，key_timer开始准备计时
30:                               //状态切换到按下时间计时状态
31:                           } else {
32:                               key->key_state_buffer1 = key_state_0;
33:                           }
34:               
35:                           //按键已经抬起，回到按键初始状态
36:                           break;  //完成软件消抖
37:               
38:                       case key_state_2:
39:                           if (key_read == 1) {
  0125    0B48    SZDECA	0x48
  0126    292A    JP	0x12A
40:                               key_return = key_click;  //按键抬起，产生一次click操作
  0127    01C7    CLR	0x47
  0128    0AC7    INCR	0x47
  0129    293A    JP	0x13A
41:                               key->key_state_buffer1 = key_state_0;  //转换到按键初始状态
  012A    0849    LD	A,0x49
  012B    0084    LD	0x4,A
  012C    3064    LDIA	0x64
  012D    0A80    INCR	0x0
  012E    0200    SUBA	0x0
  012F    1C03    SNZB	0x3,0
  0130    294B    JP	0x14B
42:                           } else if (++(key->key_timer_cnt1) >= 100)  //按键继续按下，计时超过1000ms
43:                           {
44:                               key_return = key_long;  //送回长按事件
  0131    3003    LDIA	0x3
  0132    00C7    LD	0x47,A
45:                               key->key_state_buffer1 = key_state_3;  //转换到等待按键释放状态
  0133    0A49    INCA	0x49
  0134    0084    LD	0x4,A
  0135    3003    LDIA	0x3
  0136    0080    LD	0x0,A
  0137    294B    JP	0x14B
46:               
47:                           }
48:                           break;
49:               
50:                       case key_state_3:  //等待按键释放
51:                           if (key_read == 1)  //按键释放
  0138    0B48    SZDECA	0x48
  0139    294B    JP	0x14B
52:                           {
53:                               key->key_state_buffer1 = key_state_0;  //切回按键初始状态
  013A    0A49    INCA	0x49
  013B    0084    LD	0x4,A
  013C    0180    CLR	0x0
  013D    294B    JP	0x14B
  013E    0A49    INCA	0x49
  013F    0084    LD	0x4,A
  0140    0800    LD	A,0x0
  0141    0084    LD	0x4,A
  0142    3004    LDIA	0x4
  0143    0204    SUBA	0x4
  0144    1803    SZB	0x3,0
  0145    294B    JP	0x14B
  0146    3003    LDIA	0x3
  0147    008A    LD	0xA,A
  0148    309F    LDIA	0x9F
  0149    0704    ADDA	0x4
  014A    0082    LD	0x2,A
54:                           }
55:               
56:                           break;
57:                   }
58:                   return key_return;
  014B    0847    LD	A,0x47
  014C    0008    RET
59:               }
60:               
61:               /***************************************************************************
62:               函数功能：中层按键处理函数，调用底层函数一次，处理双击事件的判断，
63:                                                       返回上层正确的无键、单击、双击、长按四种状态
64:               本函数由上层循环调用，间隔10ms
65:               ***************************************************************************/
66:               unsigned char key_read(struct Keys *key) {
67:               
68:                   unsigned char key_return = key_no;
69:                   unsigned char key_read = key_driver(key);
70:               //    printf("IO:%d  key status: %d\n",getSimpleKeyInput(key_input),key);
71:                   switch (key->key_state_buffer2) {
72:                       case key_state_0:
73:                           if (key_read == key_click) {
74:                               key->key_timer_cnt2 = 0;  //第一次单击，不返回，到下个状态判断是否会出现双击
75:                               key->key_state_buffer2 = key_state_1;
76:                           } else
77:                               key_return = key_read;  //对于无键、长按，返回原事件
78:                           break;
79:               
80:                       case key_state_1:
81:                           if (key_read == key_click)  //又一次单击，时间间隔小于500ms
82:                           {
83:                               key_return = key_double;  //返回双击事件，回到初始状态
84:                               key->key_state_buffer2 = key_state_0;
85:                           } else if (++(key->key_timer_cnt2) >= 50) {
86:                               //这里500ms内肯定读到的都是无键事件，因为长按大于1000ms
87:                               //在1s前底层返回的都是无键
88:               
89:                               key_return = key_click;  //500ms内没有再次出现单击事件，返回单击事件
90:                               key->key_state_buffer2 = key_state_0;  //返回初始状态
91:               
92:                           }
93:                           break;
94:                   }
95:               
96:                   return key_return;
97:               }
98:               
99:               
100:              void resetKey(struct Keys *key) {
  0329    00F4    LD	0x74,A
  0339    00F0    LD	0x70,A
101:                  key->key_timer_cnt1 = key->key_timer_cnt2 = key->key_state_buffer1 = key->key_state_buffer2 = 0;
  032A    3E03    ADDIA	0x3
  032B    0084    LD	0x4,A
  032C    1383    CLRB	0x3,7
  032D    0180    CLR	0x0
  032E    0A74    INCA	0x74
  032F    0084    LD	0x4,A
  0330    0180    CLR	0x0
  0331    0874    LD	A,0x74
  0332    3E02    ADDIA	0x2
  0333    0084    LD	0x4,A
  0334    0180    CLR	0x0
  0335    0874    LD	A,0x74
  0336    0084    LD	0x4,A
  0337    0180    CLR	0x0
  0338    0008    RET
  033A    3E03    ADDIA	0x3
  033B    0084    LD	0x4,A
  033C    1383    CLRB	0x3,7
  033D    0180    CLR	0x0
  033E    0A70    INCA	0x70
  033F    0084    LD	0x4,A
  0340    0180    CLR	0x0
  0341    0870    LD	A,0x70
  0342    3E02    ADDIA	0x2
  0343    0084    LD	0x4,A
  0344    0180    CLR	0x0
  0345    0870    LD	A,0x70
  0346    0084    LD	0x4,A
  0347    0180    CLR	0x0
  0348    0008    RET
102:              }
---- E:\project\project0508\scm\uf166fan\adc.c ----------------------------------------------------------------------
1:                #include "adc.h"
2:                
3:                /**********************************************************
4:                函数名称：AD_Sample
5:                函数功能：AD检测
6:                入口参数：adch - 检测通道
7:                出口参数：无 
8:                备    注：采样通道需自行设置为模拟口
9:                	      采样10次,取中间八次的平均值为采样结果存于adresult中
10:               **********************************************************/
11:               void ADC_Sample(unsigned char adch)
  001A    00CB    LD	0x4B,A
12:               {
13:               	static unsigned long adsum = 0;
14:               	static unsigned int admin = 0,admax = 0;
15:               	static unsigned char adtimes = 0;
16:               	volatile unsigned int ad_temp;
17:               	ADCON1 = 0;						//左对齐
  001B    1683    SETB	0x3,5
  001C    019F    CLR	0x1F
18:               	ADCON0 = 0X41 | (adch << 2);	//16分频
  001D    1283    CLRB	0x3,5
  001E    084B    LD	A,0x4B
  001F    00C7    LD	0x47,A
  0020    3001    LDIA	0x1
  0021    1003    CLRB	0x3,0
  0022    0DC7    RLCR	0x47
  0023    3EFF    ADDIA	0xFF
  0024    1003    CLRB	0x3,0
  0025    1D03    SNZB	0x3,2
  0026    2822    JP	0x22
  0027    0D47    RLCA	0x47
  0028    3841    ORIA	0x41
  0029    009F    LD	0x1F,A
  002A    0000    NOP
  002B    0000    NOP
19:               	asm("nop");
20:               	asm("nop");
21:               	GODONE = 1;						//开始转换
  002C    1283    CLRB	0x3,5
  002D    1303    CLRB	0x3,6
  002E    149F    SETB	0x1F,1
22:               
23:               	unsigned char i = 0;
  002F    01CC    CLR	0x4C
24:               	while(GODONE)
  0030    1C9F    SNZB	0x1F,1
  0031    2835    JP	0x35
25:               	{
26:               		if(0 == (--i))
  0032    0BCC    SZDECR	0x4C
  0033    2830    JP	0x30
  0034    0008    RET
27:               			return;
28:               	}
29:               	
30:               	ad_temp=(ADRESH<<4)+(ADRESL>>4);	//计算12位AD值
  0035    081E    LD	A,0x1E
  0036    00CD    LD	0x4D,A
  0037    01CE    CLR	0x4E
  0038    0ECD    SWAPR	0x4D
  0039    0ECE    SWAPR	0x4E
  003A    30F0    LDIA	0xF0
  003B    05CE    ANDR	0x4E
  003C    084D    LD	A,0x4D
  003D    390F    ANDIA	0xF
  003E    04CE    ORR	0x4E
  003F    30F0    LDIA	0xF0
  0040    05CD    ANDR	0x4D
  0041    1683    SETB	0x3,5
  0042    0E1E    SWAPA	0x1E
  0043    390F    ANDIA	0xF
  0044    1283    CLRB	0x3,5
  0045    07CD    ADDR	0x4D
  0046    1803    SZB	0x3,0
  0047    0ACE    INCR	0x4E
31:               	
32:               	if(0 == admax)
  0048    0824    LD	A,0x24
  0049    0425    ORA	0x25
  004A    1D03    SNZB	0x3,2
  004B    284E    JP	0x4E
33:               	{
34:               		admax = ad_temp;
  004C    20BF    CALL	0xBF
  004D    2860    JP	0x60
35:               		admin = ad_temp;
36:               	}
37:               	else if(ad_temp > admax)
  004E    084E    LD	A,0x4E
  004F    0225    SUBA	0x25
  0050    1D03    SNZB	0x3,2
  0051    2854    JP	0x54
  0052    084D    LD	A,0x4D
  0053    0224    SUBA	0x24
  0054    1803    SZB	0x3,0
  0055    2858    JP	0x58
38:               		admax = ad_temp;				//AD采样最大值
  0056    20BF    CALL	0xBF
  0057    2864    JP	0x64
39:               	else if(ad_temp < admin)
  0058    0827    LD	A,0x27
  0059    024E    SUBA	0x4E
  005A    1D03    SNZB	0x3,2
  005B    285E    JP	0x5E
  005C    0826    LD	A,0x26
  005D    024D    SUBA	0x4D
  005E    1803    SZB	0x3,0
  005F    2864    JP	0x64
40:               		admin = ad_temp;				//AD采样最小值
  0060    084E    LD	A,0x4E
  0061    00A7    LD	0x27,A
  0062    084D    LD	A,0x4D
  0063    00A6    LD	0x26,A
41:               	
42:               	adsum += ad_temp;
  0064    084D    LD	A,0x4D
  0065    00C7    LD	0x47,A
  0066    084E    LD	A,0x4E
  0067    00C8    LD	0x48,A
  0068    01C9    CLR	0x49
  0069    01CA    CLR	0x4A
  006A    0847    LD	A,0x47
  006B    07A0    ADDR	0x20
  006C    0848    LD	A,0x48
  006D    1103    CLRB	0x3,2
  006E    1803    SZB	0x3,0
  006F    3E01    ADDIA	0x1
  0070    1D03    SNZB	0x3,2
  0071    07A1    ADDR	0x21
  0072    0849    LD	A,0x49
  0073    1103    CLRB	0x3,2
  0074    1803    SZB	0x3,0
  0075    3E01    ADDIA	0x1
  0076    1D03    SNZB	0x3,2
  0077    07A2    ADDR	0x22
  0078    084A    LD	A,0x4A
  0079    1103    CLRB	0x3,2
  007A    1803    SZB	0x3,0
  007B    3E01    ADDIA	0x1
  007C    1D03    SNZB	0x3,2
  007D    07A3    ADDR	0x23
43:               	if(++adtimes >= 10)
  007E    300A    LDIA	0xA
  007F    0AB0    INCR	0x30
  0080    0230    SUBA	0x30
  0081    1C03    SNZB	0x3,0
  0082    0008    RET
44:               	{
45:               		adsum -= admax;
  0083    0824    LD	A,0x24
  0084    00C7    LD	0x47,A
  0085    0825    LD	A,0x25
  0086    20B0    CALL	0xB0
  0087    1C03    SNZB	0x3,0
  0088    0F4A    SZINCA	0x4A
  0089    02A3    SUBR	0x23
46:               		adsum -= admin;
  008A    0826    LD	A,0x26
  008B    00C7    LD	0x47,A
  008C    0827    LD	A,0x27
  008D    20B0    CALL	0xB0
  008E    1C03    SNZB	0x3,0
  008F    0F4A    SZINCA	0x4A
  0090    02A3    SUBR	0x23
47:               		
48:               		adresult = adsum >> 3;		//8次平均值作为最终结果
  0091    0820    LD	A,0x20
  0092    00C7    LD	0x47,A
  0093    0821    LD	A,0x21
  0094    00C8    LD	0x48,A
  0095    0822    LD	A,0x22
  0096    00C9    LD	0x49,A
  0097    0823    LD	A,0x23
  0098    00CA    LD	0x4A,A
  0099    3003    LDIA	0x3
  009A    1003    CLRB	0x3,0
  009B    0CCA    RRCR	0x4A
  009C    0CC9    RRCR	0x49
  009D    0CC8    RRCR	0x48
  009E    0CC7    RRCR	0x47
  009F    3EFF    ADDIA	0xFF
  00A0    1D03    SNZB	0x3,2
  00A1    289A    JP	0x9A
  00A2    0848    LD	A,0x48
  00A3    00AF    LD	0x2F,A
  00A4    0847    LD	A,0x47
  00A5    00AE    LD	0x2E,A
49:               		
50:               		adsum = 0;
  00A6    01A0    CLR	0x20
  00A7    01A1    CLR	0x21
  00A8    01A2    CLR	0x22
  00A9    01A3    CLR	0x23
51:               		admin = 0;
  00AA    01A6    CLR	0x26
  00AB    01A7    CLR	0x27
52:               		admax = 0;
  00AC    01A4    CLR	0x24
  00AD    01A5    CLR	0x25
53:               		adtimes = 0;
  00AE    01B0    CLR	0x30
  00AF    0008    RET
54:               	}
55:               }
56:               
57:               
58:               //ADC单次采样
59:               unsigned char ADC_Result(unsigned char adch)
  02D3    00C7    LD	0x47,A
60:               {
61:               	ADCON1 = 0;						//左对齐
  02D4    1683    SETB	0x3,5
  02D5    019F    CLR	0x1F
62:               	ADCON0 = 0X41 | (adch << 2);	//16分频
  02D6    1283    CLRB	0x3,5
  02D7    0847    LD	A,0x47
  02D8    00F4    LD	0x74,A
  02D9    3001    LDIA	0x1
  02DA    1003    CLRB	0x3,0
  02DB    0DF4    RLCR	0x74
  02DC    3EFF    ADDIA	0xFF
  02DD    1003    CLRB	0x3,0
  02DE    1D03    SNZB	0x3,2
  02DF    2ADB    JP	0x2DB
  02E0    0D74    RLCA	0x74
  02E1    3841    ORIA	0x41
  02E2    009F    LD	0x1F,A
  02E3    0000    NOP
  02E4    0000    NOP
63:               	asm("nop");
64:               	asm("nop");
65:               	GODONE = 1;						//开始转换
  02E5    1283    CLRB	0x3,5
  02E6    1303    CLRB	0x3,6
  02E7    149F    SETB	0x1F,1
66:               
67:               	unsigned char i = 0;
  02E8    01C8    CLR	0x48
68:               	while(GODONE)
  02E9    1C9F    SNZB	0x1F,1
  02EA    2AEE    JP	0x2EE
69:               	{
70:               		if(0 == (--i))
  02EB    0BC8    SZDECR	0x48
  02EC    2AE9    JP	0x2E9
71:               			return 0;				//转换超时
  02ED    3400    RET	0x0
72:               	}
73:               	return ADRESH;
  02EE    081E    LD	A,0x1E
  02EF    0008    RET
74:               }
75:               /***********************************************************
76:               函数名称：DelayXms
77:               函数功能：毫秒级非精准延时
78:               入口参数：x - 延时时间
79:               出口参数：
80:               备    注：
81:               ***********************************************************/
82:               void DelayXms(unsigned char x)
  0365    00C7    LD	0x47,A
83:               {
84:               	unsigned char i,j;
85:               	for(i=x;i>0;i--)
  0366    00C8    LD	0x48,A
  0367    0848    LD	A,0x48
  0368    1903    SZB	0x3,2
  0369    0008    RET
86:               		for(j=153;j>0;j--);
  036A    3099    LDIA	0x99
  036B    00C9    LD	0x49,A
  036C    0BC9    SZDECR	0x49
  036D    2B6C    JP	0x36C
  036E    03C8    DECR	0x48
  036F    2B67    JP	0x367
87:               }
88:               
89:               //读取内部电压
90:               unsigned char readVrefADC()
91:               {
92:               	DelayXms(1);
  0394    3001    LDIA	0x1
  0395    2365    CALL	0x365
93:               	ADC_Sample(15);
  0396    300F    LDIA	0xF
  0397    201A    CALL	0x1A
  0398    300F    LDIA	0xF
  0399    2AD3    JP	0x2D3
94:               	unsigned char result;
95:               		
96:               	result = ADC_Result(15);
97:               	return result;
98:               }
---- E:\cms\SCMCU_IDE_V2.00.07\data\sources\common\awdiv.c ----------------------------------------------------------------------
1:                // integer signed division
2:                
3:                signed int
4:                #ifdef __PICC__
5:                #warning TODO: update cgpic and this file to use the other prototype
6:                __awdiv(signed int divisor, signed int dividend)
  00C4    01CC    CLR	0x4C
  00C5    1FC8    SNZB	0x48,7
  00C6    28CE    JP	0xCE
  00C7    09C7    COMR	0x47
  00C8    09C8    COMR	0x48
  00C9    0AC7    INCR	0x47
  00CA    1903    SZB	0x3,2
  00CB    0AC8    INCR	0x48
  00CC    01CC    CLR	0x4C
  00CD    0ACC    INCR	0x4C
  00CE    1FCA    SNZB	0x4A,7
  00CF    28D7    JP	0xD7
  00D0    09C9    COMR	0x49
  00D1    09CA    COMR	0x4A
  00D2    0AC9    INCR	0x49
  00D3    1903    SZB	0x3,2
  00D4    0ACA    INCR	0x4A
  00D5    3001    LDIA	0x1
  00D6    06CC    XORR	0x4C
  00D7    01CD    CLR	0x4D
  00D8    01CE    CLR	0x4E
  00D9    0847    LD	A,0x47
  00DA    0448    ORA	0x48
  00DB    1903    SZB	0x3,2
  00DC    28FC    JP	0xFC
  00DD    01CB    CLR	0x4B
  00DE    0ACB    INCR	0x4B
  00DF    1BC8    SZB	0x48,7
  00E0    28E5    JP	0xE5
  00E1    1003    CLRB	0x3,0
  00E2    0DC7    RLCR	0x47
  00E3    0DC8    RLCR	0x48
  00E4    28DE    JP	0xDE
  00E5    1003    CLRB	0x3,0
  00E6    0DCD    RLCR	0x4D
  00E7    0DCE    RLCR	0x4E
  00E8    0848    LD	A,0x48
  00E9    024A    SUBA	0x4A
  00EA    1D03    SNZB	0x3,2
  00EB    28EE    JP	0xEE
  00EC    0847    LD	A,0x47
  00ED    0249    SUBA	0x49
  00EE    1C03    SNZB	0x3,0
  00EF    28F8    JP	0xF8
  00F0    0847    LD	A,0x47
  00F1    02C9    SUBR	0x49
  00F2    0848    LD	A,0x48
  00F3    1C03    SNZB	0x3,0
  00F4    03CA    DECR	0x4A
  00F5    02CA    SUBR	0x4A
  00F6    144D    SETB	0x4D,0
  00F7    1003    CLRB	0x3,0
  00F8    0CC8    RRCR	0x48
  00F9    0CC7    RRCR	0x47
  00FA    0BCB    SZDECR	0x4B
  00FB    28E5    JP	0xE5
  00FC    084C    LD	A,0x4C
  00FD    1903    SZB	0x3,2
  00FE    2904    JP	0x104
  00FF    09CD    COMR	0x4D
  0100    09CE    COMR	0x4E
  0101    0ACD    INCR	0x4D
  0102    1903    SZB	0x3,2
  0103    0ACE    INCR	0x4E
  0104    084E    LD	A,0x4E
  0105    00C8    LD	0x48,A
  0106    084D    LD	A,0x4D
  0107    00C7    LD	0x47,A
  0108    0008    RET
7:                #else
8:                __awdiv(signed int dividend, signed int divisor)
9:                #endif
10:               {
11:               	signed int	quotient;
12:               	unsigned char	counter, sign;
13:               
14:               	sign = 0;
15:               	if(divisor < 0) {
16:               		divisor = -divisor;
17:               		sign = 1;
18:               	}
19:               	if(dividend < 0) {
20:               		dividend = -dividend;
21:               		sign ^= 1;
22:               	}
23:               	quotient = 0;
24:               	if(divisor != 0) {
25:               		counter = 1;
26:               		while((divisor & 0x8000U) == 0) {
27:               			divisor <<= 1;
28:               			counter++;
29:               		}
30:               		do {
31:               			quotient <<= 1;
32:               			if((unsigned int)divisor <= (unsigned int)dividend) {
33:               				dividend -= divisor;
34:               				quotient |= 1;
35:               			}
36:               			*(unsigned int *)&divisor >>= 1;
37:               		} while(--counter != 0);
38:               	}
39:               	if(sign)
40:               		quotient = -quotient;
41:               	return quotient;
42:               }
---- E:\project\project0508\scm\uf166fan\init.c ----------------------------------------------------------------------
1:                #include "init.h"
2:                
3:                void Init_System() {
  037B    0000    NOP
  037C    0064    CLRWDT
  03A3    0000    NOP
  03A4    0064    CLRWDT
4:                    asm("nop");
5:                    asm("clrwdt");
6:                    INTCON = 0;                    //系统初始化
7:                    OSCCON = 0X71;                //配置振荡为8M,开 WDT
8:                    OPTION_REG = 0x00;        //Timer0使用内部时钟Focs/4，预分频比为1:2
  037D    2B7E    JP	0x37E
  03A5    2B7E    JP	0x37E
9:                
10:               }
11:               
12:               
13:               void Init_GPIO() {
14:                   TRISA = 0;
15:                   TRISB = 0;
16:                   TRISC = 0;
17:                   WPUA = 0xFF;
18:                   WPUB = 0xFF;
19:                   WPUC = 0xFF;
20:                   PORTA = 0xFF;
21:                   PORTB = 0xFF;
22:                   PORTC = 0xFF;
23:                   IOCB = 0x00;
  0306    2B07    JP	0x307
  03A8    2B07    JP	0x307
24:               
25:               }
26:               
27:               void Init_Interupt() {
28:                   OPTION_REG = 0x00;        //Timer0使用内部时钟Focs/4，预分频比为1:2
29:                   TMR0 = 0;                //赋予初始值
30:                   INTCON = 0xE0;            //允许所有未被屏蔽的中断、禁止外设中断，使能Timer0
  038D    2B8E    JP	0x38E
  03A7    2B8E    JP	0x38E
31:               
32:               }
---- stringtab ------------------------------------------------------------------
---- reset_enter ------------------------------------------------------------------
  0000    280C    JP	0xC
  000C    280D    JP	0xD
---- start_initialization ------------------------------------------------------------------
  000D    3002    LDIA	0x2
  000E    00F8    LD	0x78,A
  000F    3003    LDIA	0x3
  0010    00F9    LD	0x79,A
  0011    3020    LDIA	0x20
  0012    1383    CLRB	0x3,7
  0013    0084    LD	0x4,A
  0014    3047    LDIA	0x47
  0015    2385    CALL	0x385
  0016    01F6    CLR	0x76
  0017    01F7    CLR	0x77
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F1    LD	0x71,A
  0007    0804    LD	A,0x4
  0008    00F2    LD	0x72,A
  0009    080A    LD	A,0xA
  000A    00F3    LD	0x73,A
  000B    2AF0    JP	0x2F0
---- common_function ------------------------------------------------------------------
  0018    0183    CLR	0x3
  0019    2A32    JP	0x232
  00B0    00C8    LD	0x48,A
  00B1    01C9    CLR	0x49
  00B2    01CA    CLR	0x4A
  00B3    0847    LD	A,0x47
  00B4    02A0    SUBR	0x20
  00B5    0848    LD	A,0x48
  00B6    1C03    SNZB	0x3,0
  00B7    0F48    SZINCA	0x48
  00B8    02A1    SUBR	0x21
  00B9    0849    LD	A,0x49
  00BA    1C03    SNZB	0x3,0
  00BB    0F49    SZINCA	0x49
  00BC    02A2    SUBR	0x22
  00BD    084A    LD	A,0x4A
  00BE    0008    RET
  00BF    084E    LD	A,0x4E
  00C0    00A5    LD	0x25,A
  00C1    084D    LD	A,0x4D
  00C2    00A4    LD	0x24,A
  00C3    0008    RET
  0180    082F    LD	A,0x2F
  0181    00C8    LD	0x48,A
  0182    082E    LD	A,0x2E
  0183    00C7    LD	0x47,A
  0184    3000    LDIA	0x0
  0185    1003    CLRB	0x3,0
  0186    0CC8    RRCR	0x48
  0187    0CC7    RRCR	0x47
  0188    1003    CLRB	0x3,0
  0189    0CC8    RRCR	0x48
  018A    0CC7    RRCR	0x47
  018B    1003    CLRB	0x3,0
  018C    0CC8    RRCR	0x48
  018D    0CC7    RRCR	0x47
  018E    0248    SUBA	0x48
  018F    0008    RET
  01FA    1683    SETB	0x3,5
  01FB    1087    CLRB	0x7,1
  01FC    1785    SETB	0x5,7
  01FD    1007    CLRB	0x7,0
  01FE    1283    CLRB	0x3,5
  01FF    1385    CLRB	0x5,7
  0200    0008    RET
  0201    1683    SETB	0x3,5
  0202    1407    SETB	0x7,0
  0203    1385    CLRB	0x5,7
  0204    1087    CLRB	0x7,1
  0205    1283    CLRB	0x3,5
  0206    0008    RET
  0282    3004    LDIA	0x4
  0283    0096    LD	0x16,A
  0284    309B    LDIA	0x9B
  0285    1283    CLRB	0x3,5
  0286    0081    LD	0x1,A
  0287    1203    CLRB	0x3,4
  0288    3005    LDIA	0x5
  0289    00C6    LD	0x46,A
  028A    3004    LDIA	0x4
  028B    00BF    LD	0x3F,A
  028C    3003    LDIA	0x3
  028D    00B8    LD	0x38,A
  028E    3440    RET	0x40
  028F    1683    SETB	0x3,5
  0290    1303    CLRB	0x3,6
  0291    0185    CLR	0x5
  0292    307E    LDIA	0x7E
  0293    0086    LD	0x6,A
  0294    0187    CLR	0x7
  0295    1283    CLRB	0x3,5
  0296    01B1    CLR	0x31
  0297    0008    RET
  0307    0185    CLR	0x5
  0308    0186    CLR	0x6
  0309    0187    CLR	0x7
  030A    30FF    LDIA	0xFF
  030B    1703    SETB	0x3,6
  030C    008E    LD	0xE,A
  030D    1303    CLRB	0x3,6
  030E    0095    LD	0x15,A
  030F    1703    SETB	0x3,6
  0310    008F    LD	0xF,A
  0311    1283    CLRB	0x3,5
  0312    1303    CLRB	0x3,6
  0313    0085    LD	0x5,A
  0314    0086    LD	0x6,A
  0315    0087    LD	0x7,A
  0316    1683    SETB	0x3,5
  0317    0196    CLR	0x16
  0318    0008    RET
  0358    300F    LDIA	0xF
  0359    0097    LD	0x17,A
  035A    0192    CLR	0x12
  035B    3007    LDIA	0x7
  035C    1683    SETB	0x3,5
  035D    0092    LD	0x12,A
  035E    1283    CLRB	0x3,5
  035F    0195    CLR	0x15
  0360    108C    CLRB	0xC,1
  0361    0192    CLR	0x12
  0362    1683    SETB	0x3,5
  0363    1107    CLRB	0x7,2
  0364    0008    RET
  037E    018B    CLR	0xB
  037F    3071    LDIA	0x71
  0380    1683    SETB	0x3,5
  0381    1303    CLRB	0x3,6
  0382    008F    LD	0xF,A
  0383    0181    CLR	0x1
  0384    0008    RET
  0385    0064    CLRWDT
  0386    0180    CLR	0x0
  0387    0A84    INCR	0x4
  0388    0604    XORA	0x4
  0389    1903    SZB	0x3,2
  038A    3400    RET	0x0
  038B    0604    XORA	0x4
  038C    2B86    JP	0x386
  038E    0181    CLR	0x1
  038F    1283    CLRB	0x3,5
  0390    0181    CLR	0x1
  0391    30E0    LDIA	0xE0
  0392    008B    LD	0xB,A
  0393    0008    RET
  039A    29D0    JP	0x1D0
  039B    29D4    JP	0x1D4
  039C    29D8    JP	0x1D8
  039D    29DD    JP	0x1DD
  039E    29E2    JP	0x1E2
  039F    2913    JP	0x113
  03A0    291B    JP	0x11B
  03A1    2925    JP	0x125
  03A2    2938    JP	0x138
