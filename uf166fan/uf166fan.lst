---- C:\SCMCU WorkSpace\uf166fan\main.c ----------------------------------------------------------------------
1:                #include "scankey.h"
2:                #include "init.h"
3:                
4:                #define MAX_FAN_LEVEL 4
5:                #define MIN_FAN_LEVEL 1
6:                
7:                #define FAN_STATUS_OFF  0
8:                #define FAN_STATUS_ON  1
9:                #define FAN_STATUS_NONE 2
10:               
11:               #define LED_1  1
12:               #define LED_2  2
13:               #define LED_3  3
14:               #define LED_4  4
15:               
16:               static unsigned char time0Flag = 0;
17:               static unsigned int countTime = 0;
18:               static unsigned int count10Ms = 0;
19:               unsigned char currentLevel = 2;
20:               
21:               unsigned char FAN_STATUS = FAN_STATUS_NONE;
22:               //检测风扇次数
23:               unsigned int fan_check_time = 0;
24:               
25:               struct Keys key1,key2,key3;
26:               
27:               void setLedOn(int ledIndex);
28:               
29:               void checkUsbStatus()
30:               {
31:               	if(getbit(PORTB,2) == 1){
  01C8    0806    LD	A,0x6
  01C9    00F2    LD	0x72,A
  01CA    1003    CLRB	0x3,0
  01CB    0CF2    RRCR	0x72
  01CC    1003    CLRB	0x3,0
  01CD    0CF2    RRCR	0x72
  01CE    1C72    SNZB	0x72,0
  01CF    29E2    JP	0x1E2
32:               		if(getbit(PORTB,1) == 1){
  01D0    0806    LD	A,0x6
  01D1    00F2    LD	0x72,A
  01D2    1003    CLRB	0x3,0
  01D3    0CF2    RRCR	0x72
  01D4    1C72    SNZB	0x72,0
  01D5    29D8    JP	0x1D8
33:               			//充满了，Led常亮
34:               			resetbit(PORTA,0);
  01D6    1005    CLRB	0x5,0
35:               		}else if(countTime == 1000){
  01D7    0008    RET
  01D8    30E8    LDIA	0xE8
  01D9    0678    XORA	0x78
  01DA    3003    LDIA	0x3
  01DB    1903    SZB	0x3,2
  01DC    0679    XORA	0x79
  01DD    1D03    SNZB	0x3,2
  01DE    0008    RET
36:               			//充电中，一直闪		
37:               				reversebit(PORTA,0);
  01DF    3001    LDIA	0x1
  01E0    0685    XORR	0x5
  01E1    0008    RET
38:               		}
39:               	}else{
40:               		//usb断开充电灯熄灭,PA0 = 1
41:               		setbit(PORTA,0);
  01E2    1405    SETB	0x5,0
  01E3    0008    RET
42:               	}
43:               }
44:               
45:               void Init_PWM()
46:               {
47:               	CCP1CON = 0x0F;//设置PC2为PWM模式，4,5位为占空比的低2位
  0249    300F    LDIA	0xF
  024A    0097    LD	0x17,A
48:               	T2CON = 0; //时钟分频 1:1 PWM周期为（PR2+1）*4/8,000,000
  024B    0192    CLR	0x12
49:               	PR2 = 199;
  024C    30C7    LDIA	0xC7
  024D    1683    SETB	0x3,5
  024E    0092    LD	0x12,A
50:               	
51:               	CCPR1L = 0;//占空比高8位，低2位设置为0，结果就是 占空比 = CCPR1L*4/4*(PR2+1)
  024F    1283    CLRB	0x3,5
  0250    0195    CLR	0x15
52:               	TMR2IF = 0;
  0251    108C    CLRB	0xC,1
53:               	T2CON = 0;
  0252    0192    CLR	0x12
54:               	//PC2设置为输出脚
55:               	resetbit(TRISC,2);
  0253    1683    SETB	0x3,5
  0254    1107    CLRB	0x7,2
  0255    0008    RET
56:               	//T2CON = 0X04 //启动定时器2，溢出后启动PWM
57:               }
58:               
59:               //设置风扇转速
60:               void setFanLevel(char level)
  010D    1283    CLRB	0x3,5
  010E    1303    CLRB	0x3,6
  010F    00BD    LD	0x3D,A
61:               {
62:               	unsigned int levelWidth =  (PR2+1)/MAX_FAN_LEVEL;
  0110    1683    SETB	0x3,5
  0111    0812    LD	A,0x12
  0112    00F4    LD	0x74,A
  0113    01F5    CLR	0x75
  0114    0AF4    INCR	0x74
  0115    1903    SZB	0x3,2
  0116    0AF5    INCR	0x75
  0117    3004    LDIA	0x4
  0118    00F2    LD	0x72,A
  0119    01F3    CLR	0x73
  011A    2018    CALL	0x18
  011B    0873    LD	A,0x73
  011C    00BF    LD	0x3F,A
  011D    0872    LD	A,0x72
  011E    00BE    LD	0x3E,A
63:               	char tempLevel =  currentLevel + level;
  011F    083D    LD	A,0x3D
  0120    0742    ADDA	0x42
  0121    00C0    LD	0x40,A
64:               	if(tempLevel > MAX_FAN_LEVEL)
  0122    3005    LDIA	0x5
  0123    0240    SUBA	0x40
  0124    1C03    SNZB	0x3,0
  0125    2928    JP	0x128
65:               	{
66:               		tempLevel = MAX_FAN_LEVEL;
  0126    3004    LDIA	0x4
  0127    00C0    LD	0x40,A
67:               	}
68:               	
69:               	if(tempLevel < MIN_FAN_LEVEL)
  0128    0840    LD	A,0x40
  0129    1D03    SNZB	0x3,2
  012A    292D    JP	0x12D
70:               	{
71:               		tempLevel = MIN_FAN_LEVEL;
  012B    01C0    CLR	0x40
  012C    0AC0    INCR	0x40
72:               	}
73:               	currentLevel = tempLevel;
  012D    0840    LD	A,0x40
  012E    00C2    LD	0x42,A
74:               	//设置占宽比
75:               	CCPR1L = levelWidth*currentLevel;
  012F    083E    LD	A,0x3E
  0130    00F2    LD	0x72,A
  0131    0842    LD	A,0x42
  0132    223B    CALL	0x23B
  0133    0095    LD	0x15,A
76:               	if(FAN_STATUS == FAN_STATUS_ON)
  0134    0B41    SZDECA	0x41
  0135    0008    RET
77:               	{
78:               		setLedOn(currentLevel);
  0136    0842    LD	A,0x42
  0137    00F2    LD	0x72,A
  0138    01F3    CLR	0x73
  0139    293A    JP	0x13A
79:               	}
80:               	
81:               }
82:               
83:               //关闭风扇
84:               void closeFan()
85:               {
86:               	Init_PWM();
  021B    2249    CALL	0x249
87:               	currentLevel = 2;
  021C    3002    LDIA	0x2
  021D    1283    CLRB	0x3,5
  021E    00C2    LD	0x42,A
88:               	setLedOn(5);
  021F    3005    LDIA	0x5
  0220    00F2    LD	0x72,A
  0221    01F3    CLR	0x73
  0222    213A    CALL	0x13A
89:               	setbit(PORTA,0);
  0223    1405    SETB	0x5,0
90:               	//PWM输出脚设置为输入，关闭PWM
91:               	setbit(TRISC,2);
  0224    1683    SETB	0x3,5
  0225    1507    SETB	0x7,2
92:               	fan_check_time = 0;
  0226    1283    CLRB	0x3,5
  0227    01A0    CLR	0x20
  0228    01A1    CLR	0x21
93:               	FAN_STATUS = FAN_STATUS_OFF;
  0229    01C1    CLR	0x41
  022A    0008    RET
94:               	
95:               }
96:               
97:               
98:               //检测风扇是否连接
99:               void checkFan()
100:              {	
101:              	
102:              	setbit(PORTA,1);
  0163    1485    SETB	0x5,1
103:              	setFanLevel(0);
  0164    3000    LDIA	0x0
  0165    210D    CALL	0x10D
104:              	//PC2设置为输出脚
105:              	resetbit(TRISC,2);
  0166    1683    SETB	0x3,5
  0167    1107    CLRB	0x7,2
106:              	T2CON = 0X04; //启动定时器2，溢出后启动PWM
  0168    3004    LDIA	0x4
  0169    1283    CLRB	0x3,5
  016A    0092    LD	0x12,A
107:              	
108:              	//EN IN输出高电位，D1点亮，检测FAN DET，FAN DET为低电位则风扇正常工作，高电位则未连接
109:              	if(getbit(PORTB,6) == 0)
  016B    0806    LD	A,0x6
  016C    00F6    LD	0x76,A
  016D    3006    LDIA	0x6
  016E    1003    CLRB	0x3,0
  016F    0CF6    RRCR	0x76
  0170    3EFF    ADDIA	0xFF
  0171    1D03    SNZB	0x3,2
  0172    296E    JP	0x16E
  0173    1876    SZB	0x76,0
  0174    2978    JP	0x178
110:              	{
111:              		FAN_STATUS = FAN_STATUS_ON;
  0175    01C1    CLR	0x41
  0176    0AC1    INCR	0x41
112:              	}else
  0177    297A    JP	0x17A
113:              	{
114:              		FAN_STATUS = FAN_STATUS_NONE;
  0178    3002    LDIA	0x2
  0179    00C1    LD	0x41,A
115:              	}
116:              	
117:              	//没有检测到风扇
118:              	if(FAN_STATUS == FAN_STATUS_NONE)
  017A    3002    LDIA	0x2
  017B    0641    XORA	0x41
  017C    1D03    SNZB	0x3,2
  017D    0008    RET
119:              	{
120:              		fan_check_time++;
  017E    0AA0    INCR	0x20
  017F    1903    SZB	0x3,2
  0180    0AA1    INCR	0x21
121:              		if(fan_check_time == 3000)
  0181    30B8    LDIA	0xB8
  0182    0620    XORA	0x20
  0183    300B    LDIA	0xB
  0184    1903    SZB	0x3,2
  0185    0621    XORA	0x21
  0186    1D03    SNZB	0x3,2
  0187    0008    RET
122:              		{
123:              			closeFan();
  0188    2A1B    JP	0x21B
124:              			return;
125:              		}
126:              	}
127:              	
128:              	
129:              	
130:              	
131:              }
132:              
133:              
134:              
135:              
136:              
137:              //设置Led灯亮
138:              void setLedOn(int ledIndex)
139:              {
140:              	switch(ledIndex)
  013A    294F    JP	0x14F
141:              	{
142:              		case 1:
143:              		resetbit(PORTB,7); setbit(PORTC,0); resetbit(PORTC,1);
  013B    1386    CLRB	0x6,7
  013C    1407    SETB	0x7,0
  013D    1087    CLRB	0x7,1
144:              		break;
  013E    0008    RET
145:              		case 2:
146:              		setbit(PORTB,7); resetbit(PORTC,0); setbit(PORTC,1);
  013F    1786    SETB	0x6,7
  0140    1007    CLRB	0x7,0
  0141    1487    SETB	0x7,1
147:              		break;
  0142    0008    RET
148:              		setbit(PORTB,7); resetbit(PORTC,0); setbit(PORTC,1);
149:              		case 3:
150:              		setbit(PORTB,7); resetbit(PORTC,0); resetbit(PORTC,1);
  0143    1786    SETB	0x6,7
  0144    1007    CLRB	0x7,0
  0145    1087    CLRB	0x7,1
151:              		break;
  0146    0008    RET
152:              		case 4:
153:              		resetbit(PORTB,7); setbit(PORTC,0); setbit(PORTC,1);
  0147    1386    CLRB	0x6,7
  0148    1407    SETB	0x7,0
  0149    1487    SETB	0x7,1
154:              		break;
  014A    0008    RET
155:              		default:
156:              		resetbit(PORTB,7); resetbit(PORTC,0); resetbit(PORTC,1);
  014B    1386    CLRB	0x6,7
  014C    1007    CLRB	0x7,0
  014D    1087    CLRB	0x7,1
157:              		break;
  014E    0008    RET
  014F    0873    LD	A,0x73
  0150    3A00    XORIA	0x0
  0151    1903    SZB	0x3,2
  0152    2954    JP	0x154
  0153    294B    JP	0x14B
  0154    0872    LD	A,0x72
  0155    3A01    XORIA	0x1
  0156    1903    SZB	0x3,2
  0157    293B    JP	0x13B
  0158    3A03    XORIA	0x3
  0159    1903    SZB	0x3,2
  015A    293F    JP	0x13F
  015B    3A01    XORIA	0x1
  015C    1903    SZB	0x3,2
  015D    2943    JP	0x143
  015E    3A07    XORIA	0x7
  015F    1903    SZB	0x3,2
  0160    2947    JP	0x147
  0161    294B    JP	0x14B
  0162    0008    RET
158:              	}
159:              }
160:              
161:              //扫描按键
162:              void scanKeys()
163:              {
164:              	key1.key_addr_result = key2.key_addr_result = key3.key_addr_result = PORTB;
  01E4    1283    CLRB	0x3,5
  01E5    1303    CLRB	0x3,6
  01E6    0806    LD	A,0x6
  01E7    00A9    LD	0x29,A
  01E8    00B0    LD	0x30,A
  01E9    00B7    LD	0x37,A
165:              	sacnKeyInput(&key1);
  01EA    3032    LDIA	0x32
  01EB    21AB    CALL	0x1AB
166:              	sacnKeyInput(&key2);
  01EC    302B    LDIA	0x2B
  01ED    21AB    CALL	0x1AB
167:              	sacnKeyInput(&key3);
  01EE    3024    LDIA	0x24
  01EF    21AB    CALL	0x1AB
168:              	countTime++;
  01F0    0AF8    INCR	0x78
  01F1    1903    SZB	0x3,2
  01F2    0AF9    INCR	0x79
169:              	count10Ms++;
  01F3    1283    CLRB	0x3,5
  01F4    1303    CLRB	0x3,6
  01F5    0AA2    INCR	0x22
  01F6    1903    SZB	0x3,2
  01F7    0AA3    INCR	0x23
  01F8    0008    RET
170:              }
171:              
172:              //检测按键状态并处理
173:              void checkKeys()
174:              {
175:              	if(key_read(&key1) != key_no)
  0189    3032    LDIA	0x32
  018A    20D8    CALL	0xD8
  018B    3A00    XORIA	0x0
  018C    1903    SZB	0x3,2
  018D    2996    JP	0x196
176:              	{
177:              		//检测到按键了，检测风扇是否存在
178:              		
179:              		if(FAN_STATUS == FAN_STATUS_ON)
  018E    1283    CLRB	0x3,5
  018F    1303    CLRB	0x3,6
  0190    0B41    SZDECA	0x41
  0191    2993    JP	0x193
180:              		{
181:              			//关闭风扇
182:              			closeFan();
  0192    2A1B    JP	0x21B
183:              		}else
184:              		{
185:              			FAN_STATUS = FAN_STATUS_NONE;
  0193    3002    LDIA	0x2
  0194    00C1    LD	0x41,A
186:              			checkFan();
  0195    2963    JP	0x163
187:              		}
188:              		return;
189:              	}
190:              	else if(FAN_STATUS == FAN_STATUS_NONE)
  0196    3002    LDIA	0x2
  0197    1283    CLRB	0x3,5
  0198    1303    CLRB	0x3,6
  0199    0641    XORA	0x41
  019A    1D03    SNZB	0x3,2
  019B    299D    JP	0x19D
191:              	{
192:              		checkFan();
  019C    2163    CALL	0x163
193:              	}
194:              	
195:              	
196:              	
197:              	if(key_read(&key2) != key_no)
  019D    302B    LDIA	0x2B
  019E    20D8    CALL	0xD8
  019F    3A00    XORIA	0x0
  01A0    1903    SZB	0x3,2
  01A1    29A4    JP	0x1A4
198:              	{
199:              		//加档
200:              		setFanLevel(1);
  01A2    3001    LDIA	0x1
  01A3    290D    JP	0x10D
201:              		return;
202:              	}
203:              	
204:              	if(key_read(&key3) != key_no)
  01A4    3024    LDIA	0x24
  01A5    20D8    CALL	0xD8
  01A6    3A00    XORIA	0x0
  01A7    1903    SZB	0x3,2
  01A8    0008    RET
205:              	{
206:              		//减档
207:              		setFanLevel(-1);
  01A9    30FF    LDIA	0xFF
  01AA    290D    JP	0x10D
208:              		return;
209:              	}
210:              			
211:              }
212:              
213:              
214:              void main(void)
215:              {
216:              	Init_System();
  00A0    2256    CALL	0x256
217:              	Init_GPIO();
  00A1    21F9    CALL	0x1F9
218:              	Init_Interupt();
  00A2    2268    CALL	0x268
219:              	Init_PWM();
  00A3    2249    CALL	0x249
220:              	//设置唤醒
221:              	IOCB = 0x04;
  00A4    3004    LDIA	0x4
  00A5    0096    LD	0x16,A
222:              	TMR0 = 155;
  00A6    309B    LDIA	0x9B
  00A7    1283    CLRB	0x3,5
  00A8    0081    LD	0x1,A
223:              	TO = 0;
  00A9    1203    CLRB	0x3,4
224:              	
225:              	//K1开关
226:              	key1.key_index = 5;
  00AA    3005    LDIA	0x5
  00AB    00B8    LD	0x38,A
227:              	//K2加档
228:              	key2.key_index = 4;
  00AC    3004    LDIA	0x4
  00AD    00B1    LD	0x31,A
229:              	//K3减档
230:              	key3.key_index = 3;
  00AE    3003    LDIA	0x3
  00AF    00AA    LD	0x2A,A
231:              	resetKey(&key1);
  00B0    3032    LDIA	0x32
  00B1    220B    CALL	0x20B
232:              	resetKey(&key2);
  00B2    302B    LDIA	0x2B
  00B3    220B    CALL	0x20B
233:              	resetKey(&key3);
  00B4    3024    LDIA	0x24
  00B5    220B    CALL	0x20B
234:              	//设置IO方向
235:              	TRISA = 0;
  00B6    1683    SETB	0x3,5
  00B7    1303    CLRB	0x3,6
  00B8    0185    CLR	0x5
236:              	TRISB = 0x7E;//1-6脚输入
  00B9    307E    LDIA	0x7E
  00BA    0086    LD	0x6,A
237:              	TRISC = 0;
  00BB    0187    CLR	0x7
238:              	while(1)
239:              	{
240:              		//1毫秒检测一次
241:              		if(time0Flag)
  00BC    087A    LD	A,0x7A
  00BD    1903    SZB	0x3,2
  00BE    28C2    JP	0xC2
  00BF    0064    CLRWDT
242:              		{
243:              			asm("clrwdt");
244:              			time0Flag = 0;
  00C0    01FA    CLR	0x7A
245:              			scanKeys();
  00C1    21E4    CALL	0x1E4
246:              		}
247:              		
248:              		//10毫秒检测一次
249:              		if(count10Ms == 10)
  00C2    300A    LDIA	0xA
  00C3    1283    CLRB	0x3,5
  00C4    0622    XORA	0x22
  00C5    0423    ORA	0x23
  00C6    1D03    SNZB	0x3,2
  00C7    28CE    JP	0xCE
250:              		{
251:              			checkKeys();		
  00C8    2189    CALL	0x189
252:              			count10Ms = 0;
  00C9    1283    CLRB	0x3,5
  00CA    1303    CLRB	0x3,6
  00CB    01A2    CLR	0x22
  00CC    01A3    CLR	0x23
253:              			//检测USB状态
254:              			checkUsbStatus();	
  00CD    21C8    CALL	0x1C8
255:              		}
256:              			
257:              		if(countTime == 1000)
  00CE    30E8    LDIA	0xE8
  00CF    0678    XORA	0x78
  00D0    3003    LDIA	0x3
  00D1    1903    SZB	0x3,2
  00D2    0679    XORA	0x79
  00D3    1D03    SNZB	0x3,2
  00D4    28BC    JP	0xBC
258:              		{
259:              			countTime = 0;
  00D5    01F8    CLR	0x78
  00D6    01F9    CLR	0x79
  00D7    28BC    JP	0xBC
260:              		}
261:              	}
262:              	
263:              }
264:              
265:              
266:              /***********************************************
267:              函数名称：Timer0_Isr
268:              函数功能：中断服务
269:              入口参数：无
270:              出口参数：无
271:              备注：
272:              ***********************************************/
273:              void interrupt Timer0_Isr()
274:              {
275:              	if(T0IF)
  022B    1D0B    SNZB	0xB,2
  022C    2A34    JP	0x234
276:              	{
277:              	//---------------------------------------
278:              		TMR0 += 155;		//重新赋初值，在赋值前Timer0已有计数，故在该基础上加初值
  022D    309B    LDIA	0x9B
  022E    1283    CLRB	0x3,5
  022F    1303    CLRB	0x3,6
  0230    0781    ADDR	0x1
279:              	//---------------------------------------
280:              			
281:              		T0IF = 0;			//清中断标志位	
  0231    110B    CLRB	0xB,2
282:              		time0Flag =1;
  0232    01FA    CLR	0x7A
  0233    0AFA    INCR	0x7A
  0234    0871    LD	A,0x71
  0235    008A    LD	0xA,A
  0236    0E70    SWAPA	0x70
  0237    0083    LD	0x3,A
  0238    0EFE    SWAPR	0x7E
  0239    0E7E    SWAPA	0x7E
  023A    0009    RETI
283:              		
284:              	}
285:              	
286:              }
---- C:\SCMCU WorkSpace\uf166fan\scankey.c ----------------------------------------------------------------------
1:                #include "scankey.h"
2:                
3:                void sacnKeyInput(struct Keys* key)
  01AB    00F4    LD	0x74,A
4:                {
5:                    key->key_input = getbit(key->key_addr_result,key->key_index);
  01AC    3E05    ADDIA	0x5
  01AD    0084    LD	0x4,A
  01AE    1383    CLRB	0x3,7
  01AF    0800    LD	A,0x0
  01B0    00F2    LD	0x72,A
  01B1    0874    LD	A,0x74
  01B2    3E06    ADDIA	0x6
  01B3    0084    LD	0x4,A
  01B4    0A00    INCA	0x0
  01B5    29B8    JP	0x1B8
  01B6    1003    CLRB	0x3,0
  01B7    0CF2    RRCR	0x72
  01B8    3EFF    ADDIA	0xFF
  01B9    1D03    SNZB	0x3,2
  01BA    29B6    JP	0x1B6
  01BB    0872    LD	A,0x72
  01BC    00F3    LD	0x73,A
  01BD    0874    LD	A,0x74
  01BE    3E04    ADDIA	0x4
  01BF    0084    LD	0x4,A
  01C0    0873    LD	A,0x73
  01C1    0080    LD	0x0,A
  01C2    0874    LD	A,0x74
  01C3    3E04    ADDIA	0x4
  01C4    0084    LD	0x4,A
  01C5    3001    LDIA	0x1
  01C6    0580    ANDR	0x0
  01C7    0008    RET
6:                
7:                }
8:                
9:                
10:               static unsigned char key_driver(struct Keys * key)
  005E    00F4    LD	0x74,A
11:               {
12:               
13:               
14:                   unsigned char key_return = key_no;
  005F    01F2    CLR	0x72
15:                   unsigned char key_read = key->key_input;  //read the I/O states
  0060    3E04    ADDIA	0x4
  0061    0084    LD	0x4,A
  0062    1383    CLRB	0x3,7
  0063    0800    LD	A,0x0
  0064    00F3    LD	0x73,A
16:               
17:                   switch(key->key_state_buffer1)
  0065    2891    JP	0x91
18:                   {
19:                       case key_state_0:
20:                           if(key_read == 0)
  0066    0873    LD	A,0x73
  0067    1D03    SNZB	0x3,2
  0068    289E    JP	0x9E
21:                           {
22:                               key->key_state_buffer1 = key_state_1;
  0069    0A74    INCA	0x74
  006A    0084    LD	0x4,A
  006B    0180    CLR	0x0
  006C    0A80    INCR	0x0
  006D    289E    JP	0x9E
23:                           }
24:               
25:                           //按键被按下，状态转换到按键消抖和确认状态//
26:                           break;
27:               
28:                       case key_state_1:
29:                           if(key_read == 0)
  006E    0873    LD	A,0x73
  006F    1D03    SNZB	0x3,2
  0070    288D    JP	0x8D
30:                           {
31:                               key->key_timer_cnt1 = 0;
  0071    0874    LD	A,0x74
  0072    0084    LD	0x4,A
  0073    0180    CLR	0x0
32:                               key->key_state_buffer1 = key_state_2;
  0074    0A74    INCA	0x74
  0075    0084    LD	0x4,A
  0076    3002    LDIA	0x2
  0077    2889    JP	0x89
33:                               //按键仍然处于按下状态
34:                               //消抖完成，key_timer开始准备计时
35:                               //状态切换到按下时间计时状态
36:                           }
37:                           else
38:                           {
39:                               key->key_state_buffer1 = key_state_0;
40:                           }
41:               
42:                           //按键已经抬起，回到按键初始状态
43:                           break;  //完成软件消抖
44:               
45:                       case key_state_2:
46:                           if(key_read == 1)
  0078    0B73    SZDECA	0x73
  0079    287D    JP	0x7D
47:                           {
48:                               key_return = key_click;  //按键抬起，产生一次click操作
  007A    01F2    CLR	0x72
  007B    0AF2    INCR	0x72
  007C    288D    JP	0x8D
49:                               key->key_state_buffer1 = key_state_0;  //转换到按键初始状态
50:                           }
51:                           else if(++(key->key_timer_cnt1) >= 100)  //按键继续按下，计时超过1000ms
  007D    0874    LD	A,0x74
  007E    0084    LD	0x4,A
  007F    3064    LDIA	0x64
  0080    0A80    INCR	0x0
  0081    0200    SUBA	0x0
  0082    1C03    SNZB	0x3,0
  0083    289E    JP	0x9E
52:                           {
53:                               key_return = key_long;  //送回长按事件
  0084    3003    LDIA	0x3
  0085    00F2    LD	0x72,A
54:                               key->key_state_buffer1 = key_state_3;  //转换到等待按键释放状态
  0086    0A74    INCA	0x74
  0087    0084    LD	0x4,A
  0088    3003    LDIA	0x3
  0089    0080    LD	0x0,A
  008A    289E    JP	0x9E
55:                          
56:                           }
57:                           break;
58:               
59:                       case key_state_3:  //等待按键释放
60:                           if(key_read == 1)  //按键释放
  008B    0B73    SZDECA	0x73
  008C    289E    JP	0x9E
61:                           {
62:                               key->key_state_buffer1 = key_state_0;  //切回按键初始状态
  008D    0A74    INCA	0x74
  008E    0084    LD	0x4,A
  008F    0180    CLR	0x0
  0090    289E    JP	0x9E
  0091    0A74    INCA	0x74
  0092    0084    LD	0x4,A
  0093    0800    LD	A,0x0
  0094    0084    LD	0x4,A
  0095    3004    LDIA	0x4
  0096    0204    SUBA	0x4
  0097    1803    SZB	0x3,0
  0098    289E    JP	0x9E
  0099    3002    LDIA	0x2
  009A    008A    LD	0xA,A
  009B    306E    LDIA	0x6E
  009C    0704    ADDA	0x4
  009D    0082    LD	0x2,A
63:                           }
64:               
65:                           break;
66:                   }
67:                   return key_return;
  009E    0872    LD	A,0x72
  009F    0008    RET
68:               }
69:               
70:               /***************************************************************************
71:               函数功能：中层按键处理函数，调用底层函数一次，处理双击事件的判断，
72:                                                       返回上层正确的无键、单击、双击、长按四种状态
73:               本函数由上层循环调用，间隔10ms
74:               ***************************************************************************/
75:               unsigned char key_read(struct Keys * key)
  00D8    00F7    LD	0x77,A
76:               {
77:                  
78:                   unsigned char key_return = key_no;
  00D9    01F5    CLR	0x75
79:                   unsigned char key_read = key_driver(key);
  00DA    205E    CALL	0x5E
  00DB    00F6    LD	0x76,A
80:               //    printf("IO:%d  key status: %d\n",getSimpleKeyInput(key_input),key);
81:                   switch(key->key_state_buffer2)
  00DC    2900    JP	0x100
82:                   {
83:                       case key_state_0:
84:                           if(key_read == key_click)
  00DD    0B76    SZDECA	0x76
  00DE    28E9    JP	0xE9
85:                           {
86:                               key->key_timer_cnt2 = 0;  //第一次单击，不返回，到下个状态判断是否会出现双击
  00DF    0877    LD	A,0x77
  00E0    3E02    ADDIA	0x2
  00E1    0084    LD	0x4,A
  00E2    0180    CLR	0x0
87:                               key->key_state_buffer2 = key_state_1;
  00E3    0877    LD	A,0x77
  00E4    3E03    ADDIA	0x3
  00E5    0084    LD	0x4,A
  00E6    0180    CLR	0x0
  00E7    0A80    INCR	0x0
88:                           }
  00E8    290B    JP	0x10B
89:                           else
90:                               key_return = key_read;  //对于无键、长按，返回原事件
  00E9    0876    LD	A,0x76
  00EA    00F5    LD	0x75,A
  00EB    290B    JP	0x10B
91:                           break;
92:               
93:                       case key_state_1:
94:                           if(key_read == key_click)  //又一次单击，时间间隔小于500ms
  00EC    0B76    SZDECA	0x76
  00ED    28F1    JP	0xF1
95:                           {
96:                               key_return = key_double;  //返回双击事件，回到初始状态
  00EE    3002    LDIA	0x2
  00EF    00F5    LD	0x75,A
  00F0    28FB    JP	0xFB
97:                               key->key_state_buffer2 = key_state_0;
98:                           }
99:                           else if(++(key->key_timer_cnt2) >= 50)
  00F1    0877    LD	A,0x77
  00F2    3E02    ADDIA	0x2
  00F3    0084    LD	0x4,A
  00F4    3032    LDIA	0x32
  00F5    0A80    INCR	0x0
  00F6    0200    SUBA	0x0
  00F7    1C03    SNZB	0x3,0
  00F8    290B    JP	0x10B
100:                          {
101:                              //这里500ms内肯定读到的都是无键事件，因为长按大于1000ms
102:                              //在1s前底层返回的都是无键
103:              
104:                              key_return = key_click;  //500ms内没有再次出现单击事件，返回单击事件
  00F9    01F5    CLR	0x75
  00FA    0AF5    INCR	0x75
105:                              key->key_state_buffer2 = key_state_0;  //返回初始状态
  00FB    0877    LD	A,0x77
  00FC    3E03    ADDIA	0x3
  00FD    0084    LD	0x4,A
  00FE    0180    CLR	0x0
  00FF    290B    JP	0x10B
  0100    0877    LD	A,0x77
  0101    3E03    ADDIA	0x3
  0102    0084    LD	0x4,A
  0103    0800    LD	A,0x0
  0104    3A00    XORIA	0x0
  0105    1903    SZB	0x3,2
  0106    28DD    JP	0xDD
  0107    3A01    XORIA	0x1
  0108    1903    SZB	0x3,2
  0109    28EC    JP	0xEC
  010A    290B    JP	0x10B
106:              
107:                          }
108:                          break;
109:                  }
110:              
111:                  return key_return;
  010B    0875    LD	A,0x75
  010C    0008    RET
112:              }
113:              
114:              
115:              void resetKey(struct Keys* key)
  020B    00F2    LD	0x72,A
116:              {
117:              	key->key_timer_cnt1 =key->key_timer_cnt2 = key->key_state_buffer1 = key->key_state_buffer2 = 0;
  020C    3E03    ADDIA	0x3
  020D    0084    LD	0x4,A
  020E    1383    CLRB	0x3,7
  020F    0180    CLR	0x0
  0210    0A72    INCA	0x72
  0211    0084    LD	0x4,A
  0212    0180    CLR	0x0
  0213    0872    LD	A,0x72
  0214    3E02    ADDIA	0x2
  0215    0084    LD	0x4,A
  0216    0180    CLR	0x0
  0217    0872    LD	A,0x72
  0218    0084    LD	0x4,A
  0219    0180    CLR	0x0
  021A    0008    RET
118:              }
---- C:\工具\单片机学习资料\SC8P\SCMCU_IDE_V2.00.07\data\sources\common\Umul8.c ----------------------------------------------------------------------
1:                // 8 x 8 bit multiplication with 8 bit result
2:                
3:                unsigned char
4:                __bmul(unsigned char multiplier, unsigned char multiplicand)
  023B    00F4    LD	0x74,A
  023C    01F3    CLR	0x73
  023D    0872    LD	A,0x72
  023E    1874    SZB	0x74,0
  023F    07F3    ADDR	0x73
  0240    1003    CLRB	0x3,0
  0241    0DF2    RLCR	0x72
  0242    1003    CLRB	0x3,0
  0243    0CF4    RRCR	0x74
  0244    0874    LD	A,0x74
  0245    1D03    SNZB	0x3,2
  0246    2A3D    JP	0x23D
  0247    0873    LD	A,0x73
  0248    0008    RET
5:                {
6:                	unsigned char product = 0;
7:                
8:                #if defined(__OPTIMIZE_SPEED__)
9:                
10:               	if(multiplier & 0x01)
11:               		product = (product + multiplicand) & 0xff;
12:               	multiplicand <<= 1;
13:               
14:               	if(multiplier & 0x02)
15:               		product = (product + multiplicand) & 0xff;
16:               	multiplicand <<= 1;
17:               
18:               	if(multiplier & 0x04)
19:               		product = (product + multiplicand) & 0xff;
20:               	multiplicand <<= 1;
21:               
22:               	if(multiplier & 0x08)
23:               		product = (product + multiplicand) & 0xff;
24:               	multiplicand <<= 1;
25:               
26:               	if(multiplier & 0x10)
27:               		product = (product + multiplicand) & 0xff;
28:               	multiplicand <<= 1;
29:               
30:               	if(multiplier & 0x20)
31:               		product = (product + multiplicand) & 0xff;
32:               	multiplicand <<= 1;
33:               
34:               	if(multiplier & 0x40)
35:               		product = (product + multiplicand) & 0xff;
36:               	multiplicand <<= 1;
37:               
38:               	if(multiplier & 0x80)
39:               		product = (product + multiplicand) & 0xff;
40:               
41:               #else
42:               	do {
43:               		if(multiplier & 1)
44:               			product += multiplicand;
45:               		multiplicand <<= 1;
46:               		multiplier >>= 1;
47:               	} while(multiplier != 0);
48:               
49:               #endif
50:               	return product;
51:               }
---- C:\工具\单片机学习资料\SC8P\SCMCU_IDE_V2.00.07\data\sources\common\awdiv.c ----------------------------------------------------------------------
1:                // integer signed division
2:                
3:                signed int
4:                #ifdef __PICC__
5:                #warning TODO: update cgpic and this file to use the other prototype
6:                __awdiv(signed int divisor, signed int dividend)
  0018    1283    CLRB	0x3,5
  0019    01BA    CLR	0x3A
  001A    1FF3    SNZB	0x73,7
  001B    2823    JP	0x23
  001C    09F2    COMR	0x72
  001D    09F3    COMR	0x73
  001E    0AF2    INCR	0x72
  001F    1903    SZB	0x3,2
  0020    0AF3    INCR	0x73
  0021    01BA    CLR	0x3A
  0022    0ABA    INCR	0x3A
  0023    1FF5    SNZB	0x75,7
  0024    282C    JP	0x2C
  0025    09F4    COMR	0x74
  0026    09F5    COMR	0x75
  0027    0AF4    INCR	0x74
  0028    1903    SZB	0x3,2
  0029    0AF5    INCR	0x75
  002A    3001    LDIA	0x1
  002B    06BA    XORR	0x3A
  002C    01BB    CLR	0x3B
  002D    01BC    CLR	0x3C
  002E    0872    LD	A,0x72
  002F    0473    ORA	0x73
  0030    1903    SZB	0x3,2
  0031    2851    JP	0x51
  0032    01B9    CLR	0x39
  0033    0AB9    INCR	0x39
  0034    1BF3    SZB	0x73,7
  0035    283A    JP	0x3A
  0036    1003    CLRB	0x3,0
  0037    0DF2    RLCR	0x72
  0038    0DF3    RLCR	0x73
  0039    2833    JP	0x33
  003A    1003    CLRB	0x3,0
  003B    0DBB    RLCR	0x3B
  003C    0DBC    RLCR	0x3C
  003D    0873    LD	A,0x73
  003E    0275    SUBA	0x75
  003F    1D03    SNZB	0x3,2
  0040    2843    JP	0x43
  0041    0872    LD	A,0x72
  0042    0274    SUBA	0x74
  0043    1C03    SNZB	0x3,0
  0044    284D    JP	0x4D
  0045    0872    LD	A,0x72
  0046    02F4    SUBR	0x74
  0047    0873    LD	A,0x73
  0048    1C03    SNZB	0x3,0
  0049    03F5    DECR	0x75
  004A    02F5    SUBR	0x75
  004B    143B    SETB	0x3B,0
  004C    1003    CLRB	0x3,0
  004D    0CF3    RRCR	0x73
  004E    0CF2    RRCR	0x72
  004F    0BB9    SZDECR	0x39
  0050    283A    JP	0x3A
  0051    083A    LD	A,0x3A
  0052    1903    SZB	0x3,2
  0053    2859    JP	0x59
  0054    09BB    COMR	0x3B
  0055    09BC    COMR	0x3C
  0056    0ABB    INCR	0x3B
  0057    1903    SZB	0x3,2
  0058    0ABC    INCR	0x3C
  0059    083C    LD	A,0x3C
  005A    00F3    LD	0x73,A
  005B    083B    LD	A,0x3B
  005C    00F2    LD	0x72,A
  005D    0008    RET
7:                #else
8:                __awdiv(signed int dividend, signed int divisor)
9:                #endif
10:               {
11:               	signed int	quotient;
12:               	unsigned char	counter, sign;
13:               
14:               	sign = 0;
15:               	if(divisor < 0) {
16:               		divisor = -divisor;
17:               		sign = 1;
18:               	}
19:               	if(dividend < 0) {
20:               		dividend = -dividend;
21:               		sign ^= 1;
22:               	}
23:               	quotient = 0;
24:               	if(divisor != 0) {
25:               		counter = 1;
26:               		while((divisor & 0x8000U) == 0) {
27:               			divisor <<= 1;
28:               			counter++;
29:               		}
30:               		do {
31:               			quotient <<= 1;
32:               			if((unsigned int)divisor <= (unsigned int)dividend) {
33:               				dividend -= divisor;
34:               				quotient |= 1;
35:               			}
36:               			*(unsigned int *)&divisor >>= 1;
37:               		} while(--counter != 0);
38:               	}
39:               	if(sign)
40:               		quotient = -quotient;
41:               	return quotient;
42:               }
---- C:\SCMCU WorkSpace\uf166fan\init.c ----------------------------------------------------------------------
1:                #include "init.h"
2:                
3:                void Init_System()
  0256    0000    NOP
  0257    0064    CLRWDT
4:                {
5:                	asm("nop");
6:                	asm("clrwdt");
7:                	INTCON = 0;					//系统初始化
  0258    018B    CLR	0xB
8:                	OSCCON = 0X71;				//配置振荡为8M,开 WDT
  0259    3071    LDIA	0x71
  025A    1683    SETB	0x3,5
  025B    1303    CLRB	0x3,6
  025C    008F    LD	0xF,A
9:                	OPTION_REG = 0x00;		//Timer0使用内部时钟Focs/4，预分频比为1:2
  025D    0181    CLR	0x1
10:               	INTCON = 0x00;			//禁止所以中断
  025E    018B    CLR	0xB
  025F    0008    RET
11:               	
12:               	
13:               	
14:               }
15:               
16:               
17:               void Init_GPIO()
18:               {
19:               	TRISA = 0;
  01F9    0185    CLR	0x5
20:               	TRISB = 0;
  01FA    0186    CLR	0x6
21:               	TRISC = 0;
  01FB    0187    CLR	0x7
22:               	WPUA = 0xFF;
  01FC    30FF    LDIA	0xFF
  01FD    1703    SETB	0x3,6
  01FE    008E    LD	0xE,A
23:               	WPUB = 0xFF;	
  01FF    1303    CLRB	0x3,6
  0200    0095    LD	0x15,A
24:               	WPUC = 0xFF;
  0201    1703    SETB	0x3,6
  0202    008F    LD	0xF,A
25:               	PORTA = 0xFF;
  0203    1283    CLRB	0x3,5
  0204    1303    CLRB	0x3,6
  0205    0085    LD	0x5,A
26:               	PORTB = 0xFF;
  0206    0086    LD	0x6,A
27:               	PORTC = 0xFF;
  0207    0087    LD	0x7,A
28:               	IOCB = 0x00;
  0208    1683    SETB	0x3,5
  0209    0196    CLR	0x16
  020A    0008    RET
29:               	
30:               }
31:               
32:               void Init_Interupt()
33:               {
34:               	OPTION_REG = 0x00;		//Timer0使用内部时钟Focs/4，预分频比为1:2
  0268    0181    CLR	0x1
35:               	TMR0 = 0;				//赋予初始值
  0269    1283    CLRB	0x3,5
  026A    0181    CLR	0x1
36:               	INTCON = 0xE0;			//允许所有未被屏蔽的中断、禁止外设中断，使能Timer0
  026B    30E0    LDIA	0xE0
  026C    008B    LD	0xB,A
  026D    0008    RET
37:               
38:               }
---- stringtab ------------------------------------------------------------------
---- reset_enter ------------------------------------------------------------------
  0000    280A    JP	0xA
  000A    280B    JP	0xB
---- start_initialization ------------------------------------------------------------------
  000B    3002    LDIA	0x2
  000C    00C1    LD	0x41,A
  000D    00C2    LD	0x42,A
  000E    3020    LDIA	0x20
  000F    1383    CLRB	0x3,7
  0010    0084    LD	0x4,A
  0011    3039    LDIA	0x39
  0012    2260    CALL	0x260
  0013    01F8    CLR	0x78
  0014    01F9    CLR	0x79
  0015    01FA    CLR	0x7A
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F0    LD	0x70,A
  0007    080A    LD	A,0xA
  0008    00F1    LD	0x71,A
  0009    2A2B    JP	0x22B
---- common_function ------------------------------------------------------------------
  0016    0183    CLR	0x3
  0017    28A0    JP	0xA0
  0260    0064    CLRWDT
  0261    0180    CLR	0x0
  0262    0A84    INCR	0x4
  0263    0604    XORA	0x4
  0264    1903    SZB	0x3,2
  0265    3400    RET	0x0
  0266    0604    XORA	0x4
  0267    2A61    JP	0x261
  026E    2866    JP	0x66
  026F    286E    JP	0x6E
  0270    2878    JP	0x78
  0271    288B    JP	0x8B
