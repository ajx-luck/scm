---- E:\project\scm\uf166fan\main.c ----------------------------------------------------------------------
1:                #include<sc.h>
2:                #include "scankey.h"
3:                #include "init.h"
4:                
5:                #define MAX_FAN_LEVEL 4
6:                #define MIN_FAN_LEVEL 1
7:                
8:                #define FAN_STATUS_OFF  0
9:                #define FAN_STATUS_ON  1
10:               #define FAN_STATUS_NONE 2
11:               
12:               #define LED_1  1
13:               #define LED_2  2
14:               #define LED_3  3
15:               #define LED_4  4
16:               
17:               static unsigned char time0Flag = 0;
18:               static unsigned int countTime = 0;
19:               static unsigned int count10Ms = 0;
20:               unsigned char currentLevel = 2;
21:               
22:               unsigned char FAN_STATUS = FAN_STATUS_NONE;
23:               //检测风扇次数
24:               unsigned int fan_check_time = 0;
25:               
26:               void setLedOn(int ledIndex);
27:               
28:               void checkUsbStatus()
29:               {
30:               	if(getbit(PORTB,2) == 1){
  01CF    0806    LD	A,0x6
  01D0    00F2    LD	0x72,A
  01D1    1003    CLRB	0x3,0
  01D2    0CF2    RRCR	0x72
  01D3    1003    CLRB	0x3,0
  01D4    0CF2    RRCR	0x72
  01D5    1C72    SNZB	0x72,0
  01D6    29E9    JP	0x1E9
31:               		if(getbit(PORTB,1) == 1){
  01D7    0806    LD	A,0x6
  01D8    00F2    LD	0x72,A
  01D9    1003    CLRB	0x3,0
  01DA    0CF2    RRCR	0x72
  01DB    1C72    SNZB	0x72,0
  01DC    29DF    JP	0x1DF
32:               			//充满了，Led常亮
33:               			resetbit(PORTA,0);
  01DD    1005    CLRB	0x5,0
34:               		}else if(countTime == 1000){
  01DE    0008    RET
  01DF    30E8    LDIA	0xE8
  01E0    063C    XORA	0x3C
  01E1    3003    LDIA	0x3
  01E2    1903    SZB	0x3,2
  01E3    063D    XORA	0x3D
  01E4    1D03    SNZB	0x3,2
  01E5    0008    RET
35:               			//充电中，一直闪		
36:               				reversebit(PORTA,0);
  01E6    3001    LDIA	0x1
  01E7    0685    XORR	0x5
  01E8    0008    RET
37:               		}
38:               	}else{
39:               		//usb断开充电灯熄灭,PA0 = 1
40:               		setbit(PORTA,0);
  01E9    1405    SETB	0x5,0
  01EA    0008    RET
41:               	}
42:               }
43:               
44:               void Init_PWM()
45:               {
46:               	CCP1CON = 0x0F;//设置PC2为PWM模式，4,5位为占空比的低2位
  022B    300F    LDIA	0xF
  022C    1283    CLRB	0x3,5
  022D    1303    CLRB	0x3,6
  022E    0097    LD	0x17,A
47:               	T2CON = 0; //时钟分频 1:1 PWM周期为（PR2+1）*4/8,000,000
  022F    0192    CLR	0x12
48:               	PR2 = 199;
  0230    30C7    LDIA	0xC7
  0231    1683    SETB	0x3,5
  0232    0092    LD	0x12,A
49:               	
50:               	CCPR1L = 0;//占空比高8位，低2位设置为0，结果就是 占空比 = CCPR1L*4/4*(PR2+1)
  0233    1283    CLRB	0x3,5
  0234    0195    CLR	0x15
51:               	TMR2IF = 0;
  0235    108C    CLRB	0xC,1
52:               	T2CON = 0;
  0236    0192    CLR	0x12
  0237    0008    RET
53:               	//T2CON = 0X04 //启动定时器2，溢出后启动PWM
54:               }
55:               
56:               //设置风扇转速
57:               void setFanLevel(char level)
  0160    1283    CLRB	0x3,5
  0161    1303    CLRB	0x3,6
  0162    00A0    LD	0x20,A
58:               {
59:               	
60:               	unsigned int levelWidth =  (PR2+1)/MAX_FAN_LEVEL;
  0163    1683    SETB	0x3,5
  0164    0812    LD	A,0x12
  0165    00F4    LD	0x74,A
  0166    01F5    CLR	0x75
  0167    0AF4    INCR	0x74
  0168    1903    SZB	0x3,2
  0169    0AF5    INCR	0x75
  016A    3004    LDIA	0x4
  016B    00F2    LD	0x72,A
  016C    01F3    CLR	0x73
  016D    207B    CALL	0x7B
61:               	char tempLevel =  currentLevel + level;
  016E    1283    CLRB	0x3,5
  016F    0820    LD	A,0x20
  0170    077B    ADDA	0x7B
  0171    00A1    LD	0x21,A
62:               	if(tempLevel > MAX_FAN_LEVEL)
  0172    3005    LDIA	0x5
  0173    0221    SUBA	0x21
  0174    1C03    SNZB	0x3,0
  0175    2978    JP	0x178
63:               	{
64:               		tempLevel = MAX_FAN_LEVEL;
  0176    3004    LDIA	0x4
  0177    00A1    LD	0x21,A
65:               	}
66:               	
67:               	if(tempLevel < MIN_FAN_LEVEL)
  0178    0821    LD	A,0x21
  0179    1D03    SNZB	0x3,2
  017A    297D    JP	0x17D
68:               	{
69:               		tempLevel = MIN_FAN_LEVEL;
  017B    01A1    CLR	0x21
  017C    0AA1    INCR	0x21
70:               	}
71:               	currentLevel = tempLevel;
  017D    0821    LD	A,0x21
  017E    00FB    LD	0x7B,A
72:               	CCPR1L = tempLevel*currentLevel;
  017F    00F2    LD	0x72,A
  0180    0821    LD	A,0x21
  0181    221D    CALL	0x21D
  0182    0095    LD	0x15,A
73:               	if(FAN_STATUS == FAN_STATUS_ON)
  0183    0B7A    SZDECA	0x7A
  0184    0008    RET
74:               	{
75:               		setLedOn(currentLevel);
  0185    087B    LD	A,0x7B
  0186    00F2    LD	0x72,A
  0187    01F3    CLR	0x73
  0188    2989    JP	0x189
76:               	}
77:               	
78:               }
79:               
80:               //关闭风扇
81:               void closeFan()
82:               {
83:               	Init_PWM();
  0238    222B    CALL	0x22B
84:               	currentLevel = 2;
  0239    3002    LDIA	0x2
  023A    00FB    LD	0x7B,A
85:               	setLedOn(5);
  023B    3005    LDIA	0x5
  023C    00F2    LD	0x72,A
  023D    01F3    CLR	0x73
  023E    2189    CALL	0x189
86:               	setbit(PORTA,0);
  023F    1405    SETB	0x5,0
87:               	fan_check_time = 0;
  0240    01B8    CLR	0x38
  0241    01B9    CLR	0x39
88:               	FAN_STATUS = FAN_STATUS_OFF;
  0242    01FA    CLR	0x7A
  0243    0008    RET
89:               	
90:               }
91:               
92:               
93:               //检测风扇是否连接
94:               void checkFan()
95:               {
96:               	setbit(PORTA,1);
  0137    1283    CLRB	0x3,5
  0138    1303    CLRB	0x3,6
  0139    1485    SETB	0x5,1
97:               	setFanLevel(0);
  013A    3000    LDIA	0x0
  013B    2160    CALL	0x160
98:               	T2CON = 0X04; //启动定时器2，溢出后启动PWM
  013C    3004    LDIA	0x4
  013D    0092    LD	0x12,A
99:               		
100:              	if(FAN_STATUS == FAN_STATUS_ON)
  013E    0B7A    SZDECA	0x7A
  013F    294C    JP	0x14C
  0140    294B    JP	0x14B
101:              	{
102:              		closeFan();
  014B    2A38    JP	0x238
103:              		return;
104:              	}
105:              	//没有检测到风扇
106:              	if(FAN_STATUS == FAN_STATUS_NONE)
  014C    3002    LDIA	0x2
  014D    067A    XORA	0x7A
  014E    1903    SZB	0x3,2
  014F    2941    JP	0x141
107:              	{
108:              		fan_check_time++;
  0141    0AB8    INCR	0x38
  0142    1903    SZB	0x3,2
  0143    0AB9    INCR	0x39
109:              		if(fan_check_time == 3000)
  0144    30B8    LDIA	0xB8
  0145    0638    XORA	0x38
  0146    300B    LDIA	0xB
  0147    1903    SZB	0x3,2
  0148    0639    XORA	0x39
  0149    1D03    SNZB	0x3,2
  014A    2950    JP	0x150
110:              		{
111:              			closeFan();
112:              			return;
113:              		}
114:              	}
115:              	
116:              	if(getbit(PORTB,6) == 0)
  0150    0806    LD	A,0x6
  0151    00A2    LD	0x22,A
  0152    3006    LDIA	0x6
  0153    1003    CLRB	0x3,0
  0154    0CA2    RRCR	0x22
  0155    3EFF    ADDIA	0xFF
  0156    1D03    SNZB	0x3,2
  0157    2953    JP	0x153
  0158    1822    SZB	0x22,0
  0159    295D    JP	0x15D
117:              	{
118:              		FAN_STATUS = FAN_STATUS_ON;
  015A    01FA    CLR	0x7A
  015B    0AFA    INCR	0x7A
119:              	}else
  015C    0008    RET
120:              	{
121:              		FAN_STATUS = FAN_STATUS_NONE;
  015D    3002    LDIA	0x2
  015E    00FA    LD	0x7A,A
  015F    0008    RET
122:              	}
123:              	//EN IN输出高电位，D1点亮，检测FAN DET，FAN DET为低电位则风扇正常工作，高电位则未连接
124:              	
125:              }
126:              
127:              
128:              
129:              
130:              
131:              //设置Led灯亮
132:              void setLedOn(int ledIndex)
133:              {
134:              	switch(ledIndex)
  0189    299E    JP	0x19E
135:              	{
136:              		case 1:
137:              		resetbit(PORTB,7); setbit(PORTC,0); resetbit(PORTC,1);
  018A    1386    CLRB	0x6,7
  018B    1407    SETB	0x7,0
  018C    1087    CLRB	0x7,1
138:              		break;
  018D    0008    RET
139:              		case 2:
140:              		setbit(PORTB,7); resetbit(PORTC,0); setbit(PORTC,1);
  018E    1786    SETB	0x6,7
  018F    1007    CLRB	0x7,0
  0190    1487    SETB	0x7,1
141:              		break;
  0191    0008    RET
142:              		setbit(PORTB,7); resetbit(PORTC,0); setbit(PORTC,1);
143:              		case 3:
144:              		setbit(PORTB,7); resetbit(PORTC,0); resetbit(PORTC,1);
  0192    1786    SETB	0x6,7
  0193    1007    CLRB	0x7,0
  0194    1087    CLRB	0x7,1
145:              		break;
  0195    0008    RET
146:              		case 4:
147:              		resetbit(PORTB,7); setbit(PORTC,0); setbit(PORTC,1);
  0196    1386    CLRB	0x6,7
  0197    1407    SETB	0x7,0
  0198    1487    SETB	0x7,1
148:              		break;
  0199    0008    RET
149:              		default:
150:              		resetbit(PORTB,7); resetbit(PORTC,0); resetbit(PORTC,1);
  019A    1386    CLRB	0x6,7
  019B    1007    CLRB	0x7,0
  019C    1087    CLRB	0x7,1
151:              		break;
  019D    0008    RET
  019E    0873    LD	A,0x73
  019F    3A00    XORIA	0x0
  01A0    1903    SZB	0x3,2
  01A1    29A3    JP	0x1A3
  01A2    299A    JP	0x19A
  01A3    0872    LD	A,0x72
  01A4    3A01    XORIA	0x1
  01A5    1903    SZB	0x3,2
  01A6    298A    JP	0x18A
  01A7    3A03    XORIA	0x3
  01A8    1903    SZB	0x3,2
  01A9    298E    JP	0x18E
  01AA    3A01    XORIA	0x1
  01AB    1903    SZB	0x3,2
  01AC    2992    JP	0x192
  01AD    3A07    XORIA	0x7
  01AE    1903    SZB	0x3,2
  01AF    2996    JP	0x196
  01B0    299A    JP	0x19A
  01B1    0008    RET
152:              	}
153:              }
154:              
155:              
156:              void main(void)
157:              {
158:              	Init_System();
  0017    2244    CALL	0x244
159:              	Init_GPIO();
  0018    21EB    CALL	0x1EB
160:              	Init_Interupt();
  0019    224E    CALL	0x24E
161:              	
162:              	//设置唤醒
163:              	IOCB = 0x04;
  001A    3004    LDIA	0x4
  001B    1683    SETB	0x3,5
  001C    0096    LD	0x16,A
164:              	TMR0 = 155;
  001D    309B    LDIA	0x9B
  001E    1283    CLRB	0x3,5
  001F    0081    LD	0x1,A
165:              	TO = 0;
  0020    1203    CLRB	0x3,4
166:              	
167:              	struct Keys key1,key2,key3;
168:              	//K1开关
169:              	key1.key_index = 5;
  0021    3005    LDIA	0x5
  0022    00A9    LD	0x29,A
170:              	//K2加档
171:              	key2.key_index = 4;
  0023    3004    LDIA	0x4
  0024    00B0    LD	0x30,A
172:              	//K3减档
173:              	key3.key_index = 3;
  0025    3003    LDIA	0x3
  0026    00B7    LD	0x37,A
174:              	resetKey(&key1);
  0027    3023    LDIA	0x23
  0028    21FD    CALL	0x1FD
175:              	resetKey(&key2);
  0029    302A    LDIA	0x2A
  002A    21FD    CALL	0x1FD
176:              	resetKey(&key3);
  002B    3031    LDIA	0x31
  002C    21FD    CALL	0x1FD
177:              	//设置IO方向
178:              	TRISA = 0;
  002D    1683    SETB	0x3,5
  002E    1303    CLRB	0x3,6
  002F    0185    CLR	0x5
179:              	//TRISB = 0x0E;//1-6脚输入
180:              	TRISB = 0;
  0030    0186    CLR	0x6
181:              	PORTB = 0;
  0031    1283    CLRB	0x3,5
  0032    0186    CLR	0x6
182:              	TRISC = 0;
  0033    1683    SETB	0x3,5
  0034    0187    CLR	0x7
183:              	while(1)
184:              	{
185:              		//1毫秒检测一次
186:              		if(time0Flag)
  0035    1283    CLRB	0x3,5
  0036    083E    LD	A,0x3E
  0037    1903    SZB	0x3,2
  0038    284F    JP	0x4F
  0039    0064    CLRWDT
187:              		{
188:              			asm("clrwdt");
189:              			time0Flag = 0;
  003A    1283    CLRB	0x3,5
  003B    1303    CLRB	0x3,6
  003C    01BE    CLR	0x3E
190:              			key1.key_addr_result = key2.key_addr_result = key3.key_addr_result = PORTB;
  003D    0806    LD	A,0x6
  003E    00B6    LD	0x36,A
  003F    00AF    LD	0x2F,A
  0040    00A8    LD	0x28,A
191:              			sacnKeyInput(&key1);
  0041    3023    LDIA	0x23
  0042    21B2    CALL	0x1B2
192:              			sacnKeyInput(&key2);
  0043    302A    LDIA	0x2A
  0044    21B2    CALL	0x1B2
193:              			sacnKeyInput(&key3);
  0045    3031    LDIA	0x31
  0046    21B2    CALL	0x1B2
194:              			countTime++;
  0047    1283    CLRB	0x3,5
  0048    1303    CLRB	0x3,6
  0049    0ABC    INCR	0x3C
  004A    1903    SZB	0x3,2
  004B    0ABD    INCR	0x3D
195:              			count10Ms++;
  004C    0ABA    INCR	0x3A
  004D    1903    SZB	0x3,2
  004E    0ABB    INCR	0x3B
196:              		}
197:              		
198:              		//10毫秒检测一次
199:              		if(count10Ms == 10)
  004F    300A    LDIA	0xA
  0050    063A    XORA	0x3A
  0051    043B    ORA	0x3B
  0052    1D03    SNZB	0x3,2
  0053    2871    JP	0x71
200:              		{
201:              			if(key_read(&key1) != key_no)
  0054    3023    LDIA	0x23
  0055    2102    CALL	0x102
  0056    3A00    XORIA	0x0
  0057    1D03    SNZB	0x3,2
  0058    285D    JP	0x5D
202:              			{
203:              				//检测到按键了，检测风扇是否存在
204:              				checkFan();
  005D    2137    CALL	0x137
205:              				
206:              			}
  0059    3002    LDIA	0x2
  005A    067A    XORA	0x7A
  005B    1D03    SNZB	0x3,2
  005C    285E    JP	0x5E
207:              			else if(FAN_STATUS == FAN_STATUS_NONE)
208:              			{
209:              				checkFan();
210:              			}
211:              			
212:              			
213:              			
214:              			if(key_read(&key2) != key_no)
  005E    302A    LDIA	0x2A
  005F    2102    CALL	0x102
  0060    3A00    XORIA	0x0
  0061    1903    SZB	0x3,2
  0062    2865    JP	0x65
215:              			{
216:              				//加档
217:              				setFanLevel(1);
  0063    3001    LDIA	0x1
  0064    2160    CALL	0x160
218:              			}
219:              			
220:              			if(key_read(&key3) != key_no)
  0065    3031    LDIA	0x31
  0066    2102    CALL	0x102
  0067    3A00    XORIA	0x0
  0068    1903    SZB	0x3,2
  0069    286C    JP	0x6C
221:              			{
222:              				//减档
223:              				setFanLevel(-1);
  006A    30FF    LDIA	0xFF
  006B    2160    CALL	0x160
224:              			}
225:              			
226:              			
227:              			
228:              			
229:              			count10Ms = 0;
  006C    1283    CLRB	0x3,5
  006D    1303    CLRB	0x3,6
  006E    01BA    CLR	0x3A
  006F    01BB    CLR	0x3B
230:              			checkUsbStatus();
  0070    21CF    CALL	0x1CF
231:              			
232:              		}
233:              		
234:              		
235:              		
236:              		if(countTime == 1000)
  0071    30E8    LDIA	0xE8
  0072    063C    XORA	0x3C
  0073    3003    LDIA	0x3
  0074    1903    SZB	0x3,2
  0075    063D    XORA	0x3D
  0076    1D03    SNZB	0x3,2
  0077    2835    JP	0x35
237:              		{
238:              			countTime = 0;
  0078    01BC    CLR	0x3C
  0079    01BD    CLR	0x3D
  007A    2835    JP	0x35
239:              		}
240:              	}
241:              	
242:              }
243:              
244:              
245:              /***********************************************
246:              函数名称：Timer0_Isr
247:              函数功能：中断服务
248:              入口参数：无
249:              出口参数：无
250:              备注：
251:              ***********************************************/
252:              void interrupt Timer0_Isr()
253:              {
254:              	if(T0IF)
  020D    1D0B    SNZB	0xB,2
  020E    2A16    JP	0x216
255:              	{
256:              	//---------------------------------------
257:              		TMR0 += 155;		//重新赋初值，在赋值前Timer0已有计数，故在该基础上加初值
  020F    309B    LDIA	0x9B
  0210    1283    CLRB	0x3,5
  0211    1303    CLRB	0x3,6
  0212    0781    ADDR	0x1
258:              	//---------------------------------------
259:              			
260:              		T0IF = 0;			//清中断标志位	
  0213    110B    CLRB	0xB,2
261:              		time0Flag =1;
  0214    01BE    CLR	0x3E
  0215    0ABE    INCR	0x3E
  0216    0871    LD	A,0x71
  0217    008A    LD	0xA,A
  0218    0E70    SWAPA	0x70
  0219    0083    LD	0x3,A
  021A    0EFE    SWAPR	0x7E
  021B    0E7E    SWAPA	0x7E
  021C    0009    RETI
262:              		
263:              	}
264:              	
265:              }
---- E:\project\scm\uf166fan\scankey.c ----------------------------------------------------------------------
1:                #include "scankey.h"
2:                
3:                void sacnKeyInput(struct Keys* key)
  01B2    00F4    LD	0x74,A
4:                {
5:                    key->key_input = getbit(key->key_addr_result,key->key_index);
  01B3    3E05    ADDIA	0x5
  01B4    0084    LD	0x4,A
  01B5    1383    CLRB	0x3,7
  01B6    0800    LD	A,0x0
  01B7    00F2    LD	0x72,A
  01B8    0874    LD	A,0x74
  01B9    3E06    ADDIA	0x6
  01BA    0084    LD	0x4,A
  01BB    0A00    INCA	0x0
  01BC    29BF    JP	0x1BF
  01BD    1003    CLRB	0x3,0
  01BE    0CF2    RRCR	0x72
  01BF    3EFF    ADDIA	0xFF
  01C0    1D03    SNZB	0x3,2
  01C1    29BD    JP	0x1BD
  01C2    0872    LD	A,0x72
  01C3    00F3    LD	0x73,A
  01C4    0874    LD	A,0x74
  01C5    3E04    ADDIA	0x4
  01C6    0084    LD	0x4,A
  01C7    0873    LD	A,0x73
  01C8    0080    LD	0x0,A
  01C9    0874    LD	A,0x74
  01CA    3E04    ADDIA	0x4
  01CB    0084    LD	0x4,A
  01CC    3001    LDIA	0x1
  01CD    0580    ANDR	0x0
  01CE    0008    RET
6:                
7:                }
8:                
9:                
10:               static unsigned char key_driver(struct Keys * key)
  00C0    00F4    LD	0x74,A
11:               {
12:               
13:               
14:                   unsigned char key_return = key_no;
  00C1    01F2    CLR	0x72
15:                   unsigned char key_read = key->key_input;  //read the I/O states
  00C2    3E04    ADDIA	0x4
  00C3    0084    LD	0x4,A
  00C4    1383    CLRB	0x3,7
  00C5    0800    LD	A,0x0
  00C6    00F3    LD	0x73,A
16:               
17:                   switch(key->key_state_buffer1)
  00C7    28F3    JP	0xF3
18:                   {
19:                       case key_state_0:
20:                           if(key_read == 0)
  00C8    0873    LD	A,0x73
  00C9    1D03    SNZB	0x3,2
  00CA    2900    JP	0x100
21:                           {
22:                               key->key_state_buffer1 = key_state_1;
  00CB    0A74    INCA	0x74
  00CC    0084    LD	0x4,A
  00CD    0180    CLR	0x0
  00CE    0A80    INCR	0x0
  00CF    2900    JP	0x100
23:                           }
24:               
25:                           //按键被按下，状态转换到按键消抖和确认状态//
26:                           break;
27:               
28:                       case key_state_1:
29:                           if(key_read == 0)
  00D0    0873    LD	A,0x73
  00D1    1D03    SNZB	0x3,2
  00D2    28EF    JP	0xEF
30:                           {
31:                               key->key_timer_cnt1 = 0;
  00D3    0874    LD	A,0x74
  00D4    0084    LD	0x4,A
  00D5    0180    CLR	0x0
32:                               key->key_state_buffer1 = key_state_2;
  00D6    0A74    INCA	0x74
  00D7    0084    LD	0x4,A
  00D8    3002    LDIA	0x2
  00D9    28EB    JP	0xEB
33:                               //按键仍然处于按下状态
34:                               //消抖完成，key_timer开始准备计时
35:                               //状态切换到按下时间计时状态
36:                           }
37:                           else
38:                           {
39:                               key->key_state_buffer1 = key_state_0;
40:                           }
41:               
42:                           //按键已经抬起，回到按键初始状态
43:                           break;  //完成软件消抖
44:               
45:                       case key_state_2:
46:                           if(key_read == 1)
  00DA    0B73    SZDECA	0x73
  00DB    28DF    JP	0xDF
47:                           {
48:                               key_return = key_click;  //按键抬起，产生一次click操作
  00DC    01F2    CLR	0x72
  00DD    0AF2    INCR	0x72
  00DE    28EF    JP	0xEF
49:                               key->key_state_buffer1 = key_state_0;  //转换到按键初始状态
50:                           }
51:                           else if(++(key->key_timer_cnt1) >= 100)  //按键继续按下，计时超过1000ms
  00DF    0874    LD	A,0x74
  00E0    0084    LD	0x4,A
  00E1    3064    LDIA	0x64
  00E2    0A80    INCR	0x0
  00E3    0200    SUBA	0x0
  00E4    1C03    SNZB	0x3,0
  00E5    2900    JP	0x100
52:                           {
53:                               key_return = key_long;  //送回长按事件
  00E6    3003    LDIA	0x3
  00E7    00F2    LD	0x72,A
54:                               key->key_state_buffer1 = key_state_3;  //转换到等待按键释放状态
  00E8    0A74    INCA	0x74
  00E9    0084    LD	0x4,A
  00EA    3003    LDIA	0x3
  00EB    0080    LD	0x0,A
  00EC    2900    JP	0x100
55:                          
56:                           }
57:                           break;
58:               
59:                       case key_state_3:  //等待按键释放
60:                           if(key_read == 1)  //按键释放
  00ED    0B73    SZDECA	0x73
  00EE    2900    JP	0x100
61:                           {
62:                               key->key_state_buffer1 = key_state_0;  //切回按键初始状态
  00EF    0A74    INCA	0x74
  00F0    0084    LD	0x4,A
  00F1    0180    CLR	0x0
  00F2    2900    JP	0x100
  00F3    0A74    INCA	0x74
  00F4    0084    LD	0x4,A
  00F5    0800    LD	A,0x0
  00F6    0084    LD	0x4,A
  00F7    3004    LDIA	0x4
  00F8    0204    SUBA	0x4
  00F9    1803    SZB	0x3,0
  00FA    2900    JP	0x100
  00FB    3002    LDIA	0x2
  00FC    008A    LD	0xA,A
  00FD    3054    LDIA	0x54
  00FE    0704    ADDA	0x4
  00FF    0082    LD	0x2,A
63:                           }
64:               
65:                           break;
66:                   }
67:                   return key_return;
  0100    0872    LD	A,0x72
  0101    0008    RET
68:               }
69:               
70:               /***************************************************************************
71:               函数功能：中层按键处理函数，调用底层函数一次，处理双击事件的判断，
72:                                                       返回上层正确的无键、单击、双击、长按四种状态
73:               本函数由上层循环调用，间隔10ms
74:               ***************************************************************************/
75:               unsigned char key_read(struct Keys * key)
  0102    00F7    LD	0x77,A
76:               {
77:                  
78:                   unsigned char key_return = key_no;
  0103    01F5    CLR	0x75
79:                   unsigned char key_read = key_driver(key);
  0104    20C0    CALL	0xC0
  0105    00F6    LD	0x76,A
80:               //    printf("IO:%d  key status: %d\n",getSimpleKeyInput(key_input),key);
81:                   switch(key->key_state_buffer2)
  0106    292A    JP	0x12A
82:                   {
83:                       case key_state_0:
84:                           if(key_read == key_click)
  0107    0B76    SZDECA	0x76
  0108    2913    JP	0x113
85:                           {
86:                               key->key_timer_cnt2 = 0;  //第一次单击，不返回，到下个状态判断是否会出现双击
  0109    0877    LD	A,0x77
  010A    3E02    ADDIA	0x2
  010B    0084    LD	0x4,A
  010C    0180    CLR	0x0
87:                               key->key_state_buffer2 = key_state_1;
  010D    0877    LD	A,0x77
  010E    3E03    ADDIA	0x3
  010F    0084    LD	0x4,A
  0110    0180    CLR	0x0
  0111    0A80    INCR	0x0
88:                           }
  0112    2935    JP	0x135
89:                           else
90:                               key_return = key_read;  //对于无键、长按，返回原事件
  0113    0876    LD	A,0x76
  0114    00F5    LD	0x75,A
  0115    2935    JP	0x135
91:                           break;
92:               
93:                       case key_state_1:
94:                           if(key_read == key_click)  //又一次单击，时间间隔小于500ms
  0116    0B76    SZDECA	0x76
  0117    291B    JP	0x11B
95:                           {
96:                               key_return = key_double;  //返回双击事件，回到初始状态
  0118    3002    LDIA	0x2
  0119    00F5    LD	0x75,A
  011A    2925    JP	0x125
97:                               key->key_state_buffer2 = key_state_0;
98:                           }
99:                           else if(++(key->key_timer_cnt2) >= 50)
  011B    0877    LD	A,0x77
  011C    3E02    ADDIA	0x2
  011D    0084    LD	0x4,A
  011E    3032    LDIA	0x32
  011F    0A80    INCR	0x0
  0120    0200    SUBA	0x0
  0121    1C03    SNZB	0x3,0
  0122    2935    JP	0x135
100:                          {
101:                              //这里500ms内肯定读到的都是无键事件，因为长按大于1000ms
102:                              //在1s前底层返回的都是无键
103:              
104:                              key_return = key_click;  //500ms内没有再次出现单击事件，返回单击事件
  0123    01F5    CLR	0x75
  0124    0AF5    INCR	0x75
105:                              key->key_state_buffer2 = key_state_0;  //返回初始状态
  0125    0877    LD	A,0x77
  0126    3E03    ADDIA	0x3
  0127    0084    LD	0x4,A
  0128    0180    CLR	0x0
  0129    2935    JP	0x135
  012A    0877    LD	A,0x77
  012B    3E03    ADDIA	0x3
  012C    0084    LD	0x4,A
  012D    0800    LD	A,0x0
  012E    3A00    XORIA	0x0
  012F    1903    SZB	0x3,2
  0130    2907    JP	0x107
  0131    3A01    XORIA	0x1
  0132    1903    SZB	0x3,2
  0133    2916    JP	0x116
  0134    2935    JP	0x135
106:              
107:                          }
108:                          break;
109:                  }
110:              
111:                  return key_return;
  0135    0875    LD	A,0x75
  0136    0008    RET
112:              }
113:              
114:              
115:              void resetKey(struct Keys* key)
  01FD    00F2    LD	0x72,A
116:              {
117:              	key->key_timer_cnt1 =key->key_timer_cnt2 = key->key_state_buffer1 = key->key_state_buffer2 = 0;
  01FE    3E03    ADDIA	0x3
  01FF    0084    LD	0x4,A
  0200    1383    CLRB	0x3,7
  0201    0180    CLR	0x0
  0202    0A72    INCA	0x72
  0203    0084    LD	0x4,A
  0204    0180    CLR	0x0
  0205    0872    LD	A,0x72
  0206    3E02    ADDIA	0x2
  0207    0084    LD	0x4,A
  0208    0180    CLR	0x0
  0209    0872    LD	A,0x72
  020A    0084    LD	0x4,A
  020B    0180    CLR	0x0
  020C    0008    RET
118:              }
---- E:\cms\SCMCU_IDE_V2.00.07\data\sources\common\Umul8.c ----------------------------------------------------------------------
1:                // 8 x 8 bit multiplication with 8 bit result
2:                
3:                unsigned char
4:                __bmul(unsigned char multiplier, unsigned char multiplicand)
  021D    00F4    LD	0x74,A
  021E    01F3    CLR	0x73
  021F    0872    LD	A,0x72
  0220    1874    SZB	0x74,0
  0221    07F3    ADDR	0x73
  0222    1003    CLRB	0x3,0
  0223    0DF2    RLCR	0x72
  0224    1003    CLRB	0x3,0
  0225    0CF4    RRCR	0x74
  0226    0874    LD	A,0x74
  0227    1D03    SNZB	0x3,2
  0228    2A1F    JP	0x21F
  0229    0873    LD	A,0x73
  022A    0008    RET
5:                {
6:                	unsigned char product = 0;
7:                
8:                #if defined(__OPTIMIZE_SPEED__)
9:                
10:               	if(multiplier & 0x01)
11:               		product = (product + multiplicand) & 0xff;
12:               	multiplicand <<= 1;
13:               
14:               	if(multiplier & 0x02)
15:               		product = (product + multiplicand) & 0xff;
16:               	multiplicand <<= 1;
17:               
18:               	if(multiplier & 0x04)
19:               		product = (product + multiplicand) & 0xff;
20:               	multiplicand <<= 1;
21:               
22:               	if(multiplier & 0x08)
23:               		product = (product + multiplicand) & 0xff;
24:               	multiplicand <<= 1;
25:               
26:               	if(multiplier & 0x10)
27:               		product = (product + multiplicand) & 0xff;
28:               	multiplicand <<= 1;
29:               
30:               	if(multiplier & 0x20)
31:               		product = (product + multiplicand) & 0xff;
32:               	multiplicand <<= 1;
33:               
34:               	if(multiplier & 0x40)
35:               		product = (product + multiplicand) & 0xff;
36:               	multiplicand <<= 1;
37:               
38:               	if(multiplier & 0x80)
39:               		product = (product + multiplicand) & 0xff;
40:               
41:               #else
42:               	do {
43:               		if(multiplier & 1)
44:               			product += multiplicand;
45:               		multiplicand <<= 1;
46:               		multiplier >>= 1;
47:               	} while(multiplier != 0);
48:               
49:               #endif
50:               	return product;
51:               }
---- E:\cms\SCMCU_IDE_V2.00.07\data\sources\common\awdiv.c ----------------------------------------------------------------------
1:                // integer signed division
2:                
3:                signed int
4:                #ifdef __PICC__
5:                #warning TODO: update cgpic and this file to use the other prototype
6:                __awdiv(signed int divisor, signed int dividend)
  007B    01F7    CLR	0x77
  007C    1FF3    SNZB	0x73,7
  007D    2885    JP	0x85
  007E    09F2    COMR	0x72
  007F    09F3    COMR	0x73
  0080    0AF2    INCR	0x72
  0081    1903    SZB	0x3,2
  0082    0AF3    INCR	0x73
  0083    01F7    CLR	0x77
  0084    0AF7    INCR	0x77
  0085    1FF5    SNZB	0x75,7
  0086    288E    JP	0x8E
  0087    09F4    COMR	0x74
  0088    09F5    COMR	0x75
  0089    0AF4    INCR	0x74
  008A    1903    SZB	0x3,2
  008B    0AF5    INCR	0x75
  008C    3001    LDIA	0x1
  008D    06F7    XORR	0x77
  008E    01F8    CLR	0x78
  008F    01F9    CLR	0x79
  0090    0872    LD	A,0x72
  0091    0473    ORA	0x73
  0092    1903    SZB	0x3,2
  0093    28B3    JP	0xB3
  0094    01F6    CLR	0x76
  0095    0AF6    INCR	0x76
  0096    1BF3    SZB	0x73,7
  0097    289C    JP	0x9C
  0098    1003    CLRB	0x3,0
  0099    0DF2    RLCR	0x72
  009A    0DF3    RLCR	0x73
  009B    2895    JP	0x95
  009C    1003    CLRB	0x3,0
  009D    0DF8    RLCR	0x78
  009E    0DF9    RLCR	0x79
  009F    0873    LD	A,0x73
  00A0    0275    SUBA	0x75
  00A1    1D03    SNZB	0x3,2
  00A2    28A5    JP	0xA5
  00A3    0872    LD	A,0x72
  00A4    0274    SUBA	0x74
  00A5    1C03    SNZB	0x3,0
  00A6    28AF    JP	0xAF
  00A7    0872    LD	A,0x72
  00A8    02F4    SUBR	0x74
  00A9    0873    LD	A,0x73
  00AA    1C03    SNZB	0x3,0
  00AB    03F5    DECR	0x75
  00AC    02F5    SUBR	0x75
  00AD    1478    SETB	0x78,0
  00AE    1003    CLRB	0x3,0
  00AF    0CF3    RRCR	0x73
  00B0    0CF2    RRCR	0x72
  00B1    0BF6    SZDECR	0x76
  00B2    289C    JP	0x9C
  00B3    0877    LD	A,0x77
  00B4    1903    SZB	0x3,2
  00B5    28BB    JP	0xBB
  00B6    09F8    COMR	0x78
  00B7    09F9    COMR	0x79
  00B8    0AF8    INCR	0x78
  00B9    1903    SZB	0x3,2
  00BA    0AF9    INCR	0x79
  00BB    0879    LD	A,0x79
  00BC    00F3    LD	0x73,A
  00BD    0878    LD	A,0x78
  00BE    00F2    LD	0x72,A
  00BF    0008    RET
7:                #else
8:                __awdiv(signed int dividend, signed int divisor)
9:                #endif
10:               {
11:               	signed int	quotient;
12:               	unsigned char	counter, sign;
13:               
14:               	sign = 0;
15:               	if(divisor < 0) {
16:               		divisor = -divisor;
17:               		sign = 1;
18:               	}
19:               	if(dividend < 0) {
20:               		dividend = -dividend;
21:               		sign ^= 1;
22:               	}
23:               	quotient = 0;
24:               	if(divisor != 0) {
25:               		counter = 1;
26:               		while((divisor & 0x8000U) == 0) {
27:               			divisor <<= 1;
28:               			counter++;
29:               		}
30:               		do {
31:               			quotient <<= 1;
32:               			if((unsigned int)divisor <= (unsigned int)dividend) {
33:               				dividend -= divisor;
34:               				quotient |= 1;
35:               			}
36:               			*(unsigned int *)&divisor >>= 1;
37:               		} while(--counter != 0);
38:               	}
39:               	if(sign)
40:               		quotient = -quotient;
41:               	return quotient;
42:               }
---- E:\project\scm\uf166fan\init.c ----------------------------------------------------------------------
1:                #include "init.h"
2:                
3:                void Init_System()
  0244    0000    NOP
  0245    0064    CLRWDT
4:                {
5:                	asm("nop");
6:                	asm("clrwdt");
7:                	INTCON = 0;					//系统初始化
  0246    018B    CLR	0xB
8:                	OSCCON = 0X71;				//配置振荡为8M,开 WDT
  0247    3071    LDIA	0x71
  0248    1683    SETB	0x3,5
  0249    1303    CLRB	0x3,6
  024A    008F    LD	0xF,A
9:                	OPTION_REG = 0x00;		//Timer0使用内部时钟Focs/4，预分频比为1:2
  024B    0181    CLR	0x1
10:               	INTCON = 0x00;			//禁止所以中断
  024C    018B    CLR	0xB
  024D    0008    RET
11:               	
12:               	
13:               	
14:               }
15:               
16:               
17:               void Init_GPIO()
18:               {
19:               	TRISA = 0;
  01EB    0185    CLR	0x5
20:               	TRISB = 0;
  01EC    0186    CLR	0x6
21:               	TRISC = 0;
  01ED    0187    CLR	0x7
22:               	WPUA = 0xFF;
  01EE    30FF    LDIA	0xFF
  01EF    1703    SETB	0x3,6
  01F0    008E    LD	0xE,A
23:               	WPUB = 0xFF;	
  01F1    1303    CLRB	0x3,6
  01F2    0095    LD	0x15,A
24:               	WPUC = 0xFF;
  01F3    1703    SETB	0x3,6
  01F4    008F    LD	0xF,A
25:               	PORTA = 0xFF;
  01F5    1283    CLRB	0x3,5
  01F6    1303    CLRB	0x3,6
  01F7    0085    LD	0x5,A
26:               	PORTB = 0xFF;
  01F8    0086    LD	0x6,A
27:               	PORTC = 0xFF;
  01F9    0087    LD	0x7,A
28:               	IOCB = 0x00;
  01FA    1683    SETB	0x3,5
  01FB    0196    CLR	0x16
  01FC    0008    RET
29:               	
30:               }
31:               
32:               void Init_Interupt()
33:               {
34:               	OPTION_REG = 0x00;		//Timer0使用内部时钟Focs/4，预分频比为1:2
  024E    0181    CLR	0x1
35:               	TMR0 = 0;				//赋予初始值
  024F    1283    CLRB	0x3,5
  0250    0181    CLR	0x1
36:               	INTCON = 0xE0;			//允许所有未被屏蔽的中断、禁止外设中断，使能Timer0
  0251    30E0    LDIA	0xE0
  0252    008B    LD	0xB,A
  0253    0008    RET
37:               
38:               }
---- stringtab ------------------------------------------------------------------
---- reset_enter ------------------------------------------------------------------
  0000    280A    JP	0xA
  000A    280B    JP	0xB
---- start_initialization ------------------------------------------------------------------
  000B    3002    LDIA	0x2
  000C    00FA    LD	0x7A,A
  000D    00FB    LD	0x7B,A
  000E    01B8    CLR	0x38
  000F    01B9    CLR	0x39
  0010    01BA    CLR	0x3A
  0011    01BB    CLR	0x3B
  0012    01BC    CLR	0x3C
  0013    01BD    CLR	0x3D
  0014    01BE    CLR	0x3E
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F0    LD	0x70,A
  0007    080A    LD	A,0xA
  0008    00F1    LD	0x71,A
  0009    2A0D    JP	0x20D
---- common_function ------------------------------------------------------------------
  0015    0183    CLR	0x3
  0016    2817    JP	0x17
  0254    28C8    JP	0xC8
  0255    28D0    JP	0xD0
  0256    28DA    JP	0xDA
  0257    28ED    JP	0xED
