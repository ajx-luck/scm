---- E:\project\project0508\scm\uf166fan\main.c ----------------------------------------------------------------------
1:                #include "scankey.h"
2:                #include "init.h"
3:                #include "adc.h"
4:                
5:                #define MAX_FAN_LEVEL 4
6:                #define MIN_FAN_LEVEL 1
7:                
8:                #define FAN_STATUS_OFF  0
9:                #define FAN_STATUS_ON  1
10:               #define FAN_STATUS_NONE 2
11:               
12:               #define PBPORTB PORTA
13:               #define PBTRISB TRISA
14:               
15:               #define LED_1  1
16:               #define LED_2  2
17:               #define LED_3  3
18:               #define LED_4  4
19:               //1毫秒中断标志
20:               static unsigned char time0Flag = 0;
21:               static unsigned int countTime = 0;
22:               static unsigned int count10Ms = 0;
23:               unsigned char currentLevel = 3;
24:               //风扇状态
25:               unsigned char FAN_STATUS = FAN_STATUS_NONE;
26:               //检测风扇次数
27:               unsigned int fan_check_time = 0;
28:               //低电压检测次数
29:               unsigned char lowVTime = 0;
30:               unsigned char count300ms = 0;
31:               //按键结构体
32:               struct Keys key1, key2, key3;
33:               //显示风扇挡位
34:               void setLedOn(unsigned char ledIndex);
35:               //初始化配置
36:               void Init_Config();
37:               //睡眠模式
38:               void Sleep_Mode();
39:               //关闭风扇
40:               void closeFan();
41:               
42:               void checkUsbStatus() {
43:                   if (getbit(PORTB, 2) == 1) {
  00C4    0806    LD	A,0x6
  00C5    00C7    LD	0x47,A
  00C6    1003    CLRB	0x3,0
  00C7    0CC7    RRCR	0x47
  00C8    1003    CLRB	0x3,0
  00C9    0CC7    RRCR	0x47
  00CA    1C47    SNZB	0x47,0
  00CB    28DD    JP	0xDD
44:                       if (getbit(PORTB, 1) == 0) {
  00CC    0806    LD	A,0x6
  00CD    00C7    LD	0x47,A
  00CE    1003    CLRB	0x3,0
  00CF    0CC7    RRCR	0x47
  00D0    1847    SZB	0x47,0
  00D1    28D4    JP	0xD4
45:                           //充满了，Led常亮
46:                           resetbit(PORTA, 0);
  00D2    1005    CLRB	0x5,0
47:                       } else if (countTime < 15) {
  00D3    0008    RET
  00D4    3000    LDIA	0x0
  00D5    022D    SUBA	0x2D
  00D6    300F    LDIA	0xF
  00D7    1903    SZB	0x3,2
  00D8    022C    SUBA	0x2C
  00D9    1C03    SNZB	0x3,0
  00DA    28D2    JP	0xD2
48:                           //充电中，一直闪		
49:                           resetbit(PORTA, 0);
50:                       }else{
51:               			setbit(PORTA, 0);
  00DB    1405    SETB	0x5,0
  00DC    0008    RET
52:               		}
53:                   } else {
54:                       //usb断开充电灯熄灭,PA0 = 1
55:                       setbit(PORTA, 0);
  00DD    1405    SETB	0x5,0
56:               		if((adresult/8) > 0x63 && count300ms == 0)
  00DE    20F9    CALL	0xF9
  00DF    3064    LDIA	0x64
  00E0    1903    SZB	0x3,2
  00E1    0247    SUBA	0x47
  00E2    1C03    SNZB	0x3,0
  00E3    28F0    JP	0xF0
  00E4    0876    LD	A,0x76
  00E5    1D03    SNZB	0x3,2
  00E6    28F0    JP	0xF0
57:               		{
58:               			if(lowVTime < 20)
  00E7    3014    LDIA	0x14
  00E8    0231    SUBA	0x31
  00E9    1803    SZB	0x3,0
  00EA    28EF    JP	0xEF
  00EB    3001    LDIA	0x1
59:               			{
60:               				lowVTime++;
  00EC    0AB1    INCR	0x31
61:               				//闪红灯，
62:               				reversebit(PORTA, 0);
  00ED    0685    XORR	0x5
63:               			}else
  00EE    28F0    JP	0xF0
64:               			{
65:               				//关闭风扇
66:               				closeFan();
  00EF    2325    CALL	0x325
67:               			}
68:               		}
69:               		if((adresult/8) < 0x63)
  00F0    1283    CLRB	0x3,5
  00F1    1303    CLRB	0x3,6
  00F2    20F9    CALL	0xF9
  00F3    3063    LDIA	0x63
  00F4    1903    SZB	0x3,2
  00F5    0247    SUBA	0x47
  00F6    1C03    SNZB	0x3,0
70:               		{
71:               			lowVTime = 0;
  00F7    01B1    CLR	0x31
  00F8    0008    RET
72:               		}
73:                   }
74:               }
75:               
76:               void Init_PWM() {
77:                   CCP1CON = 0x0F;//设置PC2为PWM模式，4,5位为占空比的低2位
  038A    300F    LDIA	0xF
  038B    0097    LD	0x17,A
  03AA    300F    LDIA	0xF
  03AB    0097    LD	0x17,A
78:                   T2CON = 0; //时钟分频 1:1 PWM周期为（PR2+1）*4/8,000,000
  038C    0192    CLR	0x12
  03AC    0192    CLR	0x12
79:                   PR2 = 7;
  038D    3007    LDIA	0x7
  038E    1683    SETB	0x3,5
  038F    0092    LD	0x12,A
  03AD    3007    LDIA	0x7
  03AE    1683    SETB	0x3,5
  03AF    0092    LD	0x12,A
80:               
81:                   CCPR1L = 0;//占空比高8位，低2位设置为0，结果就是 占空比 = CCPR1L*4/4*(PR2+1)
  0390    1283    CLRB	0x3,5
  0391    0195    CLR	0x15
  03B0    1283    CLRB	0x3,5
  03B1    0195    CLR	0x15
82:                   TMR2IF = 0;
  0392    108C    CLRB	0xC,1
  03B2    108C    CLRB	0xC,1
83:                   T2CON = 0;
  0393    0192    CLR	0x12
  03B3    0192    CLR	0x12
84:                   //PC2设置为输出脚
85:                   resetbit(TRISC, 2);
  0394    1683    SETB	0x3,5
  0395    1107    CLRB	0x7,2
  03B4    1683    SETB	0x3,5
  03B5    1107    CLRB	0x7,2
86:                   T2CON = 0X04; //启动定时器2，溢出后启动PWM
  0396    3004    LDIA	0x4
  0397    1283    CLRB	0x3,5
  0398    0092    LD	0x12,A
  0399    0008    RET
  03B6    3004    LDIA	0x4
  03B7    1283    CLRB	0x3,5
  03B8    0092    LD	0x12,A
  03B9    0008    RET
87:               }
88:               
89:               //设置风扇转速
90:               void setFanLevel(char level) {
  0192    00CF    LD	0x4F,A
91:               	Init_PWM();
  0193    238A    CALL	0x38A
92:               	if(level == 0)
  0194    084F    LD	A,0x4F
  0195    1D03    SNZB	0x3,2
  0196    2999    JP	0x199
93:               	{
94:               		currentLevel = 3;
  0197    3003    LDIA	0x3
  0198    00F9    LD	0x79,A
95:               	}
96:                   unsigned int levelWidth = (PR2 + 1) / MAX_FAN_LEVEL;
  0199    1683    SETB	0x3,5
  019A    0812    LD	A,0x12
  019B    1283    CLRB	0x3,5
  019C    00C9    LD	0x49,A
  019D    01CA    CLR	0x4A
  019E    0AC9    INCR	0x49
  019F    1903    SZB	0x3,2
  01A0    0ACA    INCR	0x4A
  01A1    3004    LDIA	0x4
  01A2    00C7    LD	0x47,A
  01A3    01C8    CLR	0x48
  01A4    2109    CALL	0x109
97:                   char tempLevel = currentLevel + level;
  01A5    084F    LD	A,0x4F
  01A6    0779    ADDA	0x79
  01A7    00D0    LD	0x50,A
98:                   if (tempLevel > MAX_FAN_LEVEL) {
  01A8    3005    LDIA	0x5
  01A9    0250    SUBA	0x50
  01AA    1C03    SNZB	0x3,0
  01AB    29AE    JP	0x1AE
99:                       tempLevel = MAX_FAN_LEVEL;
  01AC    3004    LDIA	0x4
  01AD    00D0    LD	0x50,A
100:                  }
101:              
102:                  if (tempLevel < MIN_FAN_LEVEL) {
  01AE    0850    LD	A,0x50
  01AF    1D03    SNZB	0x3,2
  01B0    29B3    JP	0x1B3
103:                      tempLevel = MIN_FAN_LEVEL;
  01B1    01D0    CLR	0x50
  01B2    0AD0    INCR	0x50
104:                  }
105:              	
106:                  
107:                  if (FAN_STATUS == FAN_STATUS_ON) {
  01B3    0B78    SZDECA	0x78
  01B4    0008    RET
108:              		currentLevel = tempLevel;
  01B5    0850    LD	A,0x50
  01B6    00F9    LD	0x79,A
109:              		switch(currentLevel)
  01B7    29C1    JP	0x1C1
110:              		{
111:              			case 1:
112:              			CCPR1L = 1;
  01B8    3001    LDIA	0x1
  01B9    29BF    JP	0x1BF
113:              			break;
114:              			case 2:
115:              			CCPR1L = 2;
  01BA    3002    LDIA	0x2
  01BB    29BF    JP	0x1BF
116:              			break;
117:              			case 3:
118:              			CCPR1L = 3;
  01BC    3003    LDIA	0x3
  01BD    29BF    JP	0x1BF
119:              			break;
120:              			case 4:
121:              			CCPR1L = 5;
  01BE    3005    LDIA	0x5
  01BF    0095    LD	0x15,A
122:              			break;
  01C0    29CF    JP	0x1CF
  01C1    0879    LD	A,0x79
  01C2    3A01    XORIA	0x1
  01C3    1903    SZB	0x3,2
  01C4    29B8    JP	0x1B8
  01C5    3A03    XORIA	0x3
  01C6    1903    SZB	0x3,2
  01C7    29BA    JP	0x1BA
  01C8    3A01    XORIA	0x1
  01C9    1903    SZB	0x3,2
  01CA    29BC    JP	0x1BC
  01CB    3A07    XORIA	0x7
  01CC    1903    SZB	0x3,2
  01CD    29BE    JP	0x1BE
  01CE    29CF    JP	0x1CF
123:              		}
124:                  //设置占宽比
125:              		//CCPR1L = levelWidth * currentLevel;
126:                      setLedOn(currentLevel);
  01CF    0879    LD	A,0x79
  01D0    29D1    JP	0x1D1
127:                  }
128:              
129:              }
130:              
131:              //关闭风扇
132:              void closeFan() {
133:                  CCP1CON = 0x00;
  0325    0197    CLR	0x17
134:              	T2CON = 0X00;
  0326    0192    CLR	0x12
135:              	
136:                  currentLevel = 2;
  0327    3002    LDIA	0x2
  0328    00F9    LD	0x79,A
137:                  setLedOn(5);
  0329    3005    LDIA	0x5
  032A    21D1    CALL	0x1D1
138:                  setbit(PORTA, 0);
  032B    1405    SETB	0x5,0
139:                  //PWM输出脚设置为输入，关闭PWM
140:              	resetbit(TRISC, 2);
  032C    1683    SETB	0x3,5
  032D    1107    CLRB	0x7,2
141:              	resetbit(PORTC, 2);
  032E    1283    CLRB	0x3,5
  032F    1107    CLRB	0x7,2
142:              	resetbit(TRISA, 2);
  0330    1683    SETB	0x3,5
  0331    1105    CLRB	0x5,2
143:              	resetbit(PORTA, 2);
  0332    1283    CLRB	0x3,5
  0333    1105    CLRB	0x5,2
144:                  fan_check_time = 0;
  0334    01A8    CLR	0x28
  0335    01A9    CLR	0x29
145:                  FAN_STATUS = FAN_STATUS_OFF;
  0336    01F8    CLR	0x78
146:              	//usb充电未连接，进入睡眠模式
147:                  if (getbit(PORTB, 2) == 0) {
  0337    0806    LD	A,0x6
  0338    00F5    LD	0x75,A
  0339    1003    CLRB	0x3,0
  033A    0CF5    RRCR	0x75
  033B    1003    CLRB	0x3,0
  033C    0CF5    RRCR	0x75
  033D    1875    SZB	0x75,0
  033E    0008    RET
148:              		Sleep_Mode();
  033F    2A5D    JP	0x25D
149:              	}
150:              }
151:              
152:              
153:              //检测风扇是否连接
154:              void checkFan() {
155:              	resetbit(TRISA, 1);
  020A    1683    SETB	0x3,5
  020B    1085    CLRB	0x5,1
156:                  setbit(PORTA, 1);
  020C    1283    CLRB	0x3,5
  020D    1485    SETB	0x5,1
157:                  //PC2设置为输出脚
158:                  resetbit(TRISC, 2);
  020E    1683    SETB	0x3,5
  020F    1107    CLRB	0x7,2
159:              	setbit(PORTA, 2);
  0210    1283    CLRB	0x3,5
  0211    1505    SETB	0x5,2
160:                  T2CON = 0X04; //启动定时器2，溢出后启动PWM
  0212    3004    LDIA	0x4
  0213    0092    LD	0x12,A
161:              
162:                  //EN IN输出高电位，D1点亮，检测FAN DET，FAN DET为低电位则风扇正常工作，高电位则未连接
163:                  if (getbit(PORTB, 6) == 0) {
  0214    0806    LD	A,0x6
  0215    00D1    LD	0x51,A
  0216    3006    LDIA	0x6
  0217    1003    CLRB	0x3,0
  0218    0CD1    RRCR	0x51
  0219    3EFF    ADDIA	0xFF
  021A    1D03    SNZB	0x3,2
  021B    2A17    JP	0x217
  021C    1851    SZB	0x51,0
  021D    2A21    JP	0x221
164:                      FAN_STATUS = FAN_STATUS_ON;
  021E    01F8    CLR	0x78
  021F    0AF8    INCR	0x78
165:                  } else {
  0220    2A23    JP	0x223
166:                      FAN_STATUS = FAN_STATUS_NONE;
  0221    3002    LDIA	0x2
  0222    00F8    LD	0x78,A
167:                  }
168:              	
169:              	setFanLevel(0);
  0223    3000    LDIA	0x0
  0224    2192    CALL	0x192
170:              
171:                  //没有检测到风扇
172:                  if (FAN_STATUS == FAN_STATUS_NONE) {
  0225    3002    LDIA	0x2
  0226    0678    XORA	0x78
  0227    1D03    SNZB	0x3,2
  0228    0008    RET
173:                      fan_check_time++;
  0229    0AA8    INCR	0x28
  022A    1903    SZB	0x3,2
  022B    0AA9    INCR	0x29
174:                      if (fan_check_time == 3000) {
  022C    30B8    LDIA	0xB8
  022D    0628    XORA	0x28
  022E    300B    LDIA	0xB
  022F    1903    SZB	0x3,2
  0230    0629    XORA	0x29
  0231    1D03    SNZB	0x3,2
  0232    0008    RET
175:                          closeFan();
  0233    2B25    JP	0x325
176:                          return;
177:                      }
178:                  }
179:              
180:              
181:              }
182:              
183:              
184:              //设置Led灯亮
185:              void setLedOn(unsigned char ledIndex) {
  01D1    00F4    LD	0x74,A
186:                  switch(ledIndex) {
  01D2    29EE    JP	0x1EE
187:                      case 1:
188:                          //PB7设置为输入脚,PC1和PC0设置为输出
189:              			resetbit(TRISC, 1);
190:              			setbit(PBTRISB, 7);
191:                          resetbit(TRISC, 0);
192:                          resetbit(PBPORTB, 7);
  01D3    21FD    CALL	0x1FD
193:                          setbit(PORTC, 0);
  01D4    1407    SETB	0x7,0
194:                          resetbit(PORTC, 1);            
  01D5    1087    CLRB	0x7,1
195:                          break;
  01D6    0008    RET
196:                      case 2:
197:              			resetbit(TRISC, 1);
198:              			setbit(PBTRISB, 7);
199:                          resetbit(TRISC, 0);
200:              			resetbit(PBPORTB, 7);
  01D7    21FD    CALL	0x1FD
201:                          resetbit(PORTC, 0);
  01D8    1007    CLRB	0x7,0
202:                          setbit(PORTC, 1);
  01D9    1487    SETB	0x7,1
203:                          break;
  01DA    0008    RET
204:                      case 3:
205:                          //PC0设置为输入脚，PB7和PC1设置为输出
206:              			setbit(TRISC, 0);
207:              			resetbit(PBTRISB, 7);
208:                          resetbit(TRISC, 1);
209:                          setbit(PBPORTB, 7);
  01DB    2204    CALL	0x204
  01DC    1785    SETB	0x5,7
210:                          resetbit(PORTC, 0);
  01DD    1007    CLRB	0x7,0
211:                          resetbit(PORTC, 1);
  01DE    1087    CLRB	0x7,1
212:                          break;
  01DF    0008    RET
213:                      case 4:
214:              			setbit(TRISC, 0);
215:              			resetbit(PBTRISB, 7);
216:                          resetbit(TRISC, 1);
217:                          resetbit(PBPORTB, 7);
  01E0    2204    CALL	0x204
  01E1    1385    CLRB	0x5,7
218:                          setbit(PORTC, 0);
  01E2    1407    SETB	0x7,0
219:                          setbit(PORTC, 1);
  01E3    1487    SETB	0x7,1
220:                          break;
  01E4    0008    RET
221:                      case 5:
222:                          //全部设置为输入脚
223:              			setbit(TRISC, 0);
  01E5    1683    SETB	0x3,5
  01E6    1407    SETB	0x7,0
224:              			setbit(PBTRISB, 7);
  01E7    1785    SETB	0x5,7
225:                          setbit(TRISC, 1);
  01E8    1487    SETB	0x7,1
226:              			setbit(PBPORTB, 7);
  01E9    1283    CLRB	0x3,5
  01EA    1785    SETB	0x5,7
227:              			setbit(PORTC, 0);
  01EB    1407    SETB	0x7,0
228:                          setbit(PORTC, 1);
  01EC    1487    SETB	0x7,1
229:                          break;
  01ED    0008    RET
  01EE    0874    LD	A,0x74
  01EF    3EFF    ADDIA	0xFF
  01F0    1C03    SNZB	0x3,0
  01F1    0008    RET
  01F2    0084    LD	0x4,A
  01F3    3005    LDIA	0x5
  01F4    0204    SUBA	0x4
  01F5    1803    SZB	0x3,0
  01F6    0008    RET
  01F7    3004    LDIA	0x4
  01F8    008A    LD	0xA,A
  01F9    3000    LDIA	0x0
  01FA    0704    ADDA	0x4
  01FB    0082    LD	0x2,A
  01FC    0008    RET
230:                  }
231:              }
232:              
233:              
234:              //扫描按键
235:              void scanKeys() {
236:                  key1.key_addr_result = key2.key_addr_result = key3.key_addr_result = PORTB;
  03BA    1283    CLRB	0x3,5
  03BB    1303    CLRB	0x3,6
  03BC    0806    LD	A,0x6
  03BD    00B7    LD	0x37,A
  03BE    00BE    LD	0x3E,A
  03BF    00C5    LD	0x45,A
237:                  sacnKeyInput(&key1);
  03C0    3040    LDIA	0x40
  03C1    22EB    CALL	0x2EB
238:                  sacnKeyInput(&key2);
  03C2    3039    LDIA	0x39
  03C3    22EB    CALL	0x2EB
239:                  sacnKeyInput(&key3);
  03C4    3032    LDIA	0x32
  03C5    2AEB    JP	0x2EB
240:                 
241:              }
242:              
243:              //检测按键状态并处理
244:              void checkKeys() {
245:                  if (key_driver(&key1) == key_click) {
  02CD    3040    LDIA	0x40
  02CE    214E    CALL	0x14E
  02CF    3A01    XORIA	0x1
  02D0    1D03    SNZB	0x3,2
  02D1    2AD8    JP	0x2D8
246:                      //检测到按键了，检测风扇是否存在
247:              
248:                      if (FAN_STATUS == FAN_STATUS_ON) {
  02D2    0B78    SZDECA	0x78
  02D3    2AD5    JP	0x2D5
249:                          //关闭风扇
250:                          closeFan();
  02D4    2B25    JP	0x325
251:                      } else {
252:                          FAN_STATUS = FAN_STATUS_NONE;
  02D5    3002    LDIA	0x2
  02D6    00F8    LD	0x78,A
253:                          checkFan();
  02D7    2A0A    JP	0x20A
  02D8    3002    LDIA	0x2
  02D9    0678    XORA	0x78
  02DA    1D03    SNZB	0x3,2
  02DB    2ADD    JP	0x2DD
254:                      }
255:                      return;
256:                  } else if (FAN_STATUS == FAN_STATUS_NONE) {
257:                      checkFan();
  02DC    220A    CALL	0x20A
258:                  }
259:              
260:              	unsigned char key2Status = key_driver(&key2);
  02DD    3039    LDIA	0x39
  02DE    214E    CALL	0x14E
  02DF    00D2    LD	0x52,A
261:                  if (key2Status == key_click) {
  02E0    0B52    SZDECA	0x52
  02E1    2AE4    JP	0x2E4
262:                      //加档
263:                      setFanLevel(1);
  02E2    3001    LDIA	0x1
  02E3    2992    JP	0x192
264:                      return;
265:                  }
266:              	unsigned char key3Status = key_driver(&key3);
  02E4    3032    LDIA	0x32
  02E5    214E    CALL	0x14E
  02E6    00D3    LD	0x53,A
267:                  if (key3Status == key_click) {
  02E7    0B53    SZDECA	0x53
  02E8    0008    RET
268:                      //减档
269:                      setFanLevel(-1);
  02E9    30FF    LDIA	0xFF
  02EA    2992    JP	0x192
270:                      return;
271:                  }
272:              
273:              }
274:              
275:              
276:              void main(void) {
277:              	
278:                  Init_Config();
  0234    22AA    CALL	0x2AA
279:              	closeFan();
  0235    2325    CALL	0x325
280:                  while (1) {
281:                      //0.1毫秒检测一次
282:                      if (time0Flag) {
  0236    0877    LD	A,0x77
  0237    1903    SZB	0x3,2
  0238    2A3F    JP	0x23F
  0239    0064    CLRWDT
283:                          asm("clrwdt");
284:                          time0Flag = 0;
  023A    01F7    CLR	0x77
285:              			scanKeys();
  023B    23BA    CALL	0x3BA
286:                          count10Ms++;
  023C    0AAA    INCR	0x2A
  023D    1903    SZB	0x3,2
  023E    0AAB    INCR	0x2B
287:                      }
288:              
289:                      //10毫秒检测一次
290:                      if (count10Ms == 100) {	
  023F    3064    LDIA	0x64
  0240    1283    CLRB	0x3,5
  0241    1303    CLRB	0x3,6
  0242    062A    XORA	0x2A
  0243    042B    ORA	0x2B
  0244    1D03    SNZB	0x3,2
  0245    2A51    JP	0x251
291:              			countTime++;
  0246    0AAC    INCR	0x2C
  0247    1903    SZB	0x3,2
  0248    0AAD    INCR	0x2D
292:              			count300ms++;	
  0249    0AF6    INCR	0x76
293:                          checkKeys();
  024A    22CD    CALL	0x2CD
294:                          count10Ms = 0;
  024B    1283    CLRB	0x3,5
  024C    1303    CLRB	0x3,6
  024D    01AA    CLR	0x2A
  024E    01AB    CLR	0x2B
295:                          //检测USB状态
296:                          checkUsbStatus();
  024F    20C4    CALL	0xC4
297:              			//检测内部电压
298:              			readVrefADC();
  0250    23EB    CALL	0x3EB
299:                      }
300:              		//300ms
301:              		if(count300ms == 10)
  0251    300A    LDIA	0xA
  0252    0676    XORA	0x76
  0253    1903    SZB	0x3,2
302:              		{
303:              			count300ms = 0;
  0254    01F6    CLR	0x76
304:              		}
305:              		//1s钟
306:                      if (countTime == 50) {
  0255    3032    LDIA	0x32
  0256    062C    XORA	0x2C
  0257    042D    ORA	0x2D
  0258    1D03    SNZB	0x3,2
  0259    2A36    JP	0x236
307:                          countTime = 0;
  025A    01AC    CLR	0x2C
  025B    01AD    CLR	0x2D
  025C    2A36    JP	0x236
308:                      }
309:              		
310:                  }
311:              
312:              }
313:              
314:              void Init_Config() {
315:              	if(FAN_STATUS == FAN_STATUS_ON)
  0286    0B78    SZDECA	0x78
  0287    2A89    JP	0x289
  0288    0008    RET
  02AA    0B78    SZDECA	0x78
  02AB    2AAD    JP	0x2AD
  02AC    0008    RET
316:              	{
317:              		return;
318:              	}
319:                  Init_System();
  0289    23DA    CALL	0x3DA
  02AD    23D1    CALL	0x3D1
320:                  Init_GPIO();
  028A    2368    CALL	0x368
  02AE    2356    CALL	0x356
321:                  Init_Interupt();
  028B    23F7    CALL	0x3F7
  02AF    23F1    CALL	0x3F1
322:                  Init_PWM();
  028C    23AA    CALL	0x3AA
  02B0    238A    CALL	0x38A
323:                  //设置唤醒
324:                  IOCB = 0x04;
  028D    3004    LDIA	0x4
  028E    1683    SETB	0x3,5
  028F    0096    LD	0x16,A
  02B1    3004    LDIA	0x4
  02B2    1683    SETB	0x3,5
  02B3    0096    LD	0x16,A
325:                  TMR0 = 155;
  0290    309B    LDIA	0x9B
  0291    1283    CLRB	0x3,5
  0292    0081    LD	0x1,A
  02B4    309B    LDIA	0x9B
  02B5    1283    CLRB	0x3,5
  02B6    0081    LD	0x1,A
326:                  TO = 0;
  0293    1203    CLRB	0x3,4
  02B7    1203    CLRB	0x3,4
327:              
328:                  //K1开关
329:                  key1.key_index = 5;
  0294    3005    LDIA	0x5
  0295    00C6    LD	0x46,A
  02B8    3005    LDIA	0x5
  02B9    00C6    LD	0x46,A
330:                  //K2加档
331:                  key2.key_index = 4;
  0296    3004    LDIA	0x4
  0297    00BF    LD	0x3F,A
  02BA    3004    LDIA	0x4
  02BB    00BF    LD	0x3F,A
332:                  //K3减档
333:                  key3.key_index = 3;
  0298    3003    LDIA	0x3
  0299    00B8    LD	0x38,A
  02BC    3003    LDIA	0x3
  02BD    00B8    LD	0x38,A
334:                  resetKey(&key1);
  029A    3040    LDIA	0x40
  029B    239A    CALL	0x39A
  02BE    3040    LDIA	0x40
  02BF    237A    CALL	0x37A
335:                  resetKey(&key2);
  029C    3039    LDIA	0x39
  029D    239A    CALL	0x39A
  02C0    3039    LDIA	0x39
  02C1    237A    CALL	0x37A
336:                  resetKey(&key3);
  029E    3032    LDIA	0x32
  029F    239A    CALL	0x39A
  02C2    3032    LDIA	0x32
  02C3    237A    CALL	0x37A
337:                  //设置IO方向
338:                  TRISA = 0;
  02A0    1683    SETB	0x3,5
  02A1    1303    CLRB	0x3,6
  02A2    0185    CLR	0x5
  02C4    1683    SETB	0x3,5
  02C5    1303    CLRB	0x3,6
  02C6    0185    CLR	0x5
339:                  TRISB = 0x7E;//1-6脚输入
  02A3    307E    LDIA	0x7E
  02A4    0086    LD	0x6,A
  02C7    307E    LDIA	0x7E
  02C8    0086    LD	0x6,A
340:                  TRISC = 0;
  02A5    0187    CLR	0x7
  02C9    0187    CLR	0x7
341:              	lowVTime = 0;
  02A6    1283    CLRB	0x3,5
  02A7    01B1    CLR	0x31
  02CA    1283    CLRB	0x3,5
  02CB    01B1    CLR	0x31
342:              	Init_PWM();
  02A8    23AA    CALL	0x3AA
  02A9    0008    RET
  02CC    2B8A    JP	0x38A
343:              }
344:              
345:              void Sleep_Mode() {
346:                  INTCON = 0;
  025D    018B    CLR	0xB
347:              
348:                  OPTION_REG = 0;
  025E    1683    SETB	0x3,5
  025F    0181    CLR	0x1
349:              
350:                  TRISA = 0B00000000;        //关闭所有输出
  0260    0185    CLR	0x5
351:                  PORTA = 0B01000001;
  0261    3041    LDIA	0x41
  0262    1283    CLRB	0x3,5
  0263    0085    LD	0x5,A
352:                  WPUA = 0B00000000;
  0264    1683    SETB	0x3,5
  0265    1703    SETB	0x3,6
  0266    018E    CLR	0xE
353:              
354:                  TRISB = 0B00100100;
  0267    3024    LDIA	0x24
  0268    1303    CLRB	0x3,6
  0269    0086    LD	0x6,A
355:                  PORTB = 0B01000000;
  026A    3040    LDIA	0x40
  026B    1283    CLRB	0x3,5
  026C    0086    LD	0x6,A
356:              
357:              	TRISC = 0B00000000;
  026D    1683    SETB	0x3,5
  026E    0187    CLR	0x7
358:                  PORTC = 0B00000011;
  026F    3003    LDIA	0x3
  0270    1283    CLRB	0x3,5
  0271    0087    LD	0x7,A
359:              	setLedOn(5);
  0272    3005    LDIA	0x5
  0273    21D1    CALL	0x1D1
360:                  WPUB = 0B00100000;         //RB5 上拉
  0274    3020    LDIA	0x20
  0275    1683    SETB	0x3,5
  0276    0095    LD	0x15,A
361:              	
362:              
363:                  IOCB = 0B00100100;            //允许RB5 RB2的IO口电平变化中断
  0277    3024    LDIA	0x24
  0278    0096    LD	0x16,A
364:                  RBIE = 1;                    //允许PORTB电平变化中断
  0279    158B    SETB	0xB,3
365:                  GIE = 1;                    //GIE = 0时，唤醒后执行SLEEP后程序;GIE = 1时，唤醒后跳至中断服务
  027A    178B    SETB	0xB,7
366:              
367:                  ADCON0 = 0;                    //关闭所有模块
  027B    1283    CLRB	0x3,5
  027C    019F    CLR	0x1F
368:              
369:                  OSCCON = 0X70;                //配置振荡为16M,关闭WDT
  027D    3070    LDIA	0x70
  027E    1683    SETB	0x3,5
  027F    008F    LD	0xF,A
370:              	
371:                  PORTB;                        //读PORTB值并锁存	
  0280    1283    CLRB	0x3,5
  0281    0806    LD	A,0x6
  0282    0064    CLRWDT
  0283    0063    STOP
  0284    0000    NOP
  0285    0008    RET
372:              			
373:                  asm("clrwdt");
374:              
375:                  asm("sleep");                //进入休眠模式
376:              
377:                  asm("nop");
378:              	
379:              	
380:              
381:              
382:              }
383:              
384:              
385:              
386:              /***********************************************
387:              函数名称：Timer0_Isr
388:              函数功能：中断服务
389:              入口参数：无
390:              出口参数：无
391:              备注：
392:              ***********************************************/
393:              void interrupt
394:              
395:              Timer0_Isr() {
396:                  if (T0IF) {
  0340    1D0B    SNZB	0xB,2
  0341    2B49    JP	0x349
397:                      //---------------------------------------
398:                      TMR0 += 155;        //重新赋初值，在赋值前Timer0已有计数，故在该基础上加初值
  0342    309B    LDIA	0x9B
  0343    1283    CLRB	0x3,5
  0344    1303    CLRB	0x3,6
  0345    0781    ADDR	0x1
399:                      //---------------------------------------
400:              
401:                      T0IF = 0;            //清中断标志位	
  0346    110B    CLRB	0xB,2
402:                      time0Flag = 1;
  0347    01F7    CLR	0x77
  0348    0AF7    INCR	0x77
403:              
404:                  }
405:              
406:                  if (RBIF) {
  0349    1C0B    SNZB	0xB,0
  034A    2B4D    JP	0x34D
407:                      RBIF = 0;            //清中断标志
  034B    100B    CLRB	0xB,0
408:                      Init_Config();
  034C    2286    CALL	0x286
  034D    0873    LD	A,0x73
  034E    008A    LD	0xA,A
  034F    0872    LD	A,0x72
  0350    0084    LD	0x4,A
  0351    0E71    SWAPA	0x71
  0352    0083    LD	0x3,A
  0353    0EFE    SWAPR	0x7E
  0354    0E7E    SWAPA	0x7E
  0355    0009    RETI
409:                  }
410:              }
411:              
412:              
413:              
---- E:\project\project0508\scm\uf166fan\scankey.c ----------------------------------------------------------------------
1:                #include "scankey.h"
2:                
3:                void sacnKeyInput(struct Keys *key) {
  02EB    00C7    LD	0x47,A
4:                    key->key_input = getbit(key->key_addr_result, key->key_index);
  02EC    3E05    ADDIA	0x5
  02ED    0084    LD	0x4,A
  02EE    1383    CLRB	0x3,7
  02EF    0800    LD	A,0x0
  02F0    00F4    LD	0x74,A
  02F1    0847    LD	A,0x47
  02F2    3E06    ADDIA	0x6
  02F3    0084    LD	0x4,A
  02F4    0A00    INCA	0x0
  02F5    2AF8    JP	0x2F8
  02F6    1003    CLRB	0x3,0
  02F7    0CF4    RRCR	0x74
  02F8    3EFF    ADDIA	0xFF
  02F9    1D03    SNZB	0x3,2
  02FA    2AF6    JP	0x2F6
  02FB    0874    LD	A,0x74
  02FC    00F5    LD	0x75,A
  02FD    0847    LD	A,0x47
  02FE    3E04    ADDIA	0x4
  02FF    0084    LD	0x4,A
  0300    0875    LD	A,0x75
  0301    0080    LD	0x0,A
  0302    0847    LD	A,0x47
  0303    3E04    ADDIA	0x4
  0304    0084    LD	0x4,A
  0305    3001    LDIA	0x1
  0306    0580    ANDR	0x0
  0307    0008    RET
5:                
6:                }
7:                
8:                
9:                unsigned char key_driver(struct Keys *key) {
  014E    1283    CLRB	0x3,5
  014F    1303    CLRB	0x3,6
  0150    00C9    LD	0x49,A
10:               
11:               
12:                   unsigned char key_return = key_no;
  0151    01C7    CLR	0x47
13:                   unsigned char key_read = key->key_input;  //read the I/O states
  0152    3E04    ADDIA	0x4
  0153    0084    LD	0x4,A
  0154    1383    CLRB	0x3,7
  0155    0800    LD	A,0x0
  0156    00C8    LD	0x48,A
14:               
15:                   switch (key->key_state_buffer1) {
  0157    2983    JP	0x183
16:                       case key_state_0:
17:                           if (key_read == 0) {
  0158    0848    LD	A,0x48
  0159    1D03    SNZB	0x3,2
  015A    2990    JP	0x190
18:                               key->key_state_buffer1 = key_state_1;
  015B    0A49    INCA	0x49
  015C    0084    LD	0x4,A
  015D    0180    CLR	0x0
  015E    0A80    INCR	0x0
  015F    2990    JP	0x190
19:                           }
20:               
21:                           //按键被按下，状态转换到按键消抖和确认状态//
22:                           break;
23:               
24:                       case key_state_1:
25:                           if (key_read == 0) {
  0160    0848    LD	A,0x48
  0161    1D03    SNZB	0x3,2
  0162    297F    JP	0x17F
26:                               key->key_timer_cnt1 = 0;
  0163    0849    LD	A,0x49
  0164    0084    LD	0x4,A
  0165    0180    CLR	0x0
27:                               key->key_state_buffer1 = key_state_2;
  0166    0A49    INCA	0x49
  0167    0084    LD	0x4,A
  0168    3002    LDIA	0x2
  0169    297B    JP	0x17B
28:                               //按键仍然处于按下状态
29:                               //消抖完成，key_timer开始准备计时
30:                               //状态切换到按下时间计时状态
31:                           } else {
32:                               key->key_state_buffer1 = key_state_0;
33:                           }
34:               
35:                           //按键已经抬起，回到按键初始状态
36:                           break;  //完成软件消抖
37:               
38:                       case key_state_2:
39:                           if (key_read == 1) {
  016A    0B48    SZDECA	0x48
  016B    296F    JP	0x16F
40:                               key_return = key_click;  //按键抬起，产生一次click操作
  016C    01C7    CLR	0x47
  016D    0AC7    INCR	0x47
  016E    297F    JP	0x17F
41:                               key->key_state_buffer1 = key_state_0;  //转换到按键初始状态
  016F    0849    LD	A,0x49
  0170    0084    LD	0x4,A
  0171    3064    LDIA	0x64
  0172    0A80    INCR	0x0
  0173    0200    SUBA	0x0
  0174    1C03    SNZB	0x3,0
  0175    2990    JP	0x190
42:                           } else if (++(key->key_timer_cnt1) >= 100)  //按键继续按下，计时超过1000ms
43:                           {
44:                               key_return = key_long;  //送回长按事件
  0176    3003    LDIA	0x3
  0177    00C7    LD	0x47,A
45:                               key->key_state_buffer1 = key_state_3;  //转换到等待按键释放状态
  0178    0A49    INCA	0x49
  0179    0084    LD	0x4,A
  017A    3003    LDIA	0x3
  017B    0080    LD	0x0,A
  017C    2990    JP	0x190
46:               
47:                           }
48:                           break;
49:               
50:                       case key_state_3:  //等待按键释放
51:                           if (key_read == 1)  //按键释放
  017D    0B48    SZDECA	0x48
  017E    2990    JP	0x190
52:                           {
53:                               key->key_state_buffer1 = key_state_0;  //切回按键初始状态
  017F    0A49    INCA	0x49
  0180    0084    LD	0x4,A
  0181    0180    CLR	0x0
  0182    2990    JP	0x190
  0183    0A49    INCA	0x49
  0184    0084    LD	0x4,A
  0185    0800    LD	A,0x0
  0186    0084    LD	0x4,A
  0187    3004    LDIA	0x4
  0188    0204    SUBA	0x4
  0189    1803    SZB	0x3,0
  018A    2990    JP	0x190
  018B    3004    LDIA	0x4
  018C    008A    LD	0xA,A
  018D    3005    LDIA	0x5
  018E    0704    ADDA	0x4
  018F    0082    LD	0x2,A
54:                           }
55:               
56:                           break;
57:                   }
58:                   return key_return;
  0190    0847    LD	A,0x47
  0191    0008    RET
59:               }
60:               
61:               /***************************************************************************
62:               函数功能：中层按键处理函数，调用底层函数一次，处理双击事件的判断，
63:                                                       返回上层正确的无键、单击、双击、长按四种状态
64:               本函数由上层循环调用，间隔10ms
65:               ***************************************************************************/
66:               unsigned char key_read(struct Keys *key) {
67:               
68:                   unsigned char key_return = key_no;
69:                   unsigned char key_read = key_driver(key);
70:               //    printf("IO:%d  key status: %d\n",getSimpleKeyInput(key_input),key);
71:                   switch (key->key_state_buffer2) {
72:                       case key_state_0:
73:                           if (key_read == key_click) {
74:                               key->key_timer_cnt2 = 0;  //第一次单击，不返回，到下个状态判断是否会出现双击
75:                               key->key_state_buffer2 = key_state_1;
76:                           } else
77:                               key_return = key_read;  //对于无键、长按，返回原事件
78:                           break;
79:               
80:                       case key_state_1:
81:                           if (key_read == key_click)  //又一次单击，时间间隔小于500ms
82:                           {
83:                               key_return = key_double;  //返回双击事件，回到初始状态
84:                               key->key_state_buffer2 = key_state_0;
85:                           } else if (++(key->key_timer_cnt2) >= 50) {
86:                               //这里500ms内肯定读到的都是无键事件，因为长按大于1000ms
87:                               //在1s前底层返回的都是无键
88:               
89:                               key_return = key_click;  //500ms内没有再次出现单击事件，返回单击事件
90:                               key->key_state_buffer2 = key_state_0;  //返回初始状态
91:               
92:                           }
93:                           break;
94:                   }
95:               
96:                   return key_return;
97:               }
98:               
99:               
100:              void resetKey(struct Keys *key) {
  037A    00F4    LD	0x74,A
  039A    00F0    LD	0x70,A
101:                  key->key_timer_cnt1 = key->key_timer_cnt2 = key->key_state_buffer1 = key->key_state_buffer2 = 0;
  037B    3E03    ADDIA	0x3
  037C    0084    LD	0x4,A
  037D    1383    CLRB	0x3,7
  037E    0180    CLR	0x0
  037F    0A74    INCA	0x74
  0380    0084    LD	0x4,A
  0381    0180    CLR	0x0
  0382    0874    LD	A,0x74
  0383    3E02    ADDIA	0x2
  0384    0084    LD	0x4,A
  0385    0180    CLR	0x0
  0386    0874    LD	A,0x74
  0387    0084    LD	0x4,A
  0388    0180    CLR	0x0
  0389    0008    RET
  039B    3E03    ADDIA	0x3
  039C    0084    LD	0x4,A
  039D    1383    CLRB	0x3,7
  039E    0180    CLR	0x0
  039F    0A70    INCA	0x70
  03A0    0084    LD	0x4,A
  03A1    0180    CLR	0x0
  03A2    0870    LD	A,0x70
  03A3    3E02    ADDIA	0x2
  03A4    0084    LD	0x4,A
  03A5    0180    CLR	0x0
  03A6    0870    LD	A,0x70
  03A7    0084    LD	0x4,A
  03A8    0180    CLR	0x0
  03A9    0008    RET
102:              }
---- E:\project\project0508\scm\uf166fan\adc.c ----------------------------------------------------------------------
1:                #include "adc.h"
2:                
3:                /**********************************************************
4:                函数名称：AD_Sample
5:                函数功能：AD检测
6:                入口参数：adch - 检测通道
7:                出口参数：无 
8:                备    注：采样通道需自行设置为模拟口
9:                	      采样10次,取中间八次的平均值为采样结果存于adresult中
10:               **********************************************************/
11:               void ADC_Sample(unsigned char adch)
  001A    00CB    LD	0x4B,A
12:               {
13:               	static unsigned long adsum = 0;
14:               	static unsigned int admin = 0,admax = 0;
15:               	static unsigned char adtimes = 0;
16:               	volatile unsigned int ad_temp;
17:               	ADCON1 = 0;						//左对齐
  001B    1683    SETB	0x3,5
  001C    019F    CLR	0x1F
18:               	ADCON0 = 0X41 | (adch << 2);	//16分频
  001D    1283    CLRB	0x3,5
  001E    084B    LD	A,0x4B
  001F    00C7    LD	0x47,A
  0020    3001    LDIA	0x1
  0021    1003    CLRB	0x3,0
  0022    0DC7    RLCR	0x47
  0023    3EFF    ADDIA	0xFF
  0024    1003    CLRB	0x3,0
  0025    1D03    SNZB	0x3,2
  0026    2822    JP	0x22
  0027    0D47    RLCA	0x47
  0028    3841    ORIA	0x41
  0029    009F    LD	0x1F,A
  002A    0000    NOP
  002B    0000    NOP
19:               	asm("nop");
20:               	asm("nop");
21:               	GODONE = 1;						//开始转换
  002C    1283    CLRB	0x3,5
  002D    1303    CLRB	0x3,6
  002E    149F    SETB	0x1F,1
22:               
23:               	unsigned char i = 0;
  002F    01CC    CLR	0x4C
24:               	while(GODONE)
  0030    1C9F    SNZB	0x1F,1
  0031    2835    JP	0x35
25:               	{
26:               		if(0 == (--i))
  0032    0BCC    SZDECR	0x4C
  0033    2830    JP	0x30
  0034    0008    RET
27:               			return;
28:               	}
29:               	
30:               	ad_temp=(ADRESH<<4)+(ADRESL>>4);	//计算12位AD值
  0035    081E    LD	A,0x1E
  0036    00CD    LD	0x4D,A
  0037    01CE    CLR	0x4E
  0038    0ECD    SWAPR	0x4D
  0039    0ECE    SWAPR	0x4E
  003A    30F0    LDIA	0xF0
  003B    05CE    ANDR	0x4E
  003C    084D    LD	A,0x4D
  003D    390F    ANDIA	0xF
  003E    04CE    ORR	0x4E
  003F    30F0    LDIA	0xF0
  0040    05CD    ANDR	0x4D
  0041    1683    SETB	0x3,5
  0042    0E1E    SWAPA	0x1E
  0043    390F    ANDIA	0xF
  0044    1283    CLRB	0x3,5
  0045    07CD    ADDR	0x4D
  0046    1803    SZB	0x3,0
  0047    0ACE    INCR	0x4E
31:               	
32:               	if(0 == admax)
  0048    0824    LD	A,0x24
  0049    0425    ORA	0x25
  004A    1D03    SNZB	0x3,2
  004B    284E    JP	0x4E
33:               	{
34:               		admax = ad_temp;
  004C    20BF    CALL	0xBF
  004D    2860    JP	0x60
35:               		admin = ad_temp;
36:               	}
37:               	else if(ad_temp > admax)
  004E    084E    LD	A,0x4E
  004F    0225    SUBA	0x25
  0050    1D03    SNZB	0x3,2
  0051    2854    JP	0x54
  0052    084D    LD	A,0x4D
  0053    0224    SUBA	0x24
  0054    1803    SZB	0x3,0
  0055    2858    JP	0x58
38:               		admax = ad_temp;				//AD采样最大值
  0056    20BF    CALL	0xBF
  0057    2864    JP	0x64
39:               	else if(ad_temp < admin)
  0058    0827    LD	A,0x27
  0059    024E    SUBA	0x4E
  005A    1D03    SNZB	0x3,2
  005B    285E    JP	0x5E
  005C    0826    LD	A,0x26
  005D    024D    SUBA	0x4D
  005E    1803    SZB	0x3,0
  005F    2864    JP	0x64
40:               		admin = ad_temp;				//AD采样最小值
  0060    084E    LD	A,0x4E
  0061    00A7    LD	0x27,A
  0062    084D    LD	A,0x4D
  0063    00A6    LD	0x26,A
41:               	
42:               	adsum += ad_temp;
  0064    084D    LD	A,0x4D
  0065    00C7    LD	0x47,A
  0066    084E    LD	A,0x4E
  0067    00C8    LD	0x48,A
  0068    01C9    CLR	0x49
  0069    01CA    CLR	0x4A
  006A    0847    LD	A,0x47
  006B    07A0    ADDR	0x20
  006C    0848    LD	A,0x48
  006D    1103    CLRB	0x3,2
  006E    1803    SZB	0x3,0
  006F    3E01    ADDIA	0x1
  0070    1D03    SNZB	0x3,2
  0071    07A1    ADDR	0x21
  0072    0849    LD	A,0x49
  0073    1103    CLRB	0x3,2
  0074    1803    SZB	0x3,0
  0075    3E01    ADDIA	0x1
  0076    1D03    SNZB	0x3,2
  0077    07A2    ADDR	0x22
  0078    084A    LD	A,0x4A
  0079    1103    CLRB	0x3,2
  007A    1803    SZB	0x3,0
  007B    3E01    ADDIA	0x1
  007C    1D03    SNZB	0x3,2
  007D    07A3    ADDR	0x23
43:               	if(++adtimes >= 10)
  007E    300A    LDIA	0xA
  007F    0AB0    INCR	0x30
  0080    0230    SUBA	0x30
  0081    1C03    SNZB	0x3,0
  0082    0008    RET
44:               	{
45:               		adsum -= admax;
  0083    0824    LD	A,0x24
  0084    00C7    LD	0x47,A
  0085    0825    LD	A,0x25
  0086    20B0    CALL	0xB0
  0087    1C03    SNZB	0x3,0
  0088    0F4A    SZINCA	0x4A
  0089    02A3    SUBR	0x23
46:               		adsum -= admin;
  008A    0826    LD	A,0x26
  008B    00C7    LD	0x47,A
  008C    0827    LD	A,0x27
  008D    20B0    CALL	0xB0
  008E    1C03    SNZB	0x3,0
  008F    0F4A    SZINCA	0x4A
  0090    02A3    SUBR	0x23
47:               		
48:               		adresult = adsum >> 3;		//8次平均值作为最终结果
  0091    0820    LD	A,0x20
  0092    00C7    LD	0x47,A
  0093    0821    LD	A,0x21
  0094    00C8    LD	0x48,A
  0095    0822    LD	A,0x22
  0096    00C9    LD	0x49,A
  0097    0823    LD	A,0x23
  0098    00CA    LD	0x4A,A
  0099    3003    LDIA	0x3
  009A    1003    CLRB	0x3,0
  009B    0CCA    RRCR	0x4A
  009C    0CC9    RRCR	0x49
  009D    0CC8    RRCR	0x48
  009E    0CC7    RRCR	0x47
  009F    3EFF    ADDIA	0xFF
  00A0    1D03    SNZB	0x3,2
  00A1    289A    JP	0x9A
  00A2    0848    LD	A,0x48
  00A3    00AF    LD	0x2F,A
  00A4    0847    LD	A,0x47
  00A5    00AE    LD	0x2E,A
49:               		
50:               		adsum = 0;
  00A6    01A0    CLR	0x20
  00A7    01A1    CLR	0x21
  00A8    01A2    CLR	0x22
  00A9    01A3    CLR	0x23
51:               		admin = 0;
  00AA    01A6    CLR	0x26
  00AB    01A7    CLR	0x27
52:               		admax = 0;
  00AC    01A4    CLR	0x24
  00AD    01A5    CLR	0x25
53:               		adtimes = 0;
  00AE    01B0    CLR	0x30
  00AF    0008    RET
54:               	}
55:               }
56:               
57:               
58:               //ADC单次采样
59:               unsigned char ADC_Result(unsigned char adch)
  0308    00C7    LD	0x47,A
60:               {
61:               	ADCON1 = 0;						//左对齐
  0309    1683    SETB	0x3,5
  030A    019F    CLR	0x1F
62:               	ADCON0 = 0X41 | (adch << 2);	//16分频
  030B    1283    CLRB	0x3,5
  030C    0847    LD	A,0x47
  030D    00F4    LD	0x74,A
  030E    3001    LDIA	0x1
  030F    1003    CLRB	0x3,0
  0310    0DF4    RLCR	0x74
  0311    3EFF    ADDIA	0xFF
  0312    1003    CLRB	0x3,0
  0313    1D03    SNZB	0x3,2
  0314    2B10    JP	0x310
  0315    0D74    RLCA	0x74
  0316    3841    ORIA	0x41
  0317    009F    LD	0x1F,A
  0318    0000    NOP
  0319    0000    NOP
63:               	asm("nop");
64:               	asm("nop");
65:               	GODONE = 1;						//开始转换
  031A    1283    CLRB	0x3,5
  031B    1303    CLRB	0x3,6
  031C    149F    SETB	0x1F,1
66:               
67:               	unsigned char i = 0;
  031D    01C8    CLR	0x48
68:               	while(GODONE)
  031E    1C9F    SNZB	0x1F,1
  031F    2B23    JP	0x323
69:               	{
70:               		if(0 == (--i))
  0320    0BC8    SZDECR	0x48
  0321    2B1E    JP	0x31E
71:               			return 0;				//转换超时
  0322    3400    RET	0x0
72:               	}
73:               	return ADRESH;
  0323    081E    LD	A,0x1E
  0324    0008    RET
74:               }
75:               /***********************************************************
76:               函数名称：DelayXms
77:               函数功能：毫秒级非精准延时
78:               入口参数：x - 延时时间
79:               出口参数：
80:               备    注：
81:               ***********************************************************/
82:               void DelayXms(unsigned char x)
  03C6    00C7    LD	0x47,A
83:               {
84:               	unsigned char i,j;
85:               	for(i=x;i>0;i--)
  03C7    00C8    LD	0x48,A
  03C8    0848    LD	A,0x48
  03C9    1903    SZB	0x3,2
  03CA    0008    RET
86:               		for(j=153;j>0;j--);
  03CB    3099    LDIA	0x99
  03CC    00C9    LD	0x49,A
  03CD    0BC9    SZDECR	0x49
  03CE    2BCD    JP	0x3CD
  03CF    03C8    DECR	0x48
  03D0    2BC8    JP	0x3C8
87:               }
88:               
89:               //读取内部电压
90:               unsigned char readVrefADC()
91:               {
92:               	DelayXms(1);
  03EB    3001    LDIA	0x1
  03EC    23C6    CALL	0x3C6
93:               	ADC_Sample(15);
  03ED    300F    LDIA	0xF
  03EE    201A    CALL	0x1A
  03EF    300F    LDIA	0xF
  03F0    2B08    JP	0x308
94:               	unsigned char result;
95:               		
96:               	result = ADC_Result(15);
97:               	return result;
98:               }
---- E:\cms\SCMCU_IDE_V2.00.07\data\sources\common\awdiv.c ----------------------------------------------------------------------
1:                // integer signed division
2:                
3:                signed int
4:                #ifdef __PICC__
5:                #warning TODO: update cgpic and this file to use the other prototype
6:                __awdiv(signed int divisor, signed int dividend)
  0109    01CC    CLR	0x4C
  010A    1FC8    SNZB	0x48,7
  010B    2913    JP	0x113
  010C    09C7    COMR	0x47
  010D    09C8    COMR	0x48
  010E    0AC7    INCR	0x47
  010F    1903    SZB	0x3,2
  0110    0AC8    INCR	0x48
  0111    01CC    CLR	0x4C
  0112    0ACC    INCR	0x4C
  0113    1FCA    SNZB	0x4A,7
  0114    291C    JP	0x11C
  0115    09C9    COMR	0x49
  0116    09CA    COMR	0x4A
  0117    0AC9    INCR	0x49
  0118    1903    SZB	0x3,2
  0119    0ACA    INCR	0x4A
  011A    3001    LDIA	0x1
  011B    06CC    XORR	0x4C
  011C    01CD    CLR	0x4D
  011D    01CE    CLR	0x4E
  011E    0847    LD	A,0x47
  011F    0448    ORA	0x48
  0120    1903    SZB	0x3,2
  0121    2941    JP	0x141
  0122    01CB    CLR	0x4B
  0123    0ACB    INCR	0x4B
  0124    1BC8    SZB	0x48,7
  0125    292A    JP	0x12A
  0126    1003    CLRB	0x3,0
  0127    0DC7    RLCR	0x47
  0128    0DC8    RLCR	0x48
  0129    2923    JP	0x123
  012A    1003    CLRB	0x3,0
  012B    0DCD    RLCR	0x4D
  012C    0DCE    RLCR	0x4E
  012D    0848    LD	A,0x48
  012E    024A    SUBA	0x4A
  012F    1D03    SNZB	0x3,2
  0130    2933    JP	0x133
  0131    0847    LD	A,0x47
  0132    0249    SUBA	0x49
  0133    1C03    SNZB	0x3,0
  0134    293D    JP	0x13D
  0135    0847    LD	A,0x47
  0136    02C9    SUBR	0x49
  0137    0848    LD	A,0x48
  0138    1C03    SNZB	0x3,0
  0139    03CA    DECR	0x4A
  013A    02CA    SUBR	0x4A
  013B    144D    SETB	0x4D,0
  013C    1003    CLRB	0x3,0
  013D    0CC8    RRCR	0x48
  013E    0CC7    RRCR	0x47
  013F    0BCB    SZDECR	0x4B
  0140    292A    JP	0x12A
  0141    084C    LD	A,0x4C
  0142    1903    SZB	0x3,2
  0143    2949    JP	0x149
  0144    09CD    COMR	0x4D
  0145    09CE    COMR	0x4E
  0146    0ACD    INCR	0x4D
  0147    1903    SZB	0x3,2
  0148    0ACE    INCR	0x4E
  0149    084E    LD	A,0x4E
  014A    00C8    LD	0x48,A
  014B    084D    LD	A,0x4D
  014C    00C7    LD	0x47,A
  014D    0008    RET
7:                #else
8:                __awdiv(signed int dividend, signed int divisor)
9:                #endif
10:               {
11:               	signed int	quotient;
12:               	unsigned char	counter, sign;
13:               
14:               	sign = 0;
15:               	if(divisor < 0) {
16:               		divisor = -divisor;
17:               		sign = 1;
18:               	}
19:               	if(dividend < 0) {
20:               		dividend = -dividend;
21:               		sign ^= 1;
22:               	}
23:               	quotient = 0;
24:               	if(divisor != 0) {
25:               		counter = 1;
26:               		while((divisor & 0x8000U) == 0) {
27:               			divisor <<= 1;
28:               			counter++;
29:               		}
30:               		do {
31:               			quotient <<= 1;
32:               			if((unsigned int)divisor <= (unsigned int)dividend) {
33:               				dividend -= divisor;
34:               				quotient |= 1;
35:               			}
36:               			*(unsigned int *)&divisor >>= 1;
37:               		} while(--counter != 0);
38:               	}
39:               	if(sign)
40:               		quotient = -quotient;
41:               	return quotient;
42:               }
---- E:\project\project0508\scm\uf166fan\init.c ----------------------------------------------------------------------
1:                #include "init.h"
2:                
3:                void Init_System() {
  03D1    0000    NOP
  03D2    0064    CLRWDT
  03DA    0000    NOP
  03DB    0064    CLRWDT
4:                    asm("nop");
5:                    asm("clrwdt");
6:                    INTCON = 0;                    //系统初始化
  03D3    018B    CLR	0xB
  03DC    018B    CLR	0xB
7:                    OSCCON = 0X71;                //配置振荡为8M,开 WDT
  03D4    3071    LDIA	0x71
  03D5    1683    SETB	0x3,5
  03D6    1303    CLRB	0x3,6
  03D7    008F    LD	0xF,A
  03DD    3071    LDIA	0x71
  03DE    1683    SETB	0x3,5
  03DF    1303    CLRB	0x3,6
  03E0    008F    LD	0xF,A
8:                    OPTION_REG = 0x00;        //Timer0使用内部时钟Focs/4，预分频比为1:2
  03D8    0181    CLR	0x1
  03D9    0008    RET
  03E1    0181    CLR	0x1
  03E2    0008    RET
9:                
10:               }
11:               
12:               
13:               void Init_GPIO() {
14:                   TRISA = 0;
  0356    0185    CLR	0x5
  0368    0185    CLR	0x5
15:                   TRISB = 0;
  0357    0186    CLR	0x6
  0369    0186    CLR	0x6
16:                   TRISC = 0;
  0358    0187    CLR	0x7
  036A    0187    CLR	0x7
17:                   WPUA = 0xFF;
  0359    30FF    LDIA	0xFF
  035A    1703    SETB	0x3,6
  035B    008E    LD	0xE,A
  036B    30FF    LDIA	0xFF
  036C    1703    SETB	0x3,6
  036D    008E    LD	0xE,A
18:                   WPUB = 0xFF;
  035C    1303    CLRB	0x3,6
  035D    0095    LD	0x15,A
  036E    1303    CLRB	0x3,6
  036F    0095    LD	0x15,A
19:                   WPUC = 0xFF;
  035E    1703    SETB	0x3,6
  035F    008F    LD	0xF,A
  0370    1703    SETB	0x3,6
  0371    008F    LD	0xF,A
20:                   PORTA = 0xFF;
  0360    1283    CLRB	0x3,5
  0361    1303    CLRB	0x3,6
  0362    0085    LD	0x5,A
  0372    1283    CLRB	0x3,5
  0373    1303    CLRB	0x3,6
  0374    0085    LD	0x5,A
21:                   PORTB = 0xFF;
  0363    0086    LD	0x6,A
  0375    0086    LD	0x6,A
22:                   PORTC = 0xFF;
  0364    0087    LD	0x7,A
  0376    0087    LD	0x7,A
23:                   IOCB = 0x00;
  0365    1683    SETB	0x3,5
  0366    0196    CLR	0x16
  0367    0008    RET
  0377    1683    SETB	0x3,5
  0378    0196    CLR	0x16
  0379    0008    RET
24:               
25:               }
26:               
27:               void Init_Interupt() {
28:                   OPTION_REG = 0x00;        //Timer0使用内部时钟Focs/4，预分频比为1:2
  03F1    0181    CLR	0x1
  03F7    0181    CLR	0x1
29:                   TMR0 = 0;                //赋予初始值
  03F2    1283    CLRB	0x3,5
  03F3    0181    CLR	0x1
  03F8    1283    CLRB	0x3,5
  03F9    0181    CLR	0x1
30:                   INTCON = 0xE0;            //允许所有未被屏蔽的中断、禁止外设中断，使能Timer0
  03F4    30E0    LDIA	0xE0
  03F5    008B    LD	0xB,A
  03F6    0008    RET
  03FA    30E0    LDIA	0xE0
  03FB    008B    LD	0xB,A
  03FC    0008    RET
31:               
32:               }
---- stringtab ------------------------------------------------------------------
---- reset_enter ------------------------------------------------------------------
  0000    280C    JP	0xC
  000C    280D    JP	0xD
---- start_initialization ------------------------------------------------------------------
  000D    3002    LDIA	0x2
  000E    00F8    LD	0x78,A
  000F    3003    LDIA	0x3
  0010    00F9    LD	0x79,A
  0011    3020    LDIA	0x20
  0012    1383    CLRB	0x3,7
  0013    0084    LD	0x4,A
  0014    3047    LDIA	0x47
  0015    23E3    CALL	0x3E3
  0016    01F6    CLR	0x76
  0017    01F7    CLR	0x77
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F1    LD	0x71,A
  0007    0804    LD	A,0x4
  0008    00F2    LD	0x72,A
  0009    080A    LD	A,0xA
  000A    00F3    LD	0x73,A
  000B    2B40    JP	0x340
---- common_function ------------------------------------------------------------------
  0018    0183    CLR	0x3
  0019    2A34    JP	0x234
  00B0    00C8    LD	0x48,A
  00B1    01C9    CLR	0x49
  00B2    01CA    CLR	0x4A
  00B3    0847    LD	A,0x47
  00B4    02A0    SUBR	0x20
  00B5    0848    LD	A,0x48
  00B6    1C03    SNZB	0x3,0
  00B7    0F48    SZINCA	0x48
  00B8    02A1    SUBR	0x21
  00B9    0849    LD	A,0x49
  00BA    1C03    SNZB	0x3,0
  00BB    0F49    SZINCA	0x49
  00BC    02A2    SUBR	0x22
  00BD    084A    LD	A,0x4A
  00BE    0008    RET
  00BF    084E    LD	A,0x4E
  00C0    00A5    LD	0x25,A
  00C1    084D    LD	A,0x4D
  00C2    00A4    LD	0x24,A
  00C3    0008    RET
  00F9    082F    LD	A,0x2F
  00FA    00C8    LD	0x48,A
  00FB    082E    LD	A,0x2E
  00FC    00C7    LD	0x47,A
  00FD    3000    LDIA	0x0
  00FE    1003    CLRB	0x3,0
  00FF    0CC8    RRCR	0x48
  0100    0CC7    RRCR	0x47
  0101    1003    CLRB	0x3,0
  0102    0CC8    RRCR	0x48
  0103    0CC7    RRCR	0x47
  0104    1003    CLRB	0x3,0
  0105    0CC8    RRCR	0x48
  0106    0CC7    RRCR	0x47
  0107    0248    SUBA	0x48
  0108    0008    RET
  01FD    1683    SETB	0x3,5
  01FE    1087    CLRB	0x7,1
  01FF    1785    SETB	0x5,7
  0200    1007    CLRB	0x7,0
  0201    1283    CLRB	0x3,5
  0202    1385    CLRB	0x5,7
  0203    0008    RET
  0204    1683    SETB	0x3,5
  0205    1407    SETB	0x7,0
  0206    1385    CLRB	0x5,7
  0207    1087    CLRB	0x7,1
  0208    1283    CLRB	0x3,5
  0209    0008    RET
  03E3    0064    CLRWDT
  03E4    0180    CLR	0x0
  03E5    0A84    INCR	0x4
  03E6    0604    XORA	0x4
  03E7    1903    SZB	0x3,2
  03E8    3400    RET	0x0
  03E9    0604    XORA	0x4
  03EA    2BE4    JP	0x3E4
  0400    29D3    JP	0x1D3
  0401    29D7    JP	0x1D7
  0402    29DB    JP	0x1DB
  0403    29E0    JP	0x1E0
  0404    29E5    JP	0x1E5
  0405    2958    JP	0x158
  0406    2960    JP	0x160
  0407    296A    JP	0x16A
  0408    297D    JP	0x17D
