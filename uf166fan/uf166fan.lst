---- E:\project\scm\uf166fan\main.c ----------------------------------------------------------------------
1:                #include "scankey.h"
2:                #include "init.h"
3:                
4:                #define MAX_FAN_LEVEL 4
5:                #define MIN_FAN_LEVEL 1
6:                
7:                #define FAN_STATUS_OFF  0
8:                #define FAN_STATUS_ON  1
9:                #define FAN_STATUS_NONE 2
10:               
11:               #define PBPORTB PORTA
12:               #define PBTRISB TRISA
13:               
14:               #define LED_1  1
15:               #define LED_2  2
16:               #define LED_3  3
17:               #define LED_4  4
18:               //1毫秒中断标志
19:               static unsigned char time0Flag = 0;
20:               static unsigned int countTime = 0;
21:               static unsigned int count10Ms = 0;
22:               unsigned char currentLevel = 3;
23:               //风扇状态
24:               unsigned char FAN_STATUS = FAN_STATUS_NONE;
25:               //检测风扇次数
26:               unsigned int fan_check_time = 0;
27:               //按键结构体
28:               struct Keys key1, key2, key3;
29:               //显示风扇挡位
30:               void setLedOn(unsigned char ledIndex);
31:               //初始化配置
32:               void Init_Config();
33:               //睡眠模式
34:               void Sleep_Mode();
35:               
36:               void checkUsbStatus() {
37:                   if (getbit(PORTB, 2) == 1) {
  01BE    0806    LD	A,0x6
  01BF    00F4    LD	0x74,A
  01C0    1003    CLRB	0x3,0
  01C1    0CF4    RRCR	0x74
  01C2    1003    CLRB	0x3,0
  01C3    0CF4    RRCR	0x74
  01C4    1C74    SNZB	0x74,0
  01C5    29D8    JP	0x1D8
38:                       if (getbit(PORTB, 1) == 1) {
  01C6    0806    LD	A,0x6
  01C7    00F4    LD	0x74,A
  01C8    1003    CLRB	0x3,0
  01C9    0CF4    RRCR	0x74
  01CA    1C74    SNZB	0x74,0
  01CB    29CE    JP	0x1CE
39:                           //充满了，Led常亮
40:                           resetbit(PORTA, 0);
  01CC    1005    CLRB	0x5,0
41:                       } else if (countTime == 1000) {
  01CD    0008    RET
  01CE    30E8    LDIA	0xE8
  01CF    0622    XORA	0x22
  01D0    3003    LDIA	0x3
  01D1    1903    SZB	0x3,2
  01D2    0623    XORA	0x23
  01D3    1D03    SNZB	0x3,2
  01D4    0008    RET
42:                           //充电中，一直闪		
43:                           reversebit(PORTA, 0);
  01D5    3001    LDIA	0x1
  01D6    0685    XORR	0x5
  01D7    0008    RET
44:                       }
45:                   } else {
46:                       //usb断开充电灯熄灭,PA0 = 1
47:                       setbit(PORTA, 0);
  01D8    1405    SETB	0x5,0
  01D9    0008    RET
48:                   }
49:               }
50:               
51:               void Init_PWM() {
52:                   CCP1CON = 0x0F;//设置PC2为PWM模式，4,5位为占空比的低2位
  0223    300F    LDIA	0xF
  0224    1283    CLRB	0x3,5
  027D    300F    LDIA	0xF
53:                   T2CON = 0; //时钟分频 1:1 PWM周期为（PR2+1）*4/8,000,000
54:                   PR2 = 7;
55:               
56:                   CCPR1L = 0;//占空比高8位，低2位设置为0，结果就是 占空比 = CCPR1L*4/4*(PR2+1)
57:                   TMR2IF = 0;
58:                   T2CON = 0;
59:                   //PC2设置为输出脚
60:                   resetbit(TRISC, 2);
  0225    2A26    JP	0x226
  027E    2A26    JP	0x226
61:                   //T2CON = 0X04 //启动定时器2，溢出后启动PWM
62:               }
63:               
64:               //设置风扇转速
65:               void setFanLevel(char level) {
  00A2    00C2    LD	0x42,A
66:               	if(level == 0)
  00A3    0842    LD	A,0x42
  00A4    1D03    SNZB	0x3,2
  00A5    28A8    JP	0xA8
67:               	{
68:               		currentLevel = 3;
  00A6    3003    LDIA	0x3
  00A7    00F9    LD	0x79,A
69:               	}
70:                   unsigned int levelWidth = (PR2 + 1) / MAX_FAN_LEVEL;
  00A8    1683    SETB	0x3,5
  00A9    0812    LD	A,0x12
  00AA    1283    CLRB	0x3,5
  00AB    00BC    LD	0x3C,A
  00AC    01BD    CLR	0x3D
  00AD    0ABC    INCR	0x3C
  00AE    1903    SZB	0x3,2
  00AF    0ABD    INCR	0x3D
  00B0    3004    LDIA	0x4
  00B1    00BA    LD	0x3A,A
  00B2    01BB    CLR	0x3B
  00B3    201A    CALL	0x1A
71:                   char tempLevel = currentLevel + level;
  00B4    0842    LD	A,0x42
  00B5    0779    ADDA	0x79
  00B6    00C3    LD	0x43,A
72:                   if (tempLevel > MAX_FAN_LEVEL) {
  00B7    3005    LDIA	0x5
  00B8    0243    SUBA	0x43
  00B9    1C03    SNZB	0x3,0
  00BA    28BD    JP	0xBD
73:                       tempLevel = MAX_FAN_LEVEL;
  00BB    3004    LDIA	0x4
  00BC    00C3    LD	0x43,A
74:                   }
75:               
76:                   if (tempLevel < MIN_FAN_LEVEL) {
  00BD    0843    LD	A,0x43
  00BE    1D03    SNZB	0x3,2
  00BF    28C2    JP	0xC2
77:                       tempLevel = MIN_FAN_LEVEL;
  00C0    01C3    CLR	0x43
  00C1    0AC3    INCR	0x43
78:                   }
79:               	
80:                   
81:                   if (FAN_STATUS == FAN_STATUS_ON) {
  00C2    0B78    SZDECA	0x78
  00C3    0008    RET
82:               		currentLevel = tempLevel;
  00C4    0843    LD	A,0x43
  00C5    00F9    LD	0x79,A
83:               		switch(currentLevel)
  00C6    28D0    JP	0xD0
84:               		{
85:               			case 1:
86:               			CCPR1L = 1;
  00C7    3001    LDIA	0x1
  00C8    28CE    JP	0xCE
87:               			break;
88:               			case 2:
89:               			CCPR1L = 2;
  00C9    3002    LDIA	0x2
  00CA    28CE    JP	0xCE
90:               			break;
91:               			case 3:
92:               			CCPR1L = 3;
  00CB    3003    LDIA	0x3
  00CC    28CE    JP	0xCE
93:               			break;
94:               			case 4:
95:               			CCPR1L = 5;
  00CD    3005    LDIA	0x5
  00CE    0095    LD	0x15,A
96:               			break;
  00CF    28DE    JP	0xDE
  00D0    0879    LD	A,0x79
  00D1    3A01    XORIA	0x1
  00D2    1903    SZB	0x3,2
  00D3    28C7    JP	0xC7
  00D4    3A03    XORIA	0x3
  00D5    1903    SZB	0x3,2
  00D6    28C9    JP	0xC9
  00D7    3A01    XORIA	0x1
  00D8    1903    SZB	0x3,2
  00D9    28CB    JP	0xCB
  00DA    3A07    XORIA	0x7
  00DB    1903    SZB	0x3,2
  00DC    28CD    JP	0xCD
  00DD    28DE    JP	0xDE
97:               		}
98:                   //设置占宽比
99:               		//CCPR1L = levelWidth * currentLevel;
100:                      setLedOn(currentLevel);
  00DE    0879    LD	A,0x79
  00DF    28E0    JP	0xE0
101:                  }
102:              
103:              }
104:              
105:              //关闭风扇
106:              void closeFan() {
107:                  Init_PWM();
  0240    2223    CALL	0x223
108:                  currentLevel = 2;
  0241    3002    LDIA	0x2
  0242    00F9    LD	0x79,A
109:                  setLedOn(5);
  0243    3005    LDIA	0x5
  0244    20E0    CALL	0xE0
110:                  setbit(PORTA, 0);
  0245    1283    CLRB	0x3,5
  0246    1405    SETB	0x5,0
111:                  //PWM输出脚设置为输入，关闭PWM
112:                  setbit(TRISC, 2);
  0247    1683    SETB	0x3,5
  0248    1507    SETB	0x7,2
113:                  fan_check_time = 0;
  0249    01F6    CLR	0x76
  024A    01F7    CLR	0x77
114:                  FAN_STATUS = FAN_STATUS_OFF;
  024B    01F8    CLR	0x78
  024C    0008    RET
115:                  //Sleep_Mode();
116:              }
117:              
118:              
119:              //检测风扇是否连接
120:              void checkFan() {
121:              	resetbit(TRISA, 1);
  0119    1683    SETB	0x3,5
  011A    1085    CLRB	0x5,1
122:                  setbit(PORTA, 1);
  011B    1283    CLRB	0x3,5
  011C    1485    SETB	0x5,1
123:                  //PC2设置为输出脚
124:                  resetbit(TRISC, 2);
  011D    1683    SETB	0x3,5
  011E    1107    CLRB	0x7,2
125:              	setbit(PORTA, 2);
  011F    1283    CLRB	0x3,5
  0120    1505    SETB	0x5,2
126:                  T2CON = 0X04; //启动定时器2，溢出后启动PWM
  0121    3004    LDIA	0x4
  0122    0092    LD	0x12,A
127:              
128:                  //EN IN输出高电位，D1点亮，检测FAN DET，FAN DET为低电位则风扇正常工作，高电位则未连接
129:                  if (getbit(PORTB, 6) == 0) {
  0123    0806    LD	A,0x6
  0124    00F5    LD	0x75,A
  0125    3006    LDIA	0x6
  0126    1003    CLRB	0x3,0
  0127    0CF5    RRCR	0x75
  0128    3EFF    ADDIA	0xFF
  0129    1D03    SNZB	0x3,2
  012A    2926    JP	0x126
  012B    1875    SZB	0x75,0
  012C    2930    JP	0x130
130:                      FAN_STATUS = FAN_STATUS_ON;
  012D    01F8    CLR	0x78
  012E    0AF8    INCR	0x78
131:                  } else {
  012F    2932    JP	0x132
132:                      FAN_STATUS = FAN_STATUS_NONE;
  0130    3002    LDIA	0x2
  0131    00F8    LD	0x78,A
133:                  }
134:              	
135:              	setFanLevel(0);
  0132    3000    LDIA	0x0
  0133    20A2    CALL	0xA2
136:              
137:                  //没有检测到风扇
138:                  if (FAN_STATUS == FAN_STATUS_NONE) {
  0134    3002    LDIA	0x2
  0135    0678    XORA	0x78
  0136    1D03    SNZB	0x3,2
  0137    0008    RET
139:                      fan_check_time++;
  0138    0AF6    INCR	0x76
  0139    1903    SZB	0x3,2
  013A    0AF7    INCR	0x77
140:                      if (fan_check_time == 3000) {
  013B    30B8    LDIA	0xB8
  013C    0676    XORA	0x76
  013D    300B    LDIA	0xB
  013E    1903    SZB	0x3,2
  013F    0677    XORA	0x77
  0140    1D03    SNZB	0x3,2
  0141    0008    RET
141:                          closeFan();
  0142    2A40    JP	0x240
142:                          return;
143:                      }
144:                  }
145:              
146:              
147:              }
148:              
149:              
150:              //设置Led灯亮
151:              void setLedOn(unsigned char ledIndex) {
  00E0    00F4    LD	0x74,A
152:                  switch(ledIndex) {
  00E1    28FD    JP	0xFD
153:                      case 1:
154:                          //PB7设置为输入脚,PC1和PC0设置为输出
155:              			resetbit(TRISC, 1);
156:              			setbit(PBTRISB, 7);
157:                          resetbit(TRISC, 0);
158:                          resetbit(PBPORTB, 7);
  00E2    210C    CALL	0x10C
159:                          setbit(PORTC, 0);
  00E3    1407    SETB	0x7,0
160:                          resetbit(PORTC, 1);            
  00E4    1087    CLRB	0x7,1
161:                          break;
  00E5    0008    RET
162:                      case 2:
163:              			resetbit(TRISC, 1);
164:              			setbit(PBTRISB, 7);
165:                          resetbit(TRISC, 0);
166:              			resetbit(PBPORTB, 7);
  00E6    210C    CALL	0x10C
167:                          resetbit(PORTC, 0);
  00E7    1007    CLRB	0x7,0
168:                          setbit(PORTC, 1);
  00E8    1487    SETB	0x7,1
169:                          break;
  00E9    0008    RET
170:                      case 3:
171:                          //PC0设置为输入脚，PB7和PC1设置为输出
172:              			setbit(TRISC, 0);
173:              			resetbit(PBTRISB, 7);
174:                          resetbit(TRISC, 1);
175:                          setbit(PBPORTB, 7);
  00EA    2113    CALL	0x113
  00EB    1785    SETB	0x5,7
176:                          resetbit(PORTC, 0);
  00EC    1007    CLRB	0x7,0
177:                          resetbit(PORTC, 1);
  00ED    1087    CLRB	0x7,1
178:                          break;
  00EE    0008    RET
179:                      case 4:
180:              			setbit(TRISC, 0);
181:              			resetbit(PBTRISB, 7);
182:                          resetbit(TRISC, 1);
183:                          resetbit(PBPORTB, 7);
  00EF    2113    CALL	0x113
  00F0    1385    CLRB	0x5,7
184:                          setbit(PORTC, 0);
  00F1    1407    SETB	0x7,0
185:                          setbit(PORTC, 1);
  00F2    1487    SETB	0x7,1
186:                          break;
  00F3    0008    RET
187:                      case 5:
188:                          //全部设置为输入脚
189:              			setbit(TRISC, 0);
  00F4    1683    SETB	0x3,5
  00F5    1407    SETB	0x7,0
190:              			setbit(PBTRISB, 7);
  00F6    1785    SETB	0x5,7
191:                          setbit(TRISC, 1);
  00F7    1487    SETB	0x7,1
192:              			resetbit(PORTC, 0);
  00F8    1283    CLRB	0x3,5
  00F9    1007    CLRB	0x7,0
193:              			resetbit(PBPORTB, 7);
  00FA    1385    CLRB	0x5,7
194:                          resetbit(PORTC, 1);
  00FB    1087    CLRB	0x7,1
195:                          break;
  00FC    0008    RET
  00FD    0874    LD	A,0x74
  00FE    3EFF    ADDIA	0xFF
  00FF    1C03    SNZB	0x3,0
  0100    0008    RET
  0101    0084    LD	0x4,A
  0102    3005    LDIA	0x5
  0103    0204    SUBA	0x4
  0104    1803    SZB	0x3,0
  0105    0008    RET
  0106    3002    LDIA	0x2
  0107    008A    LD	0xA,A
  0108    3071    LDIA	0x71
  0109    0704    ADDA	0x4
  010A    0082    LD	0x2,A
  010B    0008    RET
196:                  }
197:              }
198:              
199:              
200:              //扫描按键
201:              void scanKeys() {
202:                  key1.key_addr_result = key2.key_addr_result = key3.key_addr_result = PORTB;
  0232    0806    LD	A,0x6
  0233    00AA    LD	0x2A,A
  0234    00B1    LD	0x31,A
  0235    00B8    LD	0x38,A
203:                  sacnKeyInput(&key1);
  0236    3033    LDIA	0x33
  0237    21A1    CALL	0x1A1
204:                  sacnKeyInput(&key2);
  0238    302C    LDIA	0x2C
  0239    21A1    CALL	0x1A1
205:                  sacnKeyInput(&key3);
  023A    3025    LDIA	0x25
  023B    21A1    CALL	0x1A1
206:                  countTime++;
  023C    0AA2    INCR	0x22
  023D    1903    SZB	0x3,2
  023E    0AA3    INCR	0x23
  023F    0008    RET
207:                 
208:              }
209:              
210:              //检测按键状态并处理
211:              void checkKeys() {
212:                  if (key_driver(&key1) == key_click) {
  0183    3033    LDIA	0x33
  0184    205F    CALL	0x5F
  0185    3A01    XORIA	0x1
  0186    1D03    SNZB	0x3,2
  0187    298E    JP	0x18E
213:                      //检测到按键了，检测风扇是否存在
214:              
215:                      if (FAN_STATUS == FAN_STATUS_ON) {
  0188    0B78    SZDECA	0x78
  0189    298B    JP	0x18B
216:                          //关闭风扇
217:                          closeFan();
  018A    2A40    JP	0x240
218:                      } else {
219:                          FAN_STATUS = FAN_STATUS_NONE;
  018B    3002    LDIA	0x2
  018C    00F8    LD	0x78,A
220:                          checkFan();
  018D    2919    JP	0x119
  018E    3002    LDIA	0x2
  018F    0678    XORA	0x78
  0190    1D03    SNZB	0x3,2
  0191    2993    JP	0x193
221:                      }
222:                      return;
223:                  } else if (FAN_STATUS == FAN_STATUS_NONE) {
224:                      checkFan();
  0192    2119    CALL	0x119
225:                  }
226:              
227:              	unsigned char key2Status = key_driver(&key2);
  0193    302C    LDIA	0x2C
  0194    205F    CALL	0x5F
  0195    00C4    LD	0x44,A
228:                  if (key2Status == key_click) {
  0196    0B44    SZDECA	0x44
  0197    299A    JP	0x19A
229:                      //加档
230:                      setFanLevel(1);
  0198    3001    LDIA	0x1
  0199    28A2    JP	0xA2
231:                      return;
232:                  }
233:              	unsigned char key3Status = key_driver(&key3);
  019A    3025    LDIA	0x25
  019B    205F    CALL	0x5F
  019C    00C5    LD	0x45,A
234:                  if (key3Status == key_click) {
  019D    0B45    SZDECA	0x45
  019E    0008    RET
235:                      //减档
236:                      setFanLevel(-1);
  019F    30FF    LDIA	0xFF
  01A0    28A2    JP	0xA2
237:                      return;
238:                  }
239:              
240:              }
241:              
242:              
243:              void main(void) {
244:                  Init_Config();
  0143    2164    CALL	0x164
245:                  while (1) {
246:                      //0.1毫秒检测一次
247:                      if (time0Flag) {
  0144    1283    CLRB	0x3,5
  0145    0824    LD	A,0x24
  0146    1903    SZB	0x3,2
  0147    2950    JP	0x150
  0148    0064    CLRWDT
248:                          asm("clrwdt");
249:                          time0Flag = 0;
  0149    1283    CLRB	0x3,5
  014A    1303    CLRB	0x3,6
  014B    01A4    CLR	0x24
250:              			scanKeys();
  014C    2232    CALL	0x232
251:                          count10Ms++;
  014D    0AA0    INCR	0x20
  014E    1903    SZB	0x3,2
  014F    0AA1    INCR	0x21
252:                      }
253:              
254:                      //10毫秒检测一次
255:                      if (count10Ms == 100) {		
  0150    3064    LDIA	0x64
  0151    0620    XORA	0x20
  0152    0421    ORA	0x21
  0153    1D03    SNZB	0x3,2
  0154    295A    JP	0x15A
256:                          checkKeys();
  0155    2183    CALL	0x183
257:                          count10Ms = 0;
  0156    1283    CLRB	0x3,5
  0157    01A0    CLR	0x20
  0158    01A1    CLR	0x21
258:                          //检测USB状态
259:                          checkUsbStatus();
  0159    21BE    CALL	0x1BE
260:                      }
261:              
262:                      if (countTime == 1000) {
  015A    30E8    LDIA	0xE8
  015B    0622    XORA	0x22
  015C    3003    LDIA	0x3
  015D    1903    SZB	0x3,2
  015E    0623    XORA	0x23
  015F    1D03    SNZB	0x3,2
  0160    2944    JP	0x144
263:                          countTime = 0;
  0161    01A2    CLR	0x22
  0162    01A3    CLR	0x23
  0163    2944    JP	0x144
264:                      }
265:              		
266:                  }
267:              
268:              }
269:              
270:              void Init_Config() {
271:              
272:                  Init_System();
  0164    227A    CALL	0x27A
  024D    2258    CALL	0x258
273:                  Init_GPIO();
  0165    21F0    CALL	0x1F0
  024E    2280    CALL	0x280
274:                  Init_Interupt();
  0166    226A    CALL	0x26A
  024F    227F    CALL	0x27F
275:                  Init_PWM();
  0167    2223    CALL	0x223
  0250    227D    CALL	0x27D
276:                  //设置唤醒
277:                  IOCB = 0x04;
278:                  TMR0 = 155;
279:                  TO = 0;
280:              
281:                  //K1开关
282:                  key1.key_index = 5;
283:                  //K2加档
284:                  key2.key_index = 4;
285:                  //K3减档
286:                  key3.key_index = 3;
287:                  resetKey(&key1);
  0168    216F    CALL	0x16F
  0169    2203    CALL	0x203
  0251    216F    CALL	0x16F
  0252    2213    CALL	0x213
288:                  resetKey(&key2);
  016A    302C    LDIA	0x2C
  016B    2203    CALL	0x203
  0253    302C    LDIA	0x2C
  0254    2213    CALL	0x213
289:                  resetKey(&key3);
  016C    3025    LDIA	0x25
  016D    2203    CALL	0x203
  0255    3025    LDIA	0x25
  0256    2213    CALL	0x213
290:                  //设置IO方向
291:                  TRISA = 0;
292:                  TRISB = 0x7E;//1-6脚输入
293:                  TRISC = 0;
  016E    297C    JP	0x17C
  0257    297C    JP	0x17C
294:              }
295:              
296:              
297:              void Sleep_Mode() {
298:                  INTCON = 0;
299:              
300:                  OPTION_REG = 0;
301:              
302:                  TRISA = 0B00000000;        //关闭所有输出
303:                  PORTA = 0B00000000;
304:                  WPUA = 0B00000000;
305:              
306:                  TRISB = 0B00100000;
307:                  PORTB = 0B00000000;
308:              
309:                  PORTB = 0;
310:                  WPUB = 0B00100000;         //RB3 上拉
311:              
312:                  IOCB = 0B00100000;            //允许RB3的IO口电平变化中断
313:                  RBIE = 1;                    //允许PORTB电平变化中断
314:                  GIE = 1;                    //GIE = 0时，唤醒后执行SLEEP后程序;GIE = 1时，唤醒后跳至中断服务
315:              
316:                  ADCON0 = 0;                    //关闭所有模块
317:              
318:                  OSCCON = 0X70;                //配置振荡为16M,关闭WDT
319:              
320:                  PORTB;                        //读PORTB值并锁存			
321:                  asm("clrwdt");
322:              
323:                  asm("sleep");                //进入休眠模式
324:              
325:                  asm("nop");
326:              
327:              
328:              }
329:              
330:              
331:              /***********************************************
332:              函数名称：Timer0_Isr
333:              函数功能：中断服务
334:              入口参数：无
335:              出口参数：无
336:              备注：
337:              ***********************************************/
338:              void interrupt
339:              
340:              Timer0_Isr() {
341:                  if (T0IF) {
  01DA    1D0B    SNZB	0xB,2
  01DB    29E3    JP	0x1E3
342:                      //---------------------------------------
343:                      TMR0 += 155;        //重新赋初值，在赋值前Timer0已有计数，故在该基础上加初值
  01DC    309B    LDIA	0x9B
  01DD    1283    CLRB	0x3,5
  01DE    1303    CLRB	0x3,6
  01DF    0781    ADDR	0x1
344:                      //---------------------------------------
345:              
346:                      T0IF = 0;            //清中断标志位	
  01E0    110B    CLRB	0xB,2
347:                      time0Flag = 1;
  01E1    01A4    CLR	0x24
  01E2    0AA4    INCR	0x24
348:              
349:                  }
350:              
351:                  if (RBIF) {
  01E3    1C0B    SNZB	0xB,0
  01E4    29E7    JP	0x1E7
352:                      RBIF = 0;            //清中断标志
  01E5    100B    CLRB	0xB,0
353:                      Init_Config();
  01E6    224D    CALL	0x24D
  01E7    0873    LD	A,0x73
  01E8    008A    LD	0xA,A
  01E9    0872    LD	A,0x72
  01EA    0084    LD	0x4,A
  01EB    0E71    SWAPA	0x71
  01EC    0083    LD	0x3,A
  01ED    0EFE    SWAPR	0x7E
  01EE    0E7E    SWAPA	0x7E
  01EF    0009    RETI
354:                  }
355:              }
356:              
357:              
358:              
---- E:\project\scm\uf166fan\scankey.c ----------------------------------------------------------------------
1:                #include "scankey.h"
2:                
3:                void sacnKeyInput(struct Keys *key) {
  01A1    00BA    LD	0x3A,A
4:                    key->key_input = getbit(key->key_addr_result, key->key_index);
  01A2    3E05    ADDIA	0x5
  01A3    0084    LD	0x4,A
  01A4    1383    CLRB	0x3,7
  01A5    0800    LD	A,0x0
  01A6    00F4    LD	0x74,A
  01A7    083A    LD	A,0x3A
  01A8    3E06    ADDIA	0x6
  01A9    0084    LD	0x4,A
  01AA    0A00    INCA	0x0
  01AB    29AE    JP	0x1AE
  01AC    1003    CLRB	0x3,0
  01AD    0CF4    RRCR	0x74
  01AE    3EFF    ADDIA	0xFF
  01AF    1D03    SNZB	0x3,2
  01B0    29AC    JP	0x1AC
  01B1    0874    LD	A,0x74
  01B2    00F5    LD	0x75,A
  01B3    083A    LD	A,0x3A
  01B4    3E04    ADDIA	0x4
  01B5    0084    LD	0x4,A
  01B6    0875    LD	A,0x75
  01B7    0080    LD	0x0,A
  01B8    083A    LD	A,0x3A
  01B9    3E04    ADDIA	0x4
  01BA    0084    LD	0x4,A
  01BB    3001    LDIA	0x1
  01BC    0580    ANDR	0x0
  01BD    0008    RET
5:                
6:                }
7:                
8:                
9:                unsigned char key_driver(struct Keys *key) {
  005F    1283    CLRB	0x3,5
  0060    00BC    LD	0x3C,A
10:               
11:               
12:                   unsigned char key_return = key_no;
  0061    01BA    CLR	0x3A
13:                   unsigned char key_read = key->key_input;  //read the I/O states
  0062    3E04    ADDIA	0x4
  0063    0084    LD	0x4,A
  0064    1383    CLRB	0x3,7
  0065    0800    LD	A,0x0
  0066    00BB    LD	0x3B,A
14:               
15:                   switch (key->key_state_buffer1) {
  0067    2893    JP	0x93
16:                       case key_state_0:
17:                           if (key_read == 0) {
  0068    083B    LD	A,0x3B
  0069    1D03    SNZB	0x3,2
  006A    28A0    JP	0xA0
18:                               key->key_state_buffer1 = key_state_1;
  006B    0A3C    INCA	0x3C
  006C    0084    LD	0x4,A
  006D    0180    CLR	0x0
  006E    0A80    INCR	0x0
  006F    28A0    JP	0xA0
19:                           }
20:               
21:                           //按键被按下，状态转换到按键消抖和确认状态//
22:                           break;
23:               
24:                       case key_state_1:
25:                           if (key_read == 0) {
  0070    083B    LD	A,0x3B
  0071    1D03    SNZB	0x3,2
  0072    288F    JP	0x8F
26:                               key->key_timer_cnt1 = 0;
  0073    083C    LD	A,0x3C
  0074    0084    LD	0x4,A
  0075    0180    CLR	0x0
27:                               key->key_state_buffer1 = key_state_2;
  0076    0A3C    INCA	0x3C
  0077    0084    LD	0x4,A
  0078    3002    LDIA	0x2
  0079    288B    JP	0x8B
28:                               //按键仍然处于按下状态
29:                               //消抖完成，key_timer开始准备计时
30:                               //状态切换到按下时间计时状态
31:                           } else {
32:                               key->key_state_buffer1 = key_state_0;
33:                           }
34:               
35:                           //按键已经抬起，回到按键初始状态
36:                           break;  //完成软件消抖
37:               
38:                       case key_state_2:
39:                           if (key_read == 1) {
  007A    0B3B    SZDECA	0x3B
  007B    287F    JP	0x7F
40:                               key_return = key_click;  //按键抬起，产生一次click操作
  007C    01BA    CLR	0x3A
  007D    0ABA    INCR	0x3A
  007E    288F    JP	0x8F
41:                               key->key_state_buffer1 = key_state_0;  //转换到按键初始状态
  007F    083C    LD	A,0x3C
  0080    0084    LD	0x4,A
  0081    3064    LDIA	0x64
  0082    0A80    INCR	0x0
  0083    0200    SUBA	0x0
  0084    1C03    SNZB	0x3,0
  0085    28A0    JP	0xA0
42:                           } else if (++(key->key_timer_cnt1) >= 100)  //按键继续按下，计时超过1000ms
43:                           {
44:                               key_return = key_long;  //送回长按事件
  0086    3003    LDIA	0x3
  0087    00BA    LD	0x3A,A
45:                               key->key_state_buffer1 = key_state_3;  //转换到等待按键释放状态
  0088    0A3C    INCA	0x3C
  0089    0084    LD	0x4,A
  008A    3003    LDIA	0x3
  008B    0080    LD	0x0,A
  008C    28A0    JP	0xA0
46:               
47:                           }
48:                           break;
49:               
50:                       case key_state_3:  //等待按键释放
51:                           if (key_read == 1)  //按键释放
  008D    0B3B    SZDECA	0x3B
  008E    28A0    JP	0xA0
52:                           {
53:                               key->key_state_buffer1 = key_state_0;  //切回按键初始状态
  008F    0A3C    INCA	0x3C
  0090    0084    LD	0x4,A
  0091    0180    CLR	0x0
  0092    28A0    JP	0xA0
  0093    0A3C    INCA	0x3C
  0094    0084    LD	0x4,A
  0095    0800    LD	A,0x0
  0096    0084    LD	0x4,A
  0097    3004    LDIA	0x4
  0098    0204    SUBA	0x4
  0099    1803    SZB	0x3,0
  009A    28A0    JP	0xA0
  009B    3002    LDIA	0x2
  009C    008A    LD	0xA,A
  009D    3076    LDIA	0x76
  009E    0704    ADDA	0x4
  009F    0082    LD	0x2,A
54:                           }
55:               
56:                           break;
57:                   }
58:                   return key_return;
  00A0    083A    LD	A,0x3A
  00A1    0008    RET
59:               }
60:               
61:               /***************************************************************************
62:               函数功能：中层按键处理函数，调用底层函数一次，处理双击事件的判断，
63:                                                       返回上层正确的无键、单击、双击、长按四种状态
64:               本函数由上层循环调用，间隔10ms
65:               ***************************************************************************/
66:               unsigned char key_read(struct Keys *key) {
67:               
68:                   unsigned char key_return = key_no;
69:                   unsigned char key_read = key_driver(key);
70:               //    printf("IO:%d  key status: %d\n",getSimpleKeyInput(key_input),key);
71:                   switch (key->key_state_buffer2) {
72:                       case key_state_0:
73:                           if (key_read == key_click) {
74:                               key->key_timer_cnt2 = 0;  //第一次单击，不返回，到下个状态判断是否会出现双击
75:                               key->key_state_buffer2 = key_state_1;
76:                           } else
77:                               key_return = key_read;  //对于无键、长按，返回原事件
78:                           break;
79:               
80:                       case key_state_1:
81:                           if (key_read == key_click)  //又一次单击，时间间隔小于500ms
82:                           {
83:                               key_return = key_double;  //返回双击事件，回到初始状态
84:                               key->key_state_buffer2 = key_state_0;
85:                           } else if (++(key->key_timer_cnt2) >= 50) {
86:                               //这里500ms内肯定读到的都是无键事件，因为长按大于1000ms
87:                               //在1s前底层返回的都是无键
88:               
89:                               key_return = key_click;  //500ms内没有再次出现单击事件，返回单击事件
90:                               key->key_state_buffer2 = key_state_0;  //返回初始状态
91:               
92:                           }
93:                           break;
94:                   }
95:               
96:                   return key_return;
97:               }
98:               
99:               
100:              void resetKey(struct Keys *key) {
  0203    00F4    LD	0x74,A
  0213    00F0    LD	0x70,A
101:                  key->key_timer_cnt1 = key->key_timer_cnt2 = key->key_state_buffer1 = key->key_state_buffer2 = 0;
  0204    3E03    ADDIA	0x3
  0205    0084    LD	0x4,A
  0206    1383    CLRB	0x3,7
  0207    0180    CLR	0x0
  0208    0A74    INCA	0x74
  0209    0084    LD	0x4,A
  020A    0180    CLR	0x0
  020B    0874    LD	A,0x74
  020C    3E02    ADDIA	0x2
  020D    0084    LD	0x4,A
  020E    0180    CLR	0x0
  020F    0874    LD	A,0x74
  0210    0084    LD	0x4,A
  0211    0180    CLR	0x0
  0212    0008    RET
  0214    3E03    ADDIA	0x3
  0215    0084    LD	0x4,A
  0216    1383    CLRB	0x3,7
  0217    0180    CLR	0x0
  0218    0A70    INCA	0x70
  0219    0084    LD	0x4,A
  021A    0180    CLR	0x0
  021B    0870    LD	A,0x70
  021C    3E02    ADDIA	0x2
  021D    0084    LD	0x4,A
  021E    0180    CLR	0x0
  021F    0870    LD	A,0x70
  0220    0084    LD	0x4,A
  0221    0180    CLR	0x0
  0222    0008    RET
102:              }
---- E:\cms\SCMCU_IDE_V2.00.07\data\sources\common\awdiv.c ----------------------------------------------------------------------
1:                // integer signed division
2:                
3:                signed int
4:                #ifdef __PICC__
5:                #warning TODO: update cgpic and this file to use the other prototype
6:                __awdiv(signed int divisor, signed int dividend)
  001A    01BF    CLR	0x3F
  001B    1FBB    SNZB	0x3B,7
  001C    2824    JP	0x24
  001D    09BA    COMR	0x3A
  001E    09BB    COMR	0x3B
  001F    0ABA    INCR	0x3A
  0020    1903    SZB	0x3,2
  0021    0ABB    INCR	0x3B
  0022    01BF    CLR	0x3F
  0023    0ABF    INCR	0x3F
  0024    1FBD    SNZB	0x3D,7
  0025    282D    JP	0x2D
  0026    09BC    COMR	0x3C
  0027    09BD    COMR	0x3D
  0028    0ABC    INCR	0x3C
  0029    1903    SZB	0x3,2
  002A    0ABD    INCR	0x3D
  002B    3001    LDIA	0x1
  002C    06BF    XORR	0x3F
  002D    01C0    CLR	0x40
  002E    01C1    CLR	0x41
  002F    083A    LD	A,0x3A
  0030    043B    ORA	0x3B
  0031    1903    SZB	0x3,2
  0032    2852    JP	0x52
  0033    01BE    CLR	0x3E
  0034    0ABE    INCR	0x3E
  0035    1BBB    SZB	0x3B,7
  0036    283B    JP	0x3B
  0037    1003    CLRB	0x3,0
  0038    0DBA    RLCR	0x3A
  0039    0DBB    RLCR	0x3B
  003A    2834    JP	0x34
  003B    1003    CLRB	0x3,0
  003C    0DC0    RLCR	0x40
  003D    0DC1    RLCR	0x41
  003E    083B    LD	A,0x3B
  003F    023D    SUBA	0x3D
  0040    1D03    SNZB	0x3,2
  0041    2844    JP	0x44
  0042    083A    LD	A,0x3A
  0043    023C    SUBA	0x3C
  0044    1C03    SNZB	0x3,0
  0045    284E    JP	0x4E
  0046    083A    LD	A,0x3A
  0047    02BC    SUBR	0x3C
  0048    083B    LD	A,0x3B
  0049    1C03    SNZB	0x3,0
  004A    03BD    DECR	0x3D
  004B    02BD    SUBR	0x3D
  004C    1440    SETB	0x40,0
  004D    1003    CLRB	0x3,0
  004E    0CBB    RRCR	0x3B
  004F    0CBA    RRCR	0x3A
  0050    0BBE    SZDECR	0x3E
  0051    283B    JP	0x3B
  0052    083F    LD	A,0x3F
  0053    1903    SZB	0x3,2
  0054    285A    JP	0x5A
  0055    09C0    COMR	0x40
  0056    09C1    COMR	0x41
  0057    0AC0    INCR	0x40
  0058    1903    SZB	0x3,2
  0059    0AC1    INCR	0x41
  005A    0841    LD	A,0x41
  005B    00BB    LD	0x3B,A
  005C    0840    LD	A,0x40
  005D    00BA    LD	0x3A,A
  005E    0008    RET
7:                #else
8:                __awdiv(signed int dividend, signed int divisor)
9:                #endif
10:               {
11:               	signed int	quotient;
12:               	unsigned char	counter, sign;
13:               
14:               	sign = 0;
15:               	if(divisor < 0) {
16:               		divisor = -divisor;
17:               		sign = 1;
18:               	}
19:               	if(dividend < 0) {
20:               		dividend = -dividend;
21:               		sign ^= 1;
22:               	}
23:               	quotient = 0;
24:               	if(divisor != 0) {
25:               		counter = 1;
26:               		while((divisor & 0x8000U) == 0) {
27:               			divisor <<= 1;
28:               			counter++;
29:               		}
30:               		do {
31:               			quotient <<= 1;
32:               			if((unsigned int)divisor <= (unsigned int)dividend) {
33:               				dividend -= divisor;
34:               				quotient |= 1;
35:               			}
36:               			*(unsigned int *)&divisor >>= 1;
37:               		} while(--counter != 0);
38:               	}
39:               	if(sign)
40:               		quotient = -quotient;
41:               	return quotient;
42:               }
---- E:\project\scm\uf166fan\init.c ----------------------------------------------------------------------
1:                #include "init.h"
2:                
3:                void Init_System() {
  0258    0000    NOP
  0259    0064    CLRWDT
  027A    0000    NOP
  027B    0064    CLRWDT
4:                    asm("nop");
5:                    asm("clrwdt");
6:                    INTCON = 0;                    //系统初始化
7:                    OSCCON = 0X71;                //配置振荡为8M,开 WDT
8:                    OPTION_REG = 0x00;        //Timer0使用内部时钟Focs/4，预分频比为1:2
  025A    2A5B    JP	0x25B
  027C    2A5B    JP	0x25B
9:                
10:               }
11:               
12:               
13:               void Init_GPIO() {
14:                   TRISA = 0;
15:                   TRISB = 0;
16:                   TRISC = 0;
17:                   WPUA = 0xFF;
18:                   WPUB = 0xFF;
19:                   WPUC = 0xFF;
20:                   PORTA = 0xFF;
21:                   PORTB = 0xFF;
22:                   PORTC = 0xFF;
23:                   IOCB = 0x00;
  01F0    29F1    JP	0x1F1
  0280    29F1    JP	0x1F1
24:               
25:               }
26:               
27:               void Init_Interupt() {
28:                   OPTION_REG = 0x00;        //Timer0使用内部时钟Focs/4，预分频比为1:2
29:                   TMR0 = 0;                //赋予初始值
30:                   INTCON = 0xE0;            //允许所有未被屏蔽的中断、禁止外设中断，使能Timer0
  026A    2A6B    JP	0x26B
  027F    2A6B    JP	0x26B
31:               
32:               }
---- stringtab ------------------------------------------------------------------
---- reset_enter ------------------------------------------------------------------
  0000    280C    JP	0xC
  000C    280D    JP	0xD
---- start_initialization ------------------------------------------------------------------
  000D    3002    LDIA	0x2
  000E    00F8    LD	0x78,A
  000F    3003    LDIA	0x3
  0010    00F9    LD	0x79,A
  0011    3020    LDIA	0x20
  0012    1383    CLRB	0x3,7
  0013    0084    LD	0x4,A
  0014    303A    LDIA	0x3A
  0015    2262    CALL	0x262
  0016    01F6    CLR	0x76
  0017    01F7    CLR	0x77
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F1    LD	0x71,A
  0007    0804    LD	A,0x4
  0008    00F2    LD	0x72,A
  0009    080A    LD	A,0xA
  000A    00F3    LD	0x73,A
  000B    29DA    JP	0x1DA
---- common_function ------------------------------------------------------------------
  0018    0183    CLR	0x3
  0019    2943    JP	0x143
  010C    1683    SETB	0x3,5
  010D    1087    CLRB	0x7,1
  010E    1785    SETB	0x5,7
  010F    1007    CLRB	0x7,0
  0110    1283    CLRB	0x3,5
  0111    1385    CLRB	0x5,7
  0112    0008    RET
  0113    1683    SETB	0x3,5
  0114    1407    SETB	0x7,0
  0115    1385    CLRB	0x5,7
  0116    1087    CLRB	0x7,1
  0117    1283    CLRB	0x3,5
  0118    0008    RET
  016F    3004    LDIA	0x4
  0170    0096    LD	0x16,A
  0171    309B    LDIA	0x9B
  0172    1283    CLRB	0x3,5
  0173    0081    LD	0x1,A
  0174    1203    CLRB	0x3,4
  0175    3005    LDIA	0x5
  0176    00B9    LD	0x39,A
  0177    3004    LDIA	0x4
  0178    00B2    LD	0x32,A
  0179    3003    LDIA	0x3
  017A    00AB    LD	0x2B,A
  017B    3433    RET	0x33
  017C    1683    SETB	0x3,5
  017D    1303    CLRB	0x3,6
  017E    0185    CLR	0x5
  017F    307E    LDIA	0x7E
  0180    0086    LD	0x6,A
  0181    0187    CLR	0x7
  0182    0008    RET
  01F1    0185    CLR	0x5
  01F2    0186    CLR	0x6
  01F3    0187    CLR	0x7
  01F4    30FF    LDIA	0xFF
  01F5    1703    SETB	0x3,6
  01F6    008E    LD	0xE,A
  01F7    1303    CLRB	0x3,6
  01F8    0095    LD	0x15,A
  01F9    1703    SETB	0x3,6
  01FA    008F    LD	0xF,A
  01FB    1283    CLRB	0x3,5
  01FC    1303    CLRB	0x3,6
  01FD    0085    LD	0x5,A
  01FE    0086    LD	0x6,A
  01FF    0087    LD	0x7,A
  0200    1683    SETB	0x3,5
  0201    0196    CLR	0x16
  0202    0008    RET
  0226    0097    LD	0x17,A
  0227    0192    CLR	0x12
  0228    3007    LDIA	0x7
  0229    1683    SETB	0x3,5
  022A    0092    LD	0x12,A
  022B    1283    CLRB	0x3,5
  022C    0195    CLR	0x15
  022D    108C    CLRB	0xC,1
  022E    0192    CLR	0x12
  022F    1683    SETB	0x3,5
  0230    1107    CLRB	0x7,2
  0231    0008    RET
  025B    018B    CLR	0xB
  025C    3071    LDIA	0x71
  025D    1683    SETB	0x3,5
  025E    1303    CLRB	0x3,6
  025F    008F    LD	0xF,A
  0260    0181    CLR	0x1
  0261    0008    RET
  0262    0064    CLRWDT
  0263    0180    CLR	0x0
  0264    0A84    INCR	0x4
  0265    0604    XORA	0x4
  0266    1903    SZB	0x3,2
  0267    3400    RET	0x0
  0268    0604    XORA	0x4
  0269    2A63    JP	0x263
  026B    0181    CLR	0x1
  026C    1283    CLRB	0x3,5
  026D    0181    CLR	0x1
  026E    30E0    LDIA	0xE0
  026F    008B    LD	0xB,A
  0270    0008    RET
  0271    28E2    JP	0xE2
  0272    28E6    JP	0xE6
  0273    28EA    JP	0xEA
  0274    28EF    JP	0xEF
  0275    28F4    JP	0xF4
  0276    2868    JP	0x68
  0277    2870    JP	0x70
  0278    287A    JP	0x7A
  0279    288D    JP	0x8D
