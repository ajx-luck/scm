---- C:\SCMCU WorkSpace\uf166fan\main.c ----------------------------------------------------------------------
1:                #include "scankey.h"
2:                #include "init.h"
3:                
4:                #define MAX_FAN_LEVEL 4
5:                #define MIN_FAN_LEVEL 1
6:                
7:                #define FAN_STATUS_OFF  0
8:                #define FAN_STATUS_ON  1
9:                #define FAN_STATUS_NONE 2
10:               
11:               #define PBPORTB PORTB
12:               #define PBTRISB TRISB
13:               
14:               #define LED_1  1
15:               #define LED_2  2
16:               #define LED_3  3
17:               #define LED_4  4
18:               //1毫秒中断标志
19:               static unsigned char time0Flag = 0;
20:               static unsigned int countTime = 0;
21:               static unsigned int count10Ms = 0;
22:               unsigned char currentLevel = 2;
23:               //风扇状态
24:               unsigned char FAN_STATUS = FAN_STATUS_NONE;
25:               //检测风扇次数
26:               unsigned int fan_check_time = 0;
27:               //按键结构体
28:               struct Keys key1, key2, key3;
29:               //显示风扇挡位
30:               void setLedOn(unsigned char ledIndex);
31:               //初始化配置
32:               void Init_Config();
33:               //睡眠模式
34:               void Sleep_Mode();
35:               
36:               void checkUsbStatus() {
37:                   if (getbit(PORTB, 2) == 1) {
  01BF    0806    LD	A,0x6
  01C0    00F4    LD	0x74,A
  01C1    1003    CLRB	0x3,0
  01C2    0CF4    RRCR	0x74
  01C3    1003    CLRB	0x3,0
  01C4    0CF4    RRCR	0x74
  01C5    1C74    SNZB	0x74,0
  01C6    29D9    JP	0x1D9
38:                       if (getbit(PORTB, 1) == 1) {
  01C7    0806    LD	A,0x6
  01C8    00F4    LD	0x74,A
  01C9    1003    CLRB	0x3,0
  01CA    0CF4    RRCR	0x74
  01CB    1C74    SNZB	0x74,0
  01CC    29CF    JP	0x1CF
39:                           //充满了，Led常亮
40:                           resetbit(PORTA, 0);
  01CD    1005    CLRB	0x5,0
41:                       } else if (countTime == 1000) {
  01CE    0008    RET
  01CF    30E8    LDIA	0xE8
  01D0    0677    XORA	0x77
  01D1    3003    LDIA	0x3
  01D2    1903    SZB	0x3,2
  01D3    0678    XORA	0x78
  01D4    1D03    SNZB	0x3,2
  01D5    0008    RET
42:                           //充电中，一直闪		
43:                           reversebit(PORTA, 0);
  01D6    3001    LDIA	0x1
  01D7    0685    XORR	0x5
  01D8    0008    RET
44:                       }
45:                   } else {
46:                       //usb断开充电灯熄灭,PA0 = 1
47:                       setbit(PORTA, 0);
  01D9    1405    SETB	0x5,0
  01DA    0008    RET
48:                   }
49:               }
50:               
51:               void Init_PWM() {
52:                   CCP1CON = 0x0F;//设置PC2为PWM模式，4,5位为占空比的低2位
53:                   T2CON = 0; //时钟分频 1:1 PWM周期为（PR2+1）*4/8,000,000
54:                   PR2 = 7;
55:               
56:                   CCPR1L = 0;//占空比高8位，低2位设置为0，结果就是 占空比 = CCPR1L*4/4*(PR2+1)
57:                   TMR2IF = 0;
58:                   T2CON = 0;
59:                   //PC2设置为输出脚
60:                   resetbit(TRISC, 2);
  0270    2A71    JP	0x271
  02AE    2A71    JP	0x271
61:                   //T2CON = 0X04 //启动定时器2，溢出后启动PWM
62:               }
63:               
64:               //设置风扇转速
65:               void setFanLevel(char level) {
  010F    00C3    LD	0x43,A
66:               	if(level == 0)
  0110    0843    LD	A,0x43
  0111    1D03    SNZB	0x3,2
  0112    2915    JP	0x115
67:               	{
68:               		currentLevel = 2;
  0113    3002    LDIA	0x2
  0114    00C7    LD	0x47,A
69:               	}
70:                   unsigned int levelWidth = (PR2 + 1) / MAX_FAN_LEVEL;
  0115    1683    SETB	0x3,5
  0116    0812    LD	A,0x12
  0117    1283    CLRB	0x3,5
  0118    00BB    LD	0x3B,A
  0119    01BC    CLR	0x3C
  011A    0ABB    INCR	0x3B
  011B    1903    SZB	0x3,2
  011C    0ABC    INCR	0x3C
  011D    3004    LDIA	0x4
  011E    00B9    LD	0x39,A
  011F    01BA    CLR	0x3A
  0120    201A    CALL	0x1A
  0121    083A    LD	A,0x3A
  0122    00C2    LD	0x42,A
  0123    0839    LD	A,0x39
  0124    00C1    LD	0x41,A
71:                   char tempLevel = currentLevel + level;
  0125    0843    LD	A,0x43
  0126    0747    ADDA	0x47
  0127    00C4    LD	0x44,A
72:                   if (tempLevel > MAX_FAN_LEVEL) {
  0128    3005    LDIA	0x5
  0129    0244    SUBA	0x44
  012A    1C03    SNZB	0x3,0
  012B    292E    JP	0x12E
73:                       tempLevel = MAX_FAN_LEVEL;
  012C    3004    LDIA	0x4
  012D    00C4    LD	0x44,A
74:                   }
75:               
76:                   if (tempLevel < MIN_FAN_LEVEL) {
  012E    0844    LD	A,0x44
  012F    1D03    SNZB	0x3,2
  0130    2933    JP	0x133
77:                       tempLevel = MIN_FAN_LEVEL;
  0131    01C4    CLR	0x44
  0132    0AC4    INCR	0x44
78:                   }
79:                   
80:                   if (FAN_STATUS == FAN_STATUS_ON) {
  0133    0B46    SZDECA	0x46
  0134    0008    RET
81:               		currentLevel = tempLevel;
  0135    0844    LD	A,0x44
  0136    00C7    LD	0x47,A
82:                   //设置占宽比
83:               		CCPR1L = levelWidth * currentLevel;
  0137    0841    LD	A,0x41
  0138    00F4    LD	0x74,A
  0139    0847    LD	A,0x47
  013A    2254    CALL	0x254
  013B    0095    LD	0x15,A
84:                       setLedOn(currentLevel);
  013C    0847    LD	A,0x47
  013D    28A1    JP	0xA1
85:                   }
86:               
87:               }
88:               
89:               //关闭风扇
90:               void closeFan() {
91:                   Init_PWM();
  0262    2270    CALL	0x270
92:                   currentLevel = 2;
  0263    3002    LDIA	0x2
  0264    1283    CLRB	0x3,5
  0265    00C7    LD	0x47,A
93:                   setLedOn(5);
  0266    3005    LDIA	0x5
  0267    20A1    CALL	0xA1
94:                   setbit(PORTA, 0);
  0268    1405    SETB	0x5,0
95:                   //PWM输出脚设置为输入，关闭PWM
96:                   setbit(TRISC, 2);
  0269    1683    SETB	0x3,5
  026A    1507    SETB	0x7,2
97:                   fan_check_time = 0;
  026B    1283    CLRB	0x3,5
  026C    01A0    CLR	0x20
  026D    01A1    CLR	0x21
98:                   FAN_STATUS = FAN_STATUS_OFF;
  026E    01C6    CLR	0x46
  026F    0008    RET
99:                   //Sleep_Mode();
100:              }
101:              
102:              
103:              //检测风扇是否连接
104:              void checkFan() {
105:              
106:                  setbit(PORTA, 1);
  013E    1485    SETB	0x5,1
107:                  //PC2设置为输出脚
108:                  resetbit(TRISC, 2);
  013F    1683    SETB	0x3,5
  0140    1107    CLRB	0x7,2
109:              	setbit(PORTA, 2);
  0141    1283    CLRB	0x3,5
  0142    1505    SETB	0x5,2
110:                  T2CON = 0X04; //启动定时器2，溢出后启动PWM
  0143    3004    LDIA	0x4
  0144    0092    LD	0x12,A
111:              
112:                  //EN IN输出高电位，D1点亮，检测FAN DET，FAN DET为低电位则风扇正常工作，高电位则未连接
113:                  if (getbit(PORTB, 6) == 0) {
  0145    0806    LD	A,0x6
  0146    00C5    LD	0x45,A
  0147    3006    LDIA	0x6
  0148    1003    CLRB	0x3,0
  0149    0CC5    RRCR	0x45
  014A    3EFF    ADDIA	0xFF
  014B    1D03    SNZB	0x3,2
  014C    2948    JP	0x148
  014D    1845    SZB	0x45,0
  014E    2952    JP	0x152
114:                      FAN_STATUS = FAN_STATUS_ON;
  014F    01C6    CLR	0x46
  0150    0AC6    INCR	0x46
115:                  } else {
  0151    2954    JP	0x154
116:                      FAN_STATUS = FAN_STATUS_NONE;
  0152    3002    LDIA	0x2
  0153    00C6    LD	0x46,A
117:                  }
118:              	
119:              	setFanLevel(0);
  0154    3000    LDIA	0x0
  0155    210F    CALL	0x10F
120:              
121:                  //没有检测到风扇
122:                  if (FAN_STATUS == FAN_STATUS_NONE) {
  0156    3002    LDIA	0x2
  0157    0646    XORA	0x46
  0158    1D03    SNZB	0x3,2
  0159    0008    RET
123:                      fan_check_time++;
  015A    0AA0    INCR	0x20
  015B    1903    SZB	0x3,2
  015C    0AA1    INCR	0x21
124:                      if (fan_check_time == 3000) {
  015D    30B8    LDIA	0xB8
  015E    0620    XORA	0x20
  015F    300B    LDIA	0xB
  0160    1903    SZB	0x3,2
  0161    0621    XORA	0x21
  0162    1D03    SNZB	0x3,2
  0163    0008    RET
125:                          closeFan();
  0164    2A62    JP	0x262
126:                          return;
127:                      }
128:                  }
129:              
130:              
131:              }
132:              
133:              
134:              //设置Led灯亮
135:              void setLedOn(unsigned char ledIndex) {
  00A1    00F4    LD	0x74,A
136:                  switch(ledIndex) {
  00A2    28BE    JP	0xBE
137:                      case 1:
138:                          //PB7设置为输入脚,PC1和PC0设置为输出
139:              			resetbit(TRISC, 1);
140:              			setbit(PBTRISB, 7);
141:                          resetbit(TRISC, 0);
142:                          resetbit(PBPORTB, 7);
  00A3    20CD    CALL	0xCD
143:                          setbit(PORTC, 0);
  00A4    1407    SETB	0x7,0
144:                          resetbit(PORTC, 1);            
  00A5    1087    CLRB	0x7,1
145:                          break;
  00A6    0008    RET
146:                      case 2:
147:              			resetbit(TRISC, 1);
148:              			setbit(PBTRISB, 7);
149:                          resetbit(TRISC, 0);
150:              			resetbit(PBPORTB, 7);
  00A7    20CD    CALL	0xCD
151:                          resetbit(PORTC, 0);
  00A8    1007    CLRB	0x7,0
152:                          setbit(PORTC, 1);
  00A9    1487    SETB	0x7,1
153:                          break;
  00AA    0008    RET
154:                      case 3:
155:                          //PC0设置为输入脚，PB7和PC1设置为输出
156:              			setbit(TRISC, 0);
157:              			resetbit(PBTRISB, 7);
158:                          resetbit(TRISC, 1);
159:                          setbit(PBPORTB, 7);
  00AB    20D4    CALL	0xD4
  00AC    1786    SETB	0x6,7
160:                          resetbit(PORTC, 0);
  00AD    1007    CLRB	0x7,0
161:                          resetbit(PORTC, 1);
  00AE    1087    CLRB	0x7,1
162:                          break;
  00AF    0008    RET
163:                      case 4:
164:              			setbit(TRISC, 0);
165:              			resetbit(PBTRISB, 7);
166:                          resetbit(TRISC, 1);
167:                          resetbit(PBPORTB, 7);
  00B0    20D4    CALL	0xD4
  00B1    1386    CLRB	0x6,7
168:                          setbit(PORTC, 0);
  00B2    1407    SETB	0x7,0
169:                          setbit(PORTC, 1);
  00B3    1487    SETB	0x7,1
170:                          break;
  00B4    0008    RET
171:                      case 5:
172:                          //全部设置为输入脚
173:              			setbit(TRISC, 0);
  00B5    1683    SETB	0x3,5
  00B6    1407    SETB	0x7,0
174:              			setbit(PBTRISB, 7);
  00B7    1786    SETB	0x6,7
175:                          setbit(TRISC, 1);
  00B8    1487    SETB	0x7,1
176:              			resetbit(PORTC, 0);
  00B9    1283    CLRB	0x3,5
  00BA    1007    CLRB	0x7,0
177:              			resetbit(PBPORTB, 7);
  00BB    1386    CLRB	0x6,7
178:                          resetbit(PORTC, 1);
  00BC    1087    CLRB	0x7,1
179:                          break;
  00BD    0008    RET
  00BE    0874    LD	A,0x74
  00BF    3EFF    ADDIA	0xFF
  00C0    1C03    SNZB	0x3,0
  00C1    0008    RET
  00C2    0084    LD	0x4,A
  00C3    3005    LDIA	0x5
  00C4    0204    SUBA	0x4
  00C5    1803    SZB	0x3,0
  00C6    0008    RET
  00C7    3002    LDIA	0x2
  00C8    008A    LD	0xA,A
  00C9    30A2    LDIA	0xA2
  00CA    0704    ADDA	0x4
  00CB    0082    LD	0x2,A
  00CC    0008    RET
180:                  }
181:              }
182:              
183:              
184:              //扫描按键
185:              void scanKeys() {
186:                  key1.key_addr_result = key2.key_addr_result = key3.key_addr_result = PORTB;
  020C    1283    CLRB	0x3,5
  020D    1303    CLRB	0x3,6
  020E    0806    LD	A,0x6
  020F    00A9    LD	0x29,A
  0210    00B0    LD	0x30,A
  0211    00B7    LD	0x37,A
187:                  sacnKeyInput(&key1);
  0212    3032    LDIA	0x32
  0213    21A2    CALL	0x1A2
188:                  sacnKeyInput(&key2);
  0214    302B    LDIA	0x2B
  0215    21A2    CALL	0x1A2
189:                  sacnKeyInput(&key3);
  0216    3024    LDIA	0x24
  0217    21A2    CALL	0x1A2
190:                  countTime++;
  0218    0AF7    INCR	0x77
  0219    1903    SZB	0x3,2
  021A    0AF8    INCR	0x78
191:                  count10Ms++;
  021B    1283    CLRB	0x3,5
  021C    1303    CLRB	0x3,6
  021D    0AA2    INCR	0x22
  021E    1903    SZB	0x3,2
  021F    0AA3    INCR	0x23
  0220    0008    RET
192:              }
193:              
194:              //检测按键状态并处理
195:              void checkKeys() {
196:                  if (key_read(&key1) != key_no) {
  0184    3032    LDIA	0x32
  0185    20DA    CALL	0xDA
  0186    3A00    XORIA	0x0
  0187    1903    SZB	0x3,2
  0188    298F    JP	0x18F
197:                      //检测到按键了，检测风扇是否存在
198:              
199:                      if (FAN_STATUS == FAN_STATUS_ON) {
  0189    0B46    SZDECA	0x46
  018A    298C    JP	0x18C
200:                          //关闭风扇
201:                          closeFan();
  018B    2A62    JP	0x262
202:                      } else {
203:                          FAN_STATUS = FAN_STATUS_NONE;
  018C    3002    LDIA	0x2
  018D    00C6    LD	0x46,A
204:                          checkFan();
  018E    293E    JP	0x13E
  018F    3002    LDIA	0x2
  0190    0646    XORA	0x46
  0191    1D03    SNZB	0x3,2
  0192    2994    JP	0x194
205:                      }
206:                      return;
207:                  } else if (FAN_STATUS == FAN_STATUS_NONE) {
208:                      checkFan();
  0193    213E    CALL	0x13E
209:                  }
210:              
211:              
212:                  if (key_read(&key2) != key_no) {
  0194    302B    LDIA	0x2B
  0195    20DA    CALL	0xDA
  0196    3A00    XORIA	0x0
  0197    1903    SZB	0x3,2
  0198    299B    JP	0x19B
213:                      //加档
214:                      setFanLevel(1);
  0199    3001    LDIA	0x1
  019A    290F    JP	0x10F
215:                      return;
216:                  }
217:              
218:                  if (key_read(&key3) != key_no) {
  019B    3024    LDIA	0x24
  019C    20DA    CALL	0xDA
  019D    3A00    XORIA	0x0
  019E    1903    SZB	0x3,2
  019F    0008    RET
219:                      //减档
220:                      setFanLevel(-1);
  01A0    30FF    LDIA	0xFF
  01A1    290F    JP	0x10F
221:                      return;
222:                  }
223:              
224:              }
225:              
226:              
227:              void main(void) {
228:                  Init_Config();
  01DB    2165    CALL	0x165
229:                  while (1) {
230:                      //1毫秒检测一次
231:                      if (time0Flag) {
  01DC    0879    LD	A,0x79
  01DD    1903    SZB	0x3,2
  01DE    29E2    JP	0x1E2
  01DF    0064    CLRWDT
232:                          asm("clrwdt");
233:                          time0Flag = 0;
  01E0    01F9    CLR	0x79
234:                          scanKeys();
  01E1    220C    CALL	0x20C
235:                      }
236:              
237:                      //10毫秒检测一次
238:                      if (count10Ms == 10) {
  01E2    300A    LDIA	0xA
  01E3    1283    CLRB	0x3,5
  01E4    0622    XORA	0x22
  01E5    0423    ORA	0x23
  01E6    1D03    SNZB	0x3,2
  01E7    29EC    JP	0x1EC
239:                          checkKeys();
  01E8    2184    CALL	0x184
240:                          count10Ms = 0;
  01E9    01A2    CLR	0x22
  01EA    01A3    CLR	0x23
241:                          //检测USB状态
242:                          checkUsbStatus();
  01EB    21BF    CALL	0x1BF
243:                      }
244:              
245:                      if (countTime == 1000) {
  01EC    30E8    LDIA	0xE8
  01ED    0677    XORA	0x77
  01EE    3003    LDIA	0x3
  01EF    1903    SZB	0x3,2
  01F0    0678    XORA	0x78
  01F1    1D03    SNZB	0x3,2
  01F2    29DC    JP	0x1DC
246:                          countTime = 0;
  01F3    01F7    CLR	0x77
  01F4    01F8    CLR	0x78
  01F5    29DC    JP	0x1DC
247:                      }
248:                  }
249:              
250:              }
251:              
252:              void Init_Config() {
253:              
254:                  Init_System();
  0165    22AB    CALL	0x2AB
  027E    2289    CALL	0x289
255:                  Init_GPIO();
  0166    2221    CALL	0x221
  027F    22B0    CALL	0x2B0
256:                  Init_Interupt();
  0167    229B    CALL	0x29B
  0280    22AF    CALL	0x2AF
257:                  Init_PWM();
  0168    2270    CALL	0x270
  0281    22AE    CALL	0x2AE
258:                  //设置唤醒
259:                  IOCB = 0x04;
260:                  TMR0 = 155;
261:                  TO = 0;
262:              
263:                  //K1开关
264:                  key1.key_index = 5;
265:                  //K2加档
266:                  key2.key_index = 4;
267:                  //K3减档
268:                  key3.key_index = 3;
269:                  resetKey(&key1);
  0169    2170    CALL	0x170
  016A    2234    CALL	0x234
  0282    2170    CALL	0x170
  0283    2244    CALL	0x244
270:                  resetKey(&key2);
  016B    302B    LDIA	0x2B
  016C    2234    CALL	0x234
  0284    302B    LDIA	0x2B
  0285    2244    CALL	0x244
271:                  resetKey(&key3);
  016D    3024    LDIA	0x24
  016E    2234    CALL	0x234
  0286    3024    LDIA	0x24
  0287    2244    CALL	0x244
272:                  //设置IO方向
273:                  TRISA = 0;
274:                  TRISB = 0x7E;//1-6脚输入
275:                  TRISC = 0;
  016F    297D    JP	0x17D
  0288    297D    JP	0x17D
276:              }
277:              
278:              
279:              void Sleep_Mode() {
280:                  INTCON = 0;
281:              
282:                  OPTION_REG = 0;
283:              
284:                  TRISA = 0B00000000;        //关闭所有输出
285:                  PORTA = 0B00000000;
286:                  WPUA = 0B00000000;
287:              
288:                  TRISB = 0B00100000;
289:                  PORTB = 0B00000000;
290:              
291:                  PORTB = 0;
292:                  WPUB = 0B00100000;         //RB3 上拉
293:              
294:                  IOCB = 0B00100000;            //允许RB3的IO口电平变化中断
295:                  RBIE = 1;                    //允许PORTB电平变化中断
296:                  GIE = 1;                    //GIE = 0时，唤醒后执行SLEEP后程序;GIE = 1时，唤醒后跳至中断服务
297:              
298:                  ADCON0 = 0;                    //关闭所有模块
299:              
300:                  OSCCON = 0X70;                //配置振荡为16M,关闭WDT
301:              
302:                  PORTB;                        //读PORTB值并锁存			
303:                  asm("clrwdt");
304:              
305:                  asm("sleep");                //进入休眠模式
306:              
307:                  asm("nop");
308:              
309:              
310:              }
311:              
312:              
313:              /***********************************************
314:              函数名称：Timer0_Isr
315:              函数功能：中断服务
316:              入口参数：无
317:              出口参数：无
318:              备注：
319:              ***********************************************/
320:              void interrupt
321:              
322:              Timer0_Isr() {
323:                  if (T0IF) {
  01F6    1D0B    SNZB	0xB,2
  01F7    29FF    JP	0x1FF
324:                      //---------------------------------------
325:                      TMR0 += 155;        //重新赋初值，在赋值前Timer0已有计数，故在该基础上加初值
  01F8    309B    LDIA	0x9B
  01F9    1283    CLRB	0x3,5
  01FA    1303    CLRB	0x3,6
  01FB    0781    ADDR	0x1
326:                      //---------------------------------------
327:              
328:                      T0IF = 0;            //清中断标志位	
  01FC    110B    CLRB	0xB,2
329:                      time0Flag = 1;
  01FD    01F9    CLR	0x79
  01FE    0AF9    INCR	0x79
330:              
331:                  }
332:              
333:                  if (RBIF) {
  01FF    1C0B    SNZB	0xB,0
  0200    2A03    JP	0x203
334:                      RBIF = 0;            //清中断标志
  0201    100B    CLRB	0xB,0
335:                      Init_Config();
  0202    227E    CALL	0x27E
  0203    0873    LD	A,0x73
  0204    008A    LD	0xA,A
  0205    0872    LD	A,0x72
  0206    0084    LD	0x4,A
  0207    0E71    SWAPA	0x71
  0208    0083    LD	0x3,A
  0209    0EFE    SWAPR	0x7E
  020A    0E7E    SWAPA	0x7E
  020B    0009    RETI
336:                  }
337:              }
338:              
339:              
340:              
---- C:\SCMCU WorkSpace\uf166fan\scankey.c ----------------------------------------------------------------------
1:                #include "scankey.h"
2:                
3:                void sacnKeyInput(struct Keys *key) {
  01A2    00F6    LD	0x76,A
4:                    key->key_input = getbit(key->key_addr_result, key->key_index);
  01A3    3E05    ADDIA	0x5
  01A4    0084    LD	0x4,A
  01A5    1383    CLRB	0x3,7
  01A6    0800    LD	A,0x0
  01A7    00F4    LD	0x74,A
  01A8    0876    LD	A,0x76
  01A9    3E06    ADDIA	0x6
  01AA    0084    LD	0x4,A
  01AB    0A00    INCA	0x0
  01AC    29AF    JP	0x1AF
  01AD    1003    CLRB	0x3,0
  01AE    0CF4    RRCR	0x74
  01AF    3EFF    ADDIA	0xFF
  01B0    1D03    SNZB	0x3,2
  01B1    29AD    JP	0x1AD
  01B2    0874    LD	A,0x74
  01B3    00F5    LD	0x75,A
  01B4    0876    LD	A,0x76
  01B5    3E04    ADDIA	0x4
  01B6    0084    LD	0x4,A
  01B7    0875    LD	A,0x75
  01B8    0080    LD	0x0,A
  01B9    0876    LD	A,0x76
  01BA    3E04    ADDIA	0x4
  01BB    0084    LD	0x4,A
  01BC    3001    LDIA	0x1
  01BD    0580    ANDR	0x0
  01BE    0008    RET
5:                
6:                }
7:                
8:                
9:                static unsigned char key_driver(struct Keys *key) {
  005F    00F6    LD	0x76,A
10:               
11:               
12:                   unsigned char key_return = key_no;
  0060    01F4    CLR	0x74
13:                   unsigned char key_read = key->key_input;  //read the I/O states
  0061    3E04    ADDIA	0x4
  0062    0084    LD	0x4,A
  0063    1383    CLRB	0x3,7
  0064    0800    LD	A,0x0
  0065    00F5    LD	0x75,A
14:               
15:                   switch (key->key_state_buffer1) {
  0066    2892    JP	0x92
16:                       case key_state_0:
17:                           if (key_read == 0) {
  0067    0875    LD	A,0x75
  0068    1D03    SNZB	0x3,2
  0069    289F    JP	0x9F
18:                               key->key_state_buffer1 = key_state_1;
  006A    0A76    INCA	0x76
  006B    0084    LD	0x4,A
  006C    0180    CLR	0x0
  006D    0A80    INCR	0x0
  006E    289F    JP	0x9F
19:                           }
20:               
21:                           //按键被按下，状态转换到按键消抖和确认状态//
22:                           break;
23:               
24:                       case key_state_1:
25:                           if (key_read == 0) {
  006F    0875    LD	A,0x75
  0070    1D03    SNZB	0x3,2
  0071    288E    JP	0x8E
26:                               key->key_timer_cnt1 = 0;
  0072    0876    LD	A,0x76
  0073    0084    LD	0x4,A
  0074    0180    CLR	0x0
27:                               key->key_state_buffer1 = key_state_2;
  0075    0A76    INCA	0x76
  0076    0084    LD	0x4,A
  0077    3002    LDIA	0x2
  0078    288A    JP	0x8A
28:                               //按键仍然处于按下状态
29:                               //消抖完成，key_timer开始准备计时
30:                               //状态切换到按下时间计时状态
31:                           } else {
32:                               key->key_state_buffer1 = key_state_0;
33:                           }
34:               
35:                           //按键已经抬起，回到按键初始状态
36:                           break;  //完成软件消抖
37:               
38:                       case key_state_2:
39:                           if (key_read == 1) {
  0079    0B75    SZDECA	0x75
  007A    287E    JP	0x7E
40:                               key_return = key_click;  //按键抬起，产生一次click操作
  007B    01F4    CLR	0x74
  007C    0AF4    INCR	0x74
  007D    288E    JP	0x8E
41:                               key->key_state_buffer1 = key_state_0;  //转换到按键初始状态
  007E    0876    LD	A,0x76
  007F    0084    LD	0x4,A
  0080    3064    LDIA	0x64
  0081    0A80    INCR	0x0
  0082    0200    SUBA	0x0
  0083    1C03    SNZB	0x3,0
  0084    289F    JP	0x9F
42:                           } else if (++(key->key_timer_cnt1) >= 100)  //按键继续按下，计时超过1000ms
43:                           {
44:                               key_return = key_long;  //送回长按事件
  0085    3003    LDIA	0x3
  0086    00F4    LD	0x74,A
45:                               key->key_state_buffer1 = key_state_3;  //转换到等待按键释放状态
  0087    0A76    INCA	0x76
  0088    0084    LD	0x4,A
  0089    3003    LDIA	0x3
  008A    0080    LD	0x0,A
  008B    289F    JP	0x9F
46:               
47:                           }
48:                           break;
49:               
50:                       case key_state_3:  //等待按键释放
51:                           if (key_read == 1)  //按键释放
  008C    0B75    SZDECA	0x75
  008D    289F    JP	0x9F
52:                           {
53:                               key->key_state_buffer1 = key_state_0;  //切回按键初始状态
  008E    0A76    INCA	0x76
  008F    0084    LD	0x4,A
  0090    0180    CLR	0x0
  0091    289F    JP	0x9F
  0092    0A76    INCA	0x76
  0093    0084    LD	0x4,A
  0094    0800    LD	A,0x0
  0095    0084    LD	0x4,A
  0096    3004    LDIA	0x4
  0097    0204    SUBA	0x4
  0098    1803    SZB	0x3,0
  0099    289F    JP	0x9F
  009A    3002    LDIA	0x2
  009B    008A    LD	0xA,A
  009C    30A7    LDIA	0xA7
  009D    0704    ADDA	0x4
  009E    0082    LD	0x2,A
54:                           }
55:               
56:                           break;
57:                   }
58:                   return key_return;
  009F    0874    LD	A,0x74
  00A0    0008    RET
59:               }
60:               
61:               /***************************************************************************
62:               函数功能：中层按键处理函数，调用底层函数一次，处理双击事件的判断，
63:                                                       返回上层正确的无键、单击、双击、长按四种状态
64:               本函数由上层循环调用，间隔10ms
65:               ***************************************************************************/
66:               unsigned char key_read(struct Keys *key) {
  00DA    00BB    LD	0x3B,A
67:               
68:                   unsigned char key_return = key_no;
  00DB    01B9    CLR	0x39
69:                   unsigned char key_read = key_driver(key);
  00DC    205F    CALL	0x5F
  00DD    00BA    LD	0x3A,A
70:               //    printf("IO:%d  key status: %d\n",getSimpleKeyInput(key_input),key);
71:                   switch (key->key_state_buffer2) {
  00DE    2902    JP	0x102
72:                       case key_state_0:
73:                           if (key_read == key_click) {
  00DF    0B3A    SZDECA	0x3A
  00E0    28EB    JP	0xEB
74:                               key->key_timer_cnt2 = 0;  //第一次单击，不返回，到下个状态判断是否会出现双击
  00E1    083B    LD	A,0x3B
  00E2    3E02    ADDIA	0x2
  00E3    0084    LD	0x4,A
  00E4    0180    CLR	0x0
75:                               key->key_state_buffer2 = key_state_1;
  00E5    083B    LD	A,0x3B
  00E6    3E03    ADDIA	0x3
  00E7    0084    LD	0x4,A
  00E8    0180    CLR	0x0
  00E9    0A80    INCR	0x0
76:                           } else
  00EA    290D    JP	0x10D
77:                               key_return = key_read;  //对于无键、长按，返回原事件
  00EB    083A    LD	A,0x3A
  00EC    00B9    LD	0x39,A
  00ED    290D    JP	0x10D
78:                           break;
79:               
80:                       case key_state_1:
81:                           if (key_read == key_click)  //又一次单击，时间间隔小于500ms
  00EE    0B3A    SZDECA	0x3A
  00EF    28F3    JP	0xF3
82:                           {
83:                               key_return = key_double;  //返回双击事件，回到初始状态
  00F0    3002    LDIA	0x2
  00F1    00B9    LD	0x39,A
  00F2    28FD    JP	0xFD
84:                               key->key_state_buffer2 = key_state_0;
  00F3    083B    LD	A,0x3B
  00F4    3E02    ADDIA	0x2
  00F5    0084    LD	0x4,A
  00F6    3032    LDIA	0x32
  00F7    0A80    INCR	0x0
  00F8    0200    SUBA	0x0
  00F9    1C03    SNZB	0x3,0
  00FA    290D    JP	0x10D
85:                           } else if (++(key->key_timer_cnt2) >= 50) {
86:                               //这里500ms内肯定读到的都是无键事件，因为长按大于1000ms
87:                               //在1s前底层返回的都是无键
88:               
89:                               key_return = key_click;  //500ms内没有再次出现单击事件，返回单击事件
  00FB    01B9    CLR	0x39
  00FC    0AB9    INCR	0x39
90:                               key->key_state_buffer2 = key_state_0;  //返回初始状态
  00FD    083B    LD	A,0x3B
  00FE    3E03    ADDIA	0x3
  00FF    0084    LD	0x4,A
  0100    0180    CLR	0x0
  0101    290D    JP	0x10D
  0102    083B    LD	A,0x3B
  0103    3E03    ADDIA	0x3
  0104    0084    LD	0x4,A
  0105    0800    LD	A,0x0
  0106    3A00    XORIA	0x0
  0107    1903    SZB	0x3,2
  0108    28DF    JP	0xDF
  0109    3A01    XORIA	0x1
  010A    1903    SZB	0x3,2
  010B    28EE    JP	0xEE
  010C    290D    JP	0x10D
91:               
92:                           }
93:                           break;
94:                   }
95:               
96:                   return key_return;
  010D    0839    LD	A,0x39
  010E    0008    RET
97:               }
98:               
99:               
100:              void resetKey(struct Keys *key) {
  0234    00F4    LD	0x74,A
  0244    00F0    LD	0x70,A
101:                  key->key_timer_cnt1 = key->key_timer_cnt2 = key->key_state_buffer1 = key->key_state_buffer2 = 0;
  0235    3E03    ADDIA	0x3
  0236    0084    LD	0x4,A
  0237    1383    CLRB	0x3,7
  0238    0180    CLR	0x0
  0239    0A74    INCA	0x74
  023A    0084    LD	0x4,A
  023B    0180    CLR	0x0
  023C    0874    LD	A,0x74
  023D    3E02    ADDIA	0x2
  023E    0084    LD	0x4,A
  023F    0180    CLR	0x0
  0240    0874    LD	A,0x74
  0241    0084    LD	0x4,A
  0242    0180    CLR	0x0
  0243    0008    RET
  0245    3E03    ADDIA	0x3
  0246    0084    LD	0x4,A
  0247    1383    CLRB	0x3,7
  0248    0180    CLR	0x0
  0249    0A70    INCA	0x70
  024A    0084    LD	0x4,A
  024B    0180    CLR	0x0
  024C    0870    LD	A,0x70
  024D    3E02    ADDIA	0x2
  024E    0084    LD	0x4,A
  024F    0180    CLR	0x0
  0250    0870    LD	A,0x70
  0251    0084    LD	0x4,A
  0252    0180    CLR	0x0
  0253    0008    RET
102:              }
---- C:\工具\单片机学习资料\SC8P\SCMCU_IDE_V2.00.07\data\sources\common\Umul8.c ----------------------------------------------------------------------
1:                // 8 x 8 bit multiplication with 8 bit result
2:                
3:                unsigned char
4:                __bmul(unsigned char multiplier, unsigned char multiplicand)
  0254    00F6    LD	0x76,A
  0255    01F5    CLR	0x75
  0256    0874    LD	A,0x74
  0257    1876    SZB	0x76,0
  0258    07F5    ADDR	0x75
  0259    1003    CLRB	0x3,0
  025A    0DF4    RLCR	0x74
  025B    1003    CLRB	0x3,0
  025C    0CF6    RRCR	0x76
  025D    0876    LD	A,0x76
  025E    1D03    SNZB	0x3,2
  025F    2A56    JP	0x256
  0260    0875    LD	A,0x75
  0261    0008    RET
5:                {
6:                	unsigned char product = 0;
7:                
8:                #if defined(__OPTIMIZE_SPEED__)
9:                
10:               	if(multiplier & 0x01)
11:               		product = (product + multiplicand) & 0xff;
12:               	multiplicand <<= 1;
13:               
14:               	if(multiplier & 0x02)
15:               		product = (product + multiplicand) & 0xff;
16:               	multiplicand <<= 1;
17:               
18:               	if(multiplier & 0x04)
19:               		product = (product + multiplicand) & 0xff;
20:               	multiplicand <<= 1;
21:               
22:               	if(multiplier & 0x08)
23:               		product = (product + multiplicand) & 0xff;
24:               	multiplicand <<= 1;
25:               
26:               	if(multiplier & 0x10)
27:               		product = (product + multiplicand) & 0xff;
28:               	multiplicand <<= 1;
29:               
30:               	if(multiplier & 0x20)
31:               		product = (product + multiplicand) & 0xff;
32:               	multiplicand <<= 1;
33:               
34:               	if(multiplier & 0x40)
35:               		product = (product + multiplicand) & 0xff;
36:               	multiplicand <<= 1;
37:               
38:               	if(multiplier & 0x80)
39:               		product = (product + multiplicand) & 0xff;
40:               
41:               #else
42:               	do {
43:               		if(multiplier & 1)
44:               			product += multiplicand;
45:               		multiplicand <<= 1;
46:               		multiplier >>= 1;
47:               	} while(multiplier != 0);
48:               
49:               #endif
50:               	return product;
51:               }
---- C:\工具\单片机学习资料\SC8P\SCMCU_IDE_V2.00.07\data\sources\common\awdiv.c ----------------------------------------------------------------------
1:                // integer signed division
2:                
3:                signed int
4:                #ifdef __PICC__
5:                #warning TODO: update cgpic and this file to use the other prototype
6:                __awdiv(signed int divisor, signed int dividend)
  001A    01BE    CLR	0x3E
  001B    1FBA    SNZB	0x3A,7
  001C    2824    JP	0x24
  001D    09B9    COMR	0x39
  001E    09BA    COMR	0x3A
  001F    0AB9    INCR	0x39
  0020    1903    SZB	0x3,2
  0021    0ABA    INCR	0x3A
  0022    01BE    CLR	0x3E
  0023    0ABE    INCR	0x3E
  0024    1FBC    SNZB	0x3C,7
  0025    282D    JP	0x2D
  0026    09BB    COMR	0x3B
  0027    09BC    COMR	0x3C
  0028    0ABB    INCR	0x3B
  0029    1903    SZB	0x3,2
  002A    0ABC    INCR	0x3C
  002B    3001    LDIA	0x1
  002C    06BE    XORR	0x3E
  002D    01BF    CLR	0x3F
  002E    01C0    CLR	0x40
  002F    0839    LD	A,0x39
  0030    043A    ORA	0x3A
  0031    1903    SZB	0x3,2
  0032    2852    JP	0x52
  0033    01BD    CLR	0x3D
  0034    0ABD    INCR	0x3D
  0035    1BBA    SZB	0x3A,7
  0036    283B    JP	0x3B
  0037    1003    CLRB	0x3,0
  0038    0DB9    RLCR	0x39
  0039    0DBA    RLCR	0x3A
  003A    2834    JP	0x34
  003B    1003    CLRB	0x3,0
  003C    0DBF    RLCR	0x3F
  003D    0DC0    RLCR	0x40
  003E    083A    LD	A,0x3A
  003F    023C    SUBA	0x3C
  0040    1D03    SNZB	0x3,2
  0041    2844    JP	0x44
  0042    0839    LD	A,0x39
  0043    023B    SUBA	0x3B
  0044    1C03    SNZB	0x3,0
  0045    284E    JP	0x4E
  0046    0839    LD	A,0x39
  0047    02BB    SUBR	0x3B
  0048    083A    LD	A,0x3A
  0049    1C03    SNZB	0x3,0
  004A    03BC    DECR	0x3C
  004B    02BC    SUBR	0x3C
  004C    143F    SETB	0x3F,0
  004D    1003    CLRB	0x3,0
  004E    0CBA    RRCR	0x3A
  004F    0CB9    RRCR	0x39
  0050    0BBD    SZDECR	0x3D
  0051    283B    JP	0x3B
  0052    083E    LD	A,0x3E
  0053    1903    SZB	0x3,2
  0054    285A    JP	0x5A
  0055    09BF    COMR	0x3F
  0056    09C0    COMR	0x40
  0057    0ABF    INCR	0x3F
  0058    1903    SZB	0x3,2
  0059    0AC0    INCR	0x40
  005A    0840    LD	A,0x40
  005B    00BA    LD	0x3A,A
  005C    083F    LD	A,0x3F
  005D    00B9    LD	0x39,A
  005E    0008    RET
7:                #else
8:                __awdiv(signed int dividend, signed int divisor)
9:                #endif
10:               {
11:               	signed int	quotient;
12:               	unsigned char	counter, sign;
13:               
14:               	sign = 0;
15:               	if(divisor < 0) {
16:               		divisor = -divisor;
17:               		sign = 1;
18:               	}
19:               	if(dividend < 0) {
20:               		dividend = -dividend;
21:               		sign ^= 1;
22:               	}
23:               	quotient = 0;
24:               	if(divisor != 0) {
25:               		counter = 1;
26:               		while((divisor & 0x8000U) == 0) {
27:               			divisor <<= 1;
28:               			counter++;
29:               		}
30:               		do {
31:               			quotient <<= 1;
32:               			if((unsigned int)divisor <= (unsigned int)dividend) {
33:               				dividend -= divisor;
34:               				quotient |= 1;
35:               			}
36:               			*(unsigned int *)&divisor >>= 1;
37:               		} while(--counter != 0);
38:               	}
39:               	if(sign)
40:               		quotient = -quotient;
41:               	return quotient;
42:               }
---- C:\SCMCU WorkSpace\uf166fan\init.c ----------------------------------------------------------------------
1:                #include "init.h"
2:                
3:                void Init_System() {
  0289    0000    NOP
  028A    0064    CLRWDT
  02AB    0000    NOP
  02AC    0064    CLRWDT
4:                    asm("nop");
5:                    asm("clrwdt");
6:                    INTCON = 0;                    //系统初始化
7:                    OSCCON = 0X71;                //配置振荡为8M,开 WDT
8:                    OPTION_REG = 0x00;        //Timer0使用内部时钟Focs/4，预分频比为1:2
  028B    2A8C    JP	0x28C
  02AD    2A8C    JP	0x28C
9:                
10:               }
11:               
12:               
13:               void Init_GPIO() {
14:                   TRISA = 0;
15:                   TRISB = 0;
16:                   TRISC = 0;
17:                   WPUA = 0xFF;
18:                   WPUB = 0xFF;
19:                   WPUC = 0xFF;
20:                   PORTA = 0xFF;
21:                   PORTB = 0xFF;
22:                   PORTC = 0xFF;
23:                   IOCB = 0x00;
  0221    2A22    JP	0x222
  02B0    2A22    JP	0x222
24:               
25:               }
26:               
27:               void Init_Interupt() {
28:                   OPTION_REG = 0x00;        //Timer0使用内部时钟Focs/4，预分频比为1:2
29:                   TMR0 = 0;                //赋予初始值
30:                   INTCON = 0xE0;            //允许所有未被屏蔽的中断、禁止外设中断，使能Timer0
  029B    2A9C    JP	0x29C
  02AF    2A9C    JP	0x29C
31:               
32:               }
---- stringtab ------------------------------------------------------------------
---- reset_enter ------------------------------------------------------------------
  0000    280C    JP	0xC
  000C    280D    JP	0xD
---- start_initialization ------------------------------------------------------------------
  000D    3002    LDIA	0x2
  000E    00C6    LD	0x46,A
  000F    00C7    LD	0x47,A
  0010    3020    LDIA	0x20
  0011    1383    CLRB	0x3,7
  0012    0084    LD	0x4,A
  0013    3039    LDIA	0x39
  0014    2293    CALL	0x293
  0015    01F7    CLR	0x77
  0016    01F8    CLR	0x78
  0017    01F9    CLR	0x79
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F1    LD	0x71,A
  0007    0804    LD	A,0x4
  0008    00F2    LD	0x72,A
  0009    080A    LD	A,0xA
  000A    00F3    LD	0x73,A
  000B    29F6    JP	0x1F6
---- common_function ------------------------------------------------------------------
  0018    0183    CLR	0x3
  0019    29DB    JP	0x1DB
  00CD    1683    SETB	0x3,5
  00CE    1087    CLRB	0x7,1
  00CF    1786    SETB	0x6,7
  00D0    1007    CLRB	0x7,0
  00D1    1283    CLRB	0x3,5
  00D2    1386    CLRB	0x6,7
  00D3    0008    RET
  00D4    1683    SETB	0x3,5
  00D5    1407    SETB	0x7,0
  00D6    1386    CLRB	0x6,7
  00D7    1087    CLRB	0x7,1
  00D8    1283    CLRB	0x3,5
  00D9    0008    RET
  0170    3004    LDIA	0x4
  0171    0096    LD	0x16,A
  0172    309B    LDIA	0x9B
  0173    1283    CLRB	0x3,5
  0174    0081    LD	0x1,A
  0175    1203    CLRB	0x3,4
  0176    3005    LDIA	0x5
  0177    00B8    LD	0x38,A
  0178    3004    LDIA	0x4
  0179    00B1    LD	0x31,A
  017A    3003    LDIA	0x3
  017B    00AA    LD	0x2A,A
  017C    3432    RET	0x32
  017D    1683    SETB	0x3,5
  017E    1303    CLRB	0x3,6
  017F    0185    CLR	0x5
  0180    307E    LDIA	0x7E
  0181    0086    LD	0x6,A
  0182    0187    CLR	0x7
  0183    0008    RET
  0222    0185    CLR	0x5
  0223    0186    CLR	0x6
  0224    0187    CLR	0x7
  0225    30FF    LDIA	0xFF
  0226    1703    SETB	0x3,6
  0227    008E    LD	0xE,A
  0228    1303    CLRB	0x3,6
  0229    0095    LD	0x15,A
  022A    1703    SETB	0x3,6
  022B    008F    LD	0xF,A
  022C    1283    CLRB	0x3,5
  022D    1303    CLRB	0x3,6
  022E    0085    LD	0x5,A
  022F    0086    LD	0x6,A
  0230    0087    LD	0x7,A
  0231    1683    SETB	0x3,5
  0232    0196    CLR	0x16
  0233    0008    RET
  0271    300F    LDIA	0xF
  0272    0097    LD	0x17,A
  0273    0192    CLR	0x12
  0274    3007    LDIA	0x7
  0275    1683    SETB	0x3,5
  0276    0092    LD	0x12,A
  0277    1283    CLRB	0x3,5
  0278    0195    CLR	0x15
  0279    108C    CLRB	0xC,1
  027A    0192    CLR	0x12
  027B    1683    SETB	0x3,5
  027C    1107    CLRB	0x7,2
  027D    0008    RET
  028C    018B    CLR	0xB
  028D    3071    LDIA	0x71
  028E    1683    SETB	0x3,5
  028F    1303    CLRB	0x3,6
  0290    008F    LD	0xF,A
  0291    0181    CLR	0x1
  0292    0008    RET
  0293    0064    CLRWDT
  0294    0180    CLR	0x0
  0295    0A84    INCR	0x4
  0296    0604    XORA	0x4
  0297    1903    SZB	0x3,2
  0298    3400    RET	0x0
  0299    0604    XORA	0x4
  029A    2A94    JP	0x294
  029C    0181    CLR	0x1
  029D    1283    CLRB	0x3,5
  029E    0181    CLR	0x1
  029F    30E0    LDIA	0xE0
  02A0    008B    LD	0xB,A
  02A1    0008    RET
  02A2    28A3    JP	0xA3
  02A3    28A7    JP	0xA7
  02A4    28AB    JP	0xAB
  02A5    28B0    JP	0xB0
  02A6    28B5    JP	0xB5
  02A7    2867    JP	0x67
  02A8    286F    JP	0x6F
  02A9    2879    JP	0x79
  02AA    288C    JP	0x8C
