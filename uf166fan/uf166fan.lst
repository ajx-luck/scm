---- E:\project\project0508\scm\uf166fan\main.c ----------------------------------------------------------------------
1:                #include "scankey.h"
2:                #include "init.h"
3:                #include "adc.h"
4:                
5:                #define MAX_FAN_LEVEL 4
6:                #define MIN_FAN_LEVEL 1
7:                
8:                #define FAN_STATUS_OFF  0
9:                #define FAN_STATUS_ON  1
10:               #define FAN_STATUS_NONE 2
11:               
12:               #define PBPORTB PORTA
13:               #define PBTRISB TRISA
14:               
15:               #define LED_1  1
16:               #define LED_2  2
17:               #define LED_3  3
18:               #define LED_4  4
19:               //1毫秒中断标志
20:               static unsigned char time0Flag = 0;
21:               static unsigned int countTime = 0;
22:               static unsigned int count10Ms = 0;
23:               unsigned char currentLevel = 3;
24:               //风扇状态
25:               unsigned char FAN_STATUS = FAN_STATUS_NONE;
26:               //检测风扇次数
27:               unsigned int fan_check_time = 0;
28:               //低电压检测次数
29:               unsigned char lowVTime = 0;
30:               unsigned char count300ms = 0;
31:               //按键结构体
32:               struct Keys key1, key2, key3;
33:               //显示风扇挡位
34:               void setLedOn(unsigned char ledIndex);
35:               //初始化配置
36:               void Init_Config();
37:               //睡眠模式
38:               void Sleep_Mode();
39:               //关闭风扇
40:               void closeFan();
41:               
42:               void checkUsbStatus() {
43:                   if (getbit(PORTB, 2) == 1) {
  0109    0806    LD	A,0x6
  010A    00C7    LD	0x47,A
  010B    1003    CLRB	0x3,0
  010C    0CC7    RRCR	0x47
  010D    1003    CLRB	0x3,0
  010E    0CC7    RRCR	0x47
  010F    1C47    SNZB	0x47,0
  0110    2921    JP	0x121
44:                       if (getbit(PORTB, 1) == 1) {
  0111    0806    LD	A,0x6
  0112    00C7    LD	0x47,A
  0113    1003    CLRB	0x3,0
  0114    0CC7    RRCR	0x47
  0115    1C47    SNZB	0x47,0
  0116    2919    JP	0x119
45:                           //充满了，Led常亮
46:                           resetbit(PORTA, 0);
  0117    1005    CLRB	0x5,0
47:                       } else if (countTime == 50) {
  0118    0008    RET
  0119    3032    LDIA	0x32
  011A    062C    XORA	0x2C
  011B    042D    ORA	0x2D
  011C    1D03    SNZB	0x3,2
  011D    0008    RET
48:                           //充电中，一直闪		
49:                           reversebit(PORTA, 0);
  011E    3001    LDIA	0x1
  011F    0685    XORR	0x5
  0120    0008    RET
50:                       }
51:                   } else {
52:                       //usb断开充电灯熄灭,PA0 = 1
53:                       setbit(PORTA, 0);
  0121    1405    SETB	0x5,0
54:               		if((adresult/8) > 0x63 && count300ms == 0)
  0122    213D    CALL	0x13D
  0123    3064    LDIA	0x64
  0124    1903    SZB	0x3,2
  0125    0247    SUBA	0x47
  0126    1C03    SNZB	0x3,0
  0127    2934    JP	0x134
  0128    0876    LD	A,0x76
  0129    1D03    SNZB	0x3,2
  012A    2934    JP	0x134
55:               		{
56:               			if(lowVTime < 20)
  012B    3014    LDIA	0x14
  012C    0231    SUBA	0x31
  012D    1803    SZB	0x3,0
  012E    2933    JP	0x133
  012F    3001    LDIA	0x1
57:               			{
58:               				lowVTime++;
  0130    0AB1    INCR	0x31
59:               				//闪红灯，
60:               				reversebit(PORTA, 0);
  0131    0685    XORR	0x5
61:               			}else
  0132    2934    JP	0x134
62:               			{
63:               				//关闭风扇
64:               				closeFan();
  0133    22FC    CALL	0x2FC
65:               			}
66:               		}
67:               		if((adresult/8) < 0x63)
  0134    1283    CLRB	0x3,5
  0135    1303    CLRB	0x3,6
  0136    213D    CALL	0x13D
  0137    3063    LDIA	0x63
  0138    1903    SZB	0x3,2
  0139    0247    SUBA	0x47
  013A    1C03    SNZB	0x3,0
68:               		{
69:               			lowVTime = 0;
  013B    01B1    CLR	0x31
  013C    0008    RET
70:               		}
71:                   }
72:               }
73:               
74:               void Init_PWM() {
75:                   CCP1CON = 0x0F;//设置PC2为PWM模式，4,5位为占空比的低2位
76:                   T2CON = 0; //时钟分频 1:1 PWM周期为（PR2+1）*4/8,000,000
77:                   PR2 = 7;
78:               
79:                   CCPR1L = 0;//占空比高8位，低2位设置为0，结果就是 占空比 = CCPR1L*4/4*(PR2+1)
80:                   TMR2IF = 0;
81:                   T2CON = 0;
82:                   //PC2设置为输出脚
83:                   resetbit(TRISC, 2);
  035B    2B5C    JP	0x35C
  03B6    2B5C    JP	0x35C
84:                   //T2CON = 0X04 //启动定时器2，溢出后启动PWM
85:               }
86:               
87:               //设置风扇转速
88:               void setFanLevel(char level) {
  0191    00CF    LD	0x4F,A
89:               	if(level == 0)
  0192    084F    LD	A,0x4F
  0193    1D03    SNZB	0x3,2
  0194    2997    JP	0x197
90:               	{
91:               		currentLevel = 3;
  0195    3003    LDIA	0x3
  0196    00F9    LD	0x79,A
92:               	}
93:                   unsigned int levelWidth = (PR2 + 1) / MAX_FAN_LEVEL;
  0197    1683    SETB	0x3,5
  0198    0812    LD	A,0x12
  0199    1283    CLRB	0x3,5
  019A    00C9    LD	0x49,A
  019B    01CA    CLR	0x4A
  019C    0AC9    INCR	0x49
  019D    1903    SZB	0x3,2
  019E    0ACA    INCR	0x4A
  019F    3004    LDIA	0x4
  01A0    00C7    LD	0x47,A
  01A1    01C8    CLR	0x48
  01A2    20C4    CALL	0xC4
94:                   char tempLevel = currentLevel + level;
  01A3    084F    LD	A,0x4F
  01A4    0779    ADDA	0x79
  01A5    00D0    LD	0x50,A
95:                   if (tempLevel > MAX_FAN_LEVEL) {
  01A6    3005    LDIA	0x5
  01A7    0250    SUBA	0x50
  01A8    1C03    SNZB	0x3,0
  01A9    29AC    JP	0x1AC
96:                       tempLevel = MAX_FAN_LEVEL;
  01AA    3004    LDIA	0x4
  01AB    00D0    LD	0x50,A
97:                   }
98:               
99:                   if (tempLevel < MIN_FAN_LEVEL) {
  01AC    0850    LD	A,0x50
  01AD    1D03    SNZB	0x3,2
  01AE    29B1    JP	0x1B1
100:                      tempLevel = MIN_FAN_LEVEL;
  01AF    01D0    CLR	0x50
  01B0    0AD0    INCR	0x50
101:                  }
102:              	
103:                  
104:                  if (FAN_STATUS == FAN_STATUS_ON) {
  01B1    0B78    SZDECA	0x78
  01B2    0008    RET
105:              		currentLevel = tempLevel;
  01B3    0850    LD	A,0x50
  01B4    00F9    LD	0x79,A
106:              		switch(currentLevel)
  01B5    29BF    JP	0x1BF
107:              		{
108:              			case 1:
109:              			CCPR1L = 1;
  01B6    3001    LDIA	0x1
  01B7    29BD    JP	0x1BD
110:              			break;
111:              			case 2:
112:              			CCPR1L = 2;
  01B8    3002    LDIA	0x2
  01B9    29BD    JP	0x1BD
113:              			break;
114:              			case 3:
115:              			CCPR1L = 3;
  01BA    3003    LDIA	0x3
  01BB    29BD    JP	0x1BD
116:              			break;
117:              			case 4:
118:              			CCPR1L = 5;
  01BC    3005    LDIA	0x5
  01BD    0095    LD	0x15,A
119:              			break;
  01BE    29CD    JP	0x1CD
  01BF    0879    LD	A,0x79
  01C0    3A01    XORIA	0x1
  01C1    1903    SZB	0x3,2
  01C2    29B6    JP	0x1B6
  01C3    3A03    XORIA	0x3
  01C4    1903    SZB	0x3,2
  01C5    29B8    JP	0x1B8
  01C6    3A01    XORIA	0x1
  01C7    1903    SZB	0x3,2
  01C8    29BA    JP	0x1BA
  01C9    3A07    XORIA	0x7
  01CA    1903    SZB	0x3,2
  01CB    29BC    JP	0x1BC
  01CC    29CD    JP	0x1CD
120:              		}
121:                  //设置占宽比
122:              		//CCPR1L = levelWidth * currentLevel;
123:                      setLedOn(currentLevel);
  01CD    0879    LD	A,0x79
  01CE    29CF    JP	0x1CF
124:                  }
125:              
126:              }
127:              
128:              //关闭风扇
129:              void closeFan() {
130:                  Init_PWM();
  02FC    235B    CALL	0x35B
131:                  currentLevel = 2;
  02FD    3002    LDIA	0x2
  02FE    00F9    LD	0x79,A
132:                  setLedOn(5);
  02FF    3005    LDIA	0x5
  0300    21CF    CALL	0x1CF
133:                  setbit(PORTA, 0);
  0301    1283    CLRB	0x3,5
  0302    1405    SETB	0x5,0
134:                  //PWM输出脚设置为输入，关闭PWM
135:                  setbit(TRISC, 2);
  0303    1683    SETB	0x3,5
  0304    1507    SETB	0x7,2
136:                  fan_check_time = 0;
  0305    1283    CLRB	0x3,5
  0306    01A8    CLR	0x28
  0307    01A9    CLR	0x29
137:                  FAN_STATUS = FAN_STATUS_OFF;
  0308    01F8    CLR	0x78
138:                  if (getbit(PORTB, 2) == 0) {
  0309    0806    LD	A,0x6
  030A    00F5    LD	0x75,A
  030B    1003    CLRB	0x3,0
  030C    0CF5    RRCR	0x75
  030D    1003    CLRB	0x3,0
  030E    0CF5    RRCR	0x75
  030F    1875    SZB	0x75,0
  0310    0008    RET
139:              		Sleep_Mode();
  0311    2A62    JP	0x262
140:              	}
141:              }
142:              
143:              
144:              //检测风扇是否连接
145:              void checkFan() {
146:              	resetbit(TRISA, 1);
  0237    1683    SETB	0x3,5
  0238    1085    CLRB	0x5,1
147:                  setbit(PORTA, 1);
  0239    1283    CLRB	0x3,5
  023A    1485    SETB	0x5,1
148:                  //PC2设置为输出脚
149:                  resetbit(TRISC, 2);
  023B    1683    SETB	0x3,5
  023C    1107    CLRB	0x7,2
150:              	setbit(PORTA, 2);
  023D    1283    CLRB	0x3,5
  023E    1505    SETB	0x5,2
151:                  T2CON = 0X04; //启动定时器2，溢出后启动PWM
  023F    3004    LDIA	0x4
  0240    0092    LD	0x12,A
152:              
153:                  //EN IN输出高电位，D1点亮，检测FAN DET，FAN DET为低电位则风扇正常工作，高电位则未连接
154:                  if (getbit(PORTB, 6) == 0) {
  0241    0806    LD	A,0x6
  0242    00D1    LD	0x51,A
  0243    3006    LDIA	0x6
  0244    1003    CLRB	0x3,0
  0245    0CD1    RRCR	0x51
  0246    3EFF    ADDIA	0xFF
  0247    1D03    SNZB	0x3,2
  0248    2A44    JP	0x244
  0249    1851    SZB	0x51,0
  024A    2A4E    JP	0x24E
155:                      FAN_STATUS = FAN_STATUS_ON;
  024B    01F8    CLR	0x78
  024C    0AF8    INCR	0x78
156:                  } else {
  024D    2A50    JP	0x250
157:                      FAN_STATUS = FAN_STATUS_NONE;
  024E    3002    LDIA	0x2
  024F    00F8    LD	0x78,A
158:                  }
159:              	
160:              	setFanLevel(0);
  0250    3000    LDIA	0x0
  0251    2191    CALL	0x191
161:              
162:                  //没有检测到风扇
163:                  if (FAN_STATUS == FAN_STATUS_NONE) {
  0252    3002    LDIA	0x2
  0253    0678    XORA	0x78
  0254    1D03    SNZB	0x3,2
  0255    0008    RET
164:                      fan_check_time++;
  0256    1283    CLRB	0x3,5
  0257    0AA8    INCR	0x28
  0258    1903    SZB	0x3,2
  0259    0AA9    INCR	0x29
165:                      if (fan_check_time == 3000) {
  025A    30B8    LDIA	0xB8
  025B    0628    XORA	0x28
  025C    300B    LDIA	0xB
  025D    1903    SZB	0x3,2
  025E    0629    XORA	0x29
  025F    1D03    SNZB	0x3,2
  0260    0008    RET
166:                          closeFan();
  0261    2AFC    JP	0x2FC
167:                          return;
168:                      }
169:                  }
170:              
171:              
172:              }
173:              
174:              
175:              //设置Led灯亮
176:              void setLedOn(unsigned char ledIndex) {
  01CF    00F4    LD	0x74,A
177:                  switch(ledIndex) {
  01D0    29EC    JP	0x1EC
178:                      case 1:
179:                          //PB7设置为输入脚,PC1和PC0设置为输出
180:              			resetbit(TRISC, 1);
181:              			setbit(PBTRISB, 7);
182:                          resetbit(TRISC, 0);
183:                          resetbit(PBPORTB, 7);
  01D1    21FB    CALL	0x1FB
184:                          setbit(PORTC, 0);
  01D2    1407    SETB	0x7,0
185:                          resetbit(PORTC, 1);            
  01D3    1087    CLRB	0x7,1
186:                          break;
  01D4    0008    RET
187:                      case 2:
188:              			resetbit(TRISC, 1);
189:              			setbit(PBTRISB, 7);
190:                          resetbit(TRISC, 0);
191:              			resetbit(PBPORTB, 7);
  01D5    21FB    CALL	0x1FB
192:                          resetbit(PORTC, 0);
  01D6    1007    CLRB	0x7,0
193:                          setbit(PORTC, 1);
  01D7    1487    SETB	0x7,1
194:                          break;
  01D8    0008    RET
195:                      case 3:
196:                          //PC0设置为输入脚，PB7和PC1设置为输出
197:              			setbit(TRISC, 0);
198:              			resetbit(PBTRISB, 7);
199:                          resetbit(TRISC, 1);
200:                          setbit(PBPORTB, 7);
  01D9    2202    CALL	0x202
  01DA    1785    SETB	0x5,7
201:                          resetbit(PORTC, 0);
  01DB    1007    CLRB	0x7,0
202:                          resetbit(PORTC, 1);
  01DC    1087    CLRB	0x7,1
203:                          break;
  01DD    0008    RET
204:                      case 4:
205:              			setbit(TRISC, 0);
206:              			resetbit(PBTRISB, 7);
207:                          resetbit(TRISC, 1);
208:                          resetbit(PBPORTB, 7);
  01DE    2202    CALL	0x202
  01DF    1385    CLRB	0x5,7
209:                          setbit(PORTC, 0);
  01E0    1407    SETB	0x7,0
210:                          setbit(PORTC, 1);
  01E1    1487    SETB	0x7,1
211:                          break;
  01E2    0008    RET
212:                      case 5:
213:                          //全部设置为输入脚
214:              			setbit(TRISC, 0);
  01E3    1683    SETB	0x3,5
  01E4    1407    SETB	0x7,0
215:              			setbit(PBTRISB, 7);
  01E5    1785    SETB	0x5,7
216:                          setbit(TRISC, 1);
  01E6    1487    SETB	0x7,1
217:              			resetbit(PORTC, 0);
  01E7    1283    CLRB	0x3,5
  01E8    1007    CLRB	0x7,0
218:              			resetbit(PBPORTB, 7);
  01E9    1385    CLRB	0x5,7
219:                          resetbit(PORTC, 1);
  01EA    1087    CLRB	0x7,1
220:                          break;
  01EB    0008    RET
  01EC    0874    LD	A,0x74
  01ED    3EFF    ADDIA	0xFF
  01EE    1C03    SNZB	0x3,0
  01EF    0008    RET
  01F0    0084    LD	0x4,A
  01F1    3005    LDIA	0x5
  01F2    0204    SUBA	0x4
  01F3    1803    SZB	0x3,0
  01F4    0008    RET
  01F5    3003    LDIA	0x3
  01F6    008A    LD	0xA,A
  01F7    30AA    LDIA	0xAA
  01F8    0704    ADDA	0x4
  01F9    0082    LD	0x2,A
  01FA    0008    RET
221:                  }
222:              }
223:              
224:              
225:              //扫描按键
226:              void scanKeys() {
227:                  key1.key_addr_result = key2.key_addr_result = key3.key_addr_result = PORTB;
  0369    1283    CLRB	0x3,5
  036A    1303    CLRB	0x3,6
  036B    0806    LD	A,0x6
  036C    00B7    LD	0x37,A
  036D    00BE    LD	0x3E,A
  036E    00C5    LD	0x45,A
228:                  sacnKeyInput(&key1);
  036F    3040    LDIA	0x40
  0370    22C2    CALL	0x2C2
229:                  sacnKeyInput(&key2);
  0371    3039    LDIA	0x39
  0372    22C2    CALL	0x2C2
230:                  sacnKeyInput(&key3);
  0373    3032    LDIA	0x32
  0374    2AC2    JP	0x2C2
231:                 
232:              }
233:              
234:              //检测按键状态并处理
235:              void checkKeys() {
236:                  if (key_driver(&key1) == key_click) {
  02A4    3040    LDIA	0x40
  02A5    214D    CALL	0x14D
  02A6    3A01    XORIA	0x1
  02A7    1D03    SNZB	0x3,2
  02A8    2AAF    JP	0x2AF
237:                      //检测到按键了，检测风扇是否存在
238:              
239:                      if (FAN_STATUS == FAN_STATUS_ON) {
  02A9    0B78    SZDECA	0x78
  02AA    2AAC    JP	0x2AC
240:                          //关闭风扇
241:                          closeFan();
  02AB    2AFC    JP	0x2FC
242:                      } else {
243:                          FAN_STATUS = FAN_STATUS_NONE;
  02AC    3002    LDIA	0x2
  02AD    00F8    LD	0x78,A
244:                          checkFan();
  02AE    2A37    JP	0x237
  02AF    3002    LDIA	0x2
  02B0    0678    XORA	0x78
  02B1    1D03    SNZB	0x3,2
  02B2    2AB4    JP	0x2B4
245:                      }
246:                      return;
247:                  } else if (FAN_STATUS == FAN_STATUS_NONE) {
248:                      checkFan();
  02B3    2237    CALL	0x237
249:                  }
250:              
251:              	unsigned char key2Status = key_driver(&key2);
  02B4    3039    LDIA	0x39
  02B5    214D    CALL	0x14D
  02B6    00D2    LD	0x52,A
252:                  if (key2Status == key_click) {
  02B7    0B52    SZDECA	0x52
  02B8    2ABB    JP	0x2BB
253:                      //加档
254:                      setFanLevel(1);
  02B9    3001    LDIA	0x1
  02BA    2991    JP	0x191
255:                      return;
256:                  }
257:              	unsigned char key3Status = key_driver(&key3);
  02BB    3032    LDIA	0x32
  02BC    214D    CALL	0x14D
  02BD    00D3    LD	0x53,A
258:                  if (key3Status == key_click) {
  02BE    0B53    SZDECA	0x53
  02BF    0008    RET
259:                      //减档
260:                      setFanLevel(-1);
  02C0    30FF    LDIA	0xFF
  02C1    2991    JP	0x191
261:                      return;
262:                  }
263:              
264:              }
265:              
266:              
267:              void main(void) {
268:              	if (getbit(PORTB, 2) == 0) {
  0208    0806    LD	A,0x6
  0209    00D4    LD	0x54,A
  020A    1003    CLRB	0x3,0
  020B    0CD4    RRCR	0x54
  020C    1003    CLRB	0x3,0
  020D    0CD4    RRCR	0x54
  020E    1854    SZB	0x54,0
  020F    2A11    JP	0x211
269:              		Sleep_Mode();
  0210    2262    CALL	0x262
270:              	}
271:              	
272:                  Init_Config();
  0211    2380    CALL	0x380
273:                  while (1) {
274:                      //0.1毫秒检测一次
275:                      if (time0Flag) {
  0212    0877    LD	A,0x77
  0213    1903    SZB	0x3,2
  0214    2A1B    JP	0x21B
  0215    0064    CLRWDT
276:                          asm("clrwdt");
277:                          time0Flag = 0;
  0216    01F7    CLR	0x77
278:              			scanKeys();
  0217    2369    CALL	0x369
279:                          count10Ms++;
  0218    0AAA    INCR	0x2A
  0219    1903    SZB	0x3,2
  021A    0AAB    INCR	0x2B
280:                      }
281:              
282:                      //10毫秒检测一次
283:                      if (count10Ms == 100) {	
  021B    3064    LDIA	0x64
  021C    062A    XORA	0x2A
  021D    042B    ORA	0x2B
  021E    1D03    SNZB	0x3,2
  021F    2A2B    JP	0x22B
284:              			countTime++;
  0220    0AAC    INCR	0x2C
  0221    1903    SZB	0x3,2
  0222    0AAD    INCR	0x2D
285:              			count300ms++;	
  0223    0AF6    INCR	0x76
286:                          checkKeys();
  0224    22A4    CALL	0x2A4
287:                          count10Ms = 0;
  0225    1283    CLRB	0x3,5
  0226    1303    CLRB	0x3,6
  0227    01AA    CLR	0x2A
  0228    01AB    CLR	0x2B
288:                          //检测USB状态
289:                          checkUsbStatus();
  0229    2109    CALL	0x109
290:              			//检测内部电压
291:              			readVrefADC();
  022A    23A4    CALL	0x3A4
292:                      }
293:              		//300ms
294:              		if(count300ms == 30)
  022B    301E    LDIA	0x1E
  022C    0676    XORA	0x76
  022D    1903    SZB	0x3,2
295:              		{
296:              			count300ms = 0;
  022E    01F6    CLR	0x76
297:              		}
298:              		//1s钟
299:                      if (countTime == 100) {
  022F    3064    LDIA	0x64
  0230    062C    XORA	0x2C
  0231    042D    ORA	0x2D
  0232    1D03    SNZB	0x3,2
  0233    2A12    JP	0x212
300:                          countTime = 0;
  0234    01AC    CLR	0x2C
  0235    01AD    CLR	0x2D
  0236    2A12    JP	0x212
301:                      }
302:              		
303:                  }
304:              
305:              }
306:              
307:              void Init_Config() {
308:              
309:                  Init_System();
  0283    238B    CALL	0x38B
  0380    23B3    CALL	0x3B3
310:                  Init_GPIO();
  0284    23B8    CALL	0x3B8
  0381    2328    CALL	0x328
311:                  Init_Interupt();
  0285    23B7    CALL	0x3B7
  0382    239D    CALL	0x39D
312:                  Init_PWM();
  0286    23B6    CALL	0x3B6
  0383    235B    CALL	0x35B
313:                  //设置唤醒
314:                  IOCB = 0x04;
315:                  TMR0 = 155;
316:                  TO = 0;
317:              
318:                  //K1开关
319:                  key1.key_index = 5;
320:                  //K2加档
321:                  key2.key_index = 4;
322:                  //K3减档
323:                  key3.key_index = 3;
324:                  resetKey(&key1);
  0287    228E    CALL	0x28E
  0288    234B    CALL	0x34B
  0384    228E    CALL	0x28E
  0385    233B    CALL	0x33B
325:                  resetKey(&key2);
  0289    3039    LDIA	0x39
  028A    234B    CALL	0x34B
  0386    3039    LDIA	0x39
  0387    233B    CALL	0x33B
326:                  resetKey(&key3);
  028B    3032    LDIA	0x32
  028C    234B    CALL	0x34B
  0388    3032    LDIA	0x32
  0389    233B    CALL	0x33B
327:                  //设置IO方向
328:                  TRISA = 0;
329:                  TRISB = 0x7E;//1-6脚输入
330:                  TRISC = 0;
331:              	lowVTime = 0;
  028D    2A9B    JP	0x29B
  038A    2A9B    JP	0x29B
332:              }
333:              
334:              
335:              void Sleep_Mode() {
336:                  INTCON = 0;
  0262    018B    CLR	0xB
337:              
338:                  OPTION_REG = 0;
  0263    1683    SETB	0x3,5
  0264    0181    CLR	0x1
339:              
340:                  TRISA = 0B00000000;        //关闭所有输出
  0265    0185    CLR	0x5
341:                  PORTA = 0B00000000;
  0266    1283    CLRB	0x3,5
  0267    0185    CLR	0x5
342:                  WPUA = 0B00000000;
  0268    1683    SETB	0x3,5
  0269    1703    SETB	0x3,6
  026A    018E    CLR	0xE
343:              
344:                  TRISB = 0B00100100;
  026B    3024    LDIA	0x24
  026C    1303    CLRB	0x3,6
  026D    0086    LD	0x6,A
345:                  PORTB = 0B00000000;
  026E    1283    CLRB	0x3,5
  026F    0186    CLR	0x6
346:              
347:                  PORTB = 0;
  0270    0186    CLR	0x6
348:                  WPUB = 0B00100000;         //RB3 上拉
  0271    3020    LDIA	0x20
  0272    1683    SETB	0x3,5
  0273    0095    LD	0x15,A
349:              
350:                  IOCB = 0B00100100;            //允许RB3的IO口电平变化中断
  0274    3024    LDIA	0x24
  0275    0096    LD	0x16,A
351:                  RBIE = 1;                    //允许PORTB电平变化中断
  0276    158B    SETB	0xB,3
352:                  GIE = 1;                    //GIE = 0时，唤醒后执行SLEEP后程序;GIE = 1时，唤醒后跳至中断服务
  0277    178B    SETB	0xB,7
353:              
354:                  ADCON0 = 0;                    //关闭所有模块
  0278    1283    CLRB	0x3,5
  0279    019F    CLR	0x1F
355:              
356:                  OSCCON = 0X70;                //配置振荡为16M,关闭WDT
  027A    3070    LDIA	0x70
  027B    1683    SETB	0x3,5
  027C    008F    LD	0xF,A
357:              
358:                  PORTB;                        //读PORTB值并锁存			
  027D    1283    CLRB	0x3,5
  027E    0806    LD	A,0x6
  027F    0064    CLRWDT
  0280    0063    STOP
  0281    0000    NOP
  0282    0008    RET
359:                  asm("clrwdt");
360:              
361:                  asm("sleep");                //进入休眠模式
362:              
363:                  asm("nop");
364:              
365:              
366:              }
367:              
368:              
369:              /***********************************************
370:              函数名称：Timer0_Isr
371:              函数功能：中断服务
372:              入口参数：无
373:              出口参数：无
374:              备注：
375:              ***********************************************/
376:              void interrupt
377:              
378:              Timer0_Isr() {
379:                  if (T0IF) {
  0312    1D0B    SNZB	0xB,2
  0313    2B1B    JP	0x31B
380:                      //---------------------------------------
381:                      TMR0 += 155;        //重新赋初值，在赋值前Timer0已有计数，故在该基础上加初值
  0314    309B    LDIA	0x9B
  0315    1283    CLRB	0x3,5
  0316    1303    CLRB	0x3,6
  0317    0781    ADDR	0x1
382:                      //---------------------------------------
383:              
384:                      T0IF = 0;            //清中断标志位	
  0318    110B    CLRB	0xB,2
385:                      time0Flag = 1;
  0319    01F7    CLR	0x77
  031A    0AF7    INCR	0x77
386:              
387:                  }
388:              
389:                  if (RBIF) {
  031B    1C0B    SNZB	0xB,0
  031C    2B1F    JP	0x31F
390:                      RBIF = 0;            //清中断标志
  031D    100B    CLRB	0xB,0
391:                      Init_Config();
  031E    2283    CALL	0x283
  031F    0873    LD	A,0x73
  0320    008A    LD	0xA,A
  0321    0872    LD	A,0x72
  0322    0084    LD	0x4,A
  0323    0E71    SWAPA	0x71
  0324    0083    LD	0x3,A
  0325    0EFE    SWAPR	0x7E
  0326    0E7E    SWAPA	0x7E
  0327    0009    RETI
392:                  }
393:              }
394:              
395:              
396:              
---- E:\project\project0508\scm\uf166fan\scankey.c ----------------------------------------------------------------------
1:                #include "scankey.h"
2:                
3:                void sacnKeyInput(struct Keys *key) {
  02C2    00C7    LD	0x47,A
4:                    key->key_input = getbit(key->key_addr_result, key->key_index);
  02C3    3E05    ADDIA	0x5
  02C4    0084    LD	0x4,A
  02C5    1383    CLRB	0x3,7
  02C6    0800    LD	A,0x0
  02C7    00F4    LD	0x74,A
  02C8    0847    LD	A,0x47
  02C9    3E06    ADDIA	0x6
  02CA    0084    LD	0x4,A
  02CB    0A00    INCA	0x0
  02CC    2ACF    JP	0x2CF
  02CD    1003    CLRB	0x3,0
  02CE    0CF4    RRCR	0x74
  02CF    3EFF    ADDIA	0xFF
  02D0    1D03    SNZB	0x3,2
  02D1    2ACD    JP	0x2CD
  02D2    0874    LD	A,0x74
  02D3    00F5    LD	0x75,A
  02D4    0847    LD	A,0x47
  02D5    3E04    ADDIA	0x4
  02D6    0084    LD	0x4,A
  02D7    0875    LD	A,0x75
  02D8    0080    LD	0x0,A
  02D9    0847    LD	A,0x47
  02DA    3E04    ADDIA	0x4
  02DB    0084    LD	0x4,A
  02DC    3001    LDIA	0x1
  02DD    0580    ANDR	0x0
  02DE    0008    RET
5:                
6:                }
7:                
8:                
9:                unsigned char key_driver(struct Keys *key) {
  014D    1283    CLRB	0x3,5
  014E    1303    CLRB	0x3,6
  014F    00C9    LD	0x49,A
10:               
11:               
12:                   unsigned char key_return = key_no;
  0150    01C7    CLR	0x47
13:                   unsigned char key_read = key->key_input;  //read the I/O states
  0151    3E04    ADDIA	0x4
  0152    0084    LD	0x4,A
  0153    1383    CLRB	0x3,7
  0154    0800    LD	A,0x0
  0155    00C8    LD	0x48,A
14:               
15:                   switch (key->key_state_buffer1) {
  0156    2982    JP	0x182
16:                       case key_state_0:
17:                           if (key_read == 0) {
  0157    0848    LD	A,0x48
  0158    1D03    SNZB	0x3,2
  0159    298F    JP	0x18F
18:                               key->key_state_buffer1 = key_state_1;
  015A    0A49    INCA	0x49
  015B    0084    LD	0x4,A
  015C    0180    CLR	0x0
  015D    0A80    INCR	0x0
  015E    298F    JP	0x18F
19:                           }
20:               
21:                           //按键被按下，状态转换到按键消抖和确认状态//
22:                           break;
23:               
24:                       case key_state_1:
25:                           if (key_read == 0) {
  015F    0848    LD	A,0x48
  0160    1D03    SNZB	0x3,2
  0161    297E    JP	0x17E
26:                               key->key_timer_cnt1 = 0;
  0162    0849    LD	A,0x49
  0163    0084    LD	0x4,A
  0164    0180    CLR	0x0
27:                               key->key_state_buffer1 = key_state_2;
  0165    0A49    INCA	0x49
  0166    0084    LD	0x4,A
  0167    3002    LDIA	0x2
  0168    297A    JP	0x17A
28:                               //按键仍然处于按下状态
29:                               //消抖完成，key_timer开始准备计时
30:                               //状态切换到按下时间计时状态
31:                           } else {
32:                               key->key_state_buffer1 = key_state_0;
33:                           }
34:               
35:                           //按键已经抬起，回到按键初始状态
36:                           break;  //完成软件消抖
37:               
38:                       case key_state_2:
39:                           if (key_read == 1) {
  0169    0B48    SZDECA	0x48
  016A    296E    JP	0x16E
40:                               key_return = key_click;  //按键抬起，产生一次click操作
  016B    01C7    CLR	0x47
  016C    0AC7    INCR	0x47
  016D    297E    JP	0x17E
41:                               key->key_state_buffer1 = key_state_0;  //转换到按键初始状态
  016E    0849    LD	A,0x49
  016F    0084    LD	0x4,A
  0170    3064    LDIA	0x64
  0171    0A80    INCR	0x0
  0172    0200    SUBA	0x0
  0173    1C03    SNZB	0x3,0
  0174    298F    JP	0x18F
42:                           } else if (++(key->key_timer_cnt1) >= 100)  //按键继续按下，计时超过1000ms
43:                           {
44:                               key_return = key_long;  //送回长按事件
  0175    3003    LDIA	0x3
  0176    00C7    LD	0x47,A
45:                               key->key_state_buffer1 = key_state_3;  //转换到等待按键释放状态
  0177    0A49    INCA	0x49
  0178    0084    LD	0x4,A
  0179    3003    LDIA	0x3
  017A    0080    LD	0x0,A
  017B    298F    JP	0x18F
46:               
47:                           }
48:                           break;
49:               
50:                       case key_state_3:  //等待按键释放
51:                           if (key_read == 1)  //按键释放
  017C    0B48    SZDECA	0x48
  017D    298F    JP	0x18F
52:                           {
53:                               key->key_state_buffer1 = key_state_0;  //切回按键初始状态
  017E    0A49    INCA	0x49
  017F    0084    LD	0x4,A
  0180    0180    CLR	0x0
  0181    298F    JP	0x18F
  0182    0A49    INCA	0x49
  0183    0084    LD	0x4,A
  0184    0800    LD	A,0x0
  0185    0084    LD	0x4,A
  0186    3004    LDIA	0x4
  0187    0204    SUBA	0x4
  0188    1803    SZB	0x3,0
  0189    298F    JP	0x18F
  018A    3003    LDIA	0x3
  018B    008A    LD	0xA,A
  018C    30AF    LDIA	0xAF
  018D    0704    ADDA	0x4
  018E    0082    LD	0x2,A
54:                           }
55:               
56:                           break;
57:                   }
58:                   return key_return;
  018F    0847    LD	A,0x47
  0190    0008    RET
59:               }
60:               
61:               /***************************************************************************
62:               函数功能：中层按键处理函数，调用底层函数一次，处理双击事件的判断，
63:                                                       返回上层正确的无键、单击、双击、长按四种状态
64:               本函数由上层循环调用，间隔10ms
65:               ***************************************************************************/
66:               unsigned char key_read(struct Keys *key) {
67:               
68:                   unsigned char key_return = key_no;
69:                   unsigned char key_read = key_driver(key);
70:               //    printf("IO:%d  key status: %d\n",getSimpleKeyInput(key_input),key);
71:                   switch (key->key_state_buffer2) {
72:                       case key_state_0:
73:                           if (key_read == key_click) {
74:                               key->key_timer_cnt2 = 0;  //第一次单击，不返回，到下个状态判断是否会出现双击
75:                               key->key_state_buffer2 = key_state_1;
76:                           } else
77:                               key_return = key_read;  //对于无键、长按，返回原事件
78:                           break;
79:               
80:                       case key_state_1:
81:                           if (key_read == key_click)  //又一次单击，时间间隔小于500ms
82:                           {
83:                               key_return = key_double;  //返回双击事件，回到初始状态
84:                               key->key_state_buffer2 = key_state_0;
85:                           } else if (++(key->key_timer_cnt2) >= 50) {
86:                               //这里500ms内肯定读到的都是无键事件，因为长按大于1000ms
87:                               //在1s前底层返回的都是无键
88:               
89:                               key_return = key_click;  //500ms内没有再次出现单击事件，返回单击事件
90:                               key->key_state_buffer2 = key_state_0;  //返回初始状态
91:               
92:                           }
93:                           break;
94:                   }
95:               
96:                   return key_return;
97:               }
98:               
99:               
100:              void resetKey(struct Keys *key) {
  033B    00F4    LD	0x74,A
  034B    00F0    LD	0x70,A
101:                  key->key_timer_cnt1 = key->key_timer_cnt2 = key->key_state_buffer1 = key->key_state_buffer2 = 0;
  033C    3E03    ADDIA	0x3
  033D    0084    LD	0x4,A
  033E    1383    CLRB	0x3,7
  033F    0180    CLR	0x0
  0340    0A74    INCA	0x74
  0341    0084    LD	0x4,A
  0342    0180    CLR	0x0
  0343    0874    LD	A,0x74
  0344    3E02    ADDIA	0x2
  0345    0084    LD	0x4,A
  0346    0180    CLR	0x0
  0347    0874    LD	A,0x74
  0348    0084    LD	0x4,A
  0349    0180    CLR	0x0
  034A    0008    RET
  034C    3E03    ADDIA	0x3
  034D    0084    LD	0x4,A
  034E    1383    CLRB	0x3,7
  034F    0180    CLR	0x0
  0350    0A70    INCA	0x70
  0351    0084    LD	0x4,A
  0352    0180    CLR	0x0
  0353    0870    LD	A,0x70
  0354    3E02    ADDIA	0x2
  0355    0084    LD	0x4,A
  0356    0180    CLR	0x0
  0357    0870    LD	A,0x70
  0358    0084    LD	0x4,A
  0359    0180    CLR	0x0
  035A    0008    RET
102:              }
---- E:\project\project0508\scm\uf166fan\adc.c ----------------------------------------------------------------------
1:                #include "adc.h"
2:                
3:                /**********************************************************
4:                函数名称：AD_Sample
5:                函数功能：AD检测
6:                入口参数：adch - 检测通道
7:                出口参数：无 
8:                备    注：采样通道需自行设置为模拟口
9:                	      采样10次,取中间八次的平均值为采样结果存于adresult中
10:               **********************************************************/
11:               void ADC_Sample(unsigned char adch)
  001A    00CB    LD	0x4B,A
12:               {
13:               	static unsigned long adsum = 0;
14:               	static unsigned int admin = 0,admax = 0;
15:               	static unsigned char adtimes = 0;
16:               	volatile unsigned int ad_temp;
17:               	ADCON1 = 0;						//左对齐
  001B    1683    SETB	0x3,5
  001C    019F    CLR	0x1F
18:               	ADCON0 = 0X41 | (adch << 2);	//16分频
  001D    1283    CLRB	0x3,5
  001E    084B    LD	A,0x4B
  001F    00C7    LD	0x47,A
  0020    3001    LDIA	0x1
  0021    1003    CLRB	0x3,0
  0022    0DC7    RLCR	0x47
  0023    3EFF    ADDIA	0xFF
  0024    1003    CLRB	0x3,0
  0025    1D03    SNZB	0x3,2
  0026    2822    JP	0x22
  0027    0D47    RLCA	0x47
  0028    3841    ORIA	0x41
  0029    009F    LD	0x1F,A
  002A    0000    NOP
  002B    0000    NOP
19:               	asm("nop");
20:               	asm("nop");
21:               	GODONE = 1;						//开始转换
  002C    1283    CLRB	0x3,5
  002D    1303    CLRB	0x3,6
  002E    149F    SETB	0x1F,1
22:               
23:               	unsigned char i = 0;
  002F    01CC    CLR	0x4C
24:               	while(GODONE)
  0030    1C9F    SNZB	0x1F,1
  0031    2835    JP	0x35
25:               	{
26:               		if(0 == (--i))
  0032    0BCC    SZDECR	0x4C
  0033    2830    JP	0x30
  0034    0008    RET
27:               			return;
28:               	}
29:               	
30:               	ad_temp=(ADRESH<<4)+(ADRESL>>4);	//计算12位AD值
  0035    081E    LD	A,0x1E
  0036    00CD    LD	0x4D,A
  0037    01CE    CLR	0x4E
  0038    0ECD    SWAPR	0x4D
  0039    0ECE    SWAPR	0x4E
  003A    30F0    LDIA	0xF0
  003B    05CE    ANDR	0x4E
  003C    084D    LD	A,0x4D
  003D    390F    ANDIA	0xF
  003E    04CE    ORR	0x4E
  003F    30F0    LDIA	0xF0
  0040    05CD    ANDR	0x4D
  0041    1683    SETB	0x3,5
  0042    0E1E    SWAPA	0x1E
  0043    390F    ANDIA	0xF
  0044    1283    CLRB	0x3,5
  0045    07CD    ADDR	0x4D
  0046    1803    SZB	0x3,0
  0047    0ACE    INCR	0x4E
31:               	
32:               	if(0 == admax)
  0048    0824    LD	A,0x24
  0049    0425    ORA	0x25
  004A    1D03    SNZB	0x3,2
  004B    284E    JP	0x4E
33:               	{
34:               		admax = ad_temp;
  004C    20BF    CALL	0xBF
  004D    2860    JP	0x60
35:               		admin = ad_temp;
36:               	}
37:               	else if(ad_temp > admax)
  004E    084E    LD	A,0x4E
  004F    0225    SUBA	0x25
  0050    1D03    SNZB	0x3,2
  0051    2854    JP	0x54
  0052    084D    LD	A,0x4D
  0053    0224    SUBA	0x24
  0054    1803    SZB	0x3,0
  0055    2858    JP	0x58
38:               		admax = ad_temp;				//AD采样最大值
  0056    20BF    CALL	0xBF
  0057    2864    JP	0x64
39:               	else if(ad_temp < admin)
  0058    0827    LD	A,0x27
  0059    024E    SUBA	0x4E
  005A    1D03    SNZB	0x3,2
  005B    285E    JP	0x5E
  005C    0826    LD	A,0x26
  005D    024D    SUBA	0x4D
  005E    1803    SZB	0x3,0
  005F    2864    JP	0x64
40:               		admin = ad_temp;				//AD采样最小值
  0060    084E    LD	A,0x4E
  0061    00A7    LD	0x27,A
  0062    084D    LD	A,0x4D
  0063    00A6    LD	0x26,A
41:               	
42:               	adsum += ad_temp;
  0064    084D    LD	A,0x4D
  0065    00C7    LD	0x47,A
  0066    084E    LD	A,0x4E
  0067    00C8    LD	0x48,A
  0068    01C9    CLR	0x49
  0069    01CA    CLR	0x4A
  006A    0847    LD	A,0x47
  006B    07A0    ADDR	0x20
  006C    0848    LD	A,0x48
  006D    1103    CLRB	0x3,2
  006E    1803    SZB	0x3,0
  006F    3E01    ADDIA	0x1
  0070    1D03    SNZB	0x3,2
  0071    07A1    ADDR	0x21
  0072    0849    LD	A,0x49
  0073    1103    CLRB	0x3,2
  0074    1803    SZB	0x3,0
  0075    3E01    ADDIA	0x1
  0076    1D03    SNZB	0x3,2
  0077    07A2    ADDR	0x22
  0078    084A    LD	A,0x4A
  0079    1103    CLRB	0x3,2
  007A    1803    SZB	0x3,0
  007B    3E01    ADDIA	0x1
  007C    1D03    SNZB	0x3,2
  007D    07A3    ADDR	0x23
43:               	if(++adtimes >= 10)
  007E    300A    LDIA	0xA
  007F    0AB0    INCR	0x30
  0080    0230    SUBA	0x30
  0081    1C03    SNZB	0x3,0
  0082    0008    RET
44:               	{
45:               		adsum -= admax;
  0083    0824    LD	A,0x24
  0084    00C7    LD	0x47,A
  0085    0825    LD	A,0x25
  0086    20B0    CALL	0xB0
  0087    1C03    SNZB	0x3,0
  0088    0F4A    SZINCA	0x4A
  0089    02A3    SUBR	0x23
46:               		adsum -= admin;
  008A    0826    LD	A,0x26
  008B    00C7    LD	0x47,A
  008C    0827    LD	A,0x27
  008D    20B0    CALL	0xB0
  008E    1C03    SNZB	0x3,0
  008F    0F4A    SZINCA	0x4A
  0090    02A3    SUBR	0x23
47:               		
48:               		adresult = adsum >> 3;		//8次平均值作为最终结果
  0091    0820    LD	A,0x20
  0092    00C7    LD	0x47,A
  0093    0821    LD	A,0x21
  0094    00C8    LD	0x48,A
  0095    0822    LD	A,0x22
  0096    00C9    LD	0x49,A
  0097    0823    LD	A,0x23
  0098    00CA    LD	0x4A,A
  0099    3003    LDIA	0x3
  009A    1003    CLRB	0x3,0
  009B    0CCA    RRCR	0x4A
  009C    0CC9    RRCR	0x49
  009D    0CC8    RRCR	0x48
  009E    0CC7    RRCR	0x47
  009F    3EFF    ADDIA	0xFF
  00A0    1D03    SNZB	0x3,2
  00A1    289A    JP	0x9A
  00A2    0848    LD	A,0x48
  00A3    00AF    LD	0x2F,A
  00A4    0847    LD	A,0x47
  00A5    00AE    LD	0x2E,A
49:               		
50:               		adsum = 0;
  00A6    01A0    CLR	0x20
  00A7    01A1    CLR	0x21
  00A8    01A2    CLR	0x22
  00A9    01A3    CLR	0x23
51:               		admin = 0;
  00AA    01A6    CLR	0x26
  00AB    01A7    CLR	0x27
52:               		admax = 0;
  00AC    01A4    CLR	0x24
  00AD    01A5    CLR	0x25
53:               		adtimes = 0;
  00AE    01B0    CLR	0x30
  00AF    0008    RET
54:               	}
55:               }
56:               
57:               
58:               //ADC单次采样
59:               unsigned char ADC_Result(unsigned char adch)
  02DF    00C7    LD	0x47,A
60:               {
61:               	ADCON1 = 0;						//左对齐
  02E0    1683    SETB	0x3,5
  02E1    019F    CLR	0x1F
62:               	ADCON0 = 0X41 | (adch << 2);	//16分频
  02E2    1283    CLRB	0x3,5
  02E3    0847    LD	A,0x47
  02E4    00F4    LD	0x74,A
  02E5    3001    LDIA	0x1
  02E6    1003    CLRB	0x3,0
  02E7    0DF4    RLCR	0x74
  02E8    3EFF    ADDIA	0xFF
  02E9    1003    CLRB	0x3,0
  02EA    1D03    SNZB	0x3,2
  02EB    2AE7    JP	0x2E7
  02EC    0D74    RLCA	0x74
  02ED    3841    ORIA	0x41
  02EE    009F    LD	0x1F,A
  02EF    0000    NOP
  02F0    0000    NOP
63:               	asm("nop");
64:               	asm("nop");
65:               	GODONE = 1;						//开始转换
  02F1    1283    CLRB	0x3,5
  02F2    1303    CLRB	0x3,6
  02F3    149F    SETB	0x1F,1
66:               
67:               	unsigned char i = 0;
  02F4    01C8    CLR	0x48
68:               	while(GODONE)
  02F5    1C9F    SNZB	0x1F,1
  02F6    2AFA    JP	0x2FA
69:               	{
70:               		if(0 == (--i))
  02F7    0BC8    SZDECR	0x48
  02F8    2AF5    JP	0x2F5
71:               			return 0;				//转换超时
  02F9    3400    RET	0x0
72:               	}
73:               	return ADRESH;
  02FA    081E    LD	A,0x1E
  02FB    0008    RET
74:               }
75:               /***********************************************************
76:               函数名称：DelayXms
77:               函数功能：毫秒级非精准延时
78:               入口参数：x - 延时时间
79:               出口参数：
80:               备    注：
81:               ***********************************************************/
82:               void DelayXms(unsigned char x)
  0375    00C7    LD	0x47,A
83:               {
84:               	unsigned char i,j;
85:               	for(i=x;i>0;i--)
  0376    00C8    LD	0x48,A
  0377    0848    LD	A,0x48
  0378    1903    SZB	0x3,2
  0379    0008    RET
86:               		for(j=153;j>0;j--);
  037A    3099    LDIA	0x99
  037B    00C9    LD	0x49,A
  037C    0BC9    SZDECR	0x49
  037D    2B7C    JP	0x37C
  037E    03C8    DECR	0x48
  037F    2B77    JP	0x377
87:               }
88:               
89:               //读取内部电压
90:               unsigned char readVrefADC()
91:               {
92:               	DelayXms(1);
  03A4    3001    LDIA	0x1
  03A5    2375    CALL	0x375
93:               	ADC_Sample(15);
  03A6    300F    LDIA	0xF
  03A7    201A    CALL	0x1A
  03A8    300F    LDIA	0xF
  03A9    2ADF    JP	0x2DF
94:               	unsigned char result;
95:               		
96:               	result = ADC_Result(15);
97:               	return result;
98:               }
---- E:\cms\SCMCU_IDE_V2.00.07\data\sources\common\awdiv.c ----------------------------------------------------------------------
1:                // integer signed division
2:                
3:                signed int
4:                #ifdef __PICC__
5:                #warning TODO: update cgpic and this file to use the other prototype
6:                __awdiv(signed int divisor, signed int dividend)
  00C4    01CC    CLR	0x4C
  00C5    1FC8    SNZB	0x48,7
  00C6    28CE    JP	0xCE
  00C7    09C7    COMR	0x47
  00C8    09C8    COMR	0x48
  00C9    0AC7    INCR	0x47
  00CA    1903    SZB	0x3,2
  00CB    0AC8    INCR	0x48
  00CC    01CC    CLR	0x4C
  00CD    0ACC    INCR	0x4C
  00CE    1FCA    SNZB	0x4A,7
  00CF    28D7    JP	0xD7
  00D0    09C9    COMR	0x49
  00D1    09CA    COMR	0x4A
  00D2    0AC9    INCR	0x49
  00D3    1903    SZB	0x3,2
  00D4    0ACA    INCR	0x4A
  00D5    3001    LDIA	0x1
  00D6    06CC    XORR	0x4C
  00D7    01CD    CLR	0x4D
  00D8    01CE    CLR	0x4E
  00D9    0847    LD	A,0x47
  00DA    0448    ORA	0x48
  00DB    1903    SZB	0x3,2
  00DC    28FC    JP	0xFC
  00DD    01CB    CLR	0x4B
  00DE    0ACB    INCR	0x4B
  00DF    1BC8    SZB	0x48,7
  00E0    28E5    JP	0xE5
  00E1    1003    CLRB	0x3,0
  00E2    0DC7    RLCR	0x47
  00E3    0DC8    RLCR	0x48
  00E4    28DE    JP	0xDE
  00E5    1003    CLRB	0x3,0
  00E6    0DCD    RLCR	0x4D
  00E7    0DCE    RLCR	0x4E
  00E8    0848    LD	A,0x48
  00E9    024A    SUBA	0x4A
  00EA    1D03    SNZB	0x3,2
  00EB    28EE    JP	0xEE
  00EC    0847    LD	A,0x47
  00ED    0249    SUBA	0x49
  00EE    1C03    SNZB	0x3,0
  00EF    28F8    JP	0xF8
  00F0    0847    LD	A,0x47
  00F1    02C9    SUBR	0x49
  00F2    0848    LD	A,0x48
  00F3    1C03    SNZB	0x3,0
  00F4    03CA    DECR	0x4A
  00F5    02CA    SUBR	0x4A
  00F6    144D    SETB	0x4D,0
  00F7    1003    CLRB	0x3,0
  00F8    0CC8    RRCR	0x48
  00F9    0CC7    RRCR	0x47
  00FA    0BCB    SZDECR	0x4B
  00FB    28E5    JP	0xE5
  00FC    084C    LD	A,0x4C
  00FD    1903    SZB	0x3,2
  00FE    2904    JP	0x104
  00FF    09CD    COMR	0x4D
  0100    09CE    COMR	0x4E
  0101    0ACD    INCR	0x4D
  0102    1903    SZB	0x3,2
  0103    0ACE    INCR	0x4E
  0104    084E    LD	A,0x4E
  0105    00C8    LD	0x48,A
  0106    084D    LD	A,0x4D
  0107    00C7    LD	0x47,A
  0108    0008    RET
7:                #else
8:                __awdiv(signed int dividend, signed int divisor)
9:                #endif
10:               {
11:               	signed int	quotient;
12:               	unsigned char	counter, sign;
13:               
14:               	sign = 0;
15:               	if(divisor < 0) {
16:               		divisor = -divisor;
17:               		sign = 1;
18:               	}
19:               	if(dividend < 0) {
20:               		dividend = -dividend;
21:               		sign ^= 1;
22:               	}
23:               	quotient = 0;
24:               	if(divisor != 0) {
25:               		counter = 1;
26:               		while((divisor & 0x8000U) == 0) {
27:               			divisor <<= 1;
28:               			counter++;
29:               		}
30:               		do {
31:               			quotient <<= 1;
32:               			if((unsigned int)divisor <= (unsigned int)dividend) {
33:               				dividend -= divisor;
34:               				quotient |= 1;
35:               			}
36:               			*(unsigned int *)&divisor >>= 1;
37:               		} while(--counter != 0);
38:               	}
39:               	if(sign)
40:               		quotient = -quotient;
41:               	return quotient;
42:               }
---- E:\project\project0508\scm\uf166fan\init.c ----------------------------------------------------------------------
1:                #include "init.h"
2:                
3:                void Init_System() {
  038B    0000    NOP
  038C    0064    CLRWDT
  03B3    0000    NOP
  03B4    0064    CLRWDT
4:                    asm("nop");
5:                    asm("clrwdt");
6:                    INTCON = 0;                    //系统初始化
7:                    OSCCON = 0X71;                //配置振荡为8M,开 WDT
8:                    OPTION_REG = 0x00;        //Timer0使用内部时钟Focs/4，预分频比为1:2
  038D    2B8E    JP	0x38E
  03B5    2B8E    JP	0x38E
9:                
10:               }
11:               
12:               
13:               void Init_GPIO() {
14:                   TRISA = 0;
15:                   TRISB = 0;
16:                   TRISC = 0;
17:                   WPUA = 0xFF;
18:                   WPUB = 0xFF;
19:                   WPUC = 0xFF;
20:                   PORTA = 0xFF;
21:                   PORTB = 0xFF;
22:                   PORTC = 0xFF;
23:                   IOCB = 0x00;
  0328    2B29    JP	0x329
  03B8    2B29    JP	0x329
24:               
25:               }
26:               
27:               void Init_Interupt() {
28:                   OPTION_REG = 0x00;        //Timer0使用内部时钟Focs/4，预分频比为1:2
29:                   TMR0 = 0;                //赋予初始值
30:                   INTCON = 0xE0;            //允许所有未被屏蔽的中断、禁止外设中断，使能Timer0
  039D    2B9E    JP	0x39E
  03B7    2B9E    JP	0x39E
31:               
32:               }
---- stringtab ------------------------------------------------------------------
---- reset_enter ------------------------------------------------------------------
  0000    280C    JP	0xC
  000C    280D    JP	0xD
---- start_initialization ------------------------------------------------------------------
  000D    3002    LDIA	0x2
  000E    00F8    LD	0x78,A
  000F    3003    LDIA	0x3
  0010    00F9    LD	0x79,A
  0011    3020    LDIA	0x20
  0012    1383    CLRB	0x3,7
  0013    0084    LD	0x4,A
  0014    3047    LDIA	0x47
  0015    2395    CALL	0x395
  0016    01F6    CLR	0x76
  0017    01F7    CLR	0x77
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F1    LD	0x71,A
  0007    0804    LD	A,0x4
  0008    00F2    LD	0x72,A
  0009    080A    LD	A,0xA
  000A    00F3    LD	0x73,A
  000B    2B12    JP	0x312
---- common_function ------------------------------------------------------------------
  0018    0183    CLR	0x3
  0019    2A08    JP	0x208
  00B0    00C8    LD	0x48,A
  00B1    01C9    CLR	0x49
  00B2    01CA    CLR	0x4A
  00B3    0847    LD	A,0x47
  00B4    02A0    SUBR	0x20
  00B5    0848    LD	A,0x48
  00B6    1C03    SNZB	0x3,0
  00B7    0F48    SZINCA	0x48
  00B8    02A1    SUBR	0x21
  00B9    0849    LD	A,0x49
  00BA    1C03    SNZB	0x3,0
  00BB    0F49    SZINCA	0x49
  00BC    02A2    SUBR	0x22
  00BD    084A    LD	A,0x4A
  00BE    0008    RET
  00BF    084E    LD	A,0x4E
  00C0    00A5    LD	0x25,A
  00C1    084D    LD	A,0x4D
  00C2    00A4    LD	0x24,A
  00C3    0008    RET
  013D    082F    LD	A,0x2F
  013E    00C8    LD	0x48,A
  013F    082E    LD	A,0x2E
  0140    00C7    LD	0x47,A
  0141    3000    LDIA	0x0
  0142    1003    CLRB	0x3,0
  0143    0CC8    RRCR	0x48
  0144    0CC7    RRCR	0x47
  0145    1003    CLRB	0x3,0
  0146    0CC8    RRCR	0x48
  0147    0CC7    RRCR	0x47
  0148    1003    CLRB	0x3,0
  0149    0CC8    RRCR	0x48
  014A    0CC7    RRCR	0x47
  014B    0248    SUBA	0x48
  014C    0008    RET
  01FB    1683    SETB	0x3,5
  01FC    1087    CLRB	0x7,1
  01FD    1785    SETB	0x5,7
  01FE    1007    CLRB	0x7,0
  01FF    1283    CLRB	0x3,5
  0200    1385    CLRB	0x5,7
  0201    0008    RET
  0202    1683    SETB	0x3,5
  0203    1407    SETB	0x7,0
  0204    1385    CLRB	0x5,7
  0205    1087    CLRB	0x7,1
  0206    1283    CLRB	0x3,5
  0207    0008    RET
  028E    3004    LDIA	0x4
  028F    0096    LD	0x16,A
  0290    309B    LDIA	0x9B
  0291    1283    CLRB	0x3,5
  0292    0081    LD	0x1,A
  0293    1203    CLRB	0x3,4
  0294    3005    LDIA	0x5
  0295    00C6    LD	0x46,A
  0296    3004    LDIA	0x4
  0297    00BF    LD	0x3F,A
  0298    3003    LDIA	0x3
  0299    00B8    LD	0x38,A
  029A    3440    RET	0x40
  029B    1683    SETB	0x3,5
  029C    1303    CLRB	0x3,6
  029D    0185    CLR	0x5
  029E    307E    LDIA	0x7E
  029F    0086    LD	0x6,A
  02A0    0187    CLR	0x7
  02A1    1283    CLRB	0x3,5
  02A2    01B1    CLR	0x31
  02A3    0008    RET
  0329    0185    CLR	0x5
  032A    0186    CLR	0x6
  032B    0187    CLR	0x7
  032C    30FF    LDIA	0xFF
  032D    1703    SETB	0x3,6
  032E    008E    LD	0xE,A
  032F    1303    CLRB	0x3,6
  0330    0095    LD	0x15,A
  0331    1703    SETB	0x3,6
  0332    008F    LD	0xF,A
  0333    1283    CLRB	0x3,5
  0334    1303    CLRB	0x3,6
  0335    0085    LD	0x5,A
  0336    0086    LD	0x6,A
  0337    0087    LD	0x7,A
  0338    1683    SETB	0x3,5
  0339    0196    CLR	0x16
  033A    0008    RET
  035C    300F    LDIA	0xF
  035D    0097    LD	0x17,A
  035E    0192    CLR	0x12
  035F    3007    LDIA	0x7
  0360    1683    SETB	0x3,5
  0361    0092    LD	0x12,A
  0362    1283    CLRB	0x3,5
  0363    0195    CLR	0x15
  0364    108C    CLRB	0xC,1
  0365    0192    CLR	0x12
  0366    1683    SETB	0x3,5
  0367    1107    CLRB	0x7,2
  0368    0008    RET
  038E    018B    CLR	0xB
  038F    3071    LDIA	0x71
  0390    1683    SETB	0x3,5
  0391    1303    CLRB	0x3,6
  0392    008F    LD	0xF,A
  0393    0181    CLR	0x1
  0394    0008    RET
  0395    0064    CLRWDT
  0396    0180    CLR	0x0
  0397    0A84    INCR	0x4
  0398    0604    XORA	0x4
  0399    1903    SZB	0x3,2
  039A    3400    RET	0x0
  039B    0604    XORA	0x4
  039C    2B96    JP	0x396
  039E    0181    CLR	0x1
  039F    1283    CLRB	0x3,5
  03A0    0181    CLR	0x1
  03A1    30E0    LDIA	0xE0
  03A2    008B    LD	0xB,A
  03A3    0008    RET
  03AA    29D1    JP	0x1D1
  03AB    29D5    JP	0x1D5
  03AC    29D9    JP	0x1D9
  03AD    29DE    JP	0x1DE
  03AE    29E3    JP	0x1E3
  03AF    2957    JP	0x157
  03B0    295F    JP	0x15F
  03B1    2969    JP	0x169
  03B2    297C    JP	0x17C
