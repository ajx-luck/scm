---- F:\中微资料\SC8F289XB开发包\SC8F289XB_DEMO_C\SC8F289XB_SPI_master_Demo\main.c ----------------------------------------------------------------------
1:                /**********************************************************
2:                
3:                **********************************************************/
4:                
5:                #include <sc.h>
6:                
7:                
8:                
9:                volatile unsigned int   result,result1,result2;
10:               volatile unsigned char ReceBuffer;	//接收到的数据
11:               volatile unsigned char SendBuffer;	//待发送的数据
12:               volatile unsigned char IICReadData;
13:               
14:               void DelayXms(unsigned char x);
15:               void Init_System();
16:               
17:               /***********************************************************
18:               函数名称：DelayXms
19:               函数功能：毫秒级非精准延时
20:               入口参数：x - 延时时间
21:               出口参数：
22:               备    注：
23:               ***********************************************************/
24:               void DelayXms(unsigned char x)
  07BD    00F9    LD	0x79,A
25:               {
26:               	unsigned char i,j;
27:               	for(i=x;i>0;i--)
  07BE    00FA    LD	0x7A,A
  07BF    087A    LD	A,0x7A
  07C0    1903    SZB	0x3,2
  07C1    0008    RET
28:               		for(j=153;j>0;j--);
  07C2    3099    LDIA	0x99
  07C3    00FB    LD	0x7B,A
  07C4    0BFB    SZDECR	0x7B
  07C5    2FC4    JP	0x7C4
  07C6    03FA    DECR	0x7A
  07C7    2FBF    JP	0x7BF
29:               }
30:               
31:               /***********************************************************
32:               main主函数
33:               ***********************************************************/
34:               
35:               void main()
36:               {
37:               	Init_System();
  07DB    118A    CLRB	0xA,3
  07DC    27C8    CALL	0x7C8
  07DD    118A    CLRB	0xA,3
38:               	
39:               	/**************SPICON*********************
40:               		Bit7 SPIWCOL: 写冲突标志位  
41:               			1= 在发送/接收数据过程中，试图对SPIBUF寄存器进行写操作。 
42:               			0= 未发生冲突。 
43:               		Bit6 SPIOV: 接收溢出指示位。 
44:               			1= SPIBUF仍保持前一数据时，又收到一个新的字节。出现溢出时，SPISR中的数据会丢失。溢出只会在从动模式下发生。
45:               				在从动模式中，即使仅发送数据，用户也必须读SPIBUF以避免溢出。
46:               				在主控模式中，溢出位不被置1，因为每次接收或发送新数据，都要通过写SPIBUF寄存器来启动（该位必须由软件清零）。 
47:               			0= 没有溢出。 
48:               		Bit5 SPIEN: SPI使能位。 
49:               			1= 使能串行端口并将SCK、SDO、SDI和SS配置为串行端口引脚。
50:               			0= 禁止串行端口并将这些引脚配置为I/O端口引脚。 
51:               		Bit4 SPICKP: 时钟极性选择位。 
52:               			1= 时钟空闲状态为高电平。 
53:               			0= 时钟空闲状态为低电平。 
54:               		Bit3~Bit0 SPIM<3:0>: 同步串行端口模式选择位； 
55:               			0000= SPI主控模式，时钟= FSYS/4； 
56:               			0001= SPI主控模式，时钟= FSYS/16； 
57:               			0010= SPI主控模式，时钟= FSYS/64； 
58:               			0011= SPI主控模式，时钟= TMR2输出/2； 
59:               			0100= SPI从动模式，时钟= SCK引脚，使能SS引脚控制； 
60:               			0101= SPI从动模式，时钟= SCK引脚，禁止SS引脚控制，SS可用作I/O引脚；
61:               	*************************************************/ 
62:               	SPICON =   0B00100010;  // SPI  使能 主动模式
  07DE    3022    LDIA	0x22
  07DF    1703    SETB	0x3,6
  07E0    009D    LD	0x1D,A
63:               	
64:               	/***********SPICON2********************************************
65:               		Bit7 保留 需写0 
66:               		Bit6 CKE: SPI时钟边沿选择位。（注：在从动模式下，CKE必须设置为0） 
67:               			SPICKP= 0  0= 在SCK引脚的上升沿发送数据； 1= 在SCK引脚的下降沿发送数据。 
68:               			SPICKP = 1  0 = 在SCK引脚的下降沿发送数据；  1 = 在SCK引脚的上升沿发送数据。 
69:               		Bit5 MODE: 模式选择  
70:               				1=3线模式 (当需要发送时，SDIO口TRIS位需清0；当需要接收时，SDIO口TRIS需置1)  
71:               				0=4线模式 
72:               		Bit4~Bit1 未用。 
73:               		Bit0 SPIBF 缓冲器满状态位。  
74:               				1= 接收完成，SPIBUF满。  0= 接收未完成，SPIBUF空
75:               	************************************************************/
76:               	SPICON2 =  0B00000000;  // SPI  4线  主动模式
  07E1    019E    CLR	0x1E
77:                   
78:               	SPIIF =0;
  07E2    1303    CLRB	0x3,6
  07E3    118C    CLRB	0xC,3
79:               	PEIE =1;
  07E4    170B    SETB	0xB,6
80:               
81:               	while(1)
82:               	{
83:                        DelayXms(200);
  07E5    30C8    LDIA	0xC8
  07E6    118A    CLRB	0xA,3
  07E7    27BD    CALL	0x7BD
  07E8    118A    CLRB	0xA,3
84:               		 SPIBUF = 0x05;  //待发送数据
  07E9    3005    LDIA	0x5
  07EA    1703    SETB	0x3,6
  07EB    009C    LD	0x1C,A
85:               		 while(SPIIF==0);  //等待发送完成
  07EC    1303    CLRB	0x3,6
  07ED    1D8C    SNZB	0xC,3
  07EE    2FEC    JP	0x7EC
86:               		 SPIIF = 0;
  07EF    118C    CLRB	0xC,3
87:               	    	ReceBuffer = SPIBUF; //读取从机数据
  07F0    1703    SETB	0x3,6
  07F1    081C    LD	A,0x1C
  07F2    00F8    LD	0x78,A
  07F3    2FE5    JP	0x7E5
88:               
89:               	}
90:               }
91:               
92:               
93:               
94:               /***********************************************
95:               函数名称：Init_System
96:               函数功能：系统初始化
97:               入口参数：无
98:               出口参数：无
99:               备注：
100:              ************************************************/
101:              void Init_System()
  07C8    0000    NOP
  07C9    0064    CLRWDT
102:              {
103:              	asm("nop");
104:              	asm("clrwdt");
105:              	INTCON = 0;					//系统初始化
  07CA    018B    CLR	0xB
106:              	OSCCON = 0X70;				//配置振荡为8M,关 WDT
  07CB    3070    LDIA	0x70
  07CC    1683    SETB	0x3,5
  07CD    1303    CLRB	0x3,6
  07CE    0088    LD	0x8,A
107:              	OPTION_REG = 0;
  07CF    0181    CLR	0x1
108:              	
109:                  WPUA  = 0B00000000;			//初始化上拉
  07D0    1283    CLRB	0x3,5
  07D1    0187    CLR	0x7
110:                  WPUB  = 0B00000000;			
  07D2    0188    CLR	0x8
111:                
112:               
113:              	TRISA = 0B00000000;			//初始化IO状态
  07D3    1683    SETB	0x3,5
  07D4    0185    CLR	0x5
114:              	TRISB = 0B00100100;
  07D5    3024    LDIA	0x24
  07D6    0086    LD	0x6,A
115:              
116:              	PORTA = 0B00000000;
  07D7    1283    CLRB	0x3,5
  07D8    0185    CLR	0x5
117:              	PORTB = 0B00000000;			//初始化输出
  07D9    0186    CLR	0x6
  07DA    0008    RET
118:              
119:              }
120:              
---- stringtab ------------------------------------------------------------------
---- reset_enter ------------------------------------------------------------------
  0000    118A    CLRB	0xA,3
  0001    2FF4    JP	0x7F4
---- start_initialization ------------------------------------------------------------------
  07F4    01F0    CLR	0x70
  07F5    01F1    CLR	0x71
  07F6    01F2    CLR	0x72
  07F7    01F3    CLR	0x73
  07F8    01F4    CLR	0x74
  07F9    01F5    CLR	0x75
  07FA    01F6    CLR	0x76
  07FB    01F7    CLR	0x77
  07FC    01F8    CLR	0x78
---- interrupt_function_enter ----------------------------------------------------------
---- common_function ------------------------------------------------------------------
  07FD    0183    CLR	0x3
  07FE    118A    CLRB	0xA,3
  07FF    2FDB    JP	0x7DB
