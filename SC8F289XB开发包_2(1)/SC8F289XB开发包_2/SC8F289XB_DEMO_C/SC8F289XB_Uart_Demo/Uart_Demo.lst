---- F:\中微资料\SC8F289XB开发包\SC8F289XB_DEMO_C\SC8F289XB_Uart_Demo\main.c ----------------------------------------------------------------------
1:                /**********************************************************
2:                   波特率9600
3:                   8位数据格式，无校验
4:                   接收10个字节数字，然后发送出来
5:                **********************************************************/
6:                
7:                #include <sc.h>
8:                
9:                volatile unsigned int   result,result1,result2;
10:               
11:               unsigned char RxTable[10];
12:               bit RXOK_f;
13:               unsigned int  Read_ADC(unsigned char  ADCchannel,unsigned char  ADCLDORef);
14:               void DelayXms(unsigned char x);
15:               void Init_System();
16:               
17:               /***********************************************************
18:               函数名称：DelayXms
19:               函数功能：毫秒级非精准延时
20:               入口参数：x - 延时时间
21:               出口参数：
22:               备    注：
23:               ***********************************************************/
24:               void DelayXms(unsigned char x)
  0089    00AC    LD	0x2C,A
25:               {
26:               	unsigned char i,j;
27:               	for(i=x;i>0;i--)
  008A    00AD    LD	0x2D,A
  008B    082D    LD	A,0x2D
  008C    1903    SZB	0x3,2
  008D    0008    RET
28:               		for(j=153;j>0;j--);
  008E    3099    LDIA	0x99
  008F    00AE    LD	0x2E,A
  0090    0BAE    SZDECR	0x2E
  0091    2890    JP	0x90
  0092    03AD    DECR	0x2D
  0093    288B    JP	0x8B
29:               }
30:               
31:               /***********************************************************
32:               main主函数
33:               ***********************************************************/
34:               void main()
35:               {
36:               	DelayXms(2);
  0026    3002    LDIA	0x2
  0027    118A    CLRB	0xA,3
  0028    2089    CALL	0x89
  0029    118A    CLRB	0xA,3
37:               	unsigned char i =0 ;
38:               	Init_System();
  002A    118A    CLRB	0xA,3
  002B    206A    CALL	0x6A
  002C    118A    CLRB	0xA,3
39:               	
40:               	TXREG =0x55;
  002D    3055    LDIA	0x55
  002E    1703    SETB	0x3,6
  002F    009A    LD	0x1A,A
41:               
42:               	while(TRMT==0);
  0030    1C97    SNZB	0x17,1
  0031    2830    JP	0x30
43:               	TXREG =0xaa;
  0032    30AA    LDIA	0xAA
  0033    009A    LD	0x1A,A
44:               
45:               	while(TRMT==0);
  0034    1C97    SNZB	0x17,1
  0035    2834    JP	0x34
46:               	
47:               	while(1)
48:               	{
49:                
50:               		
51:               		if(RXOK_f==1)
  0036    1C79    SNZB	0x79,0
  0037    2836    JP	0x36
52:               		{
53:               			for(i=0;i<10;i++)
  0038    01F8    CLR	0x78
54:               			{
55:               					
56:               				TXREG =RxTable[i];
  0039    0878    LD	A,0x78
  003A    3E20    ADDIA	0x20
  003B    0084    LD	0x4,A
  003C    1383    CLRB	0x3,7
  003D    0800    LD	A,0x0
  003E    1703    SETB	0x3,6
  003F    009A    LD	0x1A,A
57:               
58:               				while(TRMT==0);
  0040    1C97    SNZB	0x17,1
  0041    2840    JP	0x40
  0042    300A    LDIA	0xA
  0043    0AF8    INCR	0x78
  0044    0278    SUBA	0x78
  0045    1C03    SNZB	0x3,0
  0046    2839    JP	0x39
59:               			}
60:               
61:               			RXOK_f = 0;
  0047    1079    CLRB	0x79,0
  0048    2836    JP	0x36
62:               		}
63:               
64:               	}
65:               }
66:               
67:               
68:               /***********************************************
69:               函数名称：Init_System
70:               函数功能：系统初始化
71:               入口参数：无
72:               出口参数：无
73:               备注：
74:               ************************************************/
75:               void Init_System()
  006A    0000    NOP
  006B    0064    CLRWDT
76:               {
77:               	asm("nop");
78:               	asm("clrwdt");
79:               	INTCON = 0;					//系统初始化
  006C    018B    CLR	0xB
80:               	OSCCON = 0X70;				//配置振荡为8M,
  006D    3070    LDIA	0x70
  006E    1683    SETB	0x3,5
  006F    1303    CLRB	0x3,6
  0070    0088    LD	0x8,A
81:               	OPTION_REG = 0;
  0071    0181    CLR	0x1
82:               	
83:                   WPUA  = 0B00000000;			//初始化上拉
  0072    1283    CLRB	0x3,5
  0073    0187    CLR	0x7
84:                   WPUB  = 0B00001000;			
  0074    3008    LDIA	0x8
  0075    0088    LD	0x8,A
85:                 
86:                
87:               	TRISA = 0B00000000;			//初始化IO状态
  0076    1683    SETB	0x3,5
  0077    0185    CLR	0x5
88:               	TRISB = 0B00011000;
  0078    3018    LDIA	0x18
  0079    0086    LD	0x6,A
89:               
90:               	PORTA = 0B00000000;
  007A    1283    CLRB	0x3,5
  007B    0185    CLR	0x5
91:               	PORTB = 0B00000000;			//初始化输出
  007C    0186    CLR	0x6
92:               	
93:               	/**************   TXSTA   **************************************
94:               		Bit7 CSRC: 时钟源选择位；  异步模式: 任意值；  同步模式:  
95:               			1=主控模式（由内部BRG产生时钟信号）；  
96:               			0=从动模式（由外部时钟源产生时钟）。 
97:               		Bit6 TX9EN: 9位发送使能位；  
98:               			1= 选择9位发送；  
99:               			0= 选择8位发送。 
100:              		Bit5 TXEN: 发送使能位(1)；  
101:              			1= 使能发送；  
102:              			0= 禁止发送。 
103:              		Bit4 SYNC: USART模式选择位；  
104:              			1= 同步模式；  
105:              			0= 异步模式。 
106:              		Bit3 SCKP: 同步时钟极性选择位。  
107:              			异步模式:  
108:              				1=将数据字符的电平取反后发送到TX/CK引脚；  
109:              				0=直接将数据字符发送到TX/CK引脚。  
110:              			同步模式:  
111:              				0=在时钟上升沿传输数据；  
112:              				1=在时钟下降沿传输数据。 
113:              		Bit2 STOPBIT: 停止位选择（仅对异步发送有效），当通过判断TRMT=1来送数据时，此位需写0。  
114:              			1= 1位停止位；  
115:              			0= 2位停止位。 
116:              		Bit1 TRMT: 发送移位寄存器状态位；  
117:              			1= TSR为空；  
118:              			0= TSR为满。 
119:              		Bit0 TX9D: 发送数据的第9位。 可以是地址/数据位或奇偶校验位
120:              	***********************************************************************/
121:              	TXSTA =  0B10100000;		//主控模式，8位数据，异步模式，
  007D    30A0    LDIA	0xA0
  007E    1703    SETB	0x3,6
  007F    0097    LD	0x17,A
122:              	
123:              	/*****************  RCSTA   ***********************************************
124:              		Bit7 SPEN: 串行端口使能位；  
125:              			1= 使能串行端口（将RX/DT和TX/CK引脚配置为串行端口引脚）； 
126:              			0= 禁止串行端口（保持在复位状态）。 
127:              		Bit6 RX9EN: 9位接收使能位；  
128:              			1= 选择9位接收；  
129:              			0= 选择8位接收。 
130:              		Bit5 SREN: 单字节接收使能位。  
131:              			异步模式: 任意值。  
132:              			同步主控模式:  
133:              				1=使能单字节接收；  
134:              				0=禁止单字节接收。 接收完成后清零该位。  
135:              			同步从动模式: 任意值。 
136:              		Bit4 CREN: 连续接收使能位。  
137:              			异步模式:  
138:              				1=使能接收；  
139:              				0=禁止接收。  
140:              			同步模式:  
141:              				1=使能连续接收直到清零CREN使能位（CREN覆盖SREN）；  
142:              				0=禁止连续接收。 
143:              		Bit3 RCIDL: 接收空闲标志位。  
144:              			异步模式: 
145:              				1=接收器空闲；  
146:              				0=已接收到起始位，接收器正在接收数据。  
147:              			同步模式: 任意值。
148:              		Bit2 FERR: 帧错误位。  
149:              			1= 帧错误（可通过读RCREG寄存器更新并接收下一个有效字节）；  
150:              			0= 没有帧错误。 
151:              		Bit1 OERR: 溢出错误位。  
152:              			1= 溢出错误（可通过清零CREN位清零）；  
153:              			0= 没有溢出错误。 
154:              		Bit0 RX9D: 接收到数据的第9位。 此位可以是地址/数据位或奇偶校验位，必须由用户固件计算得到
155:              	*********************************************************************************/
156:              	
157:              	RCSTA =  0B10010000;		//使能串口，使能接收
  0080    3090    LDIA	0x90
  0081    0098    LD	0x18,A
158:              	SPBRG =  51;        		 //波特率9600，目标波特率=FOSC/16([SPBRG]+1)
  0082    3033    LDIA	0x33
  0083    0099    LD	0x19,A
159:              	
160:              	PEIE =1;
  0084    170B    SETB	0xB,6
161:              	RCIE =1;
  0085    1303    CLRB	0x3,6
  0086    168D    SETB	0xD,5
162:              	GIE =1;
  0087    178B    SETB	0xB,7
  0088    0008    RET
163:              
164:              }
165:              
166:              /***********************************************
167:              函数名称：UART_Isr
168:              函数功能：UART中断服务
169:              入口参数：无
170:              出口参数：无
171:              备注：
172:              ************************************************/
173:              void interrupt UART_Isr()
174:              {
175:              	static unsigned char RxNum=0,TEMP;
176:              	
177:              	if(RCIF==1)
  0049    1283    CLRB	0x3,5
  004A    1303    CLRB	0x3,6
  004B    1E8C    SNZB	0xC,5
  004C    2861    JP	0x61
178:              	{
179:              		RCIF = 0;
  004D    128C    CLRB	0xC,5
180:              	    
181:              		if(RXOK_f==0)	
  004E    1879    SZB	0x79,0
  004F    285F    JP	0x5F
182:              		{
183:              			RxTable[RxNum] = RCREG;
  0050    0874    LD	A,0x74
  0051    3E20    ADDIA	0x20
  0052    0084    LD	0x4,A
  0053    1703    SETB	0x3,6
  0054    081B    LD	A,0x1B
  0055    1383    CLRB	0x3,7
  0056    0080    LD	0x0,A
  0057    300A    LDIA	0xA
184:              			RxNum++;
  0058    0AF4    INCR	0x74
185:              			if(RxNum > 9)
  0059    0274    SUBA	0x74
  005A    1C03    SNZB	0x3,0
  005B    2861    JP	0x61
186:              			{
187:              				RxNum =0;
  005C    01F4    CLR	0x74
188:              				RXOK_f =1;
  005D    1479    SETB	0x79,0
  005E    2861    JP	0x61
189:              			}
190:              		}
191:              		else
192:              		TEMP =  RCREG;
  005F    1703    SETB	0x3,6
  0060    081B    LD	A,0x1B
  0061    0877    LD	A,0x77
  0062    008A    LD	0xA,A
  0063    0876    LD	A,0x76
  0064    0084    LD	0x4,A
  0065    0E75    SWAPA	0x75
  0066    0083    LD	0x3,A
  0067    0EFE    SWAPR	0x7E
  0068    0E7E    SWAPA	0x7E
  0069    0009    RETI
193:              		
194:              	}
195:              }
---- stringtab ------------------------------------------------------------------
---- reset_enter ------------------------------------------------------------------
  0000    118A    CLRB	0xA,3
  0001    280D    JP	0xD
  000D    118A    CLRB	0xA,3
  000E    280F    JP	0xF
---- start_initialization ------------------------------------------------------------------
  000F    01F9    CLR	0x79
  0010    01F0    CLR	0x70
  0011    01F1    CLR	0x71
  0012    01F2    CLR	0x72
  0013    01F3    CLR	0x73
  0014    01F4    CLR	0x74
  0015    1283    CLRB	0x3,5
  0016    1303    CLRB	0x3,6
  0017    01A0    CLR	0x20
  0018    01A1    CLR	0x21
  0019    01A2    CLR	0x22
  001A    01A3    CLR	0x23
  001B    01A4    CLR	0x24
  001C    01A5    CLR	0x25
  001D    01A6    CLR	0x26
  001E    01A7    CLR	0x27
  001F    01A8    CLR	0x28
  0020    01A9    CLR	0x29
  0021    01AA    CLR	0x2A
  0022    01AB    CLR	0x2B
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F5    LD	0x75,A
  0007    0804    LD	A,0x4
  0008    00F6    LD	0x76,A
  0009    080A    LD	A,0xA
  000A    00F7    LD	0x77,A
  000B    118A    CLRB	0xA,3
  000C    2849    JP	0x49
---- common_function ------------------------------------------------------------------
  0023    0183    CLR	0x3
  0024    118A    CLRB	0xA,3
  0025    2826    JP	0x26
