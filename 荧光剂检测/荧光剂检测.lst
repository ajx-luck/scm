---- C:\mcuproject\scm\荧光剂检测\main.c ----------------------------------------------------------------------
1:                #include "adc.h"
2:                #include "number.h"
3:                
4:                #define LEDCTR()		PORTB ^= 0x20
5:                #define BLUEON()	PORTE |= 0x01
6:                #define BLUEOFF()	PORTE &= 0xFE
7:                
8:                typedef unsigned char uint8;
9:                typedef unsigned int uint16;
10:               
11:               //---------定义全局变量--------------
12:               uint8	intCount = 0;
13:               uint8	intFlag = 0;
14:               uint8	nubStep = 0;	//0为无 ----3为强
15:               uint8	tempbaiweiNum = 0;	//百位
16:               uint8	tempshiweiNum = 0;	//十位
17:               uint8	tempgeweiNum = 0;	//个位
18:               uint8 refreshCount = 0;	//刷新计时
19:               uint16	ygNub;			//荧光剂数量
20:               uint8	count500ms = 0;
21:               uint16	timeCount = 0;
22:               uint8	nubShowTime = 20;
23:               uint8	keyClick = 0;
24:               uint8 keyNub = 0;
25:               uint8	keyCount = 0;//消抖计数
26:               char numArray[10] = {0x3F, 0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x67};
27:               
28:               //---------定义方法------------------
29:               void initConfig();
30:               void Sleep_Mode();
31:               void refreshNub();
32:               void keyCtr();
33:               char keyRead(char KeyStatus);
34:               unsigned int ADC_AVG(unsigned char adch,unsigned char adtime);
35:               
36:               void interrupt Timer0_Isr() {
37:                   if (T0IF) 
  03A0    1D0B    SNZB	0xB,2
  03A1    2BB8    JP	0x3B8
38:               	{
39:                       
40:               		//---------------------------------------
41:                       TMR0 = 150;        //重新赋初值，在赋值前Timer0已有计数，故在该基础上加初值
  03A2    3096    LDIA	0x96
  03A3    1283    CLRB	0x3,5
  03A4    1303    CLRB	0x3,6
  03A5    0081    LD	0x1,A
42:                       //---------------------------------------
43:               		if(++intCount >= 100)
  03A6    3064    LDIA	0x64
  03A7    0ABC    INCR	0x3C
  03A8    023C    SUBA	0x3C
  03A9    1C03    SNZB	0x3,0
  03AA    2BB7    JP	0x3B7
  03AB    3064    LDIA	0x64
44:               		{
45:               			intFlag = 1;
  03AC    01BB    CLR	0x3B
  03AD    0ABB    INCR	0x3B
46:               			if(++count500ms >= 100)
  03AE    0AB8    INCR	0x38
  03AF    0238    SUBA	0x38
  03B0    1C03    SNZB	0x3,0
  03B1    2BB7    JP	0x3B7
47:               			{	
48:               				count500ms = 0;
49:               				timeCount++;
  03B2    01B8    CLR	0x38
50:               				if(nubShowTime > 0)
  03B3    087B    LD	A,0x7B
  03B4    1903    SZB	0x3,2
  03B5    2BB7    JP	0x3B7
51:               				{
52:               					--nubShowTime;
  03B6    03FB    DECR	0x7B
53:               				}
54:               			}
55:               		}	
56:                       
57:               		T0IF = 0;            //清中断标志位	
  03B7    110B    CLRB	0xB,2
58:                   }
59:               
60:                   if (RBIF) {
  03B8    180B    SZB	0xB,0
61:                       RBIF = 0;            //清中断标志
  03B9    100B    CLRB	0xB,0
  03BA    0871    LD	A,0x71
  03BB    008A    LD	0xA,A
  03BC    0E70    SWAPA	0x70
  03BD    0083    LD	0x3,A
  03BE    0EFE    SWAPR	0x7E
  03BF    0E7E    SWAPA	0x7E
  03C0    0009    RETI
62:                   }
63:               }
64:               
65:               
66:               void main()
67:               {
68:               	initConfig();
  015A    2357    CALL	0x357
69:               	for(;;)
  015B    0064    CLRWDT
70:               	{
71:               		asm("clrwdt");
72:               		refreshNub();
  015C    2099    CALL	0x99
73:               		if(intFlag == 0)
  015D    1283    CLRB	0x3,5
  015E    1303    CLRB	0x3,6
  015F    083B    LD	A,0x3B
  0160    1903    SZB	0x3,2
  0161    295B    JP	0x15B
74:               			continue;
75:               		intFlag = 0;
  0162    01BB    CLR	0x3B
76:               		
77:               		keyCtr();
  0163    240A    CALL	0x40A
78:               		
79:               		TRISB |= 0x04;
  0164    1683    SETB	0x3,5
  0165    1506    SETB	0x6,2
80:               		ANSEL = 0x00;
  0166    1703    SETB	0x3,6
  0167    0188    CLR	0x8
81:               		ANSELH = 0x01;
  0168    3001    LDIA	0x1
  0169    0089    LD	0x9,A
82:               	
83:               		uint16 res = ADC_AVG(0x0F,8);
  016A    3008    LDIA	0x8
  016B    1283    CLRB	0x3,5
  016C    1303    CLRB	0x3,6
  016D    00A4    LD	0x24,A
  016E    300F    LDIA	0xF
  016F    237E    CALL	0x37E
  0170    0825    LD	A,0x25
  0171    00AE    LD	0x2E,A
  0172    0824    LD	A,0x24
  0173    00AD    LD	0x2D,A
84:               		uint16 av = 6000/res;		//1.2*10000/2 = 6000放大一万倍，再除以2获得某一个刻度的电压值
  0174    082E    LD	A,0x2E
  0175    00F3    LD	0x73,A
  0176    082D    LD	A,0x2D
  0177    00F2    LD	0x72,A
  0178    3070    LDIA	0x70
  0179    00F4    LD	0x74,A
  017A    3017    LDIA	0x17
  017B    00F5    LD	0x75,A
  017C    232D    CALL	0x32D
  017D    0873    LD	A,0x73
  017E    00AC    LD	0x2C,A
  017F    0872    LD	A,0x72
  0180    00AB    LD	0x2B,A
85:               		uint16 res2 = 0;
86:               		for(int i=0;i<10;i++)
  0181    01B1    CLR	0x31
  0182    01B2    CLR	0x32
87:               		{
88:               			refreshNub();
  0183    2099    CALL	0x99
  0184    1283    CLRB	0x3,5
  0185    1303    CLRB	0x3,6
  0186    0AB1    INCR	0x31
  0187    1903    SZB	0x3,2
  0188    0AB2    INCR	0x32
  0189    0832    LD	A,0x32
  018A    3A80    XORIA	0x80
  018B    00FF    LD	0x7F,A
  018C    3080    LDIA	0x80
  018D    027F    SUBA	0x7F
  018E    1D03    SNZB	0x3,2
  018F    2992    JP	0x192
  0190    300A    LDIA	0xA
  0191    0231    SUBA	0x31
  0192    1C03    SNZB	0x3,0
  0193    2983    JP	0x183
89:               		}
90:               		/**
91:               		if(nubShowTime == 20)
92:               		{
93:               			res2 = ADC_AVG(0x08,8);
94:               			res = res2 * av;
95:               			ygNub = res/100;
96:               			//ygNub = res;
97:               		}
98:               		else
99:               		{
100:              			BLUEOFF();
101:              		}
102:              		**/
103:              		
104:              		res2 = ADC_AVG(0x08,8);
  0194    3008    LDIA	0x8
  0195    1283    CLRB	0x3,5
  0196    1303    CLRB	0x3,6
  0197    00A4    LD	0x24,A
  0198    237E    CALL	0x37E
  0199    0825    LD	A,0x25
  019A    00B0    LD	0x30,A
  019B    0824    LD	A,0x24
  019C    00AF    LD	0x2F,A
105:              		if(res2)
  019D    0430    ORA	0x30
  019E    1903    SZB	0x3,2
  019F    29AB    JP	0x1AB
  01A0    0830    LD	A,0x30
  01A1    00F3    LD	0x73,A
  01A2    082F    LD	A,0x2F
  01A3    00F2    LD	0x72,A
  01A4    082C    LD	A,0x2C
  01A5    00F5    LD	0x75,A
  01A6    082B    LD	A,0x2B
  01A7    00F4    LD	0x74,A
  01A8    23DD    CALL	0x3DD
106:              		{
107:              			//res2 = ADC_AVG(0x08,8);
108:              			res = res2 * av;
109:              			//ygNub = res/10;
110:              			nubShowTime = 20;
  01A9    3014    LDIA	0x14
  01AA    00FB    LD	0x7B,A
111:              		}
112:              		nubShowTime = 20;
  01AB    3014    LDIA	0x14
  01AC    00FB    LD	0x7B,A
  01AD    295B    JP	0x15B
113:              		//ygNub = 500;
114:              	}
115:              }
116:              
117:              
118:              void keyCtr()
119:              {
120:              	keyClick = keyRead(0x18&(~PORTB));
  040A    0906    COMA	0x6
  040B    3918    ANDIA	0x18
  040C    242B    CALL	0x42B
  040D    00B7    LD	0x37,A
121:              	if(keyClick > 0)
  040E    0837    LD	A,0x37
  040F    1903    SZB	0x3,2
  0410    0008    RET
122:              	{
123:              		if(keyNub & 0x08)
  0411    1DB6    SNZB	0x36,3
  0412    2C16    JP	0x416
124:              		{
125:              			//K1按下了,控制LED灯
126:              			LEDCTR();
  0413    3020    LDIA	0x20
  0414    0686    XORR	0x6
127:              		}
  0415    0008    RET
128:              		else
129:              		{
130:              			//K2按下了
131:              			BLUEON();
  0416    1409    SETB	0x9,0
132:              			nubShowTime = 20;
  0417    3014    LDIA	0x14
  0418    00FB    LD	0x7B,A
133:              			count500ms = 0;
  0419    01B8    CLR	0x38
  041A    0008    RET
134:              		}
135:              	
136:              	
137:              	}
138:              }
139:              
140:              //刷新数码管
141:              void refreshNub()
142:              {
143:              	if(nubShowTime == 0)
  0099    087B    LD	A,0x7B
  009A    1D03    SNZB	0x3,2
  009B    289D    JP	0x9D
144:              	{
145:              		setInput();
  009C    2BF6    JP	0x3F6
146:              		return;
147:              	}
148:              	if(++refreshCount >= 10)
  009D    300A    LDIA	0xA
  009E    1283    CLRB	0x3,5
  009F    1303    CLRB	0x3,6
  00A0    0AB9    INCR	0x39
  00A1    0239    SUBA	0x39
  00A2    1C03    SNZB	0x3,0
  00A3    28A8    JP	0xA8
149:              	{
150:              		refreshCount = 0;
  00A4    01B9    CLR	0x39
151:              		tempbaiweiNum = ygNub/100;
  00A5    01FA    CLR	0x7A
152:              		tempshiweiNum = (ygNub%100)/10;
  00A6    01F9    CLR	0x79
153:              		tempgeweiNum = ygNub%10;
  00A7    01F8    CLR	0x78
154:              	}
155:              	low1(numArray[tempbaiweiNum],numArray[tempshiweiNum],numArray[tempgeweiNum],1,1);
  00A8    20F2    CALL	0xF2
  00A9    00F4    LD	0x74,A
  00AA    0878    LD	A,0x78
  00AB    3E3D    ADDIA	0x3D
  00AC    0084    LD	0x4,A
  00AD    0800    LD	A,0x0
  00AE    00F5    LD	0x75,A
  00AF    01F6    CLR	0x76
  00B0    0AF6    INCR	0x76
  00B1    01F7    CLR	0x77
  00B2    0AF7    INCR	0x77
  00B3    20F8    CALL	0xF8
  00B4    22C0    CALL	0x2C0
156:              	low2(numArray[tempbaiweiNum],numArray[tempshiweiNum],numArray[tempgeweiNum],1);
  00B5    20F2    CALL	0xF2
  00B6    00F4    LD	0x74,A
  00B7    0878    LD	A,0x78
  00B8    3E3D    ADDIA	0x3D
  00B9    0084    LD	0x4,A
  00BA    0800    LD	A,0x0
  00BB    00F5    LD	0x75,A
  00BC    01F6    CLR	0x76
  00BD    0AF6    INCR	0x76
  00BE    20F8    CALL	0xF8
  00BF    20FD    CALL	0xFD
157:              	low3(numArray[tempbaiweiNum],numArray[tempshiweiNum],numArray[tempgeweiNum],1);
  00C0    20F2    CALL	0xF2
  00C1    00F4    LD	0x74,A
  00C2    0878    LD	A,0x78
  00C3    3E3D    ADDIA	0x3D
  00C4    0084    LD	0x4,A
  00C5    0800    LD	A,0x0
  00C6    00F5    LD	0x75,A
  00C7    01F6    CLR	0x76
  00C8    0AF6    INCR	0x76
  00C9    20F8    CALL	0xF8
  00CA    2030    CALL	0x30
158:              	low4(numArray[tempbaiweiNum],numArray[tempshiweiNum],numArray[tempgeweiNum],1,1);
  00CB    20F2    CALL	0xF2
  00CC    00F4    LD	0x74,A
  00CD    0878    LD	A,0x78
  00CE    3E3D    ADDIA	0x3D
  00CF    0084    LD	0x4,A
  00D0    0800    LD	A,0x0
  00D1    00F5    LD	0x75,A
  00D2    01F6    CLR	0x76
  00D3    0AF6    INCR	0x76
  00D4    01F7    CLR	0x77
  00D5    0AF7    INCR	0x77
  00D6    20F8    CALL	0xF8
  00D7    21AE    CALL	0x1AE
159:              	/**
160:              	DP();
161:              	TITLE();
162:              	showNubBaiwei(numArray[tempbaiweiNum]);
163:              	setInput();
164:              	showNubShiwei(numArray[tempshiweiNum]);
165:              	setInput();
166:              	showNubGewei(numArray[tempgeweiNum]);
167:              	**/
168:              	DelayXms(1);
  00D8    3001    LDIA	0x1
  00D9    245E    CALL	0x45E
169:              	switch(nubStep)
  00DA    28E3    JP	0xE3
170:              	{
171:              		case 0:
172:              		WU();
  00DB    2471    CALL	0x471
173:              		break;
  00DC    28F0    JP	0xF0
174:              		case 1:
175:              		RUO();
  00DD    247E    CALL	0x47E
176:              		break;
  00DE    28F0    JP	0xF0
177:              		case 2:
178:              		ZHONG();
  00DF    247A    CALL	0x47A
179:              		break;
  00E0    28F0    JP	0xF0
180:              		case 3:
181:              		QIANG();
  00E1    2482    CALL	0x482
182:              		break;
  00E2    28F0    JP	0xF0
  00E3    1283    CLRB	0x3,5
  00E4    1303    CLRB	0x3,6
  00E5    083A    LD	A,0x3A
  00E6    0084    LD	0x4,A
  00E7    3004    LDIA	0x4
  00E8    0204    SUBA	0x4
  00E9    1803    SZB	0x3,0
  00EA    28F0    JP	0xF0
  00EB    3004    LDIA	0x4
  00EC    008A    LD	0xA,A
  00ED    3076    LDIA	0x76
  00EE    0704    ADDA	0x4
  00EF    0082    LD	0x2,A
183:              	}
184:              	DelayXms(3);
  00F0    3003    LDIA	0x3
  00F1    2C5E    JP	0x45E
185:              }
186:              
187:              unsigned int ADC_AVG(unsigned char adch,unsigned char adtime)
  037E    00A7    LD	0x27,A
188:              {
189:              	unsigned int adsum = 0;
  037F    01A8    CLR	0x28
  0380    01A9    CLR	0x29
190:              	for(char i = 0; i< adtime;i++)
  0381    01AA    CLR	0x2A
  0382    0824    LD	A,0x24
  0383    022A    SUBA	0x2A
  0384    1803    SZB	0x3,0
  0385    2B93    JP	0x393
191:              	{
192:              		adsum+=ADC_Sample(adch);
  0386    0827    LD	A,0x27
  0387    22FA    CALL	0x2FA
  0388    0872    LD	A,0x72
  0389    07A8    ADDR	0x28
  038A    1803    SZB	0x3,0
  038B    0AA9    INCR	0x29
  038C    0873    LD	A,0x73
  038D    07A9    ADDR	0x29
193:              		refreshNub();
  038E    2099    CALL	0x99
  038F    1283    CLRB	0x3,5
  0390    1303    CLRB	0x3,6
  0391    0AAA    INCR	0x2A
  0392    2B82    JP	0x382
194:              	}
195:              	return adsum/adtime;
  0393    0824    LD	A,0x24
  0394    00F2    LD	0x72,A
  0395    01F3    CLR	0x73
  0396    0829    LD	A,0x29
  0397    00F5    LD	0x75,A
  0398    0828    LD	A,0x28
  0399    00F4    LD	0x74,A
  039A    232D    CALL	0x32D
  039B    0873    LD	A,0x73
  039C    00A5    LD	0x25,A
  039D    0872    LD	A,0x72
  039E    00A4    LD	0x24,A
  039F    0008    RET
196:              }
197:              
198:              
199:              void initConfig()
200:              {
201:              	COMEN = 0x00;
  0357    1683    SETB	0x3,5
  0358    1703    SETB	0x3,6
  0359    0197    CLR	0x17
202:              	PORTA = 0x00;
  035A    1283    CLRB	0x3,5
203:                  PORTB = 0x00;
204:                  PORTC = 0x00;
205:              	TRISA = 0;
  035B    2378    CALL	0x378
  035C    0185    CLR	0x5
206:                  TRISB = 0x18;
  035D    3018    LDIA	0x18
  035E    0086    LD	0x6,A
207:                  TRISC = 0;
  035F    0187    CLR	0x7
208:                  WPUA = 0x00;
  0360    1703    SETB	0x3,6
  0361    018E    CLR	0xE
209:                  WPUB = 0x18;
  0362    1303    CLRB	0x3,6
  0363    0095    LD	0x15,A
210:                  WPUC = 0x00;
  0364    1703    SETB	0x3,6
  0365    018F    CLR	0xF
211:              	WPUE = 0x00;
  0366    1283    CLRB	0x3,5
  0367    019A    CLR	0x1A
212:                  PORTA = 0x00;
213:                  PORTB = 0x00;
214:                  PORTC = 0x00;
215:                  IOCB = 0x00;
  0368    2378    CALL	0x378
  0369    0196    CLR	0x16
  036A    0000    NOP
  036B    0064    CLRWDT
216:              
217:              	
218:              	asm("nop");
219:                  asm("clrwdt");
220:                  INTCON = 0;                    //系统初始化
  036C    018B    CLR	0xB
221:                  OSCCON = 0X71;                //配置振荡为8M,开 WDT
  036D    3071    LDIA	0x71
  036E    1683    SETB	0x3,5
  036F    1303    CLRB	0x3,6
  0370    008F    LD	0xF,A
222:                  OPTION_REG = 0x06;        //Timer0使用内部时钟Focs/4，预分频比为1:128
  0371    3006    LDIA	0x6
  0372    0081    LD	0x1,A
223:              	
224:                  TMR0 = 0;                //赋予初始值
  0373    1283    CLRB	0x3,5
  0374    0181    CLR	0x1
225:                  INTCON = 0xE0;            //允许所有未被屏蔽的中断、禁止外设中断，使能Timer0
  0375    30E0    LDIA	0xE0
  0376    008B    LD	0xB,A
  0377    0008    RET
226:              }
227:              
228:              
229:              void Sleep_Mode() {
230:                  INTCON = 0;
231:              
232:                  OPTION_REG = 0;
233:              	
234:                  WPUB = 0x18;         //RB5 上拉
235:              	
236:              
237:                  IOCB = 0x18;            //允许RB3 RB4的IO口电平变化中断
238:                  RBIE = 1;                    //允许PORTB电平变化中断
239:                  GIE = 0;                    //GIE = 0时，唤醒后执行SLEEP后程序;GIE = 1时，唤醒后跳至中断服务
240:              
241:                  ADCON0 = 0;                    //关闭所有模块
242:              
243:                  OSCCON = 0X70;                //配置振荡为16M,关闭WDT
244:              	
245:                  PORTB;                        //读PORTB值并锁存	
246:              			
247:                  asm("clrwdt");
248:              
249:                  asm("sleep");                //进入休眠模式
250:              
251:                  asm("nop");
252:              	OSCCON = 0X71;                //配置振荡为16M,开WDT
253:              	IOCB = 0x00;
254:              }
255:              
256:              char keyRead(char KeyStatus)	
  042B    00F2    LD	0x72,A
257:              { 
258:              	if (KeyStatus)
  042C    0872    LD	A,0x72
  042D    1903    SZB	0x3,2
  042E    2C33    JP	0x433
259:              	{
260:              		keyNub = KeyStatus;
  042F    0872    LD	A,0x72
  0430    00B6    LD	0x36,A
261:              		keyCount++;
  0431    0AB5    INCR	0x35
262:              	}
  0432    3400    RET	0x0
263:              	else
264:              	{
265:              		if(keyCount >= 8)
  0433    3008    LDIA	0x8
  0434    0235    SUBA	0x35
266:              		{
267:              			keyCount = 0;
  0435    01B5    CLR	0x35
  0436    1803    SZB	0x3,0
268:              			return	1;
  0437    3401    RET	0x1
269:              		}
270:              		keyCount = 0;
  0438    01B6    CLR	0x36
271:              		keyNub = 0;
272:              	}
273:              	return 0;
  0439    3400    RET	0x0
274:              }
---- C:\工具\单片机学习资料\SC8P\SCMCU_IDE_V2.00.07\data\sources\common\Umul16.c ----------------------------------------------------------------------
1:                // 16 x 16 bit multiplication with 16 bit result
2:                #ifdef _PIC18
3:                #define _Has_hardware_multiply 1
4:                #else
5:                #define _Has_hardware_multiply 0
6:                #endif
7:                
8:                #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:                #define _Has_large_call_stack 1
10:               #else
11:               #define _Has_large_call_stack 0
12:               #endif
13:               
14:               unsigned int
15:               __wmul(unsigned int multiplier, unsigned int multiplicand)
  03DD    01F6    CLR	0x76
  03DE    01F7    CLR	0x77
  03DF    1C72    SNZB	0x72,0
  03E0    2BE7    JP	0x3E7
  03E1    0874    LD	A,0x74
  03E2    07F6    ADDR	0x76
  03E3    1803    SZB	0x3,0
  03E4    0AF7    INCR	0x77
  03E5    0875    LD	A,0x75
  03E6    07F7    ADDR	0x77
  03E7    1003    CLRB	0x3,0
  03E8    0DF4    RLCR	0x74
  03E9    0DF5    RLCR	0x75
  03EA    1003    CLRB	0x3,0
  03EB    0CF3    RRCR	0x73
  03EC    0CF2    RRCR	0x72
  03ED    0872    LD	A,0x72
  03EE    0473    ORA	0x73
  03EF    1D03    SNZB	0x3,2
  03F0    2BDF    JP	0x3DF
  03F1    0877    LD	A,0x77
  03F2    00F3    LD	0x73,A
  03F3    0876    LD	A,0x76
  03F4    00F2    LD	0x72,A
  03F5    0008    RET
16:               {
17:                       unsigned int product;
18:               
19:               #if _Has_hardware_multiply || _Has_large_call_stack
20:               
21:               #define LOWBYTE(x)  (*(unsigned char *)(&x))
22:               #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
23:               
24:               	// optimized to allow use of the 8 x 8 bit hardware multiply instruction
25:               /*
26:               a 16-bit multiply can be decomposed into the sum of three 8-bit multiplies
27:                      a  b
28:               *      c  d
29:               -----------
30:                    |   bd
31:                    |ad  0
32:                    |bc  0
33:               +  ac| 0  0 (we ignore this intermediate product
34:                            because it does not affect the low 16 bits of the result)
35:               ===========
36:                */
37:                       product =  LOWBYTE(multiplier) * LOWBYTE(multiplicand);
38:                       product += (LOWBYTE(multiplier) * HIGHBYTE(multiplicand)) << 8;
39:                       product += (HIGHBYTE(multiplier) * LOWBYTE(multiplicand)) << 8;
40:               
41:               #else
42:               
43:               	product = 0;
44:               	do {
45:               		if(multiplier & 1)
46:               			product += multiplicand;
47:               		multiplicand <<= 1;
48:               		multiplier >>= 1;
49:               	} while(multiplier != 0);
50:               
51:               #endif
52:                       return product;
53:               }
---- C:\mcuproject\scm\荧光剂检测\number.c ----------------------------------------------------------------------
1:                #include "adc.h"
2:                #include "number.h"
3:                
4:                
5:                void showNubShiwei(char num)
6:                {
7:                	for(char i=0;i<7;i++)
8:                	{
9:                		if((num >> i) & 0x01)
10:               			showNubShiwei2(i);
11:               		else
12:               			setInput();
13:               	}
14:               }
15:               
16:               
17:               void showNubShiwei2(char index)
18:               {
19:               	switch(index)
20:               	{
21:               		case 0:
22:               		A2();
23:               		break;
24:               		case 1:
25:               		B2();
26:               		break;
27:               		case 2:
28:               		C2();
29:               		break;
30:               		case 3:
31:               		D2();
32:               		break;
33:               		case 4:
34:               		E2();
35:               		break;
36:               		case 5:
37:               		F2();
38:               		break;
39:               		case 6:
40:               		G2();
41:               		break;
42:               	}
43:               }
44:               
45:               void showNubGewei(char num)
46:               {
47:               	for(char i=0;i<8;i++)
48:               	{
49:               		if((num >> i) & 0x01)
50:               			showNubGewei2(i);
51:               		else
52:               			setInput();
53:               	}
54:               }
55:               
56:               
57:               void showNubGewei2(char index)
58:               {
59:               	switch(index)
60:               	{
61:               		case 0:
62:               		A3();
63:               		break;
64:               		case 1:
65:               		B3();
66:               		break;
67:               		case 2:
68:               		C3();
69:               		break;
70:               		case 3:
71:               		D3();
72:               		break;
73:               		case 4:
74:               		E3();
75:               		break;
76:               		case 5:
77:               		F3();
78:               		break;
79:               		case 6:
80:               		G3();
81:               		break;
82:               	}
83:               }
84:               
85:               
86:               void showNubBaiwei(char num)
87:               {
88:               	for(char i=0;i<8;i++)
89:               	{
90:               		if((num >> i) & 0x01)
91:               			showNubBaiwei2(i);
92:               		else
93:               			setInput();
94:               	}
95:               }
96:               
97:               
98:               void showNubBaiwei2(char index)
99:               {
100:              	switch(index)
101:              	{
102:              		case 0:
103:              		A1();
104:              		break;
105:              		case 1:
106:              		B1();
107:              		break;
108:              		case 2:
109:              		C1();
110:              		break;
111:              		case 3:
112:              		D1();
113:              		break;
114:              		case 4:
115:              		E1();
116:              		break;
117:              		case 5:
118:              		F1();
119:              		break;
120:              		case 6:
121:              		G1();
122:              		break;
123:              	}
124:              }
125:              
126:              void A1()
127:              {
128:              	showNub(6,4);
129:              }
130:              
131:              void B1()
132:              {
133:              	showNub(7,4);
134:              }
135:              
136:              void C1()
137:              {
138:              	showNub(7,2);
139:              }
140:              
141:              void D1()
142:              {
143:              	showNub(6,1);
144:              }
145:              
146:              void E1()
147:              {
148:              	showNub(6,2);
149:              }
150:              
151:              void F1()
152:              {
153:              	showNub(6,3);
154:              }
155:              
156:              void G1()
157:              {
158:              	showNub(7,3);
159:              }
160:              
161:              void A2()
162:              {
163:              	showNub(8,4);
164:              }
165:              
166:              void B2()
167:              {
168:              	showNub(9,4);
169:              }
170:              
171:              void C2()
172:              {
173:              	showNub(9,2);
174:              }
175:              
176:              void D2()
177:              {
178:              	showNub(8,1);
179:              }
180:              
181:              void E2()
182:              {
183:              	showNub(8,2);
184:              }
185:              
186:              void F2()
187:              {
188:              	showNub(8,3);
189:              }
190:              
191:              void G2()
192:              {
193:              	showNub(9,3);
194:              }
195:              
196:              void A3()
197:              {
198:              	showNub(10,4);
199:              }
200:              
201:              void B3()
202:              {
203:              	showNub(11,4);
204:              }
205:              
206:              void C3()
207:              {
208:              	showNub(11,2);
209:              }
210:              
211:              void D3()
212:              {
213:              	showNub(10,1);
214:              }
215:              
216:              void E3()
217:              {
218:              	showNub(10,2);
219:              }
220:              
221:              void F3()
222:              {
223:              	showNub(10,3);
224:              }
225:              
226:              void G3()
227:              {
228:              	showNub(11,3);
229:              }
230:              
231:              void DP()
232:              {
233:              	//showNub(7,1);
234:              	setInput();
235:              	setOutput(1);		
236:              	setOutput(7);	
237:              	setHightOutput(7);
238:              	setlowOutput(1);
239:              	delayms(15);
240:              	PORTC &= 0xFE;
241:              	CLRWDT(); 
242:              }
243:              
244:              void TITLE()
245:              {
246:              	setInput();
247:              	setOutput(4);		
248:              	setlowOutput(4);
249:              	setOutput(5);	
250:              	setHightOutput(5);
251:              	delayms(15);
252:              	CLRWDT(); 
253:              	setInput();
254:              }
255:              
256:              void WU()
  0471    300C    LDIA	0xC
257:              {
258:              	showNub(12,1);
  0472    01F4    CLR	0x74
  0473    0AF4    INCR	0x74
  0474    241B    CALL	0x41B
259:              	setInput();
  0475    2BF6    JP	0x3F6
260:              }
261:              
262:              void RUO()
263:              {
264:              	showNub(12,2);
  047E    3002    LDIA	0x2
  047F    00F4    LD	0x74,A
  0480    300C    LDIA	0xC
  0481    2C1B    JP	0x41B
265:              }
266:              
267:              void ZHONG()
268:              {
269:              	showNub(12,3);
  047A    3003    LDIA	0x3
  047B    00F4    LD	0x74,A
  047C    300C    LDIA	0xC
  047D    2C1B    JP	0x41B
270:              }
271:              
272:              void QIANG()
273:              {
274:              	showNub(12,4);
  0482    3004    LDIA	0x4
  0483    00F4    LD	0x74,A
  0484    300C    LDIA	0xC
  0485    2C1B    JP	0x41B
275:              }
276:              
277:              
278:              void showNub(char hight,char low)
  041B    00F5    LD	0x75,A
279:              {
280:              	setInput();
  041C    23F6    CALL	0x3F6
281:              	delayms(2);
  041D    3002    LDIA	0x2
  041E    2469    CALL	0x469
282:              	setOutput(low);	
  041F    0874    LD	A,0x74
  0420    223E    CALL	0x23E
283:              	setOutput(hight);	
  0421    0875    LD	A,0x75
  0422    223E    CALL	0x23E
284:              	setlowOutput(low);	
  0423    0874    LD	A,0x74
  0424    21FC    CALL	0x1FC
285:              	setHightOutput(hight);
  0425    0875    LD	A,0x75
  0426    227F    CALL	0x27F
286:              	delayms(15);
  0427    300F    LDIA	0xF
  0428    2469    CALL	0x469
  0429    0064    CLRWDT
  042A    0008    RET
287:              	CLRWDT(); 
288:              }
289:              
290:              
291:              
292:              void setHightOutput(char outPut)
  027F    00F2    LD	0x72,A
293:              {
294:              	switch(outPut)
  0280    2AB1    JP	0x2B1
295:              	{
296:              		case 12:
297:              			PORTA |= 0x80;
  0281    1283    CLRB	0x3,5
  0282    1303    CLRB	0x3,6
  0283    1785    SETB	0x5,7
298:              		break;
  0284    0008    RET
299:              		case 11:
300:              			PORTA |= 0x04;
  0285    1283    CLRB	0x3,5
  0286    1303    CLRB	0x3,6
  0287    1505    SETB	0x5,2
301:              		break;
  0288    0008    RET
302:              		case 10:
303:              			PORTA |= 0x10;
  0289    1283    CLRB	0x3,5
  028A    1303    CLRB	0x3,6
  028B    1605    SETB	0x5,4
304:              		break;
  028C    0008    RET
305:              		case 9:
306:              			PORTB |= 0x02;
  028D    1283    CLRB	0x3,5
  028E    1303    CLRB	0x3,6
  028F    1486    SETB	0x6,1
307:              		break;
  0290    0008    RET
308:              		case 8:
309:              			PORTC |= 0x04;
  0291    1283    CLRB	0x3,5
  0292    1303    CLRB	0x3,6
  0293    1507    SETB	0x7,2
310:              		break;
  0294    0008    RET
311:              		case 7:
312:              			PORTC |= 0x01;
  0295    1283    CLRB	0x3,5
  0296    1303    CLRB	0x3,6
  0297    1407    SETB	0x7,0
313:              		break;
  0298    0008    RET
314:              		case 6:
315:              			PORTC |= 0x02;
  0299    1283    CLRB	0x3,5
  029A    1303    CLRB	0x3,6
  029B    1487    SETB	0x7,1
316:              		break;
  029C    0008    RET
317:              		case 5:
318:              			PORTC |= 0x08;
  029D    1283    CLRB	0x3,5
  029E    1303    CLRB	0x3,6
  029F    1587    SETB	0x7,3
319:              		break;
  02A0    0008    RET
320:              		case 4:
321:              			PORTA |= 0x20;
  02A1    1283    CLRB	0x3,5
  02A2    1303    CLRB	0x3,6
  02A3    1685    SETB	0x5,5
322:              		break;
  02A4    0008    RET
323:              		case 3:
324:              			PORTA |= 0x08;
  02A5    1283    CLRB	0x3,5
  02A6    1303    CLRB	0x3,6
  02A7    1585    SETB	0x5,3
325:              		break;
  02A8    0008    RET
326:              		case 2:
327:              			PORTA |= 0x02;
  02A9    1283    CLRB	0x3,5
  02AA    1303    CLRB	0x3,6
  02AB    1485    SETB	0x5,1
328:              		break;
  02AC    0008    RET
329:              		case 1:
330:              			PORTA |= 0x40;
  02AD    1283    CLRB	0x3,5
  02AE    1303    CLRB	0x3,6
  02AF    1705    SETB	0x5,6
331:              		break;
  02B0    0008    RET
  02B1    0872    LD	A,0x72
  02B2    3EFF    ADDIA	0xFF
  02B3    1C03    SNZB	0x3,0
  02B4    0008    RET
  02B5    0084    LD	0x4,A
  02B6    300C    LDIA	0xC
  02B7    0204    SUBA	0x4
  02B8    1803    SZB	0x3,0
  02B9    0008    RET
  02BA    3004    LDIA	0x4
  02BB    008A    LD	0xA,A
  02BC    3052    LDIA	0x52
  02BD    0704    ADDA	0x4
  02BE    0082    LD	0x2,A
  02BF    0008    RET
332:              	}
333:              }
334:              
335:              
336:              void setlowOutput(char outPut)
  01FC    00F2    LD	0x72,A
337:              {
338:              	switch(outPut)
  01FD    2A2F    JP	0x22F
339:              	{
340:              		case 12:
341:              			PORTA &= 0x7F;
  01FE    1283    CLRB	0x3,5
  01FF    1303    CLRB	0x3,6
  0200    1385    CLRB	0x5,7
342:              		break;
  0201    0008    RET
343:              		case 11:
344:              			PORTA &= 0xFB;
  0202    1283    CLRB	0x3,5
  0203    1303    CLRB	0x3,6
  0204    1105    CLRB	0x5,2
345:              		break;
  0205    0008    RET
346:              		case 10:
347:              			PORTA &= 0xEF;
  0206    1283    CLRB	0x3,5
  0207    1303    CLRB	0x3,6
  0208    1205    CLRB	0x5,4
348:              		break;
  0209    0008    RET
349:              		case 9:
350:              			PORTB &= 0xFD;
  020A    1283    CLRB	0x3,5
  020B    1303    CLRB	0x3,6
  020C    1086    CLRB	0x6,1
351:              		break;
  020D    0008    RET
352:              		case 8:
353:              			PORTC &= 0xFB;
  020E    1283    CLRB	0x3,5
  020F    1303    CLRB	0x3,6
  0210    1107    CLRB	0x7,2
354:              		break;
  0211    0008    RET
355:              		case 7:
356:              			PORTC &= 0xFE;
  0212    1283    CLRB	0x3,5
  0213    1303    CLRB	0x3,6
  0214    1007    CLRB	0x7,0
357:              		break;
  0215    0008    RET
358:              		case 6:
359:              			PORTC &= 0xFD;
  0216    1283    CLRB	0x3,5
  0217    1303    CLRB	0x3,6
  0218    1087    CLRB	0x7,1
360:              		break;
  0219    0008    RET
361:              		case 5:
362:              			PORTC &= 0xF7;
  021A    1283    CLRB	0x3,5
  021B    1303    CLRB	0x3,6
  021C    1187    CLRB	0x7,3
363:              		break;
  021D    0008    RET
364:              		case 4:
365:              			PORTA &= 0xDF;
  021E    1283    CLRB	0x3,5
  021F    1303    CLRB	0x3,6
  0220    1285    CLRB	0x5,5
366:              		break;
  0221    0008    RET
367:              		case 3:
368:              			PORTA &= 0xF7;
  0222    1283    CLRB	0x3,5
  0223    1303    CLRB	0x3,6
  0224    1185    CLRB	0x5,3
369:              		break;
  0225    0008    RET
370:              		case 2:
371:              			PORTA &= 0xFD;
  0226    1283    CLRB	0x3,5
  0227    1303    CLRB	0x3,6
  0228    1085    CLRB	0x5,1
372:              		break;
  0229    0008    RET
373:              		case 1:
374:              			PORTC &= 0xFE;
  022A    1283    CLRB	0x3,5
  022B    1303    CLRB	0x3,6
  022C    1007    CLRB	0x7,0
375:              			PORTA &= 0xBF;
  022D    1305    CLRB	0x5,6
376:              		break;
  022E    0008    RET
  022F    0872    LD	A,0x72
  0230    3EFF    ADDIA	0xFF
  0231    1C03    SNZB	0x3,0
  0232    0008    RET
  0233    0084    LD	0x4,A
  0234    300C    LDIA	0xC
  0235    0204    SUBA	0x4
  0236    1803    SZB	0x3,0
  0237    0008    RET
  0238    3004    LDIA	0x4
  0239    008A    LD	0xA,A
  023A    303A    LDIA	0x3A
  023B    0704    ADDA	0x4
  023C    0082    LD	0x2,A
  023D    0008    RET
377:              	}
378:              }
379:              
380:              
381:              void setOutput(char outPut)
  023E    00F2    LD	0x72,A
382:              {
383:              	switch(outPut)
  023F    2A70    JP	0x270
384:              	{
385:              		case 12:
386:              			TRISA &= 0x7F;
  0240    1683    SETB	0x3,5
  0241    1303    CLRB	0x3,6
  0242    1385    CLRB	0x5,7
387:              		break;
  0243    0008    RET
388:              		case 11:
389:              			TRISA &= 0xFB;
  0244    1683    SETB	0x3,5
  0245    1303    CLRB	0x3,6
  0246    1105    CLRB	0x5,2
390:              		break;
  0247    0008    RET
391:              		case 10:
392:              			TRISA &= 0xEF;
  0248    1683    SETB	0x3,5
  0249    1303    CLRB	0x3,6
  024A    1205    CLRB	0x5,4
393:              		break;
  024B    0008    RET
394:              		case 9:
395:              			TRISB &= 0xFD;
  024C    1683    SETB	0x3,5
  024D    1303    CLRB	0x3,6
  024E    1086    CLRB	0x6,1
396:              		break;
  024F    0008    RET
397:              		case 8:
398:              			TRISC &= 0xFB;
  0250    1683    SETB	0x3,5
  0251    1303    CLRB	0x3,6
  0252    1107    CLRB	0x7,2
399:              		break;
  0253    0008    RET
400:              		case 7:
401:              			TRISC &= 0xFE;
  0254    1683    SETB	0x3,5
  0255    1303    CLRB	0x3,6
  0256    1007    CLRB	0x7,0
402:              		break;
  0257    0008    RET
403:              		case 6:
404:              			TRISC &= 0xFD;
  0258    1683    SETB	0x3,5
  0259    1303    CLRB	0x3,6
  025A    1087    CLRB	0x7,1
405:              		break;
  025B    0008    RET
406:              		case 5:
407:              			TRISC &= 0xF7;
  025C    1683    SETB	0x3,5
  025D    1303    CLRB	0x3,6
  025E    1187    CLRB	0x7,3
408:              		break;
  025F    0008    RET
409:              		case 4:
410:              			TRISA &= 0xDF;
  0260    1683    SETB	0x3,5
  0261    1303    CLRB	0x3,6
  0262    1285    CLRB	0x5,5
411:              		break;
  0263    0008    RET
412:              		case 3:
413:              			TRISA &= 0xF7;
  0264    1683    SETB	0x3,5
  0265    1303    CLRB	0x3,6
  0266    1185    CLRB	0x5,3
414:              		break;
  0267    0008    RET
415:              		case 2:
416:              			TRISA &= 0xFD;
  0268    1683    SETB	0x3,5
  0269    1303    CLRB	0x3,6
  026A    1085    CLRB	0x5,1
417:              		break;
  026B    0008    RET
418:              		case 1:
419:              			TRISA &= 0xBF;
  026C    1683    SETB	0x3,5
  026D    1303    CLRB	0x3,6
  026E    1305    CLRB	0x5,6
420:              		break;
  026F    0008    RET
  0270    0872    LD	A,0x72
  0271    3EFF    ADDIA	0xFF
  0272    1C03    SNZB	0x3,0
  0273    0008    RET
  0274    0084    LD	0x4,A
  0275    300C    LDIA	0xC
  0276    0204    SUBA	0x4
  0277    1803    SZB	0x3,0
  0278    0008    RET
  0279    3004    LDIA	0x4
  027A    008A    LD	0xA,A
  027B    3046    LDIA	0x46
  027C    0704    ADDA	0x4
  027D    0082    LD	0x2,A
  027E    0008    RET
421:              	}
422:              }
423:              
424:              void setInput()
425:              {
426:              	TRISA = 0xFF;
  03F6    30FF    LDIA	0xFF
  03F7    1683    SETB	0x3,5
  03F8    1303    CLRB	0x3,6
  03F9    0085    LD	0x5,A
427:              	PORTA |= 0xFF;		
  03FA    1283    CLRB	0x3,5
  03FB    0085    LD	0x5,A
428:              	TRISB |= 0xC2;
  03FC    30C2    LDIA	0xC2
  03FD    1683    SETB	0x3,5
  03FE    0486    ORR	0x6
429:              	PORTB = 0xC2;
  03FF    1283    CLRB	0x3,5
  0400    0086    LD	0x6,A
430:              	TRISC |= 0x0F;
  0401    300F    LDIA	0xF
  0402    1683    SETB	0x3,5
  0403    0487    ORR	0x7
431:              	PORTC = 0x0F;
  0404    1283    CLRB	0x3,5
  0405    0087    LD	0x7,A
432:              	PORTA;
  0406    0805    LD	A,0x5
433:              	PORTB;
  0407    0806    LD	A,0x6
434:              	PORTC;
  0408    0807    LD	A,0x7
  0409    0008    RET
435:              }
436:              
437:              
438:              void low1(char bai,char shi,char ge,char dp,char h3)
  02C0    00A1    LD	0x21,A
439:              {
440:              	setLow();
  02C1    23C1    CALL	0x3C1
441:              	setlowOutput(1);
  02C2    3001    LDIA	0x1
  02C3    21FC    CALL	0x1FC
442:              	if((bai >> 3) & 0x01)
  02C4    1283    CLRB	0x3,5
  02C5    1303    CLRB	0x3,6
  02C6    0821    LD	A,0x21
  02C7    22F2    CALL	0x2F2
  02C8    1C20    SNZB	0x20,0
  02C9    2ACE    JP	0x2CE
443:              	{
444:              		setOutput(6);
  02CA    3006    LDIA	0x6
  02CB    223E    CALL	0x23E
445:              		setHightOutput(6);
  02CC    3006    LDIA	0x6
  02CD    227F    CALL	0x27F
446:              	}
447:              	if((shi >> 3) & 0x01)
  02CE    0874    LD	A,0x74
  02CF    1283    CLRB	0x3,5
  02D0    1303    CLRB	0x3,6
  02D1    22F2    CALL	0x2F2
  02D2    1C20    SNZB	0x20,0
  02D3    2AD8    JP	0x2D8
448:              	{
449:              		setOutput(8);
  02D4    3008    LDIA	0x8
  02D5    223E    CALL	0x23E
450:              		setHightOutput(8);
  02D6    3008    LDIA	0x8
  02D7    227F    CALL	0x27F
451:              	}
452:              	if((ge >> 3) & 0x01)
  02D8    0875    LD	A,0x75
  02D9    1283    CLRB	0x3,5
  02DA    1303    CLRB	0x3,6
  02DB    22F2    CALL	0x2F2
  02DC    1C20    SNZB	0x20,0
  02DD    2AE2    JP	0x2E2
453:              	{
454:              		setOutput(10);
  02DE    300A    LDIA	0xA
  02DF    223E    CALL	0x23E
455:              		setHightOutput(10);
  02E0    300A    LDIA	0xA
  02E1    227F    CALL	0x27F
456:              	}
457:              	if(dp)
  02E2    0876    LD	A,0x76
  02E3    1903    SZB	0x3,2
  02E4    2AE9    JP	0x2E9
458:              	{
459:              		setOutput(7);
  02E5    3007    LDIA	0x7
  02E6    223E    CALL	0x23E
460:              		setHightOutput(7);
  02E7    3007    LDIA	0x7
  02E8    227F    CALL	0x27F
461:              	}
462:              	if(h3)
  02E9    0877    LD	A,0x77
  02EA    1903    SZB	0x3,2
  02EB    2AF0    JP	0x2F0
463:              	{
464:              		setOutput(12);
  02EC    300C    LDIA	0xC
  02ED    223E    CALL	0x23E
465:              		setHightOutput(12);
  02EE    300C    LDIA	0xC
  02EF    227F    CALL	0x27F
466:              	}
467:              	delayms(15);
  02F0    300F    LDIA	0xF
  02F1    2C69    JP	0x469
468:              	
469:              }
470:              
471:              void low2(char bai,char shi,char ge,char h4)
  00FD    1283    CLRB	0x3,5
  00FE    1303    CLRB	0x3,6
  00FF    00A0    LD	0x20,A
472:              {
473:              	TRISA = 0x00;
  0100    1683    SETB	0x3,5
  0101    0185    CLR	0x5
474:              	setLow();
  0102    23C1    CALL	0x3C1
475:              	setlowOutput(2);
  0103    3002    LDIA	0x2
  0104    21FC    CALL	0x1FC
476:              	if((bai >> 2) & 0x01)
  0105    1283    CLRB	0x3,5
  0106    1303    CLRB	0x3,6
  0107    0820    LD	A,0x20
  0108    2154    CALL	0x154
  0109    1C77    SNZB	0x77,0
  010A    290F    JP	0x10F
477:              	{
478:              		setOutput(7);
  010B    3007    LDIA	0x7
  010C    223E    CALL	0x23E
479:              		setHightOutput(7);
  010D    3007    LDIA	0x7
  010E    227F    CALL	0x27F
480:              	}
481:              	if((shi >> 2) & 0x01)
  010F    0874    LD	A,0x74
  0110    2154    CALL	0x154
  0111    1C77    SNZB	0x77,0
  0112    2917    JP	0x117
482:              	{
483:              		setOutput(9);
  0113    3009    LDIA	0x9
  0114    223E    CALL	0x23E
484:              		setHightOutput(9);
  0115    3009    LDIA	0x9
  0116    227F    CALL	0x27F
485:              	}
486:              	if((ge >> 2) & 0x01)
  0117    0875    LD	A,0x75
  0118    2154    CALL	0x154
  0119    1C77    SNZB	0x77,0
  011A    291F    JP	0x11F
487:              	{
488:              		setOutput(11);
  011B    300B    LDIA	0xB
  011C    223E    CALL	0x23E
489:              		setHightOutput(11);
  011D    300B    LDIA	0xB
  011E    227F    CALL	0x27F
490:              	}
491:              	
492:              	if((bai >> 4) & 0x01)
  011F    1283    CLRB	0x3,5
  0120    1303    CLRB	0x3,6
  0121    0820    LD	A,0x20
  0122    00F7    LD	0x77,A
  0123    3004    LDIA	0x4
  0124    1003    CLRB	0x3,0
  0125    0CF7    RRCR	0x77
  0126    3EFF    ADDIA	0xFF
  0127    1D03    SNZB	0x3,2
  0128    2924    JP	0x124
  0129    1C77    SNZB	0x77,0
  012A    292F    JP	0x12F
493:              	{
494:              		setOutput(6);
  012B    3006    LDIA	0x6
  012C    223E    CALL	0x23E
495:              		setHightOutput(6);
  012D    3006    LDIA	0x6
  012E    227F    CALL	0x27F
496:              	}
497:              	if((shi >> 4) & 0x01)
  012F    0874    LD	A,0x74
  0130    00F7    LD	0x77,A
  0131    3004    LDIA	0x4
  0132    1003    CLRB	0x3,0
  0133    0CF7    RRCR	0x77
  0134    3EFF    ADDIA	0xFF
  0135    1D03    SNZB	0x3,2
  0136    2932    JP	0x132
  0137    1C77    SNZB	0x77,0
  0138    293D    JP	0x13D
498:              	{
499:              		setOutput(8);
  0139    3008    LDIA	0x8
  013A    223E    CALL	0x23E
500:              		setHightOutput(8);
  013B    3008    LDIA	0x8
  013C    227F    CALL	0x27F
501:              	}
502:              	if((ge >> 4) & 0x01)
  013D    0875    LD	A,0x75
  013E    00F7    LD	0x77,A
  013F    3004    LDIA	0x4
  0140    1003    CLRB	0x3,0
  0141    0CF7    RRCR	0x77
  0142    3EFF    ADDIA	0xFF
  0143    1D03    SNZB	0x3,2
  0144    2940    JP	0x140
  0145    1C77    SNZB	0x77,0
  0146    294B    JP	0x14B
503:              	{
504:              		setOutput(10);
  0147    300A    LDIA	0xA
  0148    223E    CALL	0x23E
505:              		setHightOutput(10);
  0149    300A    LDIA	0xA
  014A    227F    CALL	0x27F
506:              	}
507:              	if(h4)
  014B    0876    LD	A,0x76
  014C    1903    SZB	0x3,2
  014D    2952    JP	0x152
508:              	{
509:              		setOutput(12);
  014E    300C    LDIA	0xC
  014F    223E    CALL	0x23E
510:              		setHightOutput(12);
  0150    300C    LDIA	0xC
  0151    227F    CALL	0x27F
511:              	}
512:              	delayms(15);
  0152    300F    LDIA	0xF
  0153    2C69    JP	0x469
513:              }
514:              
515:              void low3(char bai,char shi,char ge,char h5)
  0030    1283    CLRB	0x3,5
  0031    1303    CLRB	0x3,6
  0032    00A0    LD	0x20,A
516:              {
517:              	TRISA = 0x00;
  0033    1683    SETB	0x3,5
  0034    0185    CLR	0x5
518:              	setLow();
  0035    23C1    CALL	0x3C1
519:              	setlowOutput(3);
  0036    3003    LDIA	0x3
  0037    21FC    CALL	0x1FC
520:              	if((bai >> 5) & 0x01)
  0038    1283    CLRB	0x3,5
  0039    1303    CLRB	0x3,6
  003A    0820    LD	A,0x20
  003B    00F7    LD	0x77,A
  003C    3005    LDIA	0x5
  003D    1003    CLRB	0x3,0
  003E    0CF7    RRCR	0x77
  003F    3EFF    ADDIA	0xFF
  0040    1D03    SNZB	0x3,2
  0041    283D    JP	0x3D
  0042    1C77    SNZB	0x77,0
  0043    2848    JP	0x48
521:              	{
522:              		setOutput(6);
  0044    3006    LDIA	0x6
  0045    223E    CALL	0x23E
523:              		setHightOutput(6);
  0046    3006    LDIA	0x6
  0047    227F    CALL	0x27F
524:              	}
525:              	if((shi >> 5) & 0x01)
  0048    0874    LD	A,0x74
  0049    00F7    LD	0x77,A
  004A    3005    LDIA	0x5
  004B    1003    CLRB	0x3,0
  004C    0CF7    RRCR	0x77
  004D    3EFF    ADDIA	0xFF
  004E    1D03    SNZB	0x3,2
  004F    284B    JP	0x4B
  0050    1C77    SNZB	0x77,0
  0051    2856    JP	0x56
526:              	{
527:              		setOutput(8);
  0052    3008    LDIA	0x8
  0053    223E    CALL	0x23E
528:              		setHightOutput(8);
  0054    3008    LDIA	0x8
  0055    227F    CALL	0x27F
529:              	}
530:              	if((ge >> 5) & 0x01)
  0056    0875    LD	A,0x75
  0057    00F7    LD	0x77,A
  0058    3005    LDIA	0x5
  0059    1003    CLRB	0x3,0
  005A    0CF7    RRCR	0x77
  005B    3EFF    ADDIA	0xFF
  005C    1D03    SNZB	0x3,2
  005D    2859    JP	0x59
  005E    1C77    SNZB	0x77,0
  005F    2864    JP	0x64
531:              	{
532:              		setOutput(10);
  0060    300A    LDIA	0xA
  0061    223E    CALL	0x23E
533:              		setHightOutput(10);
  0062    300A    LDIA	0xA
  0063    227F    CALL	0x27F
534:              	}
535:              	
536:              	if((bai >> 6) & 0x01)
  0064    1283    CLRB	0x3,5
  0065    1303    CLRB	0x3,6
  0066    0820    LD	A,0x20
  0067    00F7    LD	0x77,A
  0068    3006    LDIA	0x6
  0069    1003    CLRB	0x3,0
  006A    0CF7    RRCR	0x77
  006B    3EFF    ADDIA	0xFF
  006C    1D03    SNZB	0x3,2
  006D    2869    JP	0x69
  006E    1C77    SNZB	0x77,0
  006F    2874    JP	0x74
537:              	{
538:              		setOutput(7);
  0070    3007    LDIA	0x7
  0071    223E    CALL	0x23E
539:              		setHightOutput(7);
  0072    3007    LDIA	0x7
  0073    227F    CALL	0x27F
540:              	}
541:              	if((shi >> 6) & 0x01)
  0074    0874    LD	A,0x74
  0075    00F7    LD	0x77,A
  0076    3006    LDIA	0x6
  0077    1003    CLRB	0x3,0
  0078    0CF7    RRCR	0x77
  0079    3EFF    ADDIA	0xFF
  007A    1D03    SNZB	0x3,2
  007B    2877    JP	0x77
  007C    1C77    SNZB	0x77,0
  007D    2882    JP	0x82
542:              	{
543:              		setOutput(9);
  007E    3009    LDIA	0x9
  007F    223E    CALL	0x23E
544:              		setHightOutput(9);
  0080    3009    LDIA	0x9
  0081    227F    CALL	0x27F
545:              	}
546:              	if((ge >> 6) & 0x01)
  0082    0875    LD	A,0x75
  0083    00F7    LD	0x77,A
  0084    3006    LDIA	0x6
  0085    1003    CLRB	0x3,0
  0086    0CF7    RRCR	0x77
  0087    3EFF    ADDIA	0xFF
  0088    1D03    SNZB	0x3,2
  0089    2885    JP	0x85
  008A    1C77    SNZB	0x77,0
  008B    2890    JP	0x90
547:              	{
548:              		setOutput(11);
  008C    300B    LDIA	0xB
  008D    223E    CALL	0x23E
549:              		setHightOutput(11);
  008E    300B    LDIA	0xB
  008F    227F    CALL	0x27F
550:              	}
551:              	if(h5)
  0090    0876    LD	A,0x76
  0091    1903    SZB	0x3,2
  0092    2897    JP	0x97
552:              	{
553:              		setOutput(12);
  0093    300C    LDIA	0xC
  0094    223E    CALL	0x23E
554:              		setHightOutput(12);
  0095    300C    LDIA	0xC
  0096    227F    CALL	0x27F
555:              	}
556:              	delayms(15);
  0097    300F    LDIA	0xF
  0098    2C69    JP	0x469
557:              }
558:              
559:              void low4(char bai,char shi,char ge,char h6,char h123)
  01AE    1283    CLRB	0x3,5
  01AF    1303    CLRB	0x3,6
  01B0    00A1    LD	0x21,A
560:              {
561:              	TRISA = 0x00;
  01B1    1683    SETB	0x3,5
  01B2    0185    CLR	0x5
562:              	setLow();
  01B3    23C1    CALL	0x3C1
563:              	setlowOutput(4);
  01B4    3004    LDIA	0x4
  01B5    21FC    CALL	0x1FC
564:              
565:              	if((bai >> 0) & 0x01)
  01B6    1283    CLRB	0x3,5
  01B7    1303    CLRB	0x3,6
  01B8    1C21    SNZB	0x21,0
  01B9    29BE    JP	0x1BE
566:              	{
567:              		setOutput(6);
  01BA    3006    LDIA	0x6
  01BB    223E    CALL	0x23E
568:              		setHightOutput(6);
  01BC    3006    LDIA	0x6
  01BD    227F    CALL	0x27F
569:              	}
570:              	if((shi >> 0) & 0x01)
  01BE    1C74    SNZB	0x74,0
  01BF    29C4    JP	0x1C4
571:              	{
572:              		setOutput(8);
  01C0    3008    LDIA	0x8
  01C1    223E    CALL	0x23E
573:              		setHightOutput(8);
  01C2    3008    LDIA	0x8
  01C3    227F    CALL	0x27F
574:              	}
575:              	if((ge >> 0) & 0x01)
  01C4    1C75    SNZB	0x75,0
  01C5    29CA    JP	0x1CA
576:              	{
577:              		setOutput(10);
  01C6    300A    LDIA	0xA
  01C7    223E    CALL	0x23E
578:              		setHightOutput(10);
  01C8    300A    LDIA	0xA
  01C9    227F    CALL	0x27F
579:              	}
580:              	
581:              	if((bai >> 1) & 0x01)
  01CA    1283    CLRB	0x3,5
  01CB    1303    CLRB	0x3,6
  01CC    0821    LD	A,0x21
  01CD    00A0    LD	0x20,A
  01CE    1003    CLRB	0x3,0
  01CF    0CA0    RRCR	0x20
  01D0    1C20    SNZB	0x20,0
  01D1    29D6    JP	0x1D6
582:              	{
583:              		setOutput(7);
  01D2    3007    LDIA	0x7
  01D3    223E    CALL	0x23E
584:              		setHightOutput(7);
  01D4    3007    LDIA	0x7
  01D5    227F    CALL	0x27F
585:              	}
586:              	if((shi >> 1) & 0x01)
  01D6    0874    LD	A,0x74
  01D7    21F6    CALL	0x1F6
  01D8    1C20    SNZB	0x20,0
  01D9    29DE    JP	0x1DE
587:              	{
588:              		setOutput(9);
  01DA    3009    LDIA	0x9
  01DB    223E    CALL	0x23E
589:              		setHightOutput(9);
  01DC    3009    LDIA	0x9
  01DD    227F    CALL	0x27F
590:              	}
591:              	if((ge >> 1) & 0x01)
  01DE    0875    LD	A,0x75
  01DF    21F6    CALL	0x1F6
  01E0    1C20    SNZB	0x20,0
  01E1    29E6    JP	0x1E6
592:              	{
593:              		setOutput(11);
  01E2    300B    LDIA	0xB
  01E3    223E    CALL	0x23E
594:              		setHightOutput(11);
  01E4    300B    LDIA	0xB
  01E5    227F    CALL	0x27F
595:              	}
596:              	if(h6)
  01E6    0876    LD	A,0x76
  01E7    1903    SZB	0x3,2
  01E8    29ED    JP	0x1ED
597:              	{
598:              		setOutput(12);
  01E9    300C    LDIA	0xC
  01EA    223E    CALL	0x23E
599:              		setHightOutput(12);
  01EB    300C    LDIA	0xC
  01EC    227F    CALL	0x27F
600:              	}
601:              	if(h123)
  01ED    0877    LD	A,0x77
  01EE    1903    SZB	0x3,2
  01EF    29F4    JP	0x1F4
602:              	{
603:              		setOutput(5);
  01F0    3005    LDIA	0x5
  01F1    223E    CALL	0x23E
604:              		setHightOutput(5);
  01F2    3005    LDIA	0x5
  01F3    227F    CALL	0x27F
605:              	}
606:              	delayms(15);
  01F4    300F    LDIA	0xF
  01F5    2C69    JP	0x469
607:              }
608:              
609:              void setLow()
610:              {
611:              	TRISA = 0x00;
  03C1    1683    SETB	0x3,5
  03C2    0185    CLR	0x5
612:              	TRISB = 0x00;
  03C3    0186    CLR	0x6
613:              	TRISC = 0x00;
  03C4    0187    CLR	0x7
614:              	setHightOutput(1);
  03C5    3001    LDIA	0x1
  03C6    227F    CALL	0x27F
615:              	setHightOutput(2);
  03C7    3002    LDIA	0x2
  03C8    227F    CALL	0x27F
616:              	setHightOutput(3);
  03C9    3003    LDIA	0x3
  03CA    227F    CALL	0x27F
617:              	setHightOutput(4);
  03CB    3004    LDIA	0x4
  03CC    227F    CALL	0x27F
618:              	setlowOutput(5);
  03CD    3005    LDIA	0x5
  03CE    21FC    CALL	0x1FC
619:              	setlowOutput(6);
  03CF    3006    LDIA	0x6
  03D0    21FC    CALL	0x1FC
620:              	setlowOutput(7);
  03D1    3007    LDIA	0x7
  03D2    21FC    CALL	0x1FC
621:              	setlowOutput(8);
  03D3    3008    LDIA	0x8
  03D4    21FC    CALL	0x1FC
622:              	setlowOutput(9);
  03D5    3009    LDIA	0x9
  03D6    21FC    CALL	0x1FC
623:              	setlowOutput(10);
  03D7    300A    LDIA	0xA
  03D8    21FC    CALL	0x1FC
624:              	setlowOutput(11);
  03D9    300B    LDIA	0xB
  03DA    21FC    CALL	0x1FC
625:              	setlowOutput(12);
  03DB    300C    LDIA	0xC
  03DC    29FC    JP	0x1FC
626:              }
627:              
628:              
629:              
630:              
631:              void delayms(u8t time)
  0469    00F2    LD	0x72,A
632:              {
633:              	for(u8t i=0;i<time;i++);
  046A    01F3    CLR	0x73
  046B    0872    LD	A,0x72
  046C    0273    SUBA	0x73
  046D    1803    SZB	0x3,0
  046E    0008    RET
  046F    0AF3    INCR	0x73
  0470    2C6B    JP	0x46B
634:              }
635:              
---- C:\mcuproject\scm\荧光剂检测\adc.c ----------------------------------------------------------------------
1:                #include "adc.h"
2:                
3:                /**********************************************************
4:                函数名称：AD_Sample
5:                函数功能：AD检测
6:                入口参数：adch - 检测通道
7:                出口参数：无 
8:                备    注：采样通道需自行设置为模拟口
9:                	      采样10次,取中间八次的平均值为采样结果存于adresult中
10:               **********************************************************/
11:               //ADC左对齐采样
12:               unsigned int ADC_Sample(unsigned char adch)
  02FA    00A0    LD	0x20,A
13:               {
14:               	unsigned int adsum = 0;
15:               	unsigned int admin = 0,admax = 0;
16:               	unsigned char adtimes = 0;
17:               	volatile unsigned int ad_temp;
18:               	ADCON1 = 0;						//左对齐
  02FB    1683    SETB	0x3,5
  02FC    019F    CLR	0x1F
19:               	ADCON0 = 0X41 | (adch << 2);	//16分频
  02FD    1283    CLRB	0x3,5
  02FE    0820    LD	A,0x20
  02FF    00F4    LD	0x74,A
  0300    3001    LDIA	0x1
  0301    1003    CLRB	0x3,0
  0302    0DF4    RLCR	0x74
  0303    3EFF    ADDIA	0xFF
  0304    1003    CLRB	0x3,0
  0305    1D03    SNZB	0x3,2
  0306    2B02    JP	0x302
  0307    0D74    RLCA	0x74
  0308    3841    ORIA	0x41
  0309    009F    LD	0x1F,A
  030A    0000    NOP
  030B    0000    NOP
20:               	asm("nop");
21:               	asm("nop");
22:               	GODONE = 1;						//开始转换
  030C    1283    CLRB	0x3,5
  030D    1303    CLRB	0x3,6
  030E    149F    SETB	0x1F,1
23:               
24:               	unsigned char i = 0;
  030F    01A1    CLR	0x21
25:               	while(GODONE)
  0310    1C9F    SNZB	0x1F,1
  0311    2B15    JP	0x315
26:               	{
27:               		if(0 == (--i))
  0312    0BA1    SZDECR	0x21
  0313    2B10    JP	0x310
  0314    0008    RET
28:               			return;
29:               	}
30:               	
31:               	ad_temp=(ADRESH<<4)+(ADRESL>>4);	//计算12位AD值
  0315    081E    LD	A,0x1E
  0316    00A2    LD	0x22,A
  0317    01A3    CLR	0x23
  0318    0EA2    SWAPR	0x22
  0319    0EA3    SWAPR	0x23
  031A    30F0    LDIA	0xF0
  031B    05A3    ANDR	0x23
  031C    0822    LD	A,0x22
  031D    390F    ANDIA	0xF
  031E    04A3    ORR	0x23
  031F    30F0    LDIA	0xF0
  0320    05A2    ANDR	0x22
  0321    1683    SETB	0x3,5
  0322    0E1E    SWAPA	0x1E
  0323    390F    ANDIA	0xF
  0324    1283    CLRB	0x3,5
  0325    07A2    ADDR	0x22
  0326    1803    SZB	0x3,0
  0327    0AA3    INCR	0x23
32:               	return ad_temp;
  0328    0823    LD	A,0x23
  0329    00F3    LD	0x73,A
  032A    0822    LD	A,0x22
  032B    00F2    LD	0x72,A
  032C    0008    RET
33:               	
34:               }
35:               
36:               
37:               
38:               //ADC右对齐采样
39:               unsigned int ADC_Result(unsigned char adch)
40:               {
41:               	ADCON1 = 0x80;						//右对齐
42:               	ADCON0 = 0X41 | (adch << 2);	//16分频
43:               	asm("nop");
44:               	asm("nop");
45:               	GODONE = 1;						//开始转换
46:               
47:               	unsigned char i = 0;
48:               	while(GODONE)
49:               	{
50:               		if(0 == (--i))
51:               			return 0;				//转换超时
52:               	}
53:               	unsigned int tempResult = ADRESH;
54:               	tempResult <<= 8;
55:               	tempResult += ADRESL;
56:               	return tempResult;
57:               }
58:               /***********************************************************
59:               函数名称：DelayXms
60:               函数功能：毫秒级非精准延时
61:               入口参数：x - 延时时间
62:               出口参数：
63:               备    注：
64:               ***********************************************************/
65:               void DelayXms(unsigned char x)
  045E    00F2    LD	0x72,A
66:               {
67:               	unsigned char i,j;
68:               	for(i=x;i>0;i--)
  045F    00F3    LD	0x73,A
  0460    0873    LD	A,0x73
  0461    1903    SZB	0x3,2
  0462    0008    RET
69:               		for(j=153;j>0;j--);
  0463    3099    LDIA	0x99
  0464    00F4    LD	0x74,A
  0465    0BF4    SZDECR	0x74
  0466    2C65    JP	0x465
  0467    03F3    DECR	0x73
  0468    2C60    JP	0x460
70:               }
71:               
72:               //读取内部电压
73:               unsigned char readVrefADC()
74:               {
75:               	DelayXms(1);
76:               	ADC_Sample(0x0F);
77:               	unsigned char result;
78:               		
79:               	result = ADC_Result(0x0F);
80:               	return result;
81:               }
82:               
---- C:\工具\单片机学习资料\SC8P\SCMCU_IDE_V2.00.07\data\sources\common\lwdiv.c ----------------------------------------------------------------------
1:                // word unsigned division
2:                
3:                unsigned int
4:                #ifdef __PICC__
5:                #warning TODO: update cgpic and this file to use the other prototype
6:                __lwdiv(unsigned int divisor, unsigned int dividend)
  032D    01A1    CLR	0x21
  032E    01A2    CLR	0x22
  032F    0872    LD	A,0x72
  0330    0473    ORA	0x73
  0331    1903    SZB	0x3,2
  0332    2B52    JP	0x352
  0333    01A0    CLR	0x20
  0334    0AA0    INCR	0x20
  0335    1BF3    SZB	0x73,7
  0336    2B3B    JP	0x33B
  0337    1003    CLRB	0x3,0
  0338    0DF2    RLCR	0x72
  0339    0DF3    RLCR	0x73
  033A    2B34    JP	0x334
  033B    1003    CLRB	0x3,0
  033C    0DA1    RLCR	0x21
  033D    0DA2    RLCR	0x22
  033E    0873    LD	A,0x73
  033F    0275    SUBA	0x75
  0340    1D03    SNZB	0x3,2
  0341    2B44    JP	0x344
  0342    0872    LD	A,0x72
  0343    0274    SUBA	0x74
  0344    1C03    SNZB	0x3,0
  0345    2B4E    JP	0x34E
  0346    0872    LD	A,0x72
  0347    02F4    SUBR	0x74
  0348    0873    LD	A,0x73
  0349    1C03    SNZB	0x3,0
  034A    03F5    DECR	0x75
  034B    02F5    SUBR	0x75
  034C    1421    SETB	0x21,0
  034D    1003    CLRB	0x3,0
  034E    0CF3    RRCR	0x73
  034F    0CF2    RRCR	0x72
  0350    0BA0    SZDECR	0x20
  0351    2B3B    JP	0x33B
  0352    0822    LD	A,0x22
  0353    00F3    LD	0x73,A
  0354    0821    LD	A,0x21
  0355    00F2    LD	0x72,A
  0356    0008    RET
7:                #else
8:                __lwdiv(unsigned int dividend, unsigned int divisor)
9:                #endif
10:               {
11:               	unsigned int	quotient;
12:               	unsigned char	counter;
13:               
14:               	quotient = 0;
15:               	if(divisor != 0) {
16:               		counter = 1;
17:               		while((divisor & 0x8000) == 0) {
18:               			divisor <<= 1;
19:               			counter++;
20:               		}
21:               		do {
22:               			quotient <<= 1;
23:               			if(divisor <= dividend) {
24:               				dividend -= divisor;
25:               				quotient |= 1;
26:               			}
27:               			divisor >>= 1;
28:               		} while(--counter != 0);
29:               	}
30:               	return quotient;
31:               }
---- stringtab ------------------------------------------------------------------
---- reset_enter ------------------------------------------------------------------
  0000    280A    JP	0xA
  000A    280B    JP	0xB
---- start_initialization ------------------------------------------------------------------
  000B    303F    LDIA	0x3F
  000C    00BD    LD	0x3D,A
  000D    3006    LDIA	0x6
  000E    00BE    LD	0x3E,A
  000F    305B    LDIA	0x5B
  0010    00BF    LD	0x3F,A
  0011    304F    LDIA	0x4F
  0012    00C0    LD	0x40,A
  0013    3066    LDIA	0x66
  0014    00C1    LD	0x41,A
  0015    306D    LDIA	0x6D
  0016    00C2    LD	0x42,A
  0017    307D    LDIA	0x7D
  0018    00C3    LD	0x43,A
  0019    3007    LDIA	0x7
  001A    00C4    LD	0x44,A
  001B    307F    LDIA	0x7F
  001C    00C5    LD	0x45,A
  001D    3067    LDIA	0x67
  001E    00C6    LD	0x46,A
  001F    3014    LDIA	0x14
  0020    00FB    LD	0x7B,A
  0021    01B3    CLR	0x33
  0022    01B4    CLR	0x34
  0023    01B5    CLR	0x35
  0024    01B6    CLR	0x36
  0025    01B7    CLR	0x37
  0026    01B8    CLR	0x38
  0027    01B9    CLR	0x39
  0028    01BA    CLR	0x3A
  0029    01BB    CLR	0x3B
  002A    01BC    CLR	0x3C
  002B    01F8    CLR	0x78
  002C    01F9    CLR	0x79
  002D    01FA    CLR	0x7A
---- interrupt_function_enter ----------------------------------------------------------
  0004    00FE    LD	0x7E,A
  0005    0E03    SWAPA	0x3
  0006    00F0    LD	0x70,A
  0007    080A    LD	A,0xA
  0008    00F1    LD	0x71,A
  0009    2BA0    JP	0x3A0
---- common_function ------------------------------------------------------------------
  002E    0183    CLR	0x3
  002F    295A    JP	0x15A
  00F2    0879    LD	A,0x79
  00F3    3E3D    ADDIA	0x3D
  00F4    0084    LD	0x4,A
  00F5    1383    CLRB	0x3,7
  00F6    0800    LD	A,0x0
  00F7    0008    RET
  00F8    087A    LD	A,0x7A
  00F9    3E3D    ADDIA	0x3D
  00FA    0084    LD	0x4,A
  00FB    0800    LD	A,0x0
  00FC    0008    RET
  0154    00F7    LD	0x77,A
  0155    1003    CLRB	0x3,0
  0156    0CF7    RRCR	0x77
  0157    1003    CLRB	0x3,0
  0158    0CF7    RRCR	0x77
  0159    0008    RET
  01F6    1283    CLRB	0x3,5
  01F7    1303    CLRB	0x3,6
  01F8    00A0    LD	0x20,A
  01F9    1003    CLRB	0x3,0
  01FA    0CA0    RRCR	0x20
  01FB    0008    RET
  02F2    00A0    LD	0x20,A
  02F3    1003    CLRB	0x3,0
  02F4    0CA0    RRCR	0x20
  02F5    1003    CLRB	0x3,0
  02F6    0CA0    RRCR	0x20
  02F7    1003    CLRB	0x3,0
  02F8    0CA0    RRCR	0x20
  02F9    0008    RET
  0378    1303    CLRB	0x3,6
  0379    0185    CLR	0x5
  037A    0186    CLR	0x6
  037B    0187    CLR	0x7
  037C    1683    SETB	0x3,5
  037D    0008    RET
  043A    2A2A    JP	0x22A
  043B    2A26    JP	0x226
  043C    2A22    JP	0x222
  043D    2A1E    JP	0x21E
  043E    2A1A    JP	0x21A
  043F    2A16    JP	0x216
  0440    2A12    JP	0x212
  0441    2A0E    JP	0x20E
  0442    2A0A    JP	0x20A
  0443    2A06    JP	0x206
  0444    2A02    JP	0x202
  0445    29FE    JP	0x1FE
  0446    2A6C    JP	0x26C
  0447    2A68    JP	0x268
  0448    2A64    JP	0x264
  0449    2A60    JP	0x260
  044A    2A5C    JP	0x25C
  044B    2A58    JP	0x258
  044C    2A54    JP	0x254
  044D    2A50    JP	0x250
  044E    2A4C    JP	0x24C
  044F    2A48    JP	0x248
  0450    2A44    JP	0x244
  0451    2A40    JP	0x240
  0452    2AAD    JP	0x2AD
  0453    2AA9    JP	0x2A9
  0454    2AA5    JP	0x2A5
  0455    2AA1    JP	0x2A1
  0456    2A9D    JP	0x29D
  0457    2A99    JP	0x299
  0458    2A95    JP	0x295
  0459    2A91    JP	0x291
  045A    2A8D    JP	0x28D
  045B    2A89    JP	0x289
  045C    2A85    JP	0x285
  045D    2A81    JP	0x281
  0476    28DB    JP	0xDB
  0477    28DD    JP	0xDD
  0478    28DF    JP	0xDF
  0479    28E1    JP	0xE1
